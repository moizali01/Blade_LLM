    1|       |typedef unsigned long size_t;
    2|       |typedef long __off_t;
    3|       |typedef long __off64_t;
    4|       |struct _IO_FILE;
    5|       |struct _IO_FILE;
    6|       |struct _IO_FILE;
    7|       |typedef struct _IO_FILE FILE;
    8|       |typedef void _IO_lock_t;
    9|       |struct _IO_marker {
   10|       |    struct _IO_marker *_next;
   11|       |    struct _IO_FILE *_sbuf;
   12|       |    int _pos;
   13|       |};
   14|       |struct _IO_FILE {
   15|       |    int _flags;
   16|       |    char *_IO_read_ptr;
   17|       |    char *_IO_read_end;
   18|       |    char *_IO_read_base;
   19|       |    char *_IO_write_base;
   20|       |    char *_IO_write_ptr;
   21|       |    char *_IO_write_end;
   22|       |    char *_IO_buf_base;
   23|       |    char *_IO_buf_end;
   24|       |    char *_IO_save_base;
   25|       |    char *_IO_backup_base;
   26|       |    char *_IO_save_end;
   27|       |    struct _IO_marker *_markers;
   28|       |    struct _IO_FILE *_chain;
   29|       |    int _fileno;
   30|       |    int _flags2;
   31|       |    __off_t _old_offset;
   32|       |    unsigned short _cur_column;
   33|       |    signed char _vtable_offset;
   34|       |    char _shortbuf[1];
   35|       |    _IO_lock_t *_lock;
   36|       |    __off64_t _offset;
   37|       |    void *__pad1;
   38|       |    void *__pad2;
   39|       |    void *__pad3;
   40|       |    void *__pad4;
   41|       |    size_t __pad5;
   42|       |    int _mode;
   43|       |    char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
   44|       |};
   45|       |typedef long __time_t;
   46|       |typedef unsigned long __dev_t;
   47|       |typedef unsigned int __uid_t;
   48|       |typedef unsigned int __gid_t;
   49|       |typedef unsigned long __ino_t;
   50|       |typedef unsigned int __mode_t;
   51|       |typedef unsigned long __nlink_t;
   52|       |typedef long __blksize_t;
   53|       |typedef long __blkcnt_t;
   54|       |typedef long __syscall_slong_t;
   55|       |typedef __mode_t mode_t;
   56|       |struct timespec {
   57|       |    __time_t tv_sec;
   58|       |    __syscall_slong_t tv_nsec;
   59|       |};
   60|       |struct stat {
   61|       |    __dev_t st_dev;
   62|       |    __ino_t st_ino;
   63|       |    __nlink_t st_nlink;
   64|       |    __mode_t st_mode;
   65|       |    __uid_t st_uid;
   66|       |    __gid_t st_gid;
   67|       |    int __pad0;
   68|       |    __dev_t st_rdev;
   69|       |    __off_t st_size;
   70|       |    __blksize_t st_blksize;
   71|       |    __blkcnt_t st_blocks;
   72|       |    struct timespec st_atim;
   73|       |    struct timespec st_mtim;
   74|       |    struct timespec st_ctim;
   75|       |    __syscall_slong_t __glibc_reserved[3];
   76|       |};
   77|       |typedef __ino_t ino_t;
   78|       |typedef __dev_t dev_t;
   79|       |struct hash_table;
   80|       |struct hash_table;
   81|       |struct hash_table;
   82|       |typedef struct hash_table Hash_table;
   83|       |struct F_triple {
   84|       |    char *name;
   85|       |    ino_t st_ino;
   86|       |    dev_t st_dev;
   87|       |};
   88|       |struct __dirstream;
   89|       |struct __dirstream;
   90|       |struct __dirstream;
   91|       |typedef struct __dirstream DIR;
   92|       |typedef int wchar_t;
   93|       |union __anonunion___value_4 {
   94|       |    unsigned int __wch;
   95|       |    char __wchb[4];
   96|       |};
   97|       |struct __anonstruct___mbstate_t_3 {
   98|       |    int __count;
   99|       |    union __anonunion___value_4 __value;
  100|       |};
  101|       |typedef struct __anonstruct___mbstate_t_3 __mbstate_t;
  102|       |typedef unsigned int wint_t;
  103|       |struct hash_tuning {
  104|       |    float shrink_threshold;
  105|       |    float shrink_factor;
  106|       |    float growth_threshold;
  107|       |    float growth_factor;
  108|       |    _Bool is_n_buckets;
  109|       |};
  110|       |typedef struct hash_tuning Hash_tuning;
  111|       |typedef __mbstate_t mbstate_t;
  112|       |struct mbchar {
  113|       |    char const *ptr;
  114|       |    size_t bytes;
  115|       |    _Bool wc_valid;
  116|       |    wchar_t wc;
  117|       |    char buf[24];
  118|       |};
  119|       |struct mbuiter_multi {
  120|       |    _Bool in_shift;
  121|       |    mbstate_t state;
  122|       |    _Bool next_done;
  123|       |    struct mbchar cur;
  124|       |};
  125|       |typedef struct mbuiter_multi mbui_iterator_t;
  126|       |typedef __gid_t gid_t;
  127|       |typedef __uid_t uid_t;
  128|       |typedef unsigned long uintmax_t;
  129|       |struct dev_ino {
  130|       |    ino_t st_ino;
  131|       |    dev_t st_dev;
  132|       |};
  133|       |struct cycle_check_state {
  134|       |    struct dev_ino dev_ino;
  135|       |    uintmax_t chdir_counter;
  136|       |    int magic;
  137|       |};
  138|       |typedef long ptrdiff_t;
  139|       |struct dirent {
  140|       |    __ino_t d_ino;
  141|       |    __off_t d_off;
  142|       |    unsigned short d_reclen;
  143|       |    unsigned char d_type;
  144|       |    char d_name[256];
  145|       |};
  146|       |typedef __builtin_va_list __gnuc_va_list;
  147|       |typedef __gnuc_va_list va_list;
  148|       |enum quoting_style {
  149|       |    literal_quoting_style = 0,
  150|       |    shell_quoting_style = 1,
  151|       |    shell_always_quoting_style = 2,
  152|       |    c_quoting_style = 3,
  153|       |    c_maybe_quoting_style = 4,
  154|       |    escape_quoting_style = 5,
  155|       |    locale_quoting_style = 6,
  156|       |    clocale_quoting_style = 7,
  157|       |    custom_quoting_style = 8
  158|       |};
  159|       |enum strtol_error {
  160|       |    LONGINT_OK = 0,
  161|       |    LONGINT_OVERFLOW = 1,
  162|       |    LONGINT_INVALID_SUFFIX_CHAR = 2,
  163|       |    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
  164|       |    LONGINT_INVALID = 4
  165|       |};
  166|       |typedef enum strtol_error strtol_error;
  167|       |struct option {
  168|       |    char const *name;
  169|       |    int has_arg;
  170|       |    int *flag;
  171|       |    int val;
  172|       |};
  173|       |typedef long intmax_t;
  174|       |typedef __nlink_t nlink_t;
  175|       |struct I_ring {
  176|       |    int ir_data[4];
  177|       |    int ir_default_val;
  178|       |    unsigned int ir_front;
  179|       |    unsigned int ir_back;
  180|       |    _Bool ir_empty;
  181|       |};
  182|       |typedef struct I_ring I_ring;
  183|       |struct _ftsent;
  184|       |struct _ftsent;
  185|       |struct _ftsent;
  186|       |union __anonunion_fts_cycle_29 {
  187|       |    struct hash_table *ht;
  188|       |    struct cycle_check_state *state;
  189|       |};
  190|       |struct __anonstruct_FTS_28 {
  191|       |    struct _ftsent *fts_cur;
  192|       |    struct _ftsent *fts_child;
  193|       |    struct _ftsent **fts_array;
  194|       |    dev_t fts_dev;
  195|       |    char *fts_path;
  196|       |    int fts_rfd;
  197|       |    int fts_cwd_fd;
  198|       |    size_t fts_pathlen;
  199|       |    size_t fts_nitems;
  200|       |    int (*fts_compar)(struct _ftsent const **, struct _ftsent const **);
  201|       |    int fts_options;
  202|       |    struct hash_table *fts_leaf_optimization_works_ht;
  203|       |    union __anonunion_fts_cycle_29 fts_cycle;
  204|       |    I_ring fts_fd_ring;
  205|       |};
  206|       |typedef struct __anonstruct_FTS_28 FTS;
  207|       |struct _ftsent {
  208|       |    struct _ftsent *fts_cycle;
  209|       |    struct _ftsent *fts_parent;
  210|       |    struct _ftsent *fts_link;
  211|       |    long fts_number;
  212|       |    void *fts_pointer;
  213|       |    char *fts_accpath;
  214|       |    char *fts_path;
  215|       |    int fts_errno;
  216|       |    int fts_symfd;
  217|       |    size_t fts_pathlen;
  218|       |    FTS *fts_fts;
  219|       |    ptrdiff_t fts_level;
  220|       |    size_t fts_namelen;
  221|       |    nlink_t fts_n_dirs_remaining;
  222|       |    unsigned short fts_info;
  223|       |    unsigned short fts_flags;
  224|       |    unsigned short fts_instr;
  225|       |    struct stat fts_statp[1];
  226|       |    char fts_name[1];
  227|       |};
  228|       |typedef struct _ftsent FTSENT;
  229|       |struct passwd {
  230|       |    char *pw_name;
  231|       |    char *pw_passwd;
  232|       |    __uid_t pw_uid;
  233|       |    __gid_t pw_gid;
  234|       |    char *pw_gecos;
  235|       |    char *pw_dir;
  236|       |    char *pw_shell;
  237|       |};
  238|       |struct group {
  239|       |    char *gr_name;
  240|       |    char *gr_passwd;
  241|       |    __gid_t gr_gid;
  242|       |    char **gr_mem;
  243|       |};
  244|       |typedef unsigned long reg_syntax_t;
  245|       |struct quoting_options;
  246|       |struct quoting_options;
  247|       |struct quoting_options;
  248|       |struct quoting_options {
  249|       |    enum quoting_style style;
  250|       |    int flags;
  251|       |    unsigned int quote_these_too[255UL / (sizeof(int) * 8UL) + 1UL];
  252|       |    char const *left_quote;
  253|       |    char const *right_quote;
  254|       |};
  255|       |struct slotvec {
  256|       |    size_t size;
  257|       |    char *val;
  258|       |};
  259|       |struct hash_entry {
  260|       |    void *data;
  261|       |    struct hash_entry *next;
  262|       |};
  263|       |struct hash_table {
  264|       |    struct hash_entry *bucket;
  265|       |    struct hash_entry const *bucket_limit;
  266|       |    size_t n_buckets;
  267|       |    size_t n_buckets_used;
  268|       |    size_t n_entries;
  269|       |    Hash_tuning const *tuning;
  270|       |    size_t (*hasher)(void const *, size_t);
  271|       |    _Bool (*comparator)(void const *, void const *);
  272|       |    void (*data_freer)(void *);
  273|       |    struct hash_entry *free_entry_list;
  274|       |};
  275|       |struct __anonstruct___fsid_t_1 {
  276|       |    int __val[2];
  277|       |};
  278|       |typedef struct __anonstruct___fsid_t_1 __fsid_t;
  279|       |typedef unsigned long __fsblkcnt_t;
  280|       |typedef unsigned long __fsfilcnt_t;
  281|       |typedef long __fsword_t;
  282|       |struct Active_dir {
  283|       |    dev_t dev;
  284|       |    ino_t ino;
  285|       |    FTSENT *fts_ent;
  286|       |};
  287|       |struct statfs {
  288|       |    __fsword_t f_type;
  289|       |    __fsword_t f_bsize;
  290|       |    __fsblkcnt_t f_blocks;
  291|       |    __fsblkcnt_t f_bfree;
  292|       |    __fsblkcnt_t f_bavail;
  293|       |    __fsfilcnt_t f_files;
  294|       |    __fsfilcnt_t f_ffree;
  295|       |    __fsid_t f_fsid;
  296|       |    __fsword_t f_namelen;
  297|       |    __fsword_t f_frsize;
  298|       |    __fsword_t f_flags;
  299|       |    __fsword_t f_spare[4];
  300|       |};
  301|       |struct LCO_ent {
  302|       |    dev_t st_dev;
  303|       |    _Bool opt_ok;
  304|       |};
  305|       |enum Change_status {
  306|       |    CH_NOT_APPLIED = 1,
  307|       |    CH_SUCCEEDED = 2,
  308|       |    CH_FAILED = 3,
  309|       |    CH_NO_CHANGE_REQUESTED = 4
  310|       |};
  311|       |enum Verbosity { V_high = 0, V_changes_only = 1, V_off = 2 };
  312|       |struct Chown_option {
  313|       |    enum Verbosity verbosity;
  314|       |    _Bool recurse;
  315|       |    struct dev_ino *root_dev_ino;
  316|       |    _Bool affect_symlink_referent;
  317|       |    _Bool force_silent;
  318|       |    char *user_name;
  319|       |    char *group_name;
  320|       |};
  321|       |enum RCH_status {
  322|       |    RC_ok = 2,
  323|       |    RC_excluded = 3,
  324|       |    RC_inode_changed = 4,
  325|       |    RC_do_ordinary_chown = 5,
  326|       |    RC_error = 6
  327|       |};
  328|       |extern __attribute__((__nothrow__)) int *(
  329|       |    __attribute__((__leaf__)) __errno_location)(void)__attribute__((__const__));
  330|       |extern int close(int __fd);
  331|       |extern int(__attribute__((__nonnull__(1))) open)(char const *__file,
  332|       |        int __oflag, ...);
  333|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) tolower)(
  334|       |    int __c);
  335|       |extern __attribute__((__nothrow__))
  336|       |size_t(__attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s)
  337|       |__attribute__((__pure__));
  338|       |extern int fclose(FILE *__stream);
  339|       |int dup_safer(int fd);
  340|       |extern __attribute__((__nothrow__)) int(__attribute__((
  341|       |        __nonnull__(1, 2), __leaf__)) strcmp)(char const *__s1, char const *__s2)
  342|       |__attribute__((__pure__));
  343|       |extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2),
  344|       |                                        __leaf__)) strncmp)(
  345|       |                                                char const *__s1, char const *__s2, size_t __n) __attribute__((__pure__));
  346|       |__attribute__((__noreturn__)) void xalloc_die(void);
  347|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__)) malloc)(
  348|       |    size_t __size) __attribute__((__malloc__));
  349|       |char *last_component(char const *name);
  350|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) gettext)(
  351|       |    char const *__msgid) __attribute__((__format_arg__(1)));
  352|       |void *hash_lookup(Hash_table const *table___0, void const *entry);
  353|       |void *(__attribute__((__warn_unused_result__)) hash_insert)(
  354|       |    Hash_table *table___0, void const *entry);
  355|       |void triple_free(void *x);
  356|       |void *xmalloc(size_t n) __attribute__((__malloc__));
  357|       |char *xstrdup(char const *string) __attribute__((__malloc__));
  358|       |extern DIR *fdopendir(int __fd);
  359|       |DIR *rpl_fdopendir(int fd);
  360|       |extern __attribute__((__nothrow__)) int(__attribute__((
  361|       |        __nonnull__(2), __leaf__)) fstat)(int __fd, struct stat *__buf);
  362|       |DIR *rpl_fdopendir(int fd)
  363|      2|{
  364|      2|    struct stat st;
  365|      2|    int tmp;
  366|      2|    int *tmp___0;
  367|      2|    DIR *tmp___1;
  368|       |
  369|      2|    {
  370|      2|        tmp = fstat(fd, &st);
  371|      2|        if (tmp) {
  372|      0|            return ((DIR *)((void *)0));
  373|      0|        }
  374|      2|        if (!((st.st_mode & 61440U) == 16384U)) {
  375|      0|            tmp___0 = __errno_location();
  376|      0|            *tmp___0 = 20;
  377|      0|            return ((DIR *)((void *)0));
  378|      0|        }
  379|      2|        tmp___1 = fdopendir(fd);
  380|      2|        return (tmp___1);
  381|      2|    }
  382|      2|}
  383|       |int fd_safer(int fd);
  384|       |int fd_safer(int fd)
  385|      2|{
  386|      2|    int f;
  387|      2|    int tmp;
  388|      2|    int e;
  389|      2|    int *tmp___0;
  390|      2|    int *tmp___1;
  391|       |
  392|      2|    {
  393|      2|        if (0 <= fd) {
  394|      2|            if (fd <= 2) {
  395|      0|                tmp = dup_safer(fd);
  396|      0|                f = tmp;
  397|      0|                tmp___0 = __errno_location();
  398|      0|                e = *tmp___0;
  399|      0|                close(fd);
  400|      0|                tmp___1 = __errno_location();
  401|      0|                *tmp___1 = e;
  402|      0|                fd = f;
  403|      0|            }
  404|      2|        }
  405|      2|        return (fd);
  406|      2|    }
  407|      2|}
  408|       |int volatile exit_failure;
  409|       |int volatile exit_failure = (int volatile)1;
  410|       |extern __attribute__((__nothrow__)) unsigned short const **(
  411|       |    __attribute__((__leaf__)) __ctype_b_loc)(void)__attribute__((__const__));
  412|       |extern __attribute__((__nothrow__)) int(
  413|       |    __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream);
  414|       |extern __attribute__((__nothrow__))
  415|       |size_t(__attribute__((__leaf__)) __ctype_get_mb_cur_max)(void);
  416|       |extern __attribute__((__nothrow__)) void(__attribute__((__leaf__)) free)(
  417|       |    void *__ptr);
  418|       |extern
  419|       |__attribute__((__nothrow__,
  420|       |               __noreturn__)) void(__attribute__((__leaf__)) abort)(void);
  421|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  422|       |            __nonnull__(1), __leaf__)) memset)(void *__s, int __c, size_t __n);
  423|       |extern __attribute__((__nothrow__)) char *(
  424|       |    __attribute__((__nonnull__(1), __leaf__)) strchr)(char const *__s, int __c)
  425|       |__attribute__((__pure__));
  426|       |extern __attribute__((__nothrow__)) char *(
  427|       |    __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const *__s, int __c)
  428|       |__attribute__((__pure__));
  429|       |int mbscasecmp(char const *s1, char const *s2);
  430|       |extern __attribute__((__nothrow__))
  431|       |wint_t(__attribute__((__leaf__)) towlower)(wint_t __wc);
  432|       |size_t hash_string(char const *string, size_t n_buckets);
  433|       |Hash_table *(__attribute__((__warn_unused_result__)) hash_initialize)(
  434|       |    size_t candidate, Hash_tuning const *tuning,
  435|       |    size_t (*hasher)(void const *, size_t),
  436|       |    _Bool (*comparator)(void const *, void const *),
  437|       |    void (*data_freer)(void *));
  438|       |void hash_free(Hash_table *table___0);
  439|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((
  440|       |            __leaf__)) __assert_fail)(char const *__assertion, char const *__file,
  441|       |                                      unsigned int __line, char const *__function);
  442|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) mbsinit)(
  443|       |    mbstate_t const *__ps) __attribute__((__pure__));
  444|       |extern __attribute__((__nothrow__)) size_t(__attribute__((__leaf__)) mbrtowc)(
  445|       |    wchar_t *__restrict __pwc, char const *__restrict __s, size_t __n,
  446|       |    mbstate_t *__restrict __p);
  447|       |unsigned int const is_basic_table[8];
  448|       |__inline static _Bool is_basic(char c)
  449|      0|{
  450|       |
  451|      0|    {
  452|      0|        return ((_Bool)((is_basic_table[(int)((unsigned char)c) >> 5] >>
  453|      0|                         ((int)((unsigned char)c) & 31)) &
  454|      0|                        1U));
  455|      0|    }
  456|      0|}
  457|       |size_t strnlen1(char const *string, size_t maxlen);
  458|       |__inline static void mbuiter_multi_next(struct mbuiter_multi *iter)
  459|      0|{
  460|      0|    int tmp;
  461|      0|    size_t tmp___0;
  462|      0|    size_t tmp___1;
  463|      0|    int tmp___2;
  464|      0|    _Bool tmp___3;
  465|       |
  466|      0|    {
  467|      0|        if (iter->next_done) {
  468|      0|            return;
  469|      0|        }
  470|      0|        if (iter->in_shift) {
  471|      0|            goto with_shift;
  472|      0|        }
  473|      0|        tmp___3 = is_basic((char)*(iter->cur.ptr));
  474|      0|        if (tmp___3) {
  475|      0|            iter->cur.bytes = (size_t)1;
  476|      0|            iter->cur.wc = (wchar_t) * (iter->cur.ptr);
  477|      0|            iter->cur.wc_valid = (_Bool)1;
  478|      0|        }
  479|      0|        else {
  480|      0|            tmp = mbsinit((mbstate_t const *)(&iter->state));
  481|      0|            if (!tmp) {
  482|      0|                __assert_fail("mbsinit (&iter->state)",
  483|      0|                              "/home/khheo/project/program-reduce/benchmark/"
  484|      0|                              "coreutils-8.2/lib/mbuiter.h",
  485|      0|                              142U, "mbuiter_multi_next");
  486|      0|            }
  487|      0|            iter->in_shift = (_Bool)1;
  488|      0|with_shift:
  489|      0|            tmp___0 = __ctype_get_mb_cur_max();
  490|      0|            tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
  491|      0|            iter->cur.bytes =
  492|      0|                mbrtowc(&iter->cur.wc, iter->cur.ptr, tmp___1, &iter->state);
  493|      0|            if (iter->cur.bytes == 0xffffffffffffffffUL) {
  494|      0|                iter->cur.bytes = (size_t)1;
  495|      0|                iter->cur.wc_valid = (_Bool)0;
  496|      0|            }
  497|      0|            else {
  498|      0|                if (iter->cur.bytes == 0xfffffffffffffffeUL) {
  499|      0|                    iter->cur.bytes = strlen(iter->cur.ptr);
  500|      0|                    iter->cur.wc_valid = (_Bool)0;
  501|      0|                }
  502|      0|                else {
  503|      0|                    if (iter->cur.bytes == 0UL) {
  504|      0|                        iter->cur.bytes = (size_t)1;
  505|      0|                        if (!((int const) * (iter->cur.ptr) == 0)) {
  506|      0|                            __assert_fail("*iter->cur.ptr == \'\\0\'",
  507|      0|                                          "/home/khheo/project/program-reduce/benchmark/"
  508|      0|                                          "coreutils-8.2/lib/mbuiter.h",
  509|      0|                                          170U, "mbuiter_multi_next");
  510|      0|                        }
  511|      0|                        if (!(iter->cur.wc == 0)) {
  512|      0|                            __assert_fail("iter->cur.wc == 0",
  513|      0|                                          "/home/khheo/project/program-reduce/benchmark/"
  514|      0|                                          "coreutils-8.2/lib/mbuiter.h",
  515|      0|                                          171U, "mbuiter_multi_next");
  516|      0|                        }
  517|      0|                    }
  518|      0|                    iter->cur.wc_valid = (_Bool)1;
  519|      0|                    tmp___2 = mbsinit((mbstate_t const *)(&iter->state));
  520|      0|                    if (tmp___2) {
  521|      0|                        iter->in_shift = (_Bool)0;
  522|      0|                    }
  523|      0|                }
  524|      0|            }
  525|      0|        }
  526|      0|        iter->next_done = (_Bool)1;
  527|      0|        return;
  528|      0|    }
  529|      0|}
  530|       |void *xrealloc(void *p, size_t n);
  531|       |extern int fcntl(int __fd, int __cmd, ...);
  532|       |int dup_safer(int fd)
  533|      2|{
  534|      2|    int tmp;
  535|       |
  536|      2|    {
  537|      2|        tmp = fcntl(fd, 0, 3);
  538|      2|        return (tmp);
  539|      2|    }
  540|      2|}
  541|       |extern __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1, 2),
  542|       |        __leaf__)) memcpy)(
  543|       |            void *__restrict __dest, void const *__restrict __src, size_t __n);
  544|       |extern __attribute__((__nothrow__)) int(__attribute__((
  545|       |        __nonnull__(1, 2), __leaf__)) stat)(char const *__restrict __file,
  546|       |                struct stat *__restrict __buf);
  547|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) fchown)(
  548|       |    int __fd, __uid_t __owner, __gid_t __group);
  549|       |char const diacrit_base[256];
  550|       |char const diacrit_diac[256];
  551|       |char const diacrit_base[256] = {
  552|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  553|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  554|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  555|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  556|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  557|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  558|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  559|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  560|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  561|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  562|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  563|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  564|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  565|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  566|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  567|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  568|       |    (char const)0,   (char const)'A', (char const)'B', (char const)'C',
  569|       |    (char const)'D', (char const)'E', (char const)'F', (char const)'G',
  570|       |    (char const)'H', (char const)'I', (char const)'J', (char const)'K',
  571|       |    (char const)'L', (char const)'M', (char const)'N', (char const)'O',
  572|       |    (char const)'P', (char const)'Q', (char const)'R', (char const)'S',
  573|       |    (char const)'T', (char const)'U', (char const)'V', (char const)'W',
  574|       |    (char const)'X', (char const)'Y', (char const)'Z', (char const)0,
  575|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  576|       |    (char const)0,   (char const)'a', (char const)'b', (char const)'c',
  577|       |    (char const)'d', (char const)'e', (char const)'f', (char const)'g',
  578|       |    (char const)'h', (char const)'i', (char const)'j', (char const)'k',
  579|       |    (char const)'l', (char const)'m', (char const)'n', (char const)'o',
  580|       |    (char const)'p', (char const)'q', (char const)'r', (char const)'s',
  581|       |    (char const)'t', (char const)'u', (char const)'v', (char const)'w',
  582|       |    (char const)'x', (char const)'y', (char const)'z', (char const)0,
  583|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  584|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  585|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  586|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  587|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  588|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  589|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  590|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  591|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  592|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  593|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  594|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  595|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  596|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  597|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  598|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  599|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  600|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'A',
  601|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'C',
  602|       |    (char const)'E', (char const)'E', (char const)'E', (char const)'E',
  603|       |    (char const)'I', (char const)'I', (char const)'I', (char const)'I',
  604|       |    (char const)0,   (char const)'N', (char const)'O', (char const)'O',
  605|       |    (char const)'O', (char const)'O', (char const)'O', (char const)0,
  606|       |    (char const)'O', (char const)'U', (char const)'U', (char const)'U',
  607|       |    (char const)'U', (char const)'Y', (char const)0,   (char const)0,
  608|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'a',
  609|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'c',
  610|       |    (char const)'e', (char const)'e', (char const)'e', (char const)'e',
  611|       |    (char const)'i', (char const)'i', (char const)'i', (char const)'i',
  612|       |    (char const)0,   (char const)'n', (char const)'o', (char const)'o',
  613|       |    (char const)'o', (char const)'o', (char const)'o', (char const)0,
  614|       |    (char const)'o', (char const)'u', (char const)'u', (char const)'u',
  615|       |    (char const)'u', (char const)'y', (char const)0,   (char const)'y'
  616|       |};
  617|       |char const diacrit_diac[256] = {
  618|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  619|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  620|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  621|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  622|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  623|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  624|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  625|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  626|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  627|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  628|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  629|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  630|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  631|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  632|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  633|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  634|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  635|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  636|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)4,
  637|       |    (char const)0, (char const)3, (char const)0, (char const)0, (char const)0,
  638|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  639|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  640|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  641|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  642|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  643|       |    (char const)0, (char const)6, (char const)0, (char const)0, (char const)0,
  644|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  645|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  646|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  647|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  648|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  649|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  650|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  651|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  652|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  653|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  654|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  655|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  656|       |    (char const)0, (char const)0, (char const)3, (char const)2, (char const)4,
  657|       |    (char const)6, (char const)5, (char const)8, (char const)1, (char const)7,
  658|       |    (char const)3, (char const)2, (char const)4, (char const)5, (char const)3,
  659|       |    (char const)2, (char const)4, (char const)5, (char const)0, (char const)6,
  660|       |    (char const)3, (char const)2, (char const)4, (char const)6, (char const)5,
  661|       |    (char const)0, (char const)9, (char const)3, (char const)2, (char const)4,
  662|       |    (char const)5, (char const)2, (char const)0, (char const)0, (char const)3,
  663|       |    (char const)2, (char const)4, (char const)6, (char const)5, (char const)8,
  664|       |    (char const)1, (char const)7, (char const)3, (char const)2, (char const)4,
  665|       |    (char const)5, (char const)3, (char const)2, (char const)4, (char const)5,
  666|       |    (char const)0, (char const)6, (char const)3, (char const)2, (char const)4,
  667|       |    (char const)6, (char const)5, (char const)0, (char const)9, (char const)3,
  668|       |    (char const)2, (char const)4, (char const)5, (char const)2, (char const)0,
  669|       |    (char const)0
  670|       |};
  671|       |void cycle_check_init(struct cycle_check_state *state);
  672|       |_Bool cycle_check(struct cycle_check_state *state, struct stat const *sb);
  673|       |__inline static _Bool is_zero_or_power_of_two(uintmax_t i)
  674|      2|{
  675|       |
  676|      2|    {
  677|      2|        return ((_Bool)((i & (i - 1UL)) == 0UL));
  678|      2|    }
  679|      2|}
  680|       |void cycle_check_init(struct cycle_check_state *state)
  681|      4|{
  682|       |
  683|      4|    {
  684|      4|        state->chdir_counter = (uintmax_t)0;
  685|      4|        state->magic = 9827862;
  686|      4|        return;
  687|      4|    }
  688|      4|}
  689|       |_Bool cycle_check(struct cycle_check_state *state, struct stat const *sb)
  690|      2|{
  691|      2|    _Bool tmp;
  692|       |
  693|      2|    {
  694|      2|        if (!(state->magic == 9827862)) {
  695|      0|            __assert_fail("state->magic == 9827862",
  696|      0|                          "/home/khheo/project/program-reduce/benchmark/"
  697|      0|                          "coreutils-8.2/lib/cycle-check.c",
  698|      0|                          60U, "cycle_check");
  699|      0|        }
  700|      2|        if (state->chdir_counter) {
  701|      0|            if (sb->st_ino == (__ino_t const)state->dev_ino.st_ino) {
  702|      0|                if (sb->st_dev == (__dev_t const)state->dev_ino.st_dev) {
  703|      0|                    return ((_Bool)1);
  704|      0|                }
  705|      0|            }
  706|      0|        }
  707|      2|        (state->chdir_counter)++;
  708|      2|        tmp = is_zero_or_power_of_two(state->chdir_counter);
  709|      2|        if (tmp) {
  710|      2|            if (state->chdir_counter == 0UL) {
  711|      0|                return ((_Bool)1);
  712|      0|            }
  713|      2|            state->dev_ino.st_dev = (dev_t)sb->st_dev;
  714|      2|            state->dev_ino.st_ino = (ino_t)sb->st_ino;
  715|      2|        }
  716|      2|        return ((_Bool)0);
  717|      2|    }
  718|      2|}
  719|       |extern void error(int __status, int __errnum, char const *__format, ...);
  720|       |char const *quote(char const *name);
  721|       |void close_stdout(void);
  722|       |extern struct _IO_FILE *stdout;
  723|       |extern struct _IO_FILE *stderr;
  724|       |extern __attribute__((__noreturn__)) void _exit(int __status);
  725|       |int close_stream(FILE *stream);
  726|       |char *quotearg_colon(char const *arg);
  727|       |static char const *file_name;
  728|       |static _Bool ignore_EPIPE;
  729|       |void close_stdout(void)
  730|      2|{
  731|      2|    char const *write_error;
  732|      2|    char const *tmp;
  733|      2|    char *tmp___0;
  734|      2|    int *tmp___1;
  735|      2|    int *tmp___2;
  736|      2|    int tmp___3;
  737|      2|    int *tmp___4;
  738|      2|    int tmp___5;
  739|       |
  740|      2|    {
  741|      2|        tmp___3 = close_stream(stdout);
  742|      2|        if (tmp___3 != 0) {
  743|      0|            if (ignore_EPIPE) {
  744|      0|                tmp___4 = __errno_location();
  745|      0|                if (!(*tmp___4 == 32)) {
  746|      0|                    goto _L;
  747|      0|                }
  748|      0|            }
  749|      0|            else {
  750|      0|_L:
  751|      0|                tmp = (char const *)gettext("write error");
  752|      0|                write_error = tmp;
  753|      0|                if (file_name) {
  754|      0|                    tmp___0 = quotearg_colon(file_name);
  755|      0|                    tmp___1 = __errno_location();
  756|      0|                    error(0, *tmp___1, "%s: %s", tmp___0, write_error);
  757|      0|                }
  758|      0|                else {
  759|      0|                    tmp___2 = __errno_location();
  760|      0|                    error(0, *tmp___2, "%s", write_error);
  761|      0|                }
  762|      0|                _exit((int)exit_failure);
  763|      0|            }
  764|      0|        }
  765|      2|        tmp___5 = close_stream(stderr);
  766|      2|        if (tmp___5 != 0) {
  767|      0|            _exit((int)exit_failure);
  768|      0|        }
  769|      2|        return;
  770|      2|    }
  771|      2|}
  772|       |extern __attribute__((__nothrow__))
  773|       |size_t(__attribute__((__leaf__)) __fpending)(FILE *__fp);
  774|       |int close_stream(FILE *stream)
  775|      4|{
  776|      4|    _Bool some_pending;
  777|      4|    size_t tmp;
  778|      4|    _Bool prev_fail;
  779|      4|    int tmp___0;
  780|      4|    _Bool fclose_fail;
  781|      4|    int tmp___1;
  782|      4|    int *tmp___2;
  783|      4|    int *tmp___3;
  784|       |
  785|      4|    {
  786|      4|        tmp = __fpending(stream);
  787|      4|        some_pending = (_Bool)(tmp != 0UL);
  788|      4|        tmp___0 = ferror_unlocked(stream);
  789|      4|        prev_fail = (_Bool)(tmp___0 != 0);
  790|      4|        tmp___1 = fclose(stream);
  791|      4|        fclose_fail = (_Bool)(tmp___1 != 0);
  792|      4|        if (prev_fail) {
  793|      0|            goto _L___0;
  794|      0|        }
  795|      4|        else {
  796|      4|            if (fclose_fail) {
  797|      0|                if (some_pending) {
  798|      0|                    goto _L___0;
  799|      0|                }
  800|      0|                else {
  801|      0|                    tmp___3 = __errno_location();
  802|      0|                    if (*tmp___3 != 9) {
  803|      0|_L___0:
  804|      0|                        if (!fclose_fail) {
  805|      0|                            tmp___2 = __errno_location();
  806|      0|                            *tmp___2 = 0;
  807|      0|                        }
  808|      0|                        return (-1);
  809|      0|                    }
  810|      0|                }
  811|      0|            }
  812|      4|        }
  813|      4|        return (0);
  814|      4|    }
  815|      4|}
  816|       |int set_cloexec_flag(int desc, _Bool value);
  817|       |int set_cloexec_flag(int desc, _Bool value)
  818|      4|{
  819|      4|    int flags;
  820|      4|    int tmp;
  821|      4|    int newflags;
  822|      4|    int tmp___0;
  823|      4|    int tmp___1;
  824|       |
  825|      4|    {
  826|      4|        tmp = fcntl(desc, 1, 0);
  827|      4|        flags = tmp;
  828|      4|        if (0 <= flags) {
  829|      4|            if (value) {
  830|      4|                tmp___0 = flags | 1;
  831|      4|            }
  832|      0|            else {
  833|      0|                tmp___0 = flags & -2;
  834|      0|            }
  835|      4|            newflags = tmp___0;
  836|      4|            if (flags == newflags) {
  837|      0|                return (0);
  838|      0|            }
  839|      4|            else {
  840|      4|                tmp___1 = fcntl(desc, 2, newflags);
  841|      4|                if (tmp___1 != -1) {
  842|      4|                    return (0);
  843|      4|                }
  844|      4|            }
  845|      4|        }
  846|      0|        return (-1);
  847|      4|    }
  848|      4|}
  849|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) fchdir)(
  850|       |    int __fd);
  851|       |extern int(__attribute__((__nonnull__(2))) openat)(int __fd, char const *__file,
  852|       |        int __oflag, ...);
  853|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  854|       |            __nonnull__(1), __leaf__)) memchr)(void const *__s, int __c, size_t __n)
  855|       |__attribute__((__pure__));
  856|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  857|       |            __nonnull__(1, 2), __leaf__)) memmove)(void *__dest, void const *__src,
  858|       |                    size_t __n);
  859|       |extern __attribute__((__nothrow__)) int(__attribute__((
  860|       |        __nonnull__(1, 2), __leaf__)) lstat)(char const *__restrict __file,
  861|       |                struct stat *__restrict __buf);
  862|       |size_t triple_hash(void const *x, size_t table_size);
  863|       |_Bool triple_compare_ino_str(void const *x, void const *y);
  864|       |char *last_component(char const *name)
  865|      0|{
  866|      0|    char const *base;
  867|      0|    char const *p;
  868|      0|    _Bool saw_slash;
  869|       |
  870|      0|    {
  871|      0|        base = name + 0;
  872|      0|        saw_slash = (_Bool)0;
  873|      0|        while (1) {
  874|       |
  875|      0|            if (!((int const) * base == 47)) {
  876|      0|                goto while_break;
  877|      0|            }
  878|      0|            base++;
  879|      0|        }
  880|      0|while_break:
  881|      0|        p = base;
  882|      0|        while (1) {
  883|       |
  884|      0|            if (!*p) {
  885|      0|                goto while_break___0;
  886|      0|            }
  887|      0|            if ((int const) * p == 47) {
  888|      0|                saw_slash = (_Bool)1;
  889|      0|            }
  890|      0|            else {
  891|      0|                if (saw_slash) {
  892|      0|                    base = p;
  893|      0|                    saw_slash = (_Bool)0;
  894|      0|                }
  895|      0|            }
  896|      0|            p++;
  897|      0|        }
  898|      0|while_break___0:
  899|      0|        ;
  900|      0|        return ((char *)base);
  901|      0|    }
  902|      0|}
  903|       |char const *simple_backup_suffix;
  904|       |void (*argmatch_die)(void);
  905|       |extern __attribute__((__nothrow__)) int(__attribute__((
  906|       |        __nonnull__(1, 2), __leaf__)) memcmp)(void const *__s1, void const *__s2,
  907|       |                size_t __n) __attribute__((__pure__));
  908|       |extern int(__attribute__((__nonnull__(1))) closedir)(DIR *__dirp);
  909|       |extern struct dirent *(__attribute__((__nonnull__(1))) readdir)(DIR *__dirp);
  910|       |DIR *opendir_safer(char const *name);
  911|       |char const *simple_backup_suffix = "~";
  912|       |extern int fprintf(FILE *__restrict __stream, char const *__restrict __format,
  913|       |                   ...);
  914|       |char *quotearg_n_style(int n, enum quoting_style s, char const *arg);
  915|       |char const *quote_n(int n, char const *name);
  916|       |__attribute__((__noreturn__)) void usage(int status);
  917|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  918|       |            __warn_unused_result__, __leaf__)) realloc)(void *__ptr, size_t __size);
  919|       |__inline static void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__));
  920|       |__inline static void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__));
  921|       |__inline static void *xnmalloc(size_t n, size_t s)
  922|      0|{
  923|      0|    int tmp;
  924|      0|    void *tmp___0;
  925|      0|
  926|      0|    {
  927|      0|        if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
  928|      0|            tmp = -1;
  929|      0|        }
  930|      0|        else {
  931|      0|            tmp = -2;
  932|      0|        }
  933|      0|        if ((size_t)tmp / s < n) {
  934|      0|            xalloc_die();
  935|      0|        }
  936|      0|        tmp___0 = xmalloc(n * s);
  937|      0|        return (tmp___0);
  938|      0|    }
  939|      0|}
  940|       |strtol_error xstrtoul(char const *s, char **ptr, int strtol_base,
  941|       |                      unsigned long *val, char const *valid_suffixes);
  942|       |extern __attribute__((__nothrow__)) unsigned long(__attribute__((
  943|       |            __nonnull__(1), __leaf__)) strtoul)(char const *__restrict __nptr,
  944|       |                    char **__restrict __endptr, int __base);
  945|       |static strtol_error bkm_scale___0(unsigned long *x, int scale_factor)
  946|      0|{
  947|       |
  948|      0|    {
  949|      0|        if (0xffffffffffffffffUL / (unsigned long)scale_factor < *x) {
  950|      0|            *x = 0xffffffffffffffffUL;
  951|      0|            return ((strtol_error)1);
  952|      0|        }
  953|      0|        *x *= (unsigned long)scale_factor;
  954|      0|        return ((strtol_error)0);
  955|      0|    }
  956|      0|}
  957|       |static strtol_error bkm_scale_by_power___0(unsigned long *x, int base,
  958|       |        int power)
  959|      0|{
  960|      0|    strtol_error err;
  961|      0|    strtol_error tmp;
  962|      0|    int tmp___0;
  963|       |
  964|      0|    {
  965|      0|        err = (strtol_error)0;
  966|      0|        while (1) {
  967|      0|            tmp___0 = power;
  968|      0|            power--;
  969|      0|            if (!tmp___0) {
  970|      0|                goto while_break;
  971|      0|            }
  972|      0|            tmp = bkm_scale___0(x, base);
  973|      0|            err = (strtol_error)((unsigned int)err | (unsigned int)tmp);
  974|      0|        }
  975|      0|while_break:
  976|      0|        ;
  977|      0|        return (err);
  978|      0|    }
  979|      0|}
  980|       |strtol_error xstrtoul(char const *s, char **ptr, int strtol_base,
  981|       |                      unsigned long *val, char const *valid_suffixes)
  982|      0|{
  983|      0|    char *t_ptr;
  984|      0|    char **p;
  985|      0|    unsigned long tmp;
  986|      0|    strtol_error err;
  987|      0|    char const *q;
  988|      0|    unsigned char ch;
  989|      0|    unsigned short const **tmp___0;
  990|      0|    int *tmp___1;
  991|      0|    char *tmp___2;
  992|      0|    int *tmp___3;
  993|      0|    int *tmp___4;
  994|      0|    int base;
  995|      0|    int suffixes;
  996|      0|    strtol_error overflow;
  997|      0|    char *tmp___5;
  998|      0|    char *tmp___6;
  999|       |
 1000|      0|    {
 1001|      0|        err = (strtol_error)0;
 1002|      0|        if (0 <= strtol_base) {
 1003|      0|            if (!(strtol_base <= 36)) {
 1004|      0|                __assert_fail("0 <= strtol_base && strtol_base <= 36",
 1005|      0|                              "/home/khheo/project/program-reduce/benchmark/"
 1006|      0|                              "coreutils-8.2/lib/xstrtol.c",
 1007|      0|                              83U, "xstrtoul");
 1008|      0|            }
 1009|      0|        }
 1010|      0|        else {
 1011|      0|            __assert_fail("0 <= strtol_base && strtol_base <= 36",
 1012|      0|                          "/home/khheo/project/program-reduce/benchmark/"
 1013|      0|                          "coreutils-8.2/lib/xstrtol.c",
 1014|      0|                          83U, "xstrtoul");
 1015|      0|        }
 1016|      0|        if (ptr) {
 1017|      0|            p = ptr;
 1018|      0|        }
 1019|      0|        else {
 1020|      0|            p = &t_ptr;
 1021|      0|        }
 1022|      0|        q = s;
 1023|      0|        ch = (unsigned char)*q;
 1024|      0|        while (1) {
 1025|      0|            tmp___0 = __ctype_b_loc();
 1026|      0|            if (!((int const) * (*tmp___0 + (int)ch) & 8192)) {
 1027|      0|                goto while_break;
 1028|      0|            }
 1029|      0|            q++;
 1030|      0|            ch = (unsigned char)*q;
 1031|      0|        }
 1032|      0|while_break:
 1033|      0|        ;
 1034|      0|        if ((int)ch == 45) {
 1035|      0|            return ((strtol_error)4);
 1036|      0|        }
 1037|      0|        tmp___1 = __errno_location();
 1038|      0|        *tmp___1 = 0;
 1039|      0|        tmp = strtoul(s, p, strtol_base);
 1040|      0|        if ((unsigned long)*p == (unsigned long)s) {
 1041|      0|            if (valid_suffixes) {
 1042|      0|                if (*(*p)) {
 1043|      0|                    tmp___2 = strchr(valid_suffixes, (int)*(*p));
 1044|      0|                    if (tmp___2) {
 1045|      0|                        tmp = 1UL;
 1046|      0|                    }
 1047|      0|                    else {
 1048|      0|                        return ((strtol_error)4);
 1049|      0|                    }
 1050|      0|                }
 1051|      0|                else {
 1052|      0|                    return ((strtol_error)4);
 1053|      0|                }
 1054|      0|            }
 1055|      0|            else {
 1056|      0|                return ((strtol_error)4);
 1057|      0|            }
 1058|      0|        }
 1059|      0|        else {
 1060|      0|            tmp___4 = __errno_location();
 1061|      0|            if (*tmp___4 != 0) {
 1062|      0|                tmp___3 = __errno_location();
 1063|      0|                if (*tmp___3 != 34) {
 1064|      0|                    return ((strtol_error)4);
 1065|      0|                }
 1066|      0|                err = (strtol_error)1;
 1067|      0|            }
 1068|      0|        }
 1069|      0|        if (!valid_suffixes) {
 1070|      0|            *val = tmp;
 1071|      0|            return (err);
 1072|      0|        }
 1073|      0|        if ((int)*(*p) != 0) {
 1074|      0|            base = 1024;
 1075|      0|            suffixes = 1;
 1076|      0|            tmp___5 = strchr(valid_suffixes, (int)*(*p));
 1077|      0|            if (!tmp___5) {
 1078|      0|                *val = tmp;
 1079|      0|                return ((strtol_error)((unsigned int)err | 2U));
 1080|      0|            }
 1081|      0|            tmp___6 = strchr(valid_suffixes, '0');
 1082|      0|            if (tmp___6) {
 1083|      0|                if ((int)*(*(p + 0) + 1) == 105) {
 1084|      0|                    goto case_105;
 1085|      0|                }
 1086|      0|                if ((int)*(*(p + 0) + 1) == 66) {
 1087|      0|                    goto case_66;
 1088|      0|                }
 1089|      0|                if ((int)*(*(p + 0) + 1) == 68) {
 1090|      0|                    goto case_66;
 1091|      0|                }
 1092|      0|                goto switch_break;
 1093|      0|case_105:
 1094|      0|                if ((int)*(*(p + 0) + 2) == 66) {
 1095|      0|                    suffixes += 2;
 1096|      0|                }
 1097|      0|                goto switch_break;
 1098|      0|case_66:
 1099|      0|                base = 1000;
 1100|      0|                suffixes++;
 1101|      0|                goto switch_break;
 1102|      0|switch_break:
 1103|      0|                ;
 1104|      0|            }
 1105|      0|            if ((int)*(*p) == 98) {
 1106|      0|                goto case_98;
 1107|      0|            }
 1108|      0|            if ((int)*(*p) == 66) {
 1109|      0|                goto case_66___0;
 1110|      0|            }
 1111|      0|            if ((int)*(*p) == 99) {
 1112|      0|                goto case_99;
 1113|      0|            }
 1114|      0|            if ((int)*(*p) == 69) {
 1115|      0|                goto case_69;
 1116|      0|            }
 1117|      0|            if ((int)*(*p) == 71) {
 1118|      0|                goto case_71;
 1119|      0|            }
 1120|      0|            if ((int)*(*p) == 103) {
 1121|      0|                goto case_71;
 1122|      0|            }
 1123|      0|            if ((int)*(*p) == 107) {
 1124|      0|                goto case_107;
 1125|      0|            }
 1126|      0|            if ((int)*(*p) == 75) {
 1127|      0|                goto case_107;
 1128|      0|            }
 1129|      0|            if ((int)*(*p) == 77) {
 1130|      0|                goto case_77;
 1131|      0|            }
 1132|      0|            if ((int)*(*p) == 109) {
 1133|      0|                goto case_77;
 1134|      0|            }
 1135|      0|            if ((int)*(*p) == 80) {
 1136|      0|                goto case_80;
 1137|      0|            }
 1138|      0|            if ((int)*(*p) == 84) {
 1139|      0|                goto case_84;
 1140|      0|            }
 1141|      0|            if ((int)*(*p) == 116) {
 1142|      0|                goto case_84;
 1143|      0|            }
 1144|      0|            if ((int)*(*p) == 119) {
 1145|      0|                goto case_119;
 1146|      0|            }
 1147|      0|            if ((int)*(*p) == 89) {
 1148|      0|                goto case_89;
 1149|      0|            }
 1150|      0|            if ((int)*(*p) == 90) {
 1151|      0|                goto case_90;
 1152|      0|            }
 1153|      0|            goto switch_default;
 1154|      0|case_98:
 1155|      0|            overflow = bkm_scale___0(&tmp, 512);
 1156|      0|            goto switch_break___0;
 1157|      0|case_66___0:
 1158|      0|            overflow = bkm_scale___0(&tmp, 1024);
 1159|      0|            goto switch_break___0;
 1160|      0|case_99:
 1161|      0|            overflow = (strtol_error)0;
 1162|      0|            goto switch_break___0;
 1163|      0|case_69:
 1164|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 6);
 1165|      0|            goto switch_break___0;
 1166|      0|case_71:
 1167|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 3);
 1168|      0|            goto switch_break___0;
 1169|      0|case_107:
 1170|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 1);
 1171|      0|            goto switch_break___0;
 1172|      0|case_77:
 1173|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 2);
 1174|      0|            goto switch_break___0;
 1175|      0|case_80:
 1176|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 5);
 1177|      0|            goto switch_break___0;
 1178|      0|case_84:
 1179|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 4);
 1180|      0|            goto switch_break___0;
 1181|      0|case_119:
 1182|      0|            overflow = bkm_scale___0(&tmp, 2);
 1183|      0|            goto switch_break___0;
 1184|      0|case_89:
 1185|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 8);
 1186|      0|            goto switch_break___0;
 1187|      0|case_90:
 1188|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 7);
 1189|      0|            goto switch_break___0;
 1190|      0|switch_default:
 1191|      0|            *val = tmp;
 1192|      0|            return ((strtol_error)((unsigned int)err | 2U));
 1193|      0|switch_break___0:
 1194|      0|            err = (strtol_error)((unsigned int)err | (unsigned int)overflow);
 1195|      0|            *p += suffixes;
 1196|      0|            if (*(*p)) {
 1197|      0|                err = (strtol_error)((unsigned int)err | 2U);
 1198|      0|            }
 1199|      0|        }
 1200|      0|        *val = tmp;
 1201|      0|        return (err);
 1202|      0|    }
 1203|      0|}
 1204|       |void *xmemdup(void const *p, size_t s) __attribute__((__malloc__));
 1205|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__)) calloc)(
 1206|       |    size_t __nmemb, size_t __size) __attribute__((__malloc__));
 1207|       |void *xmalloc(size_t n) __attribute__((__malloc__));
 1208|       |void *xmalloc(size_t n)
 1209|      3|{
 1210|      3|    void *p;
 1211|      3|    void *tmp;
 1212|       |
 1213|      3|    {
 1214|      3|        tmp = malloc(n);
 1215|      3|        p = tmp;
 1216|      3|        if (!p) {
 1217|      0|            if (n != 0UL) {
 1218|      0|                xalloc_die();
 1219|      0|            }
 1220|      0|        }
 1221|      3|        return (p);
 1222|      3|    }
 1223|      3|}
 1224|       |void *xrealloc(void *p, size_t n)
 1225|      0|{
 1226|       |
 1227|      0|    {
 1228|      0|        p = realloc(p, n);
 1229|      0|        if (!p) {
 1230|      0|            if (n != 0UL) {
 1231|      0|                xalloc_die();
 1232|      0|            }
 1233|      0|        }
 1234|      0|        return (p);
 1235|      0|    }
 1236|      0|}
 1237|       |void *xmemdup(void const *p, size_t s) __attribute__((__malloc__));
 1238|       |void *xmemdup(void const *p, size_t s)
 1239|      3|{
 1240|      3|    void *tmp;
 1241|      3|    void *tmp___0;
 1242|       |
 1243|      3|    {
 1244|      3|        tmp = xmalloc(s);
 1245|      3|        tmp___0 = memcpy(tmp, p, s);
 1246|      3|        return (tmp___0);
 1247|      3|    }
 1248|      3|}
 1249|       |char *xstrdup(char const *string) __attribute__((__malloc__));
 1250|       |char *xstrdup(char const *string)
 1251|      2|{
 1252|      2|    size_t tmp;
 1253|      2|    char *tmp___0;
 1254|       |
 1255|      2|    {
 1256|      2|        tmp = strlen(string);
 1257|      2|        tmp___0 = (char *)xmemdup((void const *)string, tmp + 1UL);
 1258|      2|        return (tmp___0);
 1259|      2|    }
 1260|      2|}
 1261|       |__attribute__((__nothrow__))
 1262|       |FTS *(__attribute__((__warn_unused_result__, __leaf__)) fts_open)(
 1263|       |    char *const *argv, int options,
 1264|       |    int (*compar)(FTSENT const **, FTSENT const **));
 1265|       |FTS *xfts_open(char *const *argv, int options,
 1266|       |               int (*compar)(FTSENT const **, FTSENT const **));
 1267|       |_Bool cycle_warning_required(FTS const *fts, FTSENT const *ent);
 1268|       |FTS *xfts_open(char *const *argv, int options,
 1269|       |               int (*compar)(FTSENT const **, FTSENT const **))
 1270|      2|{
 1271|      2|    FTS *fts;
 1272|      2|    FTS *tmp;
 1273|      2|    int *tmp___0;
 1274|       |
 1275|      2|    {
 1276|      2|        tmp = fts_open(argv, options | 512, compar);
 1277|      2|        fts = tmp;
 1278|      2|        if ((unsigned long)fts == (unsigned long)((void *)0)) {
 1279|      0|            tmp___0 = __errno_location();
 1280|      0|            if (!(*tmp___0 != 22)) {
 1281|      0|                __assert_fail("(*__errno_location ()) != 22",
 1282|      0|                              "/home/khheo/project/program-reduce/benchmark/"
 1283|      0|                              "coreutils-8.2/lib/xfts.c",
 1284|      0|                              41U, "xfts_open");
 1285|      0|            }
 1286|      0|            xalloc_die();
 1287|      0|        }
 1288|      2|        return (fts);
 1289|      2|    }
 1290|      2|}
 1291|       |_Bool cycle_warning_required(FTS const *fts, FTSENT const *ent)
 1292|      0|{
 1293|      0|    int tmp;
 1294|       |
 1295|      0|    {
 1296|      0|        if (fts->fts_options & 16) {
 1297|      0|            if (!(fts->fts_options & 1)) {
 1298|      0|                tmp = 1;
 1299|      0|            }
 1300|      0|            else {
 1301|      0|                goto _L;
 1302|      0|            }
 1303|      0|        }
 1304|      0|        else {
 1305|      0|_L:
 1306|      0|            if (fts->fts_options & 16) {
 1307|      0|                if (fts->fts_options & 1) {
 1308|      0|                    if (ent->fts_level != 0L) {
 1309|      0|                        tmp = 1;
 1310|      0|                    }
 1311|      0|                    else {
 1312|      0|                        tmp = 0;
 1313|      0|                    }
 1314|      0|                }
 1315|      0|                else {
 1316|      0|                    tmp = 0;
 1317|      0|                }
 1318|      0|            }
 1319|      0|            else {
 1320|      0|                tmp = 0;
 1321|      0|            }
 1322|      0|        }
 1323|      0|        return ((_Bool)tmp);
 1324|      0|    }
 1325|      0|}
 1326|       |__attribute__((__noreturn__)) void xalloc_die(void);
 1327|       |void xalloc_die(void)
 1328|      0|{
 1329|      0|    char *tmp;
 1330|       |
 1331|      0|    {
 1332|      0|        tmp = gettext("memory exhausted");
 1333|      0|        error((int)exit_failure, 0, "%s", tmp);
 1334|      0|        abort();
 1335|      0|    }
 1336|      0|}
 1337|       |extern int printf(char const *__restrict __format, ...);
 1338|       |extern int fputs_unlocked(char const *__restrict __s,
 1339|       |                          FILE *__restrict __stream);
 1340|       |char const version_etc_copyright[47];
 1341|       |void version_etc_arn(FILE *stream, char const *command_name,
 1342|       |                     char const *package, char const *version,
 1343|       |                     char const *const *authors, size_t n_authors);
 1344|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 1345|       |                    char const *version, va_list authors);
 1346|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1347|       |                 char const *version, ...) __attribute__((__sentinel__));
 1348|       |void version_etc_arn(FILE *stream, char const *command_name,
 1349|       |                     char const *package, char const *version,
 1350|       |                     char const *const *authors, size_t n_authors)
 1351|      0|{
 1352|      0|    char *tmp;
 1353|      0|    char *tmp___0;
 1354|      0|    char *tmp___1;
 1355|      0|    char *tmp___2;
 1356|      0|    char *tmp___3;
 1357|      0|    char *tmp___4;
 1358|      0|    char *tmp___5;
 1359|      0|    char *tmp___6;
 1360|      0|    char *tmp___7;
 1361|      0|    char *tmp___8;
 1362|      0|    char *tmp___9;
 1363|      0|    char *tmp___10;
 1364|       |
 1365|      0|    {
 1366|      0|        if (command_name) {
 1367|      0|            fprintf(stream, "%s (%s) %s\n", command_name, package, version);
 1368|      0|        }
 1369|      0|        else {
 1370|      0|            fprintf(stream, "%s %s\n", package, version);
 1371|      0|        }
 1372|      0|        tmp = gettext("(C)");
 1373|      0|        fprintf(stream, version_etc_copyright, tmp, 2009);
 1374|      0|        tmp___0 =
 1375|      0|            gettext("\nLicense GPLv3+: GNU GPL version 3 or later "
 1376|      0|                    "<http://gnu.org/licenses/gpl.html>.\nThis is free software: "
 1377|      0|                    "you are free to change and redistribute it.\nThere is NO "
 1378|      0|                    "WARRANTY, to the extent permitted by law.\n\n");
 1379|      0|        fputs_unlocked((char const *)tmp___0, stream);
 1380|      0|        if (n_authors == 0UL) {
 1381|      0|            goto case_0;
 1382|      0|        }
 1383|      0|        if (n_authors == 1UL) {
 1384|      0|            goto case_1;
 1385|      0|        }
 1386|      0|        if (n_authors == 2UL) {
 1387|      0|            goto case_2;
 1388|      0|        }
 1389|      0|        if (n_authors == 3UL) {
 1390|      0|            goto case_3;
 1391|      0|        }
 1392|      0|        if (n_authors == 4UL) {
 1393|      0|            goto case_4;
 1394|      0|        }
 1395|      0|        if (n_authors == 5UL) {
 1396|      0|            goto case_5;
 1397|      0|        }
 1398|      0|        if (n_authors == 6UL) {
 1399|      0|            goto case_6;
 1400|      0|        }
 1401|      0|        if (n_authors == 7UL) {
 1402|      0|            goto case_7;
 1403|      0|        }
 1404|      0|        if (n_authors == 8UL) {
 1405|      0|            goto case_8;
 1406|      0|        }
 1407|      0|        if (n_authors == 9UL) {
 1408|      0|            goto case_9;
 1409|      0|        }
 1410|      0|        goto switch_default;
 1411|      0|case_0:
 1412|      0|        abort();
 1413|      0|case_1:
 1414|      0|        tmp___1 = gettext("Written by %s.\n");
 1415|      0|        fprintf(stream, (char const *)tmp___1, *(authors + 0));
 1416|      0|        goto switch_break;
 1417|      0|case_2:
 1418|      0|        tmp___2 = gettext("Written by %s and %s.\n");
 1419|      0|        fprintf(stream, (char const *)tmp___2, *(authors + 0), *(authors + 1));
 1420|      0|        goto switch_break;
 1421|      0|case_3:
 1422|      0|        tmp___3 = gettext("Written by %s, %s, and %s.\n");
 1423|      0|        fprintf(stream, (char const *)tmp___3, *(authors + 0), *(authors + 1),
 1424|      0|                *(authors + 2));
 1425|      0|        goto switch_break;
 1426|      0|case_4:
 1427|      0|        tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
 1428|      0|        fprintf(stream, (char const *)tmp___4, *(authors + 0), *(authors + 1),
 1429|      0|                *(authors + 2), *(authors + 3));
 1430|      0|        goto switch_break;
 1431|      0|case_5:
 1432|      0|        tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
 1433|      0|        fprintf(stream, (char const *)tmp___5, *(authors + 0), *(authors + 1),
 1434|      0|                *(authors + 2), *(authors + 3), *(authors + 4));
 1435|      0|        goto switch_break;
 1436|      0|case_6:
 1437|      0|        tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
 1438|      0|        fprintf(stream, (char const *)tmp___6, *(authors + 0), *(authors + 1),
 1439|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5));
 1440|      0|        goto switch_break;
 1441|      0|case_7:
 1442|      0|        tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
 1443|      0|        fprintf(stream, (char const *)tmp___7, *(authors + 0), *(authors + 1),
 1444|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1445|      0|                *(authors + 6));
 1446|      0|        goto switch_break;
 1447|      0|case_8:
 1448|      0|        tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
 1449|      0|        fprintf(stream, (char const *)tmp___8, *(authors + 0), *(authors + 1),
 1450|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1451|      0|                *(authors + 6), *(authors + 7));
 1452|      0|        goto switch_break;
 1453|      0|case_9:
 1454|      0|        tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
 1455|      0|        fprintf(stream, (char const *)tmp___9, *(authors + 0), *(authors + 1),
 1456|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1457|      0|                *(authors + 6), *(authors + 7), *(authors + 8));
 1458|      0|        goto switch_break;
 1459|      0|switch_default:
 1460|      0|        tmp___10 = gettext(
 1461|      0|                       "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
 1462|      0|        fprintf(stream, (char const *)tmp___10, *(authors + 0), *(authors + 1),
 1463|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1464|      0|                *(authors + 6), *(authors + 7), *(authors + 8));
 1465|      0|        goto switch_break;
 1466|      0|switch_break:
 1467|      0|        ;
 1468|      0|        return;
 1469|      0|    }
 1470|      0|}
 1471|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 1472|       |                    char const *version, va_list authors)
 1473|      0|{
 1474|      0|    size_t n_authors;
 1475|      0|    char const *authtab[10];
 1476|      0|    char const *tmp;
 1477|       |
 1478|      0|    {
 1479|      0|        n_authors = (size_t)0;
 1480|      0|        while (1) {
 1481|       |
 1482|      0|            if (n_authors < 10UL) {
 1483|      0|                tmp = __builtin_va_arg(authors, char const *);
 1484|      0|                authtab[n_authors] = tmp;
 1485|      0|                if (!((unsigned long)tmp != (unsigned long)((void *)0))) {
 1486|      0|                    goto while_break;
 1487|      0|                }
 1488|      0|            }
 1489|      0|            else {
 1490|      0|                goto while_break;
 1491|      0|            }
 1492|      0|            n_authors++;
 1493|      0|        }
 1494|      0|while_break:
 1495|      0|        version_etc_arn(stream, command_name, package, version,
 1496|      0|                        (char const *const *)(authtab), n_authors);
 1497|      0|        return;
 1498|      0|    }
 1499|      0|}
 1500|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1501|       |                 char const *version, ...) __attribute__((__sentinel__));
 1502|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1503|       |                 char const *version, ...)
 1504|      0|{
 1505|      0|    va_list authors;
 1506|       |
 1507|      0|    {
 1508|      0|        __builtin_va_start(authors, version);
 1509|      0|        version_etc_va(stream, command_name, package, version, authors);
 1510|      0|        __builtin_va_end(authors);
 1511|      0|        return;
 1512|      0|    }
 1513|      0|}
 1514|       |char const version_etc_copyright[47] = {
 1515|       |    (char const)'C', (char const)'o', (char const)'p',   (char const)'y',
 1516|       |    (char const)'r', (char const)'i', (char const)'g',   (char const)'h',
 1517|       |    (char const)'t', (char const)' ', (char const)'%',   (char const)'s',
 1518|       |    (char const)' ', (char const)'%', (char const)'d',   (char const)' ',
 1519|       |    (char const)'F', (char const)'r', (char const)'e',   (char const)'e',
 1520|       |    (char const)' ', (char const)'S', (char const)'o',   (char const)'f',
 1521|       |    (char const)'t', (char const)'w', (char const)'a',   (char const)'r',
 1522|       |    (char const)'e', (char const)' ', (char const)'F',   (char const)'o',
 1523|       |    (char const)'u', (char const)'n', (char const)'d',   (char const)'a',
 1524|       |    (char const)'t', (char const)'i', (char const)'o',   (char const)'n',
 1525|       |    (char const)',', (char const)' ', (char const)'I',   (char const)'n',
 1526|       |    (char const)'c', (char const)'.', (char const)'\000'
 1527|       |};
 1528|       |char const *parse_user_spec(char const *spec, uid_t *uid, gid_t *gid,
 1529|       |                            char **username, char **groupname);
 1530|       |extern void endpwent(void);
 1531|       |extern struct passwd *getpwnam(char const *__name);
 1532|       |extern void endgrent(void);
 1533|       |extern struct group *getgrgid(__gid_t __gid);
 1534|       |extern struct group *getgrnam(char const *__name);
 1535|       |char *(__attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i,
 1536|       |        char *buf___1);
 1537|       |static char const *parse_with_separator(char const *spec, char const *separator,
 1538|       |                                        uid_t *uid, gid_t *gid, char **username,
 1539|       |                                        char **groupname);
 1540|       |static char const *E_invalid_user = "invalid user";
 1541|       |static char const *E_invalid_group = "invalid group";
 1542|       |static char const *E_bad_spec = "invalid spec";
 1543|       |static char const *parse_with_separator(char const *spec, char const *separator,
 1544|       |                                        uid_t *uid, gid_t *gid, char **username,
 1545|       |                                        char **groupname)
 1546|      2|{
 1547|      2|    char const *error_msg;
 1548|      2|    struct passwd *pwd;
 1549|      2|    struct group *grp;
 1550|      2|    char *u;
 1551|      2|    char const *g;
 1552|      2|    char *gname;
 1553|      2|    uid_t unum;
 1554|      2|    gid_t gnum;
 1555|      2|    char *tmp;
 1556|      2|    size_t ulen;
 1557|      2|    struct passwd *tmp___0;
 1558|      2|    _Bool use_login_group;
 1559|      2|    int tmp___1;
 1560|      2|    unsigned long tmp___2;
 1561|      2|    strtol_error tmp___3;
 1562|      2|    char buf___1[(((sizeof(uintmax_t) * 8UL) * 146UL) / 485UL + 1UL) + 1UL];
 1563|      2|    char *tmp___4;
 1564|      2|    char *tmp___5;
 1565|      2|    struct group *tmp___6;
 1566|      2|    unsigned long tmp___7;
 1567|      2|    strtol_error tmp___8;
 1568|      2|    char const *tmp___9;
 1569|       |
 1570|      2|    {
 1571|      2|        gname = (char *)((void *)0);
 1572|      2|        unum = *uid;
 1573|      2|        gnum = *gid;
 1574|      2|        error_msg = (char const *)((void *)0);
 1575|      2|        tmp = (char *)((void *)0);
 1576|      2|        *groupname = tmp;
 1577|      2|        *username = tmp;
 1578|      2|        u = (char *)((void *)0);
 1579|      2|        if ((unsigned long)separator == (unsigned long)((void *)0)) {
 1580|      1|            if (*spec) {
 1581|      1|                u = xstrdup(spec);
 1582|      1|            }
 1583|      1|        }
 1584|      1|        else {
 1585|      1|            ulen = (size_t)(separator - spec);
 1586|      1|            if (ulen != 0UL) {
 1587|      1|                u = (char *)xmemdup((void const *)spec, ulen + 1UL);
 1588|      1|                *(u + ulen) = (char)'\000';
 1589|      1|            }
 1590|      1|        }
 1591|      2|        if ((unsigned long)separator == (unsigned long)((void *)0)) {
 1592|      1|            g = (char const *)((void *)0);
 1593|      1|        }
 1594|      1|        else {
 1595|      1|            if ((int const) * (separator + 1) == 0) {
 1596|      0|                g = (char const *)((void *)0);
 1597|      0|            }
 1598|      1|            else {
 1599|      1|                g = separator + 1;
 1600|      1|            }
 1601|      1|        }
 1602|      2|        if ((unsigned long)u != (unsigned long)((void *)0)) {
 1603|      2|            if ((int)*u == 43) {
 1604|      0|                pwd = (struct passwd *)((void *)0);
 1605|      0|            }
 1606|      2|            else {
 1607|      2|                tmp___0 = getpwnam((char const *)u);
 1608|      2|                pwd = tmp___0;
 1609|      2|            }
 1610|      2|            if ((unsigned long)pwd == (unsigned long)((void *)0)) {
 1611|      0|                if ((unsigned long)separator != (unsigned long)((void *)0)) {
 1612|      0|                    if ((unsigned long)g == (unsigned long)((void *)0)) {
 1613|      0|                        tmp___1 = 1;
 1614|      0|                    }
 1615|      0|                    else {
 1616|      0|                        tmp___1 = 0;
 1617|      0|                    }
 1618|      0|                }
 1619|      0|                else {
 1620|      0|                    tmp___1 = 0;
 1621|      0|                }
 1622|      0|                use_login_group = (_Bool)tmp___1;
 1623|      0|                if (use_login_group) {
 1624|      0|                    error_msg = E_bad_spec;
 1625|      0|                }
 1626|      0|                else {
 1627|      0|                    tmp___3 =
 1628|      0|                        xstrtoul((char const *)u, (char **)((void *)0), 10, &tmp___2, "");
 1629|      0|                    if ((unsigned int)tmp___3 == 0U) {
 1630|      0|                        if (tmp___2 <= 4294967295UL) {
 1631|      0|                            if ((uid_t)tmp___2 != 4294967295U) {
 1632|      0|                                unum = (uid_t)tmp___2;
 1633|      0|                            }
 1634|      0|                            else {
 1635|      0|                                error_msg = E_invalid_user;
 1636|      0|                            }
 1637|      0|                        }
 1638|      0|                        else {
 1639|      0|                            error_msg = E_invalid_user;
 1640|      0|                        }
 1641|      0|                    }
 1642|      0|                    else {
 1643|      0|                        error_msg = E_invalid_user;
 1644|      0|                    }
 1645|      0|                }
 1646|      0|            }
 1647|      2|            else {
 1648|      2|                unum = pwd->pw_uid;
 1649|      2|                if ((unsigned long)g == (unsigned long)((void *)0)) {
 1650|      1|                    if ((unsigned long)separator != (unsigned long)((void *)0)) {
 1651|      0|                        gnum = pwd->pw_gid;
 1652|      0|                        grp = getgrgid(gnum);
 1653|      0|                        if (grp) {
 1654|      0|                            tmp___5 = grp->gr_name;
 1655|      0|                        }
 1656|      0|                        else {
 1657|      0|                            tmp___4 = umaxtostr((uintmax_t)gnum, buf___1);
 1658|      0|                            tmp___5 = tmp___4;
 1659|      0|                        }
 1660|      0|                        gname = xstrdup((char const *)tmp___5);
 1661|      0|                        endgrent();
 1662|      0|                    }
 1663|      1|                }
 1664|      2|            }
 1665|      2|            endpwent();
 1666|      2|        }
 1667|      2|        if ((unsigned long)g != (unsigned long)((void *)0)) {
 1668|      1|            if ((unsigned long)error_msg == (unsigned long)((void *)0)) {
 1669|      1|                if ((int const) * g == 43) {
 1670|      0|                    grp = (struct group *)((void *)0);
 1671|      0|                }
 1672|      1|                else {
 1673|      1|                    tmp___6 = getgrnam(g);
 1674|      1|                    grp = tmp___6;
 1675|      1|                }
 1676|      1|                if ((unsigned long)grp == (unsigned long)((void *)0)) {
 1677|      0|                    tmp___8 = xstrtoul(g, (char **)((void *)0), 10, &tmp___7, "");
 1678|      0|                    if ((unsigned int)tmp___8 == 0U) {
 1679|      0|                        if (tmp___7 <= 4294967295UL) {
 1680|      0|                            if ((gid_t)tmp___7 != 4294967295U) {
 1681|      0|                                gnum = (gid_t)tmp___7;
 1682|      0|                            }
 1683|      0|                            else {
 1684|      0|                                error_msg = E_invalid_group;
 1685|      0|                            }
 1686|      0|                        }
 1687|      0|                        else {
 1688|      0|                            error_msg = E_invalid_group;
 1689|      0|                        }
 1690|      0|                    }
 1691|      0|                    else {
 1692|      0|                        error_msg = E_invalid_group;
 1693|      0|                    }
 1694|      0|                }
 1695|      1|                else {
 1696|      1|                    gnum = grp->gr_gid;
 1697|      1|                }
 1698|      1|                endgrent();
 1699|      1|                gname = xstrdup(g);
 1700|      1|            }
 1701|      1|        }
 1702|      2|        if ((unsigned long)error_msg == (unsigned long)((void *)0)) {
 1703|      2|            *uid = unum;
 1704|      2|            *gid = gnum;
 1705|      2|            *username = u;
 1706|      2|            *groupname = gname;
 1707|      2|            u = (char *)((void *)0);
 1708|      2|        }
 1709|      0|        else {
 1710|      0|            free((void *)gname);
 1711|      0|        }
 1712|      2|        free((void *)u);
 1713|      2|        tmp___9 = (char const *)gettext(error_msg);
 1714|      2|        return (tmp___9);
 1715|      2|    }
 1716|      2|}
 1717|       |char const *parse_user_spec(char const *spec, uid_t *uid, gid_t *gid,
 1718|       |                            char **username, char **groupname)
 1719|      2|{
 1720|      2|    char const *colon;
 1721|      2|    char const *tmp;
 1722|      2|    char const *error_msg;
 1723|      2|    char const *tmp___0;
 1724|      2|    char const *dot;
 1725|      2|    char const *tmp___1;
 1726|      2|    char const *tmp___2;
 1727|       |
 1728|      2|    {
 1729|      2|        tmp = (char const *)strchr(spec, ':');
 1730|      2|        colon = tmp;
 1731|      2|        tmp___0 = parse_with_separator(spec, colon, uid, gid, username, groupname);
 1732|      2|        error_msg = tmp___0;
 1733|      2|        if (!colon) {
 1734|      1|            if (error_msg) {
 1735|      0|                tmp___1 = (char const *)strchr(spec, '.');
 1736|      0|                dot = tmp___1;
 1737|      0|                if (dot) {
 1738|      0|                    tmp___2 =
 1739|      0|                        parse_with_separator(spec, dot, uid, gid, username, groupname);
 1740|      0|                    if (!tmp___2) {
 1741|      0|                        error_msg = (char const *)((void *)0);
 1742|      0|                    }
 1743|      0|                }
 1744|      0|            }
 1745|      1|        }
 1746|      2|        return (error_msg);
 1747|      2|    }
 1748|      2|}
 1749|       |char *(__attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i,
 1750|       |        char *buf___1)
 1751|      0|{
 1752|      0|    char *p;
 1753|       |
 1754|      0|    {
 1755|      0|        p = buf___1 + (((sizeof(uintmax_t) * 8UL) * 146UL) / 485UL + 1UL);
 1756|      0|        *p = (char)0;
 1757|      0|        while (1) {
 1758|      0|            p--;
 1759|      0|            *p = (char)(48UL + i % 10UL);
 1760|      0|            i /= 10UL;
 1761|      0|            if (!(i != 0UL)) {
 1762|      0|                goto while_break;
 1763|      0|            }
 1764|      0|        }
 1765|      0|while_break:
 1766|      0|        ;
 1767|      0|        return (p);
 1768|      0|    }
 1769|      0|}
 1770|       |#pragma weak pthread_key_create
 1771|       |#pragma weak pthread_getspecific
 1772|       |#pragma weak pthread_setspecific
 1773|       |#pragma weak pthread_key_delete
 1774|       |#pragma weak pthread_self
 1775|       |#pragma weak pthread_cancel
 1776|       |size_t strnlen1(char const *string, size_t maxlen)
 1777|      0|{
 1778|      0|    char const *end;
 1779|      0|    char const *tmp;
 1780|       |
 1781|      0|    {
 1782|      0|        tmp = (char const *)memchr((void const *)string, '\000', maxlen);
 1783|      0|        end = tmp;
 1784|      0|        if ((unsigned long)end != (unsigned long)((void *)0)) {
 1785|      0|            return ((size_t)((end - string) + 1L));
 1786|      0|        }
 1787|      0|        else {
 1788|      0|            return (maxlen);
 1789|      0|        }
 1790|      0|    }
 1791|      0|}
 1792|       |int open_safer(char const *file, int flags, ...);
 1793|       |struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i);
 1794|       |struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i)
 1795|      0|{
 1796|      0|    struct stat statbuf;
 1797|      0|    int tmp;
 1798|       |
 1799|      0|    {
 1800|      0|        tmp = lstat("/", &statbuf);
 1801|      0|        if (tmp) {
 1802|      0|            return ((struct dev_ino *)((void *)0));
 1803|      0|        }
 1804|      0|        root_d_i->st_ino = statbuf.st_ino;
 1805|      0|        root_d_i->st_dev = statbuf.st_dev;
 1806|      0|        return (root_d_i);
 1807|      0|    }
 1808|      0|}
 1809|       |reg_syntax_t rpl_re_syntax_options;
 1810|       |char const *const quoting_style_args[9];
 1811|       |enum quoting_style const quoting_style_vals[8];
 1812|       |int set_char_quoting(struct quoting_options *o, char c, int i);
 1813|       |char *quotearg_char(char const *arg, char ch);
 1814|       |char *quotearg_char_mem(char const *arg, size_t argsize, char ch);
 1815|       |__inline static char *xcharalloc(size_t n) __attribute__((__malloc__));
 1816|       |__inline static char *xcharalloc(size_t n) __attribute__((__malloc__));
 1817|       |__inline static char *xcharalloc(size_t n)
 1818|      0|{
 1819|      0|    void *tmp;
 1820|      0|    void *tmp___0;
 1821|      0|    void *tmp___1;
 1822|       |
 1823|      0|    {
 1824|      0|        if (sizeof(char) == 1UL) {
 1825|      0|            tmp = xmalloc(n);
 1826|      0|            tmp___1 = tmp;
 1827|      0|        }
 1828|      0|        else {
 1829|      0|            tmp___0 = xnmalloc(n, sizeof(char));
 1830|      0|            tmp___1 = tmp___0;
 1831|      0|        }
 1832|      0|        return ((char *)tmp___1);
 1833|      0|    }
 1834|      0|}
 1835|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) iswprint)(
 1836|       |    wint_t __wc);
 1837|       |char const *const quoting_style_args[9] = {
 1838|       |    "literal", "shell",   "shell-always", "c", "c-maybe", "escape",
 1839|       |    "locale",  "clocale", (char const *)0
 1840|       |};
 1841|       |enum quoting_style const quoting_style_vals[8] = {
 1842|       |    (enum quoting_style const)0, (enum quoting_style const)1,
 1843|       |    (enum quoting_style const)2, (enum quoting_style const)3,
 1844|       |    (enum quoting_style const)4, (enum quoting_style const)5,
 1845|       |    (enum quoting_style const)6, (enum quoting_style const)7
 1846|       |};
 1847|       |static struct quoting_options default_quoting_options;
 1848|       |int set_char_quoting(struct quoting_options *o, char c, int i)
 1849|      0|{
 1850|      0|    unsigned char uc;
 1851|      0|    unsigned int *p;
 1852|      0|    struct quoting_options *tmp;
 1853|      0|    int shift;
 1854|      0|    int r;
 1855|       |
 1856|      0|    {
 1857|      0|        uc = (unsigned char)c;
 1858|      0|        if (o) {
 1859|      0|            tmp = o;
 1860|      0|        }
 1861|      0|        else {
 1862|      0|            tmp = &default_quoting_options;
 1863|      0|        }
 1864|      0|        p = tmp->quote_these_too + (unsigned long)uc / (sizeof(int) * 8UL);
 1865|      0|        shift = (int)((unsigned long)uc % (sizeof(int) * 8UL));
 1866|      0|        r = (int)((*p >> shift) & 1U);
 1867|      0|        *p ^= (unsigned int)(((i & 1) ^ r) << shift);
 1868|      0|        return (r);
 1869|      0|    }
 1870|      0|}
 1871|       |static struct quoting_options
 1872|       |quoting_options_from_style(enum quoting_style style)
 1873|      0|{
 1874|      0|    struct quoting_options o;
 1875|       |
 1876|      0|    {
 1877|      0|        o.style = style;
 1878|      0|        o.flags = 0;
 1879|      0|        memset((void *)(o.quote_these_too), 0, sizeof(o.quote_these_too));
 1880|      0|        return (o);
 1881|      0|    }
 1882|      0|}
 1883|       |static char const *gettext_quote(char const *msgid, enum quoting_style s)
 1884|      0|{
 1885|      0|    char const *translation;
 1886|      0|    char const *tmp;
 1887|       |
 1888|      0|    {
 1889|      0|        tmp = (char const *)gettext(msgid);
 1890|      0|        translation = tmp;
 1891|      0|        if ((unsigned long)translation == (unsigned long)msgid) {
 1892|      0|            if ((unsigned int)s == 7U) {
 1893|      0|                translation = "\"";
 1894|      0|            }
 1895|      0|        }
 1896|      0|        return (translation);
 1897|      0|    }
 1898|      0|}
 1899|       |static size_t
 1900|       |quotearg_buffer_restyled(char *buffer, size_t buffersize, char const *arg,
 1901|       |                         size_t argsize, enum quoting_style quoting_style,
 1902|       |                         int flags, unsigned int const *quote_these_too,
 1903|       |                         char const *left_quote, char const *right_quote)
 1904|      0|{
 1905|      0|    size_t i;
 1906|      0|    size_t len;
 1907|      0|    char const *quote_string;
 1908|      0|    size_t quote_string_len;
 1909|      0|    _Bool backslash_escapes;
 1910|      0|    _Bool unibyte_locale;
 1911|      0|    size_t tmp;
 1912|      0|    _Bool elide_outer_quotes;
 1913|      0|    unsigned char c;
 1914|      0|    unsigned char esc;
 1915|      0|    _Bool is_right_quote;
 1916|      0|    int tmp___0;
 1917|      0|    int tmp___1;
 1918|      0|    size_t m;
 1919|      0|    _Bool printable;
 1920|      0|    unsigned short const **tmp___2;
 1921|      0|    mbstate_t mbstate;
 1922|      0|    wchar_t w;
 1923|      0|    size_t bytes;
 1924|      0|    size_t tmp___3;
 1925|      0|    size_t j;
 1926|      0|    int tmp___4;
 1927|      0|    int tmp___5;
 1928|      0|    size_t ilim;
 1929|      0|    int tmp___6;
 1930|      0|    size_t tmp___7;
 1931|       |
 1932|      0|    {
 1933|      0|        len = (size_t)0;
 1934|      0|        quote_string = (char const *)0;
 1935|      0|        quote_string_len = (size_t)0;
 1936|      0|        backslash_escapes = (_Bool)0;
 1937|      0|        tmp = __ctype_get_mb_cur_max();
 1938|      0|        unibyte_locale = (_Bool)(tmp == 1UL);
 1939|      0|        elide_outer_quotes = (_Bool)((flags & 2) != 0);
 1940|      0|        if ((unsigned int)quoting_style == 4U) {
 1941|      0|            goto case_4;
 1942|      0|        }
 1943|      0|        if ((unsigned int)quoting_style == 3U) {
 1944|      0|            goto case_3;
 1945|      0|        }
 1946|      0|        if ((unsigned int)quoting_style == 5U) {
 1947|      0|            goto case_5;
 1948|      0|        }
 1949|      0|        if ((unsigned int)quoting_style == 6U) {
 1950|      0|            goto case_6;
 1951|      0|        }
 1952|      0|        if ((unsigned int)quoting_style == 7U) {
 1953|      0|            goto case_6;
 1954|      0|        }
 1955|      0|        if ((unsigned int)quoting_style == 8U) {
 1956|      0|            goto case_6;
 1957|      0|        }
 1958|      0|        if ((unsigned int)quoting_style == 1U) {
 1959|      0|            goto case_1;
 1960|      0|        }
 1961|      0|        if ((unsigned int)quoting_style == 2U) {
 1962|      0|            goto case_2;
 1963|      0|        }
 1964|      0|        if ((unsigned int)quoting_style == 0U) {
 1965|      0|            goto case_0;
 1966|      0|        }
 1967|      0|        goto switch_default;
 1968|      0|case_4:
 1969|      0|        quoting_style = (enum quoting_style)3;
 1970|      0|        elide_outer_quotes = (_Bool)1;
 1971|      0|case_3:
 1972|      0|        if (!elide_outer_quotes) {
 1973|      0|            while (1) {
 1974|       |
 1975|      0|                if (len < buffersize) {
 1976|      0|                    *(buffer + len) = (char)'\"';
 1977|      0|                }
 1978|      0|                len++;
 1979|      0|                goto while_break;
 1980|      0|            }
 1981|      0|while_break:
 1982|      0|            ;
 1983|      0|        }
 1984|      0|        backslash_escapes = (_Bool)1;
 1985|      0|        quote_string = "\"";
 1986|      0|        quote_string_len = (size_t)1;
 1987|      0|        goto switch_break;
 1988|      0|case_5:
 1989|      0|        backslash_escapes = (_Bool)1;
 1990|      0|        elide_outer_quotes = (_Bool)0;
 1991|      0|        goto switch_break;
 1992|      0|case_6:
 1993|      0|        if ((unsigned int)quoting_style != 8U) {
 1994|      0|            left_quote = gettext_quote("`", quoting_style);
 1995|      0|            right_quote = gettext_quote("\'", quoting_style);
 1996|      0|        }
 1997|      0|        if (!elide_outer_quotes) {
 1998|      0|            quote_string = left_quote;
 1999|      0|            while (1) {
 2000|       |
 2001|      0|                if (!*quote_string) {
 2002|      0|                    goto while_break___0;
 2003|      0|                }
 2004|      0|                while (1) {
 2005|       |
 2006|      0|                    if (len < buffersize) {
 2007|      0|                        *(buffer + len) = (char)*quote_string;
 2008|      0|                    }
 2009|      0|                    len++;
 2010|      0|                    goto while_break___1;
 2011|      0|                }
 2012|      0|while_break___1:
 2013|      0|                quote_string++;
 2014|      0|            }
 2015|      0|while_break___0:
 2016|      0|            ;
 2017|      0|        }
 2018|      0|        backslash_escapes = (_Bool)1;
 2019|      0|        quote_string = right_quote;
 2020|      0|        quote_string_len = strlen(quote_string);
 2021|      0|        goto switch_break;
 2022|      0|case_1:
 2023|      0|        quoting_style = (enum quoting_style)2;
 2024|      0|        elide_outer_quotes = (_Bool)1;
 2025|      0|case_2:
 2026|      0|        if (!elide_outer_quotes) {
 2027|      0|            while (1) {
 2028|       |
 2029|      0|                if (len < buffersize) {
 2030|      0|                    *(buffer + len) = (char)'\'';
 2031|      0|                }
 2032|      0|                len++;
 2033|      0|                goto while_break___2;
 2034|      0|            }
 2035|      0|while_break___2:
 2036|      0|            ;
 2037|      0|        }
 2038|      0|        quote_string = "\'";
 2039|      0|        quote_string_len = (size_t)1;
 2040|      0|        goto switch_break;
 2041|      0|case_0:
 2042|      0|        elide_outer_quotes = (_Bool)0;
 2043|      0|        goto switch_break;
 2044|      0|switch_default:
 2045|      0|        abort();
 2046|      0|switch_break:
 2047|      0|        i = (size_t)0;
 2048|      0|        while (1) {
 2049|       |
 2050|      0|            if (argsize == 0xffffffffffffffffUL) {
 2051|      0|                tmp___6 = (int const) * (arg + i) == 0;
 2052|      0|            }
 2053|      0|            else {
 2054|      0|                tmp___6 = i == argsize;
 2055|      0|            }
 2056|      0|            if (tmp___6) {
 2057|      0|                goto while_break___3;
 2058|      0|            }
 2059|      0|            is_right_quote = (_Bool)0;
 2060|      0|            if (backslash_escapes) {
 2061|      0|                if (quote_string_len) {
 2062|      0|                    if (i + quote_string_len <= argsize) {
 2063|      0|                        tmp___0 = memcmp((void const *)(arg + i),
 2064|      0|                                         (void const *)quote_string, quote_string_len);
 2065|      0|                        if (tmp___0 == 0) {
 2066|      0|                            if (elide_outer_quotes) {
 2067|      0|                                goto force_outer_quoting_style;
 2068|      0|                            }
 2069|      0|                            is_right_quote = (_Bool)1;
 2070|      0|                        }
 2071|      0|                    }
 2072|      0|                }
 2073|      0|            }
 2074|      0|            c = (unsigned char)*(arg + i);
 2075|      0|            if ((int)c == 0) {
 2076|      0|                goto case_0___0;
 2077|      0|            }
 2078|      0|            if ((int)c == 63) {
 2079|      0|                goto case_63;
 2080|      0|            }
 2081|      0|            if ((int)c == 7) {
 2082|      0|                goto case_7___0;
 2083|      0|            }
 2084|      0|            if ((int)c == 8) {
 2085|      0|                goto case_8___0;
 2086|      0|            }
 2087|      0|            if ((int)c == 12) {
 2088|      0|                goto case_12;
 2089|      0|            }
 2090|      0|            if ((int)c == 10) {
 2091|      0|                goto case_10;
 2092|      0|            }
 2093|      0|            if ((int)c == 13) {
 2094|      0|                goto case_13;
 2095|      0|            }
 2096|      0|            if ((int)c == 9) {
 2097|      0|                goto case_9;
 2098|      0|            }
 2099|      0|            if ((int)c == 11) {
 2100|      0|                goto case_11;
 2101|      0|            }
 2102|      0|            if ((int)c == 92) {
 2103|      0|                goto case_92;
 2104|      0|            }
 2105|      0|            if ((int)c == 123) {
 2106|      0|                goto case_123;
 2107|      0|            }
 2108|      0|            if ((int)c == 125) {
 2109|      0|                goto case_123;
 2110|      0|            }
 2111|      0|            if ((int)c == 35) {
 2112|      0|                goto case_35;
 2113|      0|            }
 2114|      0|            if ((int)c == 126) {
 2115|      0|                goto case_35;
 2116|      0|            }
 2117|      0|            if ((int)c == 32) {
 2118|      0|                goto case_32;
 2119|      0|            }
 2120|      0|            if ((int)c == 33) {
 2121|      0|                goto case_32;
 2122|      0|            }
 2123|      0|            if ((int)c == 34) {
 2124|      0|                goto case_32;
 2125|      0|            }
 2126|      0|            if ((int)c == 36) {
 2127|      0|                goto case_32;
 2128|      0|            }
 2129|      0|            if ((int)c == 38) {
 2130|      0|                goto case_32;
 2131|      0|            }
 2132|      0|            if ((int)c == 40) {
 2133|      0|                goto case_32;
 2134|      0|            }
 2135|      0|            if ((int)c == 41) {
 2136|      0|                goto case_32;
 2137|      0|            }
 2138|      0|            if ((int)c == 42) {
 2139|      0|                goto case_32;
 2140|      0|            }
 2141|      0|            if ((int)c == 59) {
 2142|      0|                goto case_32;
 2143|      0|            }
 2144|      0|            if ((int)c == 60) {
 2145|      0|                goto case_32;
 2146|      0|            }
 2147|      0|            if ((int)c == 61) {
 2148|      0|                goto case_32;
 2149|      0|            }
 2150|      0|            if ((int)c == 62) {
 2151|      0|                goto case_32;
 2152|      0|            }
 2153|      0|            if ((int)c == 91) {
 2154|      0|                goto case_32;
 2155|      0|            }
 2156|      0|            if ((int)c == 94) {
 2157|      0|                goto case_32;
 2158|      0|            }
 2159|      0|            if ((int)c == 96) {
 2160|      0|                goto case_32;
 2161|      0|            }
 2162|      0|            if ((int)c == 124) {
 2163|      0|                goto case_32;
 2164|      0|            }
 2165|      0|            if ((int)c == 39) {
 2166|      0|                goto case_39___0;
 2167|      0|            }
 2168|      0|            if ((int)c == 37) {
 2169|      0|                goto case_37;
 2170|      0|            }
 2171|      0|            if ((int)c == 43) {
 2172|      0|                goto case_37;
 2173|      0|            }
 2174|      0|            if ((int)c == 44) {
 2175|      0|                goto case_37;
 2176|      0|            }
 2177|      0|            if ((int)c == 45) {
 2178|      0|                goto case_37;
 2179|      0|            }
 2180|      0|            if ((int)c == 46) {
 2181|      0|                goto case_37;
 2182|      0|            }
 2183|      0|            if ((int)c == 47) {
 2184|      0|                goto case_37;
 2185|      0|            }
 2186|      0|            if ((int)c == 48) {
 2187|      0|                goto case_37;
 2188|      0|            }
 2189|      0|            if ((int)c == 49) {
 2190|      0|                goto case_37;
 2191|      0|            }
 2192|      0|            if ((int)c == 50) {
 2193|      0|                goto case_37;
 2194|      0|            }
 2195|      0|            if ((int)c == 51) {
 2196|      0|                goto case_37;
 2197|      0|            }
 2198|      0|            if ((int)c == 52) {
 2199|      0|                goto case_37;
 2200|      0|            }
 2201|      0|            if ((int)c == 53) {
 2202|      0|                goto case_37;
 2203|      0|            }
 2204|      0|            if ((int)c == 54) {
 2205|      0|                goto case_37;
 2206|      0|            }
 2207|      0|            if ((int)c == 55) {
 2208|      0|                goto case_37;
 2209|      0|            }
 2210|      0|            if ((int)c == 56) {
 2211|      0|                goto case_37;
 2212|      0|            }
 2213|      0|            if ((int)c == 57) {
 2214|      0|                goto case_37;
 2215|      0|            }
 2216|      0|            if ((int)c == 58) {
 2217|      0|                goto case_37;
 2218|      0|            }
 2219|      0|            if ((int)c == 65) {
 2220|      0|                goto case_37;
 2221|      0|            }
 2222|      0|            if ((int)c == 66) {
 2223|      0|                goto case_37;
 2224|      0|            }
 2225|      0|            if ((int)c == 67) {
 2226|      0|                goto case_37;
 2227|      0|            }
 2228|      0|            if ((int)c == 68) {
 2229|      0|                goto case_37;
 2230|      0|            }
 2231|      0|            if ((int)c == 69) {
 2232|      0|                goto case_37;
 2233|      0|            }
 2234|      0|            if ((int)c == 70) {
 2235|      0|                goto case_37;
 2236|      0|            }
 2237|      0|            if ((int)c == 71) {
 2238|      0|                goto case_37;
 2239|      0|            }
 2240|      0|            if ((int)c == 72) {
 2241|      0|                goto case_37;
 2242|      0|            }
 2243|      0|            if ((int)c == 73) {
 2244|      0|                goto case_37;
 2245|      0|            }
 2246|      0|            if ((int)c == 74) {
 2247|      0|                goto case_37;
 2248|      0|            }
 2249|      0|            if ((int)c == 75) {
 2250|      0|                goto case_37;
 2251|      0|            }
 2252|      0|            if ((int)c == 76) {
 2253|      0|                goto case_37;
 2254|      0|            }
 2255|      0|            if ((int)c == 77) {
 2256|      0|                goto case_37;
 2257|      0|            }
 2258|      0|            if ((int)c == 78) {
 2259|      0|                goto case_37;
 2260|      0|            }
 2261|      0|            if ((int)c == 79) {
 2262|      0|                goto case_37;
 2263|      0|            }
 2264|      0|            if ((int)c == 80) {
 2265|      0|                goto case_37;
 2266|      0|            }
 2267|      0|            if ((int)c == 81) {
 2268|      0|                goto case_37;
 2269|      0|            }
 2270|      0|            if ((int)c == 82) {
 2271|      0|                goto case_37;
 2272|      0|            }
 2273|      0|            if ((int)c == 83) {
 2274|      0|                goto case_37;
 2275|      0|            }
 2276|      0|            if ((int)c == 84) {
 2277|      0|                goto case_37;
 2278|      0|            }
 2279|      0|            if ((int)c == 85) {
 2280|      0|                goto case_37;
 2281|      0|            }
 2282|      0|            if ((int)c == 86) {
 2283|      0|                goto case_37;
 2284|      0|            }
 2285|      0|            if ((int)c == 87) {
 2286|      0|                goto case_37;
 2287|      0|            }
 2288|      0|            if ((int)c == 88) {
 2289|      0|                goto case_37;
 2290|      0|            }
 2291|      0|            if ((int)c == 89) {
 2292|      0|                goto case_37;
 2293|      0|            }
 2294|      0|            if ((int)c == 90) {
 2295|      0|                goto case_37;
 2296|      0|            }
 2297|      0|            if ((int)c == 93) {
 2298|      0|                goto case_37;
 2299|      0|            }
 2300|      0|            if ((int)c == 95) {
 2301|      0|                goto case_37;
 2302|      0|            }
 2303|      0|            if ((int)c == 97) {
 2304|      0|                goto case_37;
 2305|      0|            }
 2306|      0|            if ((int)c == 98) {
 2307|      0|                goto case_37;
 2308|      0|            }
 2309|      0|            if ((int)c == 99) {
 2310|      0|                goto case_37;
 2311|      0|            }
 2312|      0|            if ((int)c == 100) {
 2313|      0|                goto case_37;
 2314|      0|            }
 2315|      0|            if ((int)c == 101) {
 2316|      0|                goto case_37;
 2317|      0|            }
 2318|      0|            if ((int)c == 102) {
 2319|      0|                goto case_37;
 2320|      0|            }
 2321|      0|            if ((int)c == 103) {
 2322|      0|                goto case_37;
 2323|      0|            }
 2324|      0|            if ((int)c == 104) {
 2325|      0|                goto case_37;
 2326|      0|            }
 2327|      0|            if ((int)c == 105) {
 2328|      0|                goto case_37;
 2329|      0|            }
 2330|      0|            if ((int)c == 106) {
 2331|      0|                goto case_37;
 2332|      0|            }
 2333|      0|            if ((int)c == 107) {
 2334|      0|                goto case_37;
 2335|      0|            }
 2336|      0|            if ((int)c == 108) {
 2337|      0|                goto case_37;
 2338|      0|            }
 2339|      0|            if ((int)c == 109) {
 2340|      0|                goto case_37;
 2341|      0|            }
 2342|      0|            if ((int)c == 110) {
 2343|      0|                goto case_37;
 2344|      0|            }
 2345|      0|            if ((int)c == 111) {
 2346|      0|                goto case_37;
 2347|      0|            }
 2348|      0|            if ((int)c == 112) {
 2349|      0|                goto case_37;
 2350|      0|            }
 2351|      0|            if ((int)c == 113) {
 2352|      0|                goto case_37;
 2353|      0|            }
 2354|      0|            if ((int)c == 114) {
 2355|      0|                goto case_37;
 2356|      0|            }
 2357|      0|            if ((int)c == 115) {
 2358|      0|                goto case_37;
 2359|      0|            }
 2360|      0|            if ((int)c == 116) {
 2361|      0|                goto case_37;
 2362|      0|            }
 2363|      0|            if ((int)c == 117) {
 2364|      0|                goto case_37;
 2365|      0|            }
 2366|      0|            if ((int)c == 118) {
 2367|      0|                goto case_37;
 2368|      0|            }
 2369|      0|            if ((int)c == 119) {
 2370|      0|                goto case_37;
 2371|      0|            }
 2372|      0|            if ((int)c == 120) {
 2373|      0|                goto case_37;
 2374|      0|            }
 2375|      0|            if ((int)c == 121) {
 2376|      0|                goto case_37;
 2377|      0|            }
 2378|      0|            if ((int)c == 122) {
 2379|      0|                goto case_37;
 2380|      0|            }
 2381|      0|            goto switch_default___2;
 2382|      0|case_0___0:
 2383|      0|            if (backslash_escapes) {
 2384|      0|                if (elide_outer_quotes) {
 2385|      0|                    goto force_outer_quoting_style;
 2386|      0|                }
 2387|      0|                while (1) {
 2388|       |
 2389|      0|                    if (len < buffersize) {
 2390|      0|                        *(buffer + len) = (char)'\\';
 2391|      0|                    }
 2392|      0|                    len++;
 2393|      0|                    goto while_break___4;
 2394|      0|                }
 2395|      0|while_break___4:
 2396|      0|                ;
 2397|      0|                if (i + 1UL < argsize) {
 2398|      0|                    if (48 <= (int)*(arg + (i + 1UL))) {
 2399|      0|                        if ((int const) * (arg + (i + 1UL)) <= 57) {
 2400|      0|                            while (1) {
 2401|       |
 2402|      0|                                if (len < buffersize) {
 2403|      0|                                    *(buffer + len) = (char)'0';
 2404|      0|                                }
 2405|      0|                                len++;
 2406|      0|                                goto while_break___5;
 2407|      0|                            }
 2408|      0|while_break___5:
 2409|      0|                            ;
 2410|      0|                            while (1) {
 2411|       |
 2412|      0|                                if (len < buffersize) {
 2413|      0|                                    *(buffer + len) = (char)'0';
 2414|      0|                                }
 2415|      0|                                len++;
 2416|      0|                                goto while_break___6;
 2417|      0|                            }
 2418|      0|while_break___6:
 2419|      0|                            ;
 2420|      0|                        }
 2421|      0|                    }
 2422|      0|                }
 2423|      0|                c = (unsigned char)'0';
 2424|      0|            }
 2425|      0|            else {
 2426|      0|                if (flags & 1) {
 2427|      0|                    goto __Cont;
 2428|      0|                }
 2429|      0|            }
 2430|      0|            goto switch_break___0;
 2431|      0|case_63:
 2432|      0|            if ((unsigned int)quoting_style == 2U) {
 2433|      0|                goto case_2___0;
 2434|      0|            }
 2435|      0|            if ((unsigned int)quoting_style == 3U) {
 2436|      0|                goto case_3___0;
 2437|      0|            }
 2438|      0|            goto switch_default___1;
 2439|      0|case_2___0:
 2440|      0|            if (elide_outer_quotes) {
 2441|      0|                goto force_outer_quoting_style;
 2442|      0|            }
 2443|      0|            goto switch_break___1;
 2444|      0|case_3___0:
 2445|      0|            if (flags & 4) {
 2446|      0|                if (i + 2UL < argsize) {
 2447|      0|                    if ((int const) * (arg + (i + 1UL)) == 63) {
 2448|      0|                        if ((int const) * (arg + (i + 2UL)) == 33) {
 2449|      0|                            goto case_33;
 2450|      0|                        }
 2451|      0|                        if ((int const) * (arg + (i + 2UL)) == 39) {
 2452|      0|                            goto case_33;
 2453|      0|                        }
 2454|      0|                        if ((int const) * (arg + (i + 2UL)) == 40) {
 2455|      0|                            goto case_33;
 2456|      0|                        }
 2457|      0|                        if ((int const) * (arg + (i + 2UL)) == 41) {
 2458|      0|                            goto case_33;
 2459|      0|                        }
 2460|      0|                        if ((int const) * (arg + (i + 2UL)) == 45) {
 2461|      0|                            goto case_33;
 2462|      0|                        }
 2463|      0|                        if ((int const) * (arg + (i + 2UL)) == 47) {
 2464|      0|                            goto case_33;
 2465|      0|                        }
 2466|      0|                        if ((int const) * (arg + (i + 2UL)) == 60) {
 2467|      0|                            goto case_33;
 2468|      0|                        }
 2469|      0|                        if ((int const) * (arg + (i + 2UL)) == 61) {
 2470|      0|                            goto case_33;
 2471|      0|                        }
 2472|      0|                        if ((int const) * (arg + (i + 2UL)) == 62) {
 2473|      0|                            goto case_33;
 2474|      0|                        }
 2475|      0|                        goto switch_default___0;
 2476|      0|case_33:
 2477|      0|                        if (elide_outer_quotes) {
 2478|      0|                            goto force_outer_quoting_style;
 2479|      0|                        }
 2480|      0|                        c = (unsigned char)*(arg + (i + 2UL));
 2481|      0|                        i += 2UL;
 2482|      0|                        while (1) {
 2483|       |
 2484|      0|                            if (len < buffersize) {
 2485|      0|                                *(buffer + len) = (char)'?';
 2486|      0|                            }
 2487|      0|                            len++;
 2488|      0|                            goto while_break___7;
 2489|      0|                        }
 2490|      0|while_break___7:
 2491|      0|                        ;
 2492|      0|                        while (1) {
 2493|       |
 2494|      0|                            if (len < buffersize) {
 2495|      0|                                *(buffer + len) = (char)'\"';
 2496|      0|                            }
 2497|      0|                            len++;
 2498|      0|                            goto while_break___8;
 2499|      0|                        }
 2500|      0|while_break___8:
 2501|      0|                        ;
 2502|      0|                        while (1) {
 2503|       |
 2504|      0|                            if (len < buffersize) {
 2505|      0|                                *(buffer + len) = (char)'\"';
 2506|      0|                            }
 2507|      0|                            len++;
 2508|      0|                            goto while_break___9;
 2509|      0|                        }
 2510|      0|while_break___9:
 2511|      0|                        ;
 2512|      0|                        while (1) {
 2513|       |
 2514|      0|                            if (len < buffersize) {
 2515|      0|                                *(buffer + len) = (char)'?';
 2516|      0|                            }
 2517|      0|                            len++;
 2518|      0|                            goto while_break___10;
 2519|      0|                        }
 2520|      0|while_break___10:
 2521|      0|                        ;
 2522|      0|                        goto switch_break___2;
 2523|      0|switch_default___0:
 2524|      0|                        goto switch_break___2;
 2525|      0|switch_break___2:
 2526|      0|                        ;
 2527|      0|                    }
 2528|      0|                }
 2529|      0|            }
 2530|      0|            goto switch_break___1;
 2531|      0|switch_default___1:
 2532|      0|            goto switch_break___1;
 2533|      0|switch_break___1:
 2534|      0|            ;
 2535|      0|            goto switch_break___0;
 2536|      0|case_7___0:
 2537|      0|            esc = (unsigned char)'a';
 2538|      0|            goto c_escape;
 2539|      0|case_8___0:
 2540|      0|            esc = (unsigned char)'b';
 2541|      0|            goto c_escape;
 2542|      0|case_12:
 2543|      0|            esc = (unsigned char)'f';
 2544|      0|            goto c_escape;
 2545|      0|case_10:
 2546|      0|            esc = (unsigned char)'n';
 2547|      0|            goto c_and_shell_escape;
 2548|      0|case_13:
 2549|      0|            esc = (unsigned char)'r';
 2550|      0|            goto c_and_shell_escape;
 2551|      0|case_9:
 2552|      0|            esc = (unsigned char)'t';
 2553|      0|            goto c_and_shell_escape;
 2554|      0|case_11:
 2555|      0|            esc = (unsigned char)'v';
 2556|      0|            goto c_escape;
 2557|      0|case_92:
 2558|      0|            esc = c;
 2559|      0|            if (backslash_escapes) {
 2560|      0|                if (elide_outer_quotes) {
 2561|      0|                    if (quote_string_len) {
 2562|      0|                        goto store_c;
 2563|      0|                    }
 2564|      0|                }
 2565|      0|            }
 2566|      0|c_and_shell_escape:
 2567|      0|            if ((unsigned int)quoting_style == 2U) {
 2568|      0|                if (elide_outer_quotes) {
 2569|      0|                    goto force_outer_quoting_style;
 2570|      0|                }
 2571|      0|            }
 2572|      0|c_escape:
 2573|      0|            if (backslash_escapes) {
 2574|      0|                c = esc;
 2575|      0|                goto store_escape;
 2576|      0|            }
 2577|      0|            goto switch_break___0;
 2578|      0|case_123:
 2579|      0|            if (argsize == 0xffffffffffffffffUL) {
 2580|      0|                tmp___1 = (int const) * (arg + 1) == 0;
 2581|      0|            }
 2582|      0|            else {
 2583|      0|                tmp___1 = argsize == 1UL;
 2584|      0|            }
 2585|      0|            if (!tmp___1) {
 2586|      0|                goto switch_break___0;
 2587|      0|            }
 2588|      0|case_35:
 2589|      0|            if (i != 0UL) {
 2590|      0|                goto switch_break___0;
 2591|      0|            }
 2592|      0|case_32:
 2593|      0|            if ((unsigned int)quoting_style == 2U) {
 2594|      0|                if (elide_outer_quotes) {
 2595|      0|                    goto force_outer_quoting_style;
 2596|      0|                }
 2597|      0|            }
 2598|      0|            goto switch_break___0;
 2599|      0|case_39___0:
 2600|      0|            if ((unsigned int)quoting_style == 2U) {
 2601|      0|                if (elide_outer_quotes) {
 2602|      0|                    goto force_outer_quoting_style;
 2603|      0|                }
 2604|      0|                while (1) {
 2605|       |
 2606|      0|                    if (len < buffersize) {
 2607|      0|                        *(buffer + len) = (char)'\'';
 2608|      0|                    }
 2609|      0|                    len++;
 2610|      0|                    goto while_break___11;
 2611|      0|                }
 2612|      0|while_break___11:
 2613|      0|                ;
 2614|      0|                while (1) {
 2615|       |
 2616|      0|                    if (len < buffersize) {
 2617|      0|                        *(buffer + len) = (char)'\\';
 2618|      0|                    }
 2619|      0|                    len++;
 2620|      0|                    goto while_break___12;
 2621|      0|                }
 2622|      0|while_break___12:
 2623|      0|                ;
 2624|      0|                while (1) {
 2625|       |
 2626|      0|                    if (len < buffersize) {
 2627|      0|                        *(buffer + len) = (char)'\'';
 2628|      0|                    }
 2629|      0|                    len++;
 2630|      0|                    goto while_break___13;
 2631|      0|                }
 2632|      0|while_break___13:
 2633|      0|                ;
 2634|      0|            }
 2635|      0|            goto switch_break___0;
 2636|      0|case_37:
 2637|      0|            goto switch_break___0;
 2638|      0|switch_default___2:
 2639|      0|            if (unibyte_locale) {
 2640|      0|                m = (size_t)1;
 2641|      0|                tmp___2 = __ctype_b_loc();
 2642|      0|                printable = (_Bool)(((int const) * (*tmp___2 + (int)c) & 16384) != 0);
 2643|      0|            }
 2644|      0|            else {
 2645|      0|                memset((void *)(&mbstate), 0, sizeof(mbstate));
 2646|      0|                m = (size_t)0;
 2647|      0|                printable = (_Bool)1;
 2648|      0|                if (argsize == 0xffffffffffffffffUL) {
 2649|      0|                    argsize = strlen(arg);
 2650|      0|                }
 2651|      0|                while (1) {
 2652|      0|                    tmp___3 = mbrtowc(&w, arg + (i + m), argsize - (i + m), &mbstate);
 2653|      0|                    bytes = tmp___3;
 2654|      0|                    if (bytes == 0UL) {
 2655|      0|                        goto while_break___14;
 2656|      0|                    }
 2657|      0|                    else {
 2658|      0|                        if (bytes == 0xffffffffffffffffUL) {
 2659|      0|                            printable = (_Bool)0;
 2660|      0|                            goto while_break___14;
 2661|      0|                        }
 2662|      0|                        else {
 2663|      0|                            if (bytes == 0xfffffffffffffffeUL) {
 2664|      0|                                printable = (_Bool)0;
 2665|      0|                                while (1) {
 2666|       |
 2667|      0|                                    if (i + m < argsize) {
 2668|      0|                                        if (!*(arg + (i + m))) {
 2669|      0|                                            goto while_break___15;
 2670|      0|                                        }
 2671|      0|                                    }
 2672|      0|                                    else {
 2673|      0|                                        goto while_break___15;
 2674|      0|                                    }
 2675|      0|                                    m++;
 2676|      0|                                }
 2677|      0|while_break___15:
 2678|      0|                                ;
 2679|      0|                                goto while_break___14;
 2680|      0|                            }
 2681|      0|                            else {
 2682|      0|                                if (elide_outer_quotes) {
 2683|      0|                                    if ((unsigned int)quoting_style == 2U) {
 2684|      0|                                        j = (size_t)1;
 2685|      0|                                        while (1) {
 2686|       |
 2687|      0|                                            if (!(j < bytes)) {
 2688|      0|                                                goto while_break___16;
 2689|      0|                                            }
 2690|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 91) {
 2691|      0|                                                goto case_91___0;
 2692|      0|                                            }
 2693|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 92) {
 2694|      0|                                                goto case_91___0;
 2695|      0|                                            }
 2696|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 94) {
 2697|      0|                                                goto case_91___0;
 2698|      0|                                            }
 2699|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 96) {
 2700|      0|                                                goto case_91___0;
 2701|      0|                                            }
 2702|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 124) {
 2703|      0|                                                goto case_91___0;
 2704|      0|                                            }
 2705|      0|                                            goto switch_default___3;
 2706|      0|case_91___0:
 2707|      0|                                            goto force_outer_quoting_style;
 2708|      0|switch_default___3:
 2709|      0|                                            goto switch_break___3;
 2710|      0|switch_break___3:
 2711|      0|                                            j++;
 2712|      0|                                        }
 2713|      0|while_break___16:
 2714|      0|                                        ;
 2715|      0|                                    }
 2716|      0|                                }
 2717|      0|                                tmp___4 = iswprint((wint_t)w);
 2718|      0|                                if (!tmp___4) {
 2719|      0|                                    printable = (_Bool)0;
 2720|      0|                                }
 2721|      0|                                m += bytes;
 2722|      0|                            }
 2723|      0|                        }
 2724|      0|                    }
 2725|      0|                    tmp___5 = mbsinit((mbstate_t const *)(&mbstate));
 2726|      0|                    if (tmp___5) {
 2727|      0|                        goto while_break___14;
 2728|      0|                    }
 2729|      0|                }
 2730|      0|while_break___14:
 2731|      0|                ;
 2732|      0|            }
 2733|      0|            if (1UL < m) {
 2734|      0|                goto _L___0;
 2735|      0|            }
 2736|      0|            else {
 2737|      0|                if (backslash_escapes) {
 2738|      0|                    if (!printable) {
 2739|      0|_L___0:
 2740|      0|                        ilim = i + m;
 2741|      0|                        while (1) {
 2742|       |
 2743|      0|                            if (backslash_escapes) {
 2744|      0|                                if (!printable) {
 2745|      0|                                    if (elide_outer_quotes) {
 2746|      0|                                        goto force_outer_quoting_style;
 2747|      0|                                    }
 2748|      0|                                    while (1) {
 2749|       |
 2750|      0|                                        if (len < buffersize) {
 2751|      0|                                            *(buffer + len) = (char)'\\';
 2752|      0|                                        }
 2753|      0|                                        len++;
 2754|      0|                                        goto while_break___18;
 2755|      0|                                    }
 2756|      0|while_break___18:
 2757|      0|                                    ;
 2758|      0|                                    while (1) {
 2759|       |
 2760|      0|                                        if (len < buffersize) {
 2761|      0|                                            *(buffer + len) = (char)(48 + ((int)c >> 6));
 2762|      0|                                        }
 2763|      0|                                        len++;
 2764|      0|                                        goto while_break___19;
 2765|      0|                                    }
 2766|      0|while_break___19:
 2767|      0|                                    ;
 2768|      0|                                    while (1) {
 2769|       |
 2770|      0|                                        if (len < buffersize) {
 2771|      0|                                            *(buffer + len) = (char)(48 + (((int)c >> 3) & 7));
 2772|      0|                                        }
 2773|      0|                                        len++;
 2774|      0|                                        goto while_break___20;
 2775|      0|                                    }
 2776|      0|while_break___20:
 2777|      0|                                    c = (unsigned char)(48 + ((int)c & 7));
 2778|      0|                                }
 2779|      0|                                else {
 2780|      0|                                    goto _L;
 2781|      0|                                }
 2782|      0|                            }
 2783|      0|                            else {
 2784|      0|_L:
 2785|      0|                                if (is_right_quote) {
 2786|      0|                                    while (1) {
 2787|       |
 2788|      0|                                        if (len < buffersize) {
 2789|      0|                                            *(buffer + len) = (char)'\\';
 2790|      0|                                        }
 2791|      0|                                        len++;
 2792|      0|                                        goto while_break___21;
 2793|      0|                                    }
 2794|      0|while_break___21:
 2795|      0|                                    is_right_quote = (_Bool)0;
 2796|      0|                                }
 2797|      0|                            }
 2798|      0|                            if (ilim <= i + 1UL) {
 2799|      0|                                goto while_break___17;
 2800|      0|                            }
 2801|      0|                            while (1) {
 2802|       |
 2803|      0|                                if (len < buffersize) {
 2804|      0|                                    *(buffer + len) = (char)c;
 2805|      0|                                }
 2806|      0|                                len++;
 2807|      0|                                goto while_break___22;
 2808|      0|                            }
 2809|      0|while_break___22:
 2810|      0|                            i++;
 2811|      0|                            c = (unsigned char)*(arg + i);
 2812|      0|                        }
 2813|      0|while_break___17:
 2814|      0|                        ;
 2815|      0|                        goto store_c;
 2816|      0|                    }
 2817|      0|                }
 2818|      0|            }
 2819|      0|switch_break___0:
 2820|      0|            ;
 2821|      0|            if (backslash_escapes) {
 2822|      0|                goto _L___3;
 2823|      0|            }
 2824|      0|            else {
 2825|      0|                if (elide_outer_quotes) {
 2826|      0|_L___3:
 2827|      0|                    if (quote_these_too) {
 2828|      0|                        if (!(*(quote_these_too + (unsigned long)c / (sizeof(int) * 8UL)) &
 2829|      0|                                (unsigned int const)(1 << (unsigned long)c %
 2830|      0|                                                     (sizeof(int) * 8UL)))) {
 2831|      0|                            goto _L___2;
 2832|      0|                        }
 2833|      0|                    }
 2834|      0|                    else {
 2835|      0|                        goto _L___2;
 2836|      0|                    }
 2837|      0|                }
 2838|      0|                else {
 2839|      0|_L___2:
 2840|      0|                    if (!is_right_quote) {
 2841|      0|                        goto store_c;
 2842|      0|                    }
 2843|      0|                }
 2844|      0|            }
 2845|      0|store_escape:
 2846|      0|            if (elide_outer_quotes) {
 2847|      0|                goto force_outer_quoting_style;
 2848|      0|            }
 2849|      0|            while (1) {
 2850|       |
 2851|      0|                if (len < buffersize) {
 2852|      0|                    *(buffer + len) = (char)'\\';
 2853|      0|                }
 2854|      0|                len++;
 2855|      0|                goto while_break___23;
 2856|      0|            }
 2857|      0|while_break___23:
 2858|      0|            ;
 2859|      0|store_c:
 2860|      0|            while (1) {
 2861|       |
 2862|      0|                if (len < buffersize) {
 2863|      0|                    *(buffer + len) = (char)c;
 2864|      0|                }
 2865|      0|                len++;
 2866|      0|                goto while_break___24;
 2867|      0|            }
 2868|      0|while_break___24:
 2869|      0|            ;
 2870|      0|__Cont:
 2871|      0|            i++;
 2872|      0|        }
 2873|      0|while_break___3:
 2874|      0|        ;
 2875|      0|        if (len == 0UL) {
 2876|      0|            if ((unsigned int)quoting_style == 2U) {
 2877|      0|                if (elide_outer_quotes) {
 2878|      0|                    goto force_outer_quoting_style;
 2879|      0|                }
 2880|      0|            }
 2881|      0|        }
 2882|      0|        if (quote_string) {
 2883|      0|            if (!elide_outer_quotes) {
 2884|      0|                while (1) {
 2885|       |
 2886|      0|                    if (!*quote_string) {
 2887|      0|                        goto while_break___25;
 2888|      0|                    }
 2889|      0|                    while (1) {
 2890|       |
 2891|      0|                        if (len < buffersize) {
 2892|      0|                            *(buffer + len) = (char)*quote_string;
 2893|      0|                        }
 2894|      0|                        len++;
 2895|      0|                        goto while_break___26;
 2896|      0|                    }
 2897|      0|while_break___26:
 2898|      0|                    quote_string++;
 2899|      0|                }
 2900|      0|while_break___25:
 2901|      0|                ;
 2902|      0|            }
 2903|      0|        }
 2904|      0|        if (len < buffersize) {
 2905|      0|            *(buffer + len) = (char)'\000';
 2906|      0|        }
 2907|      0|        return (len);
 2908|      0|force_outer_quoting_style:
 2909|      0|        tmp___7 = quotearg_buffer_restyled(
 2910|      0|                      buffer, buffersize, arg, argsize, quoting_style, flags & -3,
 2911|      0|                      (unsigned int const *)((void *)0), left_quote, right_quote);
 2912|      0|        return (tmp___7);
 2913|      0|    }
 2914|      0|}
 2915|       |static char slot0[256];
 2916|       |static unsigned int nslots = 1U;
 2917|       |static struct slotvec slotvec0 = {sizeof(slot0), slot0};
 2918|       |static struct slotvec *slotvec = &slotvec0;
 2919|       |static char *quotearg_n_options(int n, char const *arg, size_t argsize,
 2920|       |                                struct quoting_options const *options)
 2921|      0|{
 2922|      0|    int e;
 2923|      0|    int *tmp;
 2924|      0|    unsigned int n0;
 2925|      0|    struct slotvec *sv;
 2926|      0|    size_t n1;
 2927|      0|    _Bool preallocated;
 2928|      0|    int tmp___0;
 2929|      0|    struct slotvec *tmp___1;
 2930|      0|    size_t size;
 2931|      0|    char *val;
 2932|      0|    int flags;
 2933|      0|    size_t qsize;
 2934|      0|    size_t tmp___2;
 2935|      0|    int *tmp___3;
 2936|       |
 2937|      0|    {
 2938|      0|        tmp = __errno_location();
 2939|      0|        e = *tmp;
 2940|      0|        n0 = (unsigned int)n;
 2941|      0|        sv = slotvec;
 2942|      0|        if (n < 0) {
 2943|      0|            abort();
 2944|      0|        }
 2945|      0|        if (nslots <= n0) {
 2946|      0|            n1 = (size_t)(n0 + 1U);
 2947|      0|            preallocated = (_Bool)((unsigned long)sv == (unsigned long)(&slotvec0));
 2948|      0|            if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 2949|      0|                tmp___0 = -1;
 2950|      0|            }
 2951|      0|            else {
 2952|      0|                tmp___0 = -2;
 2953|      0|            }
 2954|      0|            if ((size_t)tmp___0 / sizeof(*sv) < n1) {
 2955|      0|                xalloc_die();
 2956|      0|            }
 2957|      0|            if (preallocated) {
 2958|      0|                tmp___1 = (struct slotvec *)((void *)0);
 2959|      0|            }
 2960|      0|            else {
 2961|      0|                tmp___1 = sv;
 2962|      0|            }
 2963|      0|            sv = (struct slotvec *)xrealloc((void *)tmp___1, n1 * sizeof(*sv));
 2964|      0|            slotvec = sv;
 2965|      0|            if (preallocated) {
 2966|      0|                *sv = slotvec0;
 2967|      0|            }
 2968|      0|            memset((void *)(sv + nslots), 0, (n1 - (size_t)nslots) * sizeof(*sv));
 2969|      0|            nslots = (unsigned int)n1;
 2970|      0|        }
 2971|      0|        size = (sv + n)->size;
 2972|      0|        val = (sv + n)->val;
 2973|      0|        flags = (int)(options->flags | 1);
 2974|      0|        tmp___2 = quotearg_buffer_restyled(
 2975|      0|                      val, size, arg, argsize, (enum quoting_style)options->style, flags,
 2976|      0|                      (unsigned int const *)(options->quote_these_too),
 2977|      0|                      (char const *)options->left_quote, (char const *)options->right_quote);
 2978|      0|        qsize = tmp___2;
 2979|      0|        if (size <= qsize) {
 2980|      0|            size = qsize + 1UL;
 2981|      0|            (sv + n)->size = size;
 2982|      0|            if ((unsigned long)val != (unsigned long)(slot0)) {
 2983|      0|                free((void *)val);
 2984|      0|            }
 2985|      0|            val = xcharalloc(size);
 2986|      0|            (sv + n)->val = val;
 2987|      0|            quotearg_buffer_restyled(val, size, arg, argsize,
 2988|      0|                                     (enum quoting_style)options->style, flags,
 2989|      0|                                     (unsigned int const *)(options->quote_these_too),
 2990|      0|                                     (char const *)options->left_quote,
 2991|      0|                                     (char const *)options->right_quote);
 2992|      0|        }
 2993|      0|        tmp___3 = __errno_location();
 2994|      0|        *tmp___3 = e;
 2995|      0|        return (val);
 2996|      0|    }
 2997|      0|}
 2998|       |char *quotearg_n_style(int n, enum quoting_style s, char const *arg)
 2999|      0|{
 3000|      0|    struct quoting_options o;
 3001|      0|    struct quoting_options tmp;
 3002|      0|    char *tmp___0;
 3003|       |
 3004|      0|    {
 3005|      0|        tmp = quoting_options_from_style(s);
 3006|      0|        o = tmp;
 3007|      0|        tmp___0 = quotearg_n_options(n, arg, (size_t)-1,
 3008|      0|                                     (struct quoting_options const *)(&o));
 3009|      0|        return (tmp___0);
 3010|      0|    }
 3011|      0|}
 3012|       |char *quotearg_char_mem(char const *arg, size_t argsize, char ch)
 3013|      0|{
 3014|      0|    struct quoting_options options;
 3015|      0|    char *tmp;
 3016|       |
 3017|      0|    {
 3018|      0|        options = default_quoting_options;
 3019|      0|        set_char_quoting(&options, ch, 1);
 3020|      0|        tmp = quotearg_n_options(0, arg, argsize,
 3021|      0|                                 (struct quoting_options const *)(&options));
 3022|      0|        return (tmp);
 3023|      0|    }
 3024|      0|}
 3025|       |char *quotearg_char(char const *arg, char ch)
 3026|      0|{
 3027|      0|    char *tmp;
 3028|       |
 3029|      0|    {
 3030|      0|        tmp = quotearg_char_mem(arg, (size_t)-1, ch);
 3031|      0|        return (tmp);
 3032|      0|    }
 3033|      0|}
 3034|       |char *quotearg_colon(char const *arg)
 3035|      0|{
 3036|      0|    char *tmp;
 3037|       |
 3038|      0|    {
 3039|      0|        tmp = quotearg_char(arg, (char)':');
 3040|      0|        return (tmp);
 3041|      0|    }
 3042|      0|}
 3043|       |char const *quote_n(int n, char const *name)
 3044|      0|{
 3045|      0|    char const *tmp;
 3046|       |
 3047|      0|    {
 3048|      0|        tmp = (char const *)quotearg_n_style(n, (enum quoting_style)6, name);
 3049|      0|        return (tmp);
 3050|      0|    }
 3051|      0|}
 3052|       |char const *quote(char const *name)
 3053|      0|{
 3054|      0|    char const *tmp;
 3055|       |
 3056|      0|    {
 3057|      0|        tmp = quote_n(0, name);
 3058|      0|        return (tmp);
 3059|      0|    }
 3060|      0|}
 3061|       |char const *program_name;
 3062|       |void set_program_name(char const *argv0);
 3063|       |extern char *program_invocation_name;
 3064|       |extern char *program_invocation_short_name;
 3065|       |extern int fputs(char const *__restrict __s, FILE *__restrict __stream);
 3066|       |char const *program_name = (char const *)((void *)0);
 3067|       |void set_program_name(char const *argv0)
 3068|      2|{
 3069|      2|    char const *slash;
 3070|      2|    char const *base;
 3071|      2|    int tmp;
 3072|      2|    int tmp___0;
 3073|       |
 3074|      2|    {
 3075|      2|        if ((unsigned long)argv0 == (unsigned long)((void *)0)) {
 3076|      0|            fputs("A NULL argv[0] was passed through an exec system call.\n", stderr);
 3077|      0|            abort();
 3078|      0|        }
 3079|      2|        slash = (char const *)strrchr(argv0, '/');
 3080|      2|        if ((unsigned long)slash != (unsigned long)((void *)0)) {
 3081|      2|            base = slash + 1;
 3082|      2|        }
 3083|      0|        else {
 3084|      0|            base = argv0;
 3085|      0|        }
 3086|      2|        if (base - argv0 >= 7L) {
 3087|      0|            tmp___0 = strncmp(base - 7, "/.libs/", (size_t)7);
 3088|      0|            if (tmp___0 == 0) {
 3089|      0|                argv0 = base;
 3090|      0|                tmp = strncmp(base, "lt-", (size_t)3);
 3091|      0|                if (tmp == 0) {
 3092|      0|                    argv0 = base + 3;
 3093|      0|                    program_invocation_short_name = (char *)argv0;
 3094|      0|                }
 3095|      0|            }
 3096|      0|        }
 3097|      2|        program_name = argv0;
 3098|      2|        program_invocation_name = (char *)argv0;
 3099|      2|        return;
 3100|      2|    }
 3101|      2|}
 3102|       |extern __attribute__((__nothrow__)) char *(__attribute__((
 3103|       |            __nonnull__(1, 2), __leaf__)) stpcpy)(char *__restrict __dest,
 3104|       |                    char const *__restrict __src);
 3105|       |extern DIR *(__attribute__((__nonnull__(1))) opendir)(char const *__name);
 3106|       |extern __attribute__((__nothrow__)) int(
 3107|       |    __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp);
 3108|       |DIR *opendir_safer(char const *name)
 3109|      0|{
 3110|      0|    DIR *dp;
 3111|      0|    DIR *tmp;
 3112|      0|    int fd;
 3113|      0|    int tmp___0;
 3114|      0|    DIR *newdp;
 3115|      0|    int e;
 3116|      0|    int f;
 3117|      0|    int tmp___1;
 3118|      0|    int *tmp___2;
 3119|      0|    int *tmp___3;
 3120|       |
 3121|      0|    {
 3122|      0|        tmp = opendir(name);
 3123|      0|        dp = tmp;
 3124|      0|        if (dp) {
 3125|      0|            tmp___0 = dirfd(dp);
 3126|      0|            fd = tmp___0;
 3127|      0|            if (0 <= fd) {
 3128|      0|                if (fd <= 2) {
 3129|      0|                    tmp___1 = dup_safer(fd);
 3130|      0|                    f = tmp___1;
 3131|      0|                    newdp = rpl_fdopendir(f);
 3132|      0|                    tmp___2 = __errno_location();
 3133|      0|                    e = *tmp___2;
 3134|      0|                    if (!newdp) {
 3135|      0|                        close(f);
 3136|      0|                    }
 3137|      0|                    closedir(dp);
 3138|      0|                    tmp___3 = __errno_location();
 3139|      0|                    *tmp___3 = e;
 3140|      0|                    dp = newdp;
 3141|      0|                }
 3142|      0|            }
 3143|      0|        }
 3144|      0|        return (dp);
 3145|      0|    }
 3146|      0|}
 3147|       |int openat_safer(int fd, char const *file, int flags, ...);
 3148|       |int openat_safer(int fd, char const *file, int flags, ...)
 3149|      2|{
 3150|      2|    mode_t mode;
 3151|      2|    va_list ap;
 3152|      2|    int tmp;
 3153|      2|    int tmp___0;
 3154|       |
 3155|      2|    {
 3156|      2|        mode = (mode_t)0;
 3157|      2|        if (flags & 64) {
 3158|      0|            __builtin_va_start(ap, flags);
 3159|      0|            mode = __builtin_va_arg(ap, mode_t);
 3160|      0|            __builtin_va_end(ap);
 3161|      0|        }
 3162|      2|        tmp = openat(fd, file, flags, mode);
 3163|      2|        tmp___0 = fd_safer(tmp);
 3164|      2|        return (tmp___0);
 3165|      2|    }
 3166|      2|}
 3167|       |int open_safer(char const *file, int flags, ...)
 3168|      0|{
 3169|      0|    mode_t mode;
 3170|      0|    va_list ap;
 3171|      0|    int tmp;
 3172|      0|    int tmp___0;
 3173|       |
 3174|      0|    {
 3175|      0|        mode = (mode_t)0;
 3176|      0|        if (flags & 64) {
 3177|      0|            __builtin_va_start(ap, flags);
 3178|      0|            mode = __builtin_va_arg(ap, mode_t);
 3179|      0|            __builtin_va_end(ap);
 3180|      0|        }
 3181|      0|        tmp = open(file, flags, mode);
 3182|      0|        tmp___0 = fd_safer(tmp);
 3183|      0|        return (tmp___0);
 3184|      0|    }
 3185|      0|}
 3186|       |int mbscasecmp(char const *s1, char const *s2)
 3187|      0|{
 3188|      0|    mbui_iterator_t iter1;
 3189|      0|    mbui_iterator_t iter2;
 3190|      0|    int cmp;
 3191|      0|    wint_t tmp;
 3192|      0|    wint_t tmp___0;
 3193|      0|    int tmp___1;
 3194|      0|    int tmp___2;
 3195|      0|    int tmp___4;
 3196|      0|    int tmp___5;
 3197|      0|    int tmp___7;
 3198|      0|    int tmp___8;
 3199|      0|    int tmp___9;
 3200|      0|    int tmp___10;
 3201|      0|    int tmp___11;
 3202|      0|    int tmp___12;
 3203|      0|    int tmp___13;
 3204|      0|    int tmp___14;
 3205|      0|    int tmp___15;
 3206|      0|    int tmp___16;
 3207|      0|    unsigned char const *p1;
 3208|      0|    unsigned char const *p2;
 3209|      0|    unsigned char c1;
 3210|      0|    unsigned char c2;
 3211|      0|    int tmp___18;
 3212|      0|    unsigned short const **tmp___19;
 3213|      0|    int tmp___21;
 3214|      0|    unsigned short const **tmp___22;
 3215|      0|    size_t tmp___25;
 3216|       |
 3217|      0|    {
 3218|      0|        if ((unsigned long)s1 == (unsigned long)s2) {
 3219|      0|            return (0);
 3220|      0|        }
 3221|      0|        tmp___25 = __ctype_get_mb_cur_max();
 3222|      0|        if (tmp___25 > 1UL) {
 3223|      0|            iter1.cur.ptr = s1;
 3224|      0|            iter1.in_shift = (_Bool)0;
 3225|      0|            memset((void *)(&iter1.state), '\000', sizeof(mbstate_t));
 3226|      0|            iter1.next_done = (_Bool)0;
 3227|      0|            iter2.cur.ptr = s2;
 3228|      0|            iter2.in_shift = (_Bool)0;
 3229|      0|            memset((void *)(&iter2.state), '\000', sizeof(mbstate_t));
 3230|      0|            iter2.next_done = (_Bool)0;
 3231|      0|            while (1) {
 3232|      0|                mbuiter_multi_next(&iter1);
 3233|      0|                if (iter1.cur.wc_valid) {
 3234|      0|                    if (iter1.cur.wc == 0) {
 3235|      0|                        tmp___13 = 0;
 3236|      0|                    }
 3237|      0|                    else {
 3238|      0|                        tmp___13 = 1;
 3239|      0|                    }
 3240|      0|                }
 3241|      0|                else {
 3242|      0|                    tmp___13 = 1;
 3243|      0|                }
 3244|      0|                if (tmp___13) {
 3245|      0|                    mbuiter_multi_next(&iter2);
 3246|      0|                    if (iter2.cur.wc_valid) {
 3247|      0|                        if (iter2.cur.wc == 0) {
 3248|      0|                            tmp___14 = 0;
 3249|      0|                        }
 3250|      0|                        else {
 3251|      0|                            tmp___14 = 1;
 3252|      0|                        }
 3253|      0|                    }
 3254|      0|                    else {
 3255|      0|                        tmp___14 = 1;
 3256|      0|                    }
 3257|      0|                    if (!tmp___14) {
 3258|      0|                        goto while_break;
 3259|      0|                    }
 3260|      0|                }
 3261|      0|                else {
 3262|      0|                    goto while_break;
 3263|      0|                }
 3264|      0|                if (iter1.cur.wc_valid) {
 3265|      0|                    if (iter2.cur.wc_valid) {
 3266|      0|                        tmp = towlower((wint_t)iter1.cur.wc);
 3267|      0|                        tmp___0 = towlower((wint_t)iter2.cur.wc);
 3268|      0|                        tmp___1 = (int)tmp - (int)tmp___0;
 3269|      0|                    }
 3270|      0|                    else {
 3271|      0|                        tmp___1 = -1;
 3272|      0|                    }
 3273|      0|                    tmp___12 = tmp___1;
 3274|      0|                }
 3275|      0|                else {
 3276|      0|                    if (iter2.cur.wc_valid) {
 3277|      0|                        tmp___11 = 1;
 3278|      0|                    }
 3279|      0|                    else {
 3280|      0|                        if (iter1.cur.bytes == iter2.cur.bytes) {
 3281|      0|                            tmp___2 = memcmp((void const *)iter1.cur.ptr,
 3282|      0|                                             (void const *)iter2.cur.ptr, iter1.cur.bytes);
 3283|      0|                            tmp___10 = tmp___2;
 3284|      0|                        }
 3285|      0|                        else {
 3286|      0|                            if (iter1.cur.bytes < iter2.cur.bytes) {
 3287|      0|                                tmp___5 = memcmp((void const *)iter1.cur.ptr,
 3288|      0|                                                 (void const *)iter2.cur.ptr, iter1.cur.bytes);
 3289|      0|                                if (tmp___5 > 0) {
 3290|      0|                                    tmp___4 = 1;
 3291|      0|                                }
 3292|      0|                                else {
 3293|      0|                                    tmp___4 = -1;
 3294|      0|                                }
 3295|      0|                                tmp___9 = tmp___4;
 3296|      0|                            }
 3297|      0|                            else {
 3298|      0|                                tmp___8 = memcmp((void const *)iter1.cur.ptr,
 3299|      0|                                                 (void const *)iter2.cur.ptr, iter2.cur.bytes);
 3300|      0|                                if (tmp___8 >= 0) {
 3301|      0|                                    tmp___7 = 1;
 3302|      0|                                }
 3303|      0|                                else {
 3304|      0|                                    tmp___7 = -1;
 3305|      0|                                }
 3306|      0|                                tmp___9 = tmp___7;
 3307|      0|                            }
 3308|      0|                            tmp___10 = tmp___9;
 3309|      0|                        }
 3310|      0|                        tmp___11 = tmp___10;
 3311|      0|                    }
 3312|      0|                    tmp___12 = tmp___11;
 3313|      0|                }
 3314|      0|                cmp = tmp___12;
 3315|      0|                if (cmp != 0) {
 3316|      0|                    return (cmp);
 3317|      0|                }
 3318|      0|                iter1.cur.ptr += iter1.cur.bytes;
 3319|      0|                iter1.next_done = (_Bool)0;
 3320|      0|                iter2.cur.ptr += iter2.cur.bytes;
 3321|      0|                iter2.next_done = (_Bool)0;
 3322|      0|            }
 3323|      0|while_break:
 3324|      0|            mbuiter_multi_next(&iter1);
 3325|      0|            if (iter1.cur.wc_valid) {
 3326|      0|                if (iter1.cur.wc == 0) {
 3327|      0|                    tmp___15 = 0;
 3328|      0|                }
 3329|      0|                else {
 3330|      0|                    tmp___15 = 1;
 3331|      0|                }
 3332|      0|            }
 3333|      0|            else {
 3334|      0|                tmp___15 = 1;
 3335|      0|            }
 3336|      0|            if (tmp___15) {
 3337|      0|                return (1);
 3338|      0|            }
 3339|      0|            mbuiter_multi_next(&iter2);
 3340|      0|            if (iter2.cur.wc_valid) {
 3341|      0|                if (iter2.cur.wc == 0) {
 3342|      0|                    tmp___16 = 0;
 3343|      0|                }
 3344|      0|                else {
 3345|      0|                    tmp___16 = 1;
 3346|      0|                }
 3347|      0|            }
 3348|      0|            else {
 3349|      0|                tmp___16 = 1;
 3350|      0|            }
 3351|      0|            if (tmp___16) {
 3352|      0|                return (-1);
 3353|      0|            }
 3354|      0|            return (0);
 3355|      0|        }
 3356|      0|        else {
 3357|      0|            p1 = (unsigned char const *)s1;
 3358|      0|            p2 = (unsigned char const *)s2;
 3359|      0|            while (1) {
 3360|      0|                tmp___19 = __ctype_b_loc();
 3361|      0|                if ((int const) * (*tmp___19 + (int)*p1) & 256) {
 3362|      0|                    tmp___18 = tolower((int)*p1);
 3363|      0|                    c1 = (unsigned char)tmp___18;
 3364|      0|                }
 3365|      0|                else {
 3366|      0|                    c1 = (unsigned char)*p1;
 3367|      0|                }
 3368|      0|                tmp___22 = __ctype_b_loc();
 3369|      0|                if ((int const) * (*tmp___22 + (int)*p2) & 256) {
 3370|      0|                    tmp___21 = tolower((int)*p2);
 3371|      0|                    c2 = (unsigned char)tmp___21;
 3372|      0|                }
 3373|      0|                else {
 3374|      0|                    c2 = (unsigned char)*p2;
 3375|      0|                }
 3376|      0|                if ((int)c1 == 0) {
 3377|      0|                    goto while_break___0;
 3378|      0|                }
 3379|      0|                p1++;
 3380|      0|                p2++;
 3381|      0|                if (!((int)c1 == (int)c2)) {
 3382|      0|                    goto while_break___0;
 3383|      0|                }
 3384|      0|            }
 3385|      0|while_break___0:
 3386|      0|            ;
 3387|      0|            return ((int)c1 - (int)c2);
 3388|      0|        }
 3389|      0|    }
 3390|      0|}
 3391|       |unsigned int const is_basic_table[8] = {
 3392|       |    (unsigned int const)6656, (unsigned int const)4294967279U,
 3393|       |    (unsigned int const)4294967294U, (unsigned int const)2147483646
 3394|       |};
 3395|       |extern __attribute__((__nothrow__, __noreturn__)) void(
 3396|       |    __attribute__((__leaf__)) exit)(int __status);
 3397|       |extern int optind;
 3398|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) getopt_long)(
 3399|       |    int ___argc, char *const *___argv, char const *__shortopts,
 3400|       |    struct option const *__longopts, int *__longind);
 3401|       |#pragma weak pthread_mutex_init
 3402|       |#pragma weak pthread_mutex_lock
 3403|       |#pragma weak pthread_mutex_unlock
 3404|       |#pragma weak pthread_mutex_destroy
 3405|       |#pragma weak pthread_rwlock_init
 3406|       |#pragma weak pthread_rwlock_rdlock
 3407|       |#pragma weak pthread_rwlock_wrlock
 3408|       |#pragma weak pthread_rwlock_unlock
 3409|       |#pragma weak pthread_rwlock_destroy
 3410|       |#pragma weak pthread_once
 3411|       |#pragma weak pthread_cond_init
 3412|       |#pragma weak pthread_cond_wait
 3413|       |#pragma weak pthread_cond_signal
 3414|       |#pragma weak pthread_cond_broadcast
 3415|       |#pragma weak pthread_cond_destroy
 3416|       |#pragma weak pthread_mutexattr_init
 3417|       |#pragma weak pthread_mutexattr_settype
 3418|       |#pragma weak pthread_mutexattr_destroy
 3419|       |#pragma weak pthread_self
 3420|       |#pragma weak pthread_cancel
 3421|       |extern struct passwd *getpwuid(__uid_t __uid);
 3422|       |void i_ring_init(I_ring *ir, int default_val);
 3423|       |int i_ring_push(I_ring *ir, int val);
 3424|       |int i_ring_pop(I_ring *ir);
 3425|       |_Bool i_ring_empty(I_ring const *ir);
 3426|       |void i_ring_init(I_ring *ir, int default_val)
 3427|      2|{
 3428|      2|    int i;
 3429|       |
 3430|      2|    {
 3431|      2|        ir->ir_empty = (_Bool)1;
 3432|      2|        ir->ir_front = 0U;
 3433|      2|        ir->ir_back = 0U;
 3434|      2|        i = 0;
 3435|     10|        while (1) {
 3436|       |
 3437|     10|            if (!(i < 4)) {
 3438|      2|                goto while_break;
 3439|      2|            }
 3440|      8|            ir->ir_data[i] = default_val;
 3441|      8|            i++;
 3442|      8|        }
 3443|      2|while_break:
 3444|      2|        ir->ir_default_val = default_val;
 3445|      2|        return;
 3446|      2|    }
 3447|      2|}
 3448|       |_Bool i_ring_empty(I_ring const *ir)
 3449|     18|{
 3450|       |
 3451|     18|    {
 3452|     18|        return ((_Bool)ir->ir_empty);
 3453|     18|    }
 3454|     18|}
 3455|       |int i_ring_push(I_ring *ir, int val)
 3456|      6|{
 3457|      6|    unsigned int dest_idx;
 3458|      6|    int old_val;
 3459|       |
 3460|      6|    {
 3461|      6|        dest_idx = (ir->ir_front + (unsigned int)(!ir->ir_empty)) % 4U;
 3462|      6|        old_val = ir->ir_data[dest_idx];
 3463|      6|        ir->ir_data[dest_idx] = val;
 3464|      6|        ir->ir_front = dest_idx;
 3465|      6|        if (dest_idx == ir->ir_back) {
 3466|      4|            ir->ir_back = (ir->ir_back + (unsigned int)(!ir->ir_empty)) % 4U;
 3467|      4|        }
 3468|      6|        ir->ir_empty = (_Bool)0;
 3469|      6|        return (old_val);
 3470|      6|    }
 3471|      6|}
 3472|       |int i_ring_pop(I_ring *ir)
 3473|      6|{
 3474|      6|    int top_val;
 3475|      6|    _Bool tmp;
 3476|       |
 3477|      6|    {
 3478|      6|        tmp = i_ring_empty((I_ring const *)ir);
 3479|      6|        if (tmp) {
 3480|      0|            abort();
 3481|      0|        }
 3482|      6|        top_val = ir->ir_data[ir->ir_front];
 3483|      6|        ir->ir_data[ir->ir_front] = ir->ir_default_val;
 3484|      6|        if (ir->ir_front == ir->ir_back) {
 3485|      4|            ir->ir_empty = (_Bool)1;
 3486|      4|        }
 3487|      2|        else {
 3488|      2|            ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
 3489|      2|        }
 3490|      6|        return (top_val);
 3491|      6|    }
 3492|      6|}
 3493|       |_Bool(__attribute__((__warn_unused_result__)) hash_rehash)(
 3494|       |    Hash_table *table___0, size_t candidate);
 3495|       |void *hash_delete(Hash_table *table___0, void const *entry);
 3496|       |__inline static size_t rotr_sz(size_t x, int n)
 3497|      0|{
 3498|       |
 3499|      0|    {
 3500|      0|        return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long)n))) &
 3501|      0|                0xffffffffffffffffUL);
 3502|      0|    }
 3503|      0|}
 3504|       |static struct hash_tuning const default_tuning = {
 3505|       |    (float)0.0, (float)1.0, (float)0.8, (float)1.414, (_Bool)0
 3506|       |};
 3507|       |void *hash_lookup(Hash_table const *table___0, void const *entry)
 3508|      0|{
 3509|      0|    struct hash_entry const *bucket;
 3510|      0|    size_t tmp;
 3511|      0|    struct hash_entry const *cursor;
 3512|      0|    _Bool tmp___0;
 3513|       |
 3514|      0|    {
 3515|      0|        tmp = (*(table___0->hasher))(entry, (size_t)table___0->n_buckets);
 3516|      0|        bucket = (struct hash_entry const *)(table___0->bucket + tmp);
 3517|      0|        if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3518|      0|            abort();
 3519|      0|        }
 3520|      0|        if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
 3521|      0|            return ((void *)0);
 3522|      0|        }
 3523|      0|        cursor = bucket;
 3524|      0|        while (1) {
 3525|       |
 3526|      0|            if (!cursor) {
 3527|      0|                goto while_break;
 3528|      0|            }
 3529|      0|            if ((unsigned long)entry == (unsigned long)cursor->data) {
 3530|      0|                return ((void *)cursor->data);
 3531|      0|            }
 3532|      0|            else {
 3533|      0|                tmp___0 = (*(table___0->comparator))(entry, (void const *)cursor->data);
 3534|      0|                if (tmp___0) {
 3535|      0|                    return ((void *)cursor->data);
 3536|      0|                }
 3537|      0|            }
 3538|      0|            cursor = (struct hash_entry const *)cursor->next;
 3539|      0|        }
 3540|      0|while_break:
 3541|      0|        ;
 3542|      0|        return ((void *)0);
 3543|      0|    }
 3544|      0|}
 3545|       |size_t hash_string(char const *string, size_t n_buckets)
 3546|      0|{
 3547|      0|    size_t value;
 3548|      0|    unsigned char ch;
 3549|       |
 3550|      0|    {
 3551|      0|        value = (size_t)0;
 3552|      0|        while (1) {
 3553|      0|            ch = (unsigned char)*string;
 3554|      0|            if (!ch) {
 3555|      0|                goto while_break;
 3556|      0|            }
 3557|      0|            value = (value * 31UL + (size_t)ch) % n_buckets;
 3558|      0|            string++;
 3559|      0|        }
 3560|      0|while_break:
 3561|      0|        ;
 3562|      0|        return (value);
 3563|      0|    }
 3564|      0|}
 3565|       |static _Bool is_prime(size_t candidate)
 3566|      0|{
 3567|      0|    size_t divisor;
 3568|      0|    size_t square;
 3569|      0|    int tmp;
 3570|       |
 3571|      0|    {
 3572|      0|        divisor = (size_t)3;
 3573|      0|        square = divisor * divisor;
 3574|      0|        while (1) {
 3575|       |
 3576|      0|            if (square < candidate) {
 3577|      0|                if (!(candidate % divisor)) {
 3578|      0|                    goto while_break;
 3579|      0|                }
 3580|      0|            }
 3581|      0|            else {
 3582|      0|                goto while_break;
 3583|      0|            }
 3584|      0|            divisor++;
 3585|      0|            square += 4UL * divisor;
 3586|      0|            divisor++;
 3587|      0|        }
 3588|      0|while_break:
 3589|      0|        ;
 3590|      0|        if (candidate % divisor) {
 3591|      0|            tmp = 1;
 3592|      0|        }
 3593|      0|        else {
 3594|      0|            tmp = 0;
 3595|      0|        }
 3596|      0|        return ((_Bool)tmp);
 3597|      0|    }
 3598|      0|}
 3599|       |static size_t next_prime(size_t candidate)
 3600|      0|{
 3601|      0|    _Bool tmp;
 3602|       |
 3603|      0|    {
 3604|      0|        if (candidate < 10UL) {
 3605|      0|            candidate = (size_t)10;
 3606|      0|        }
 3607|      0|        candidate |= 1UL;
 3608|      0|        while (1) {
 3609|       |
 3610|      0|            if (0xffffffffffffffffUL != candidate) {
 3611|      0|                tmp = is_prime(candidate);
 3612|      0|                if (tmp) {
 3613|      0|                    goto while_break;
 3614|      0|                }
 3615|      0|            }
 3616|      0|            else {
 3617|      0|                goto while_break;
 3618|      0|            }
 3619|      0|            candidate += 2UL;
 3620|      0|        }
 3621|      0|while_break:
 3622|      0|        ;
 3623|      0|        return (candidate);
 3624|      0|    }
 3625|      0|}
 3626|       |static size_t raw_hasher(void const *data, size_t n)
 3627|      0|{
 3628|      0|    size_t val;
 3629|      0|    size_t tmp;
 3630|       |
 3631|      0|    {
 3632|      0|        tmp = rotr_sz((size_t)data, 3);
 3633|      0|        val = tmp;
 3634|      0|        return (val % n);
 3635|      0|    }
 3636|      0|}
 3637|       |static _Bool raw_comparator(void const *a, void const *b)
 3638|      0|{
 3639|       |
 3640|      0|    {
 3641|      0|        return ((_Bool)((unsigned long)a == (unsigned long)b));
 3642|      0|    }
 3643|      0|}
 3644|       |static _Bool check_tuning(Hash_table *table___0)
 3645|      0|{
 3646|      0|    Hash_tuning const *tuning;
 3647|      0|    float epsilon;
 3648|       |
 3649|      0|    {
 3650|      0|        tuning = table___0->tuning;
 3651|      0|        if ((unsigned long)tuning == (unsigned long)(&default_tuning)) {
 3652|      0|            return ((_Bool)1);
 3653|      0|        }
 3654|      0|        epsilon = 0.1f;
 3655|      0|        if (epsilon < (float)tuning->growth_threshold) {
 3656|      0|            if (tuning->growth_threshold < (float const)((float)1 - epsilon)) {
 3657|      0|                if ((float)1 + epsilon < (float)tuning->growth_factor) {
 3658|      0|                    if ((float const)0 <= tuning->shrink_threshold) {
 3659|      0|                        if (tuning->shrink_threshold + (float const)epsilon <
 3660|      0|                                tuning->shrink_factor) {
 3661|      0|                            if (tuning->shrink_factor <= (float const)1) {
 3662|      0|                                if (tuning->shrink_threshold + (float const)epsilon <
 3663|      0|                                        tuning->growth_threshold) {
 3664|      0|                                    return ((_Bool)1);
 3665|      0|                                }
 3666|      0|                            }
 3667|      0|                        }
 3668|      0|                    }
 3669|      0|                }
 3670|      0|            }
 3671|      0|        }
 3672|      0|        table___0->tuning = &default_tuning;
 3673|      0|        return ((_Bool)0);
 3674|      0|    }
 3675|      0|}
 3676|       |static size_t compute_bucket_size(size_t candidate, Hash_tuning const *tuning)
 3677|      0|{
 3678|      0|    float new_candidate;
 3679|      0|    int tmp;
 3680|       |
 3681|      0|    {
 3682|      0|        if (!tuning->is_n_buckets) {
 3683|      0|            new_candidate =
 3684|      0|                (float)((float const)candidate / tuning->growth_threshold);
 3685|      0|            if ((float)0xffffffffffffffffUL <= new_candidate) {
 3686|      0|                return ((size_t)0);
 3687|      0|            }
 3688|      0|            candidate = (size_t)new_candidate;
 3689|      0|        }
 3690|      0|        candidate = next_prime(candidate);
 3691|      0|        if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 3692|      0|            tmp = -1;
 3693|      0|        }
 3694|      0|        else {
 3695|      0|            tmp = -2;
 3696|      0|        }
 3697|      0|        if ((size_t)tmp / sizeof(struct hash_entry *) < candidate) {
 3698|      0|            return ((size_t)0);
 3699|      0|        }
 3700|      0|        return (candidate);
 3701|      0|    }
 3702|      0|}
 3703|       |Hash_table *(__attribute__((__warn_unused_result__)) hash_initialize)(
 3704|       |    size_t candidate, Hash_tuning const *tuning,
 3705|       |    size_t (*hasher)(void const *, size_t),
 3706|       |    _Bool (*comparator)(void const *, void const *),
 3707|       |    void (*data_freer)(void *))
 3708|      0|{
 3709|      0|    Hash_table *table___0;
 3710|      0|    _Bool tmp;
 3711|       |
 3712|      0|    {
 3713|      0|        if ((unsigned long)hasher == (unsigned long)((void *)0)) {
 3714|      0|            hasher = &raw_hasher;
 3715|      0|        }
 3716|      0|        if ((unsigned long)comparator == (unsigned long)((void *)0)) {
 3717|      0|            comparator = &raw_comparator;
 3718|      0|        }
 3719|      0|        table___0 = (Hash_table *)malloc(sizeof(*table___0));
 3720|      0|        if ((unsigned long)table___0 == (unsigned long)((void *)0)) {
 3721|      0|            return ((Hash_table *)((void *)0));
 3722|      0|        }
 3723|      0|        if (!tuning) {
 3724|      0|            tuning = &default_tuning;
 3725|      0|        }
 3726|      0|        table___0->tuning = tuning;
 3727|      0|        tmp = check_tuning(table___0);
 3728|      0|        if (!tmp) {
 3729|      0|            goto fail;
 3730|      0|        }
 3731|      0|        table___0->n_buckets = compute_bucket_size(candidate, tuning);
 3732|      0|        if (!table___0->n_buckets) {
 3733|      0|            goto fail;
 3734|      0|        }
 3735|      0|        table___0->bucket = (struct hash_entry *)calloc(
 3736|      0|                                table___0->n_buckets, sizeof(*(table___0->bucket)));
 3737|      0|        if ((unsigned long)table___0->bucket == (unsigned long)((void *)0)) {
 3738|      0|            goto fail;
 3739|      0|        }
 3740|      0|        table___0->bucket_limit =
 3741|      0|            (struct hash_entry const *)(table___0->bucket + table___0->n_buckets);
 3742|      0|        table___0->n_buckets_used = (size_t)0;
 3743|      0|        table___0->n_entries = (size_t)0;
 3744|      0|        table___0->hasher = hasher;
 3745|      0|        table___0->comparator = comparator;
 3746|      0|        table___0->data_freer = data_freer;
 3747|      0|        table___0->free_entry_list = (struct hash_entry *)((void *)0);
 3748|      0|        return (table___0);
 3749|      0|fail:
 3750|      0|        free((void *)table___0);
 3751|      0|        return ((Hash_table *)((void *)0));
 3752|      0|    }
 3753|      0|}
 3754|       |void hash_free(Hash_table *table___0)
 3755|      0|{
 3756|      0|    struct hash_entry *bucket;
 3757|      0|    struct hash_entry *cursor;
 3758|      0|    struct hash_entry *next;
 3759|       |
 3760|      0|    {
 3761|      0|        if (table___0->data_freer) {
 3762|      0|            if (table___0->n_entries) {
 3763|      0|                bucket = table___0->bucket;
 3764|      0|                while (1) {
 3765|       |
 3766|      0|                    if (!((unsigned long)bucket <
 3767|      0|                            (unsigned long)table___0->bucket_limit)) {
 3768|      0|                        goto while_break;
 3769|      0|                    }
 3770|      0|                    if (bucket->data) {
 3771|      0|                        cursor = bucket;
 3772|      0|                        while (1) {
 3773|       |
 3774|      0|                            if (!cursor) {
 3775|      0|                                goto while_break___0;
 3776|      0|                            }
 3777|      0|                            (*(table___0->data_freer))(cursor->data);
 3778|      0|                            cursor = cursor->next;
 3779|      0|                        }
 3780|      0|while_break___0:
 3781|      0|                        ;
 3782|      0|                    }
 3783|      0|                    bucket++;
 3784|      0|                }
 3785|      0|while_break:
 3786|      0|                ;
 3787|      0|            }
 3788|      0|        }
 3789|      0|        bucket = table___0->bucket;
 3790|      0|        while (1) {
 3791|       |
 3792|      0|            if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3793|      0|                goto while_break___1;
 3794|      0|            }
 3795|      0|            cursor = bucket->next;
 3796|      0|            while (1) {
 3797|       |
 3798|      0|                if (!cursor) {
 3799|      0|                    goto while_break___2;
 3800|      0|                }
 3801|      0|                next = cursor->next;
 3802|      0|                free((void *)cursor);
 3803|      0|                cursor = next;
 3804|      0|            }
 3805|      0|while_break___2:
 3806|      0|            bucket++;
 3807|      0|        }
 3808|      0|while_break___1:
 3809|      0|        cursor = table___0->free_entry_list;
 3810|      0|        while (1) {
 3811|       |
 3812|      0|            if (!cursor) {
 3813|      0|                goto while_break___3;
 3814|      0|            }
 3815|      0|            next = cursor->next;
 3816|      0|            free((void *)cursor);
 3817|      0|            cursor = next;
 3818|      0|        }
 3819|      0|while_break___3:
 3820|      0|        free((void *)table___0->bucket);
 3821|      0|        free((void *)table___0);
 3822|      0|        return;
 3823|      0|    }
 3824|      0|}
 3825|       |static struct hash_entry *allocate_entry(Hash_table *table___0)
 3826|      0|{
 3827|      0|    struct hash_entry *new;
 3828|       |
 3829|      0|    {
 3830|      0|        if (table___0->free_entry_list) {
 3831|      0|            new = table___0->free_entry_list;
 3832|      0|            table___0->free_entry_list = new->next;
 3833|      0|        }
 3834|      0|        else {
 3835|      0|            new = (struct hash_entry *)malloc(sizeof(*new));
 3836|      0|        }
 3837|      0|        return (new);
 3838|      0|    }
 3839|      0|}
 3840|       |static void free_entry(Hash_table *table___0, struct hash_entry *entry)
 3841|      0|{
 3842|       |
 3843|      0|    {
 3844|      0|        entry->data = (void *)0;
 3845|      0|        entry->next = table___0->free_entry_list;
 3846|      0|        table___0->free_entry_list = entry;
 3847|      0|        return;
 3848|      0|    }
 3849|      0|}
 3850|       |static void *hash_find_entry(Hash_table *table___0, void const *entry,
 3851|       |                             struct hash_entry **bucket_head, _Bool delete)
 3852|      0|{
 3853|      0|    struct hash_entry *bucket;
 3854|      0|    size_t tmp;
 3855|      0|    struct hash_entry *cursor;
 3856|      0|    void *data;
 3857|      0|    struct hash_entry *next;
 3858|      0|    _Bool tmp___0;
 3859|      0|    void *data___0;
 3860|      0|    struct hash_entry *next___0;
 3861|      0|    _Bool tmp___1;
 3862|       |
 3863|      0|    {
 3864|      0|        tmp = (*(table___0->hasher))(entry, table___0->n_buckets);
 3865|      0|        bucket = table___0->bucket + tmp;
 3866|      0|        if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3867|      0|            abort();
 3868|      0|        }
 3869|      0|        *bucket_head = bucket;
 3870|      0|        if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
 3871|      0|            return ((void *)0);
 3872|      0|        }
 3873|      0|        if ((unsigned long)entry == (unsigned long)bucket->data) {
 3874|      0|            goto _L;
 3875|      0|        }
 3876|      0|        else {
 3877|      0|            tmp___0 = (*(table___0->comparator))(entry, (void const *)bucket->data);
 3878|      0|            if (tmp___0) {
 3879|      0|_L:
 3880|      0|                data = bucket->data;
 3881|      0|                if (delete) {
 3882|      0|                    if (bucket->next) {
 3883|      0|                        next = bucket->next;
 3884|      0|                        *bucket = *next;
 3885|      0|                        free_entry(table___0, next);
 3886|      0|                    }
 3887|      0|                    else {
 3888|      0|                        bucket->data = (void *)0;
 3889|      0|                    }
 3890|      0|                }
 3891|      0|                return (data);
 3892|      0|            }
 3893|      0|        }
 3894|      0|        cursor = bucket;
 3895|      0|        while (1) {
 3896|       |
 3897|      0|            if (!cursor->next) {
 3898|      0|                goto while_break;
 3899|      0|            }
 3900|      0|            if ((unsigned long)entry == (unsigned long)(cursor->next)->data) {
 3901|      0|                goto _L___0;
 3902|      0|            }
 3903|      0|            else {
 3904|      0|                tmp___1 = (*(table___0->comparator))(
 3905|      0|                              entry, (void const *)(cursor->next)->data);
 3906|      0|                if (tmp___1) {
 3907|      0|_L___0:
 3908|      0|                    data___0 = (cursor->next)->data;
 3909|      0|                    if (delete) {
 3910|      0|                        next___0 = cursor->next;
 3911|      0|                        cursor->next = next___0->next;
 3912|      0|                        free_entry(table___0, next___0);
 3913|      0|                    }
 3914|      0|                    return (data___0);
 3915|      0|                }
 3916|      0|            }
 3917|      0|            cursor = cursor->next;
 3918|      0|        }
 3919|      0|while_break:
 3920|      0|        ;
 3921|      0|        return ((void *)0);
 3922|      0|    }
 3923|      0|}
 3924|       |static _Bool transfer_entries(Hash_table *dst, Hash_table *src, _Bool safe)
 3925|      0|{
 3926|      0|    struct hash_entry *bucket;
 3927|      0|    struct hash_entry *cursor;
 3928|      0|    struct hash_entry *next;
 3929|      0|    void *data;
 3930|      0|    struct hash_entry *new_bucket;
 3931|      0|    size_t tmp;
 3932|      0|    size_t tmp___0;
 3933|      0|    struct hash_entry *new_entry;
 3934|      0|    struct hash_entry *tmp___1;
 3935|       |
 3936|      0|    {
 3937|      0|        bucket = src->bucket;
 3938|      0|        while (1) {
 3939|       |
 3940|      0|            if (!((unsigned long)bucket < (unsigned long)src->bucket_limit)) {
 3941|      0|                goto while_break;
 3942|      0|            }
 3943|      0|            if (bucket->data) {
 3944|      0|                cursor = bucket->next;
 3945|      0|                while (1) {
 3946|       |
 3947|      0|                    if (!cursor) {
 3948|      0|                        goto while_break___0;
 3949|      0|                    }
 3950|      0|                    data = cursor->data;
 3951|      0|                    tmp = (*(dst->hasher))((void const *)data, dst->n_buckets);
 3952|      0|                    new_bucket = dst->bucket + tmp;
 3953|      0|                    if (!((unsigned long)new_bucket < (unsigned long)dst->bucket_limit)) {
 3954|      0|                        abort();
 3955|      0|                    }
 3956|      0|                    next = cursor->next;
 3957|      0|                    if (new_bucket->data) {
 3958|      0|                        cursor->next = new_bucket->next;
 3959|      0|                        new_bucket->next = cursor;
 3960|      0|                    }
 3961|      0|                    else {
 3962|      0|                        new_bucket->data = data;
 3963|      0|                        (dst->n_buckets_used)++;
 3964|      0|                        free_entry(dst, cursor);
 3965|      0|                    }
 3966|      0|                    cursor = next;
 3967|      0|                }
 3968|      0|while_break___0:
 3969|      0|                data = bucket->data;
 3970|      0|                bucket->next = (struct hash_entry *)((void *)0);
 3971|      0|                if (safe) {
 3972|      0|                    goto __Cont;
 3973|      0|                }
 3974|      0|                tmp___0 = (*(dst->hasher))((void const *)data, dst->n_buckets);
 3975|      0|                new_bucket = dst->bucket + tmp___0;
 3976|      0|                if (!((unsigned long)new_bucket < (unsigned long)dst->bucket_limit)) {
 3977|      0|                    abort();
 3978|      0|                }
 3979|      0|                if (new_bucket->data) {
 3980|      0|                    tmp___1 = allocate_entry(dst);
 3981|      0|                    new_entry = tmp___1;
 3982|      0|                    if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 3983|      0|                        return ((_Bool)0);
 3984|      0|                    }
 3985|      0|                    new_entry->data = data;
 3986|      0|                    new_entry->next = new_bucket->next;
 3987|      0|                    new_bucket->next = new_entry;
 3988|      0|                }
 3989|      0|                else {
 3990|      0|                    new_bucket->data = data;
 3991|      0|                    (dst->n_buckets_used)++;
 3992|      0|                }
 3993|      0|                bucket->data = (void *)0;
 3994|      0|                (src->n_buckets_used)--;
 3995|      0|            }
 3996|      0|__Cont:
 3997|      0|            bucket++;
 3998|      0|        }
 3999|      0|while_break:
 4000|      0|        ;
 4001|      0|        return ((_Bool)1);
 4002|      0|    }
 4003|      0|}
 4004|       |_Bool(__attribute__((__warn_unused_result__)) hash_rehash)(
 4005|       |    Hash_table *table___0, size_t candidate)
 4006|      0|{
 4007|      0|    Hash_table storage;
 4008|      0|    Hash_table *new_table;
 4009|      0|    size_t new_size;
 4010|      0|    size_t tmp;
 4011|      0|    _Bool tmp___0;
 4012|      0|    _Bool tmp___1;
 4013|      0|    _Bool tmp___2;
 4014|       |
 4015|      0|    {
 4016|      0|        tmp = compute_bucket_size(candidate, table___0->tuning);
 4017|      0|        new_size = tmp;
 4018|      0|        if (!new_size) {
 4019|      0|            return ((_Bool)0);
 4020|      0|        }
 4021|      0|        if (new_size == table___0->n_buckets) {
 4022|      0|            return ((_Bool)1);
 4023|      0|        }
 4024|      0|        new_table = &storage;
 4025|      0|        new_table->bucket =
 4026|      0|            (struct hash_entry *)calloc(new_size, sizeof(*(new_table->bucket)));
 4027|      0|        if ((unsigned long)new_table->bucket == (unsigned long)((void *)0)) {
 4028|      0|            return ((_Bool)0);
 4029|      0|        }
 4030|      0|        new_table->n_buckets = new_size;
 4031|      0|        new_table->bucket_limit =
 4032|      0|            (struct hash_entry const *)(new_table->bucket + new_size);
 4033|      0|        new_table->n_buckets_used = (size_t)0;
 4034|      0|        new_table->n_entries = (size_t)0;
 4035|      0|        new_table->tuning = table___0->tuning;
 4036|      0|        new_table->hasher = table___0->hasher;
 4037|      0|        new_table->comparator = table___0->comparator;
 4038|      0|        new_table->data_freer = table___0->data_freer;
 4039|      0|        new_table->free_entry_list = table___0->free_entry_list;
 4040|      0|        tmp___0 = transfer_entries(new_table, table___0, (_Bool)0);
 4041|      0|        if (tmp___0) {
 4042|      0|            free((void *)table___0->bucket);
 4043|      0|            table___0->bucket = new_table->bucket;
 4044|      0|            table___0->bucket_limit = new_table->bucket_limit;
 4045|      0|            table___0->n_buckets = new_table->n_buckets;
 4046|      0|            table___0->n_buckets_used = new_table->n_buckets_used;
 4047|      0|            table___0->free_entry_list = new_table->free_entry_list;
 4048|      0|            return ((_Bool)1);
 4049|      0|        }
 4050|      0|        table___0->free_entry_list = new_table->free_entry_list;
 4051|      0|        tmp___1 = transfer_entries(table___0, new_table, (_Bool)1);
 4052|      0|        if (tmp___1) {
 4053|      0|            tmp___2 = transfer_entries(table___0, new_table, (_Bool)0);
 4054|      0|            if (!tmp___2) {
 4055|      0|                abort();
 4056|      0|            }
 4057|      0|        }
 4058|      0|        else {
 4059|      0|            abort();
 4060|      0|        }
 4061|      0|        free((void *)new_table->bucket);
 4062|      0|        return ((_Bool)0);
 4063|      0|    }
 4064|      0|}
 4065|       |void *(__attribute__((__warn_unused_result__)) hash_insert)(
 4066|       |    Hash_table *table___0, void const *entry)
 4067|      0|{
 4068|      0|    void *data;
 4069|      0|    struct hash_entry *bucket;
 4070|      0|    Hash_tuning const *tuning;
 4071|      0|    float candidate;
 4072|      0|    float tmp;
 4073|      0|    _Bool tmp___0;
 4074|      0|    void *tmp___1;
 4075|      0|    struct hash_entry *new_entry;
 4076|      0|    struct hash_entry *tmp___2;
 4077|       |
 4078|      0|    {
 4079|      0|        if (!entry) {
 4080|      0|            abort();
 4081|      0|        }
 4082|      0|        data = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 4083|      0|        if ((unsigned long)data != (unsigned long)((void *)0)) {
 4084|      0|            return (data);
 4085|      0|        }
 4086|      0|        if ((float const)table___0->n_buckets_used >
 4087|      0|                (table___0->tuning)->growth_threshold *
 4088|      0|                (float const)table___0->n_buckets) {
 4089|      0|            check_tuning(table___0);
 4090|      0|            if ((float const)table___0->n_buckets_used >
 4091|      0|                    (table___0->tuning)->growth_threshold *
 4092|      0|                    (float const)table___0->n_buckets) {
 4093|      0|                tuning = table___0->tuning;
 4094|      0|                if (tuning->is_n_buckets) {
 4095|      0|                    tmp = (float)((float const)table___0->n_buckets *
 4096|      0|                                  tuning->growth_factor);
 4097|      0|                }
 4098|      0|                else {
 4099|      0|                    tmp = (float)(((float const)table___0->n_buckets *
 4100|      0|                                   tuning->growth_factor) *
 4101|      0|                                  tuning->growth_threshold);
 4102|      0|                }
 4103|      0|                candidate = tmp;
 4104|      0|                if ((float)0xffffffffffffffffUL <= candidate) {
 4105|      0|                    return ((void *)0);
 4106|      0|                }
 4107|      0|                tmp___0 = hash_rehash(table___0, (size_t)candidate);
 4108|      0|                if (!tmp___0) {
 4109|      0|                    return ((void *)0);
 4110|      0|                }
 4111|      0|                tmp___1 = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 4112|      0|                if ((unsigned long)tmp___1 != (unsigned long)((void *)0)) {
 4113|      0|                    abort();
 4114|      0|                }
 4115|      0|            }
 4116|      0|        }
 4117|      0|        if (bucket->data) {
 4118|      0|            tmp___2 = allocate_entry(table___0);
 4119|      0|            new_entry = tmp___2;
 4120|      0|            if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 4121|      0|                return ((void *)0);
 4122|      0|            }
 4123|      0|            new_entry->data = (void *)entry;
 4124|      0|            new_entry->next = bucket->next;
 4125|      0|            bucket->next = new_entry;
 4126|      0|            (table___0->n_entries)++;
 4127|      0|            return ((void *)entry);
 4128|      0|        }
 4129|      0|        bucket->data = (void *)entry;
 4130|      0|        (table___0->n_entries)++;
 4131|      0|        (table___0->n_buckets_used)++;
 4132|      0|        return ((void *)entry);
 4133|      0|    }
 4134|      0|}
 4135|       |void *hash_delete(Hash_table *table___0, void const *entry)
 4136|      0|{
 4137|      0|    void *data;
 4138|      0|    struct hash_entry *bucket;
 4139|      0|    Hash_tuning const *tuning;
 4140|      0|    size_t candidate;
 4141|      0|    float tmp;
 4142|      0|    struct hash_entry *cursor;
 4143|      0|    struct hash_entry *next;
 4144|      0|    _Bool tmp___0;
 4145|       |
 4146|      0|    {
 4147|      0|        data = hash_find_entry(table___0, entry, &bucket, (_Bool)1);
 4148|      0|        if (!data) {
 4149|      0|            return ((void *)0);
 4150|      0|        }
 4151|      0|        (table___0->n_entries)--;
 4152|      0|        if (!bucket->data) {
 4153|      0|            (table___0->n_buckets_used)--;
 4154|      0|            if ((float const)table___0->n_buckets_used <
 4155|      0|                    (table___0->tuning)->shrink_threshold *
 4156|      0|                    (float const)table___0->n_buckets) {
 4157|      0|                check_tuning(table___0);
 4158|      0|                if ((float const)table___0->n_buckets_used <
 4159|      0|                        (table___0->tuning)->shrink_threshold *
 4160|      0|                        (float const)table___0->n_buckets) {
 4161|      0|                    tuning = table___0->tuning;
 4162|      0|                    if (tuning->is_n_buckets) {
 4163|      0|                        tmp = (float)((float const)table___0->n_buckets *
 4164|      0|                                      tuning->shrink_factor);
 4165|      0|                    }
 4166|      0|                    else {
 4167|      0|                        tmp = (float)(((float const)table___0->n_buckets *
 4168|      0|                                       tuning->shrink_factor) *
 4169|      0|                                      tuning->growth_threshold);
 4170|      0|                    }
 4171|      0|                    candidate = (size_t)tmp;
 4172|      0|                    tmp___0 = hash_rehash(table___0, candidate);
 4173|      0|                    if (!tmp___0) {
 4174|      0|                        cursor = table___0->free_entry_list;
 4175|      0|                        while (1) {
 4176|       |
 4177|      0|                            if (!cursor) {
 4178|      0|                                goto while_break;
 4179|      0|                            }
 4180|      0|                            next = cursor->next;
 4181|      0|                            free((void *)cursor);
 4182|      0|                            cursor = next;
 4183|      0|                        }
 4184|      0|while_break:
 4185|      0|                        ;
 4186|      0|                        table___0->free_entry_list = (struct hash_entry *)((void *)0);
 4187|      0|                    }
 4188|      0|                }
 4189|      0|            }
 4190|      0|        }
 4191|      0|        return (data);
 4192|      0|    }
 4193|      0|}
 4194|       |size_t hash_pjw(void const *x, size_t tablesize);
 4195|       |size_t triple_hash(void const *x, size_t table_size)
 4196|      0|{
 4197|      0|    struct F_triple const *p;
 4198|      0|    size_t tmp;
 4199|      0|    size_t tmp___0;
 4200|       |
 4201|      0|    {
 4202|      0|        p = (struct F_triple const *)x;
 4203|      0|        tmp___0 = hash_pjw((void const *)p->name, table_size);
 4204|      0|        tmp = tmp___0;
 4205|      0|        return ((tmp ^ (unsigned long)p->st_ino) % table_size);
 4206|      0|    }
 4207|      0|}
 4208|       |_Bool triple_compare_ino_str(void const *x, void const *y)
 4209|      0|{
 4210|      0|    struct F_triple const *a;
 4211|      0|    struct F_triple const *b;
 4212|      0|    int tmp___0;
 4213|      0|    int tmp___1;
 4214|       |
 4215|      0|    {
 4216|      0|        a = (struct F_triple const *)x;
 4217|      0|        b = (struct F_triple const *)y;
 4218|      0|        if (a->st_ino == b->st_ino) {
 4219|      0|            if (a->st_dev == b->st_dev) {
 4220|      0|                tmp___1 = strcmp((char const *)a->name, (char const *)b->name);
 4221|      0|                if (tmp___1 == 0) {
 4222|      0|                    tmp___0 = 1;
 4223|      0|                }
 4224|      0|                else {
 4225|      0|                    tmp___0 = 0;
 4226|      0|                }
 4227|      0|            }
 4228|      0|            else {
 4229|      0|                tmp___0 = 0;
 4230|      0|            }
 4231|      0|        }
 4232|      0|        else {
 4233|      0|            tmp___0 = 0;
 4234|      0|        }
 4235|      0|        return ((_Bool)tmp___0);
 4236|      0|    }
 4237|      0|}
 4238|       |void triple_free(void *x)
 4239|      0|{
 4240|      0|    struct F_triple *a;
 4241|       |
 4242|      0|    {
 4243|      0|        a = (struct F_triple *)x;
 4244|      0|        free((void *)a->name);
 4245|      0|        free((void *)a);
 4246|      0|        return;
 4247|      0|    }
 4248|      0|}
 4249|       |size_t hash_pjw(void const *x, size_t tablesize)
 4250|      0|{
 4251|      0|    char const *s;
 4252|      0|    size_t h;
 4253|       |
 4254|      0|    {
 4255|      0|        h = (size_t)0;
 4256|      0|        s = (char const *)x;
 4257|      0|        while (1) {
 4258|       |
 4259|      0|            if (!*s) {
 4260|      0|                goto while_break;
 4261|      0|            }
 4262|      0|            h = (unsigned long)*s + ((h << 9) | (h >> (sizeof(size_t) * 8UL - 9UL)));
 4263|      0|            s++;
 4264|      0|        }
 4265|      0|while_break:
 4266|      0|        ;
 4267|      0|        return (h % tablesize);
 4268|      0|    }
 4269|      0|}
 4270|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) setlocale)(
 4271|       |    int __category, char const *__locale);
 4272|       |extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2, 3),
 4273|       |                                        __leaf__)) fstatat)(
 4274|       |                                                int __fd, char const *__restrict __file, struct stat *__restrict __buf,
 4275|       |                                                int __flag);
 4276|       |__attribute__((__nothrow__)) int(__attribute__((__warn_unused_result__,
 4277|       |                                 __leaf__)) fts_close)(FTS *sp);
 4278|       |__attribute__((__nothrow__))
 4279|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp);
 4280|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__)) fts_set)(
 4281|       |    FTS *sp __attribute__((__unused__)), FTSENT *p, int instr);
 4282|       |extern void(__attribute__((__nonnull__(1, 4))) qsort)(
 4283|       |    void *__base, size_t __nmemb, size_t __size,
 4284|       |    int (*__compar)(void const *, void const *));
 4285|       |static FTSENT *fts_alloc(FTS *sp, char const *name, size_t namelen);
 4286|       |static FTSENT *fts_build(FTS *sp, int type);
 4287|       |static void fts_lfree(FTSENT *head);
 4288|       |static void fts_load(FTS *sp, FTSENT *p);
 4289|       |static size_t fts_maxarglen(char *const *argv);
 4290|       |static void fts_padjust(FTS *sp, FTSENT *head);
 4291|       |static _Bool fts_palloc(FTS *sp, size_t more);
 4292|       |static FTSENT *fts_sort(FTS *sp, FTSENT *head, size_t nitems);
 4293|       |static unsigned short fts_stat(FTS *sp, FTSENT *p, _Bool follow);
 4294|       |static int fts_safe_changedir(FTS *sp, FTSENT *p, int fd, char const *dir);
 4295|       |static _Bool AD_compare(void const *x, void const *y)
 4296|      0|{
 4297|      0|    struct Active_dir const *ax;
 4298|      0|    struct Active_dir const *ay;
 4299|      0|    int tmp;
 4300|       |
 4301|      0|    {
 4302|      0|        ax = (struct Active_dir const *)x;
 4303|      0|        ay = (struct Active_dir const *)y;
 4304|      0|        if (ax->ino == ay->ino) {
 4305|      0|            if (ax->dev == ay->dev) {
 4306|      0|                tmp = 1;
 4307|      0|            }
 4308|      0|            else {
 4309|      0|                tmp = 0;
 4310|      0|            }
 4311|      0|        }
 4312|      0|        else {
 4313|      0|            tmp = 0;
 4314|      0|        }
 4315|      0|        return ((_Bool)tmp);
 4316|      0|    }
 4317|      0|}
 4318|       |static size_t AD_hash(void const *x, size_t table_size)
 4319|      0|{
 4320|      0|    struct Active_dir const *ax;
 4321|       |
 4322|      0|    {
 4323|      0|        ax = (struct Active_dir const *)x;
 4324|      0|        return ((uintmax_t)ax->ino % table_size);
 4325|      0|    }
 4326|      0|}
 4327|       |static _Bool setup_dir(FTS *fts)
 4328|      4|{
 4329|       |
 4330|      4|    {
 4331|      4|        if (fts->fts_options & 258) {
 4332|      0|            fts->fts_cycle.ht =
 4333|      0|                hash_initialize((size_t)31, (Hash_tuning const *)((void *)0),
 4334|      0|                                &AD_hash, &AD_compare, (void (*)(void *))(&free));
 4335|      0|            if (!fts->fts_cycle.ht) {
 4336|      0|                return ((_Bool)0);
 4337|      0|            }
 4338|      0|        }
 4339|      4|        else {
 4340|      4|            fts->fts_cycle.state =
 4341|      4|                (struct cycle_check_state *)malloc(sizeof(*(fts->fts_cycle.state)));
 4342|      4|            if (!fts->fts_cycle.state) {
 4343|      0|                return ((_Bool)0);
 4344|      0|            }
 4345|      4|            cycle_check_init(fts->fts_cycle.state);
 4346|      4|        }
 4347|      4|        return ((_Bool)1);
 4348|      4|    }
 4349|      4|}
 4350|       |static _Bool enter_dir(FTS *fts, FTSENT *ent)
 4351|      2|{
 4352|      2|    struct stat const *st;
 4353|      2|    struct Active_dir *ad;
 4354|      2|    struct Active_dir *tmp;
 4355|      2|    struct Active_dir *ad_from_table;
 4356|      2|    _Bool tmp___0;
 4357|       |
 4358|      2|    {
 4359|      2|        if (fts->fts_options & 258) {
 4360|      0|            st = (struct stat const *)(ent->fts_statp);
 4361|      0|            tmp = (struct Active_dir *)malloc(sizeof(*ad));
 4362|      0|            ad = tmp;
 4363|      0|            if (!ad) {
 4364|      0|                return ((_Bool)0);
 4365|      0|            }
 4366|      0|            ad->dev = (dev_t)st->st_dev;
 4367|      0|            ad->ino = (ino_t)st->st_ino;
 4368|      0|            ad->fts_ent = ent;
 4369|      0|            ad_from_table =
 4370|      0|                (struct Active_dir *)hash_insert(fts->fts_cycle.ht, (void const *)ad);
 4371|      0|            if ((unsigned long)ad_from_table != (unsigned long)ad) {
 4372|      0|                free((void *)ad);
 4373|      0|                if (!ad_from_table) {
 4374|      0|                    return ((_Bool)0);
 4375|      0|                }
 4376|      0|                ent->fts_cycle = ad_from_table->fts_ent;
 4377|      0|                ent->fts_info = (unsigned short)2;
 4378|      0|            }
 4379|      0|        }
 4380|      2|        else {
 4381|      2|            tmp___0 = cycle_check(fts->fts_cycle.state,
 4382|      2|                                  (struct stat const *)(ent->fts_statp));
 4383|      2|            if (tmp___0) {
 4384|      0|                ent->fts_cycle = ent;
 4385|      0|                ent->fts_info = (unsigned short)2;
 4386|      0|            }
 4387|      2|        }
 4388|      2|        return ((_Bool)1);
 4389|      2|    }
 4390|      2|}
 4391|       |static void leave_dir(FTS *fts, FTSENT *ent)
 4392|      2|{
 4393|      2|    struct stat const *st;
 4394|      2|    struct Active_dir obj;
 4395|      2|    void *found;
 4396|      2|    FTSENT *parent;
 4397|       |
 4398|      2|    {
 4399|      2|        st = (struct stat const *)(ent->fts_statp);
 4400|      2|        if (fts->fts_options & 258) {
 4401|      0|            obj.dev = (dev_t)st->st_dev;
 4402|      0|            obj.ino = (ino_t)st->st_ino;
 4403|      0|            found = hash_delete(fts->fts_cycle.ht, (void const *)(&obj));
 4404|      0|            if (!found) {
 4405|      0|                abort();
 4406|      0|            }
 4407|      0|            free(found);
 4408|      0|        }
 4409|      2|        else {
 4410|      2|            parent = ent->fts_parent;
 4411|      2|            if ((unsigned long)parent != (unsigned long)((void *)0)) {
 4412|      2|                if (0L <= parent->fts_level) {
 4413|      0|                    while (1) {
 4414|       |
 4415|      0|                        if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
 4416|      0|                            abort();
 4417|      0|                        }
 4418|      0|                        if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t)st->st_ino) {
 4419|      0|                            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t)st->st_dev) {
 4420|      0|                                (fts->fts_cycle.state)->dev_ino.st_dev =
 4421|      0|                                    parent->fts_statp[0].st_dev;
 4422|      0|                                (fts->fts_cycle.state)->dev_ino.st_ino =
 4423|      0|                                    parent->fts_statp[0].st_ino;
 4424|      0|                            }
 4425|      0|                        }
 4426|      0|                        goto while_break;
 4427|      0|                    }
 4428|      0|while_break:
 4429|      0|                    ;
 4430|      0|                }
 4431|      2|            }
 4432|      2|        }
 4433|      2|        return;
 4434|      2|    }
 4435|      2|}
 4436|       |static void free_dir(FTS *sp)
 4437|      4|{
 4438|       |
 4439|      4|    {
 4440|      4|        if (sp->fts_options & 258) {
 4441|      0|            if (sp->fts_cycle.ht) {
 4442|      0|                hash_free(sp->fts_cycle.ht);
 4443|      0|            }
 4444|      0|        }
 4445|      4|        else {
 4446|      4|            free((void *)sp->fts_cycle.state);
 4447|      4|        }
 4448|      4|        return;
 4449|      4|    }
 4450|      4|}
 4451|       |static void fd_ring_clear(I_ring *fd_ring)
 4452|      6|{
 4453|      6|    int fd;
 4454|      6|    int tmp;
 4455|      6|    _Bool tmp___0;
 4456|       |
 4457|      6|    {
 4458|     12|        while (1) {
 4459|     12|            tmp___0 = i_ring_empty((I_ring const *)fd_ring);
 4460|     12|            if (tmp___0) {
 4461|      6|                goto while_break;
 4462|      6|            }
 4463|      6|            tmp = i_ring_pop(fd_ring);
 4464|      6|            fd = tmp;
 4465|      6|            if (0 <= fd) {
 4466|      2|                close(fd);
 4467|      2|            }
 4468|      6|        }
 4469|      6|while_break:
 4470|      6|        ;
 4471|      6|        return;
 4472|      6|    }
 4473|      6|}
 4474|       |static void fts_set_stat_required(FTSENT *p, _Bool required)
 4475|      4|{
 4476|       |
 4477|      4|    {
 4478|      4|        while (1) {
 4479|       |
 4480|      4|            if (!((int)p->fts_info == 11)) {
 4481|      0|                abort();
 4482|      0|            }
 4483|      4|            goto while_break;
 4484|      4|        }
 4485|      4|while_break:
 4486|      4|        ;
 4487|      4|        if (required) {
 4488|      0|            p->fts_statp[0].st_size = (__off_t)2;
 4489|      0|        }
 4490|      4|        else {
 4491|      4|            p->fts_statp[0].st_size = (__off_t)1;
 4492|      4|        }
 4493|      4|        return;
 4494|      4|    }
 4495|      4|}
 4496|       |__inline static DIR *opendirat(int fd, char const *dir)
 4497|      2|{
 4498|      2|    int new_fd;
 4499|      2|    int tmp;
 4500|      2|    DIR *dirp;
 4501|      2|    int saved_errno;
 4502|      2|    int *tmp___0;
 4503|      2|    int *tmp___1;
 4504|       |
 4505|      2|    {
 4506|      2|        tmp = openat_safer(fd, dir, 67840);
 4507|      2|        new_fd = tmp;
 4508|      2|        if (new_fd < 0) {
 4509|      0|            return ((DIR *)((void *)0));
 4510|      0|        }
 4511|      2|        set_cloexec_flag(new_fd, (_Bool)1);
 4512|      2|        dirp = rpl_fdopendir(new_fd);
 4513|      2|        if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 4514|      0|            tmp___0 = __errno_location();
 4515|      0|            saved_errno = *tmp___0;
 4516|      0|            close(new_fd);
 4517|      0|            tmp___1 = __errno_location();
 4518|      0|            *tmp___1 = saved_errno;
 4519|      0|        }
 4520|      2|        return (dirp);
 4521|      2|    }
 4522|      2|}
 4523|       |static void cwd_advance_fd(FTS *sp, int fd, _Bool chdir_down_one)
 4524|      6|{
 4525|      6|    int old;
 4526|      6|    int prev_fd_in_slot;
 4527|      6|    int tmp;
 4528|       |
 4529|      6|    {
 4530|      6|        old = sp->fts_cwd_fd;
 4531|      6|        while (1) {
 4532|       |
 4533|      6|            if (!(old != fd)) {
 4534|      2|                if (!(old == -100)) {
 4535|      0|                    abort();
 4536|      0|                }
 4537|      2|            }
 4538|      6|            goto while_break;
 4539|      6|        }
 4540|      6|while_break:
 4541|      6|        ;
 4542|      6|        if (chdir_down_one) {
 4543|      6|            tmp = i_ring_push(&sp->fts_fd_ring, old);
 4544|      6|            prev_fd_in_slot = tmp;
 4545|      6|            if (0 <= prev_fd_in_slot) {
 4546|      0|                close(prev_fd_in_slot);
 4547|      0|            }
 4548|      6|        }
 4549|      0|        else {
 4550|      0|            if (!(sp->fts_options & 4)) {
 4551|      0|                if (0 <= old) {
 4552|      0|                    close(old);
 4553|      0|                }
 4554|      0|            }
 4555|      0|        }
 4556|      6|        sp->fts_cwd_fd = fd;
 4557|      6|        return;
 4558|      6|    }
 4559|      6|}
 4560|       |__inline static int diropen(FTS const *sp, char const *dir)
 4561|      0|{
 4562|      0|    int open_flags;
 4563|      0|    int tmp;
 4564|      0|    int fd;
 4565|      0|    int tmp___0;
 4566|      0|    int tmp___1;
 4567|      0|    int tmp___2;
 4568|       |
 4569|      0|    {
 4570|      0|        if (sp->fts_options & 16) {
 4571|      0|            tmp = 131072;
 4572|      0|        }
 4573|      0|        else {
 4574|      0|            tmp = 0;
 4575|      0|        }
 4576|      0|        open_flags = 67840 | tmp;
 4577|      0|        if (sp->fts_options & 512) {
 4578|      0|            tmp___0 = openat_safer((int)sp->fts_cwd_fd, dir, open_flags);
 4579|      0|            tmp___2 = tmp___0;
 4580|      0|        }
 4581|      0|        else {
 4582|      0|            tmp___1 = open_safer(dir, open_flags);
 4583|      0|            tmp___2 = tmp___1;
 4584|      0|        }
 4585|      0|        fd = tmp___2;
 4586|      0|        if (0 <= fd) {
 4587|      0|            set_cloexec_flag(fd, (_Bool)1);
 4588|      0|        }
 4589|      0|        return (fd);
 4590|      0|    }
 4591|      0|}
 4592|       |__attribute__((__nothrow__))
 4593|       |FTS *(__attribute__((__warn_unused_result__, __leaf__)) fts_open)(
 4594|       |    char *const *argv, int options,
 4595|       |    int (*compar)(FTSENT const **, FTSENT const **));
 4596|       |FTS *(__attribute__((__warn_unused_result__, __leaf__)) fts_open)(
 4597|       |    char *const *argv, int options,
 4598|       |    int (*compar)(FTSENT const **, FTSENT const **))
 4599|      2|{
 4600|      2|    FTS *sp;
 4601|      2|    FTSENT *p;
 4602|      2|    FTSENT *root;
 4603|      2|    size_t nitems;
 4604|      2|    FTSENT *parent;
 4605|      2|    FTSENT *tmp;
 4606|      2|    _Bool defer_stat;
 4607|      2|    int *tmp___0;
 4608|      2|    int *tmp___1;
 4609|      2|    int *tmp___2;
 4610|      2|    size_t maxarglen;
 4611|      2|    size_t tmp___4;
 4612|      2|    size_t tmp___5;
 4613|      2|    _Bool tmp___6;
 4614|      2|    int tmp___7;
 4615|      2|    size_t len;
 4616|      2|    size_t tmp___8;
 4617|      2|    struct _ftsent *tmp___9;
 4618|      2|    _Bool tmp___10;
 4619|      2|    int tmp___11;
 4620|       |
 4621|      2|    {
 4622|      2|        parent = (FTSENT *)((void *)0);
 4623|      2|        tmp = (FTSENT *)((void *)0);
 4624|      2|        if (options & -2048) {
 4625|      0|            tmp___0 = __errno_location();
 4626|      0|            *tmp___0 = 22;
 4627|      0|            return ((FTS *)((void *)0));
 4628|      0|        }
 4629|      2|        if (options & 4) {
 4630|      0|            if (options & 512) {
 4631|      0|                tmp___1 = __errno_location();
 4632|      0|                *tmp___1 = 22;
 4633|      0|                return ((FTS *)((void *)0));
 4634|      0|            }
 4635|      0|        }
 4636|      2|        if (!(options & 18)) {
 4637|      0|            tmp___2 = __errno_location();
 4638|      0|            *tmp___2 = 22;
 4639|      0|            return ((FTS *)((void *)0));
 4640|      0|        }
 4641|      2|        sp = (FTS *)malloc(sizeof(FTS));
 4642|      2|        if ((unsigned long)sp == (unsigned long)((void *)0)) {
 4643|      0|            return ((FTS *)((void *)0));
 4644|      0|        }
 4645|      2|        memset((void *)sp, 0, sizeof(FTS));
 4646|      2|        sp->fts_compar = compar;
 4647|      2|        sp->fts_options = options;
 4648|      2|        if (sp->fts_options & 2) {
 4649|      0|            sp->fts_options |= 4;
 4650|      0|            sp->fts_options &= -513;
 4651|      0|        }
 4652|      2|        sp->fts_cwd_fd = -100;
 4653|      2|        tmp___4 = fts_maxarglen(argv);
 4654|      2|        maxarglen = tmp___4;
 4655|      2|        if (maxarglen > 4096UL) {
 4656|      0|            tmp___5 = maxarglen;
 4657|      0|        }
 4658|      2|        else {
 4659|      2|            tmp___5 = (size_t)4096;
 4660|      2|        }
 4661|      2|        tmp___6 = fts_palloc(sp, tmp___5);
 4662|      2|        if (!tmp___6) {
 4663|      0|            goto mem1;
 4664|      0|        }
 4665|      2|        if ((unsigned long)*argv != (unsigned long)((void *)0)) {
 4666|      2|            parent = fts_alloc(sp, "", (size_t)0);
 4667|      2|            if ((unsigned long)parent == (unsigned long)((void *)0)) {
 4668|      0|                goto mem2;
 4669|      0|            }
 4670|      2|            parent->fts_level = (ptrdiff_t)-1;
 4671|      2|        }
 4672|      2|        if ((unsigned long)compar == (unsigned long)((void *)0)) {
 4673|      2|            tmp___7 = 1;
 4674|      2|        }
 4675|      0|        else {
 4676|      0|            if (sp->fts_options & 1024) {
 4677|      0|                tmp___7 = 1;
 4678|      0|            }
 4679|      0|            else {
 4680|      0|                tmp___7 = 0;
 4681|      0|            }
 4682|      0|        }
 4683|      2|        defer_stat = (_Bool)tmp___7;
 4684|      2|        root = (FTSENT *)((void *)0);
 4685|      2|        nitems = (size_t)0;
 4686|      4|        while (1) {
 4687|       |
 4688|      4|            if (!((unsigned long)*argv != (unsigned long)((void *)0))) {
 4689|      2|                goto while_break;
 4690|      2|            }
 4691|      2|            tmp___8 = strlen((char const *)*argv);
 4692|      2|            len = tmp___8;
 4693|      2|            p = fts_alloc(sp, (char const *)*argv, len);
 4694|      2|            if ((unsigned long)p == (unsigned long)((void *)0)) {
 4695|      0|                goto mem3;
 4696|      0|            }
 4697|      2|            p->fts_level = (ptrdiff_t)0;
 4698|      2|            p->fts_parent = parent;
 4699|      2|            p->fts_accpath = p->fts_name;
 4700|      2|            if (defer_stat) {
 4701|      2|                if ((unsigned long)root != (unsigned long)((void *)0)) {
 4702|      0|                    p->fts_info = (unsigned short)11;
 4703|      0|                    fts_set_stat_required(p, (_Bool)1);
 4704|      0|                }
 4705|      2|                else {
 4706|      2|                    p->fts_info = fts_stat(sp, p, (_Bool)0);
 4707|      2|                }
 4708|      2|            }
 4709|      0|            else {
 4710|      0|                p->fts_info = fts_stat(sp, p, (_Bool)0);
 4711|      0|            }
 4712|      2|            if (compar) {
 4713|      0|                p->fts_link = root;
 4714|      0|                root = p;
 4715|      0|            }
 4716|      2|            else {
 4717|      2|                p->fts_link = (struct _ftsent *)((void *)0);
 4718|      2|                if ((unsigned long)root == (unsigned long)((void *)0)) {
 4719|      2|                    root = p;
 4720|      2|                    tmp = root;
 4721|      2|                }
 4722|      0|                else {
 4723|      0|                    tmp->fts_link = p;
 4724|      0|                    tmp = p;
 4725|      0|                }
 4726|      2|            }
 4727|      2|            argv++;
 4728|      2|            nitems++;
 4729|      2|        }
 4730|      2|while_break:
 4731|      2|        ;
 4732|      2|        if (compar) {
 4733|      0|            if (nitems > 1UL) {
 4734|      0|                root = fts_sort(sp, root, nitems);
 4735|      0|            }
 4736|      0|        }
 4737|      2|        tmp___9 = fts_alloc(sp, "", (size_t)0);
 4738|      2|        sp->fts_cur = tmp___9;
 4739|      2|        if ((unsigned long)tmp___9 == (unsigned long)((void *)0)) {
 4740|      0|            goto mem3;
 4741|      0|        }
 4742|      2|        (sp->fts_cur)->fts_link = root;
 4743|      2|        (sp->fts_cur)->fts_info = (unsigned short)9;
 4744|      2|        tmp___10 = setup_dir(sp);
 4745|      2|        if (!tmp___10) {
 4746|      0|            goto mem3;
 4747|      0|        }
 4748|      2|        if (!(sp->fts_options & 4)) {
 4749|      2|            if (!(sp->fts_options & 512)) {
 4750|      0|                tmp___11 = diropen((FTS const *)sp, ".");
 4751|      0|                sp->fts_rfd = tmp___11;
 4752|      0|                if (tmp___11 < 0) {
 4753|      0|                    sp->fts_options |= 4;
 4754|      0|                }
 4755|      0|            }
 4756|      2|        }
 4757|      2|        i_ring_init(&sp->fts_fd_ring, -1);
 4758|      2|        return (sp);
 4759|      0|mem3:
 4760|      0|        fts_lfree(root);
 4761|      0|        free((void *)parent);
 4762|      0|mem2:
 4763|      0|        free((void *)sp->fts_path);
 4764|      0|mem1:
 4765|      0|        free((void *)sp);
 4766|      0|        return ((FTS *)((void *)0));
 4767|      0|    }
 4768|      0|}
 4769|       |static void fts_load(FTS *sp, FTSENT *p)
 4770|      2|{
 4771|      2|    size_t len;
 4772|      2|    char *cp;
 4773|      2|    size_t tmp;
 4774|      2|    char *tmp___0;
 4775|       |
 4776|      2|    {
 4777|      2|        tmp = p->fts_namelen;
 4778|      2|        p->fts_pathlen = tmp;
 4779|      2|        len = tmp;
 4780|      2|        memmove((void *)sp->fts_path, (void const *)(p->fts_name), len + 1UL);
 4781|      2|        cp = strrchr((char const *)(p->fts_name), '/');
 4782|      2|        if (cp) {
 4783|      2|            if ((unsigned long)cp != (unsigned long)(p->fts_name)) {
 4784|      2|                cp++;
 4785|      2|                len = strlen((char const *)cp);
 4786|      2|                memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
 4787|      2|                p->fts_namelen = len;
 4788|      2|            }
 4789|      0|            else {
 4790|      0|                if (*(cp + 1)) {
 4791|      0|                    cp++;
 4792|      0|                    len = strlen((char const *)cp);
 4793|      0|                    memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
 4794|      0|                    p->fts_namelen = len;
 4795|      0|                }
 4796|      0|            }
 4797|      2|        }
 4798|      2|        tmp___0 = sp->fts_path;
 4799|      2|        p->fts_path = tmp___0;
 4800|      2|        p->fts_accpath = tmp___0;
 4801|      2|        return;
 4802|      2|    }
 4803|      2|}
 4804|       |__attribute__((__nothrow__)) int(__attribute__((__warn_unused_result__,
 4805|       |                                 __leaf__)) fts_close)(FTS *sp);
 4806|       |int(__attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp)
 4807|      2|{
 4808|      2|    FTSENT *freep;
 4809|      2|    FTSENT *p;
 4810|      2|    int saved_errno;
 4811|      2|    int *tmp;
 4812|      2|    int tmp___0;
 4813|      2|    int *tmp___1;
 4814|      2|    int tmp___2;
 4815|      2|    int *tmp___3;
 4816|      2|    int tmp___4;
 4817|      2|    int *tmp___5;
 4818|       |
 4819|      2|    {
 4820|      2|        saved_errno = 0;
 4821|      2|        if (sp->fts_cur) {
 4822|      0|            p = sp->fts_cur;
 4823|      0|            while (1) {
 4824|       |
 4825|      0|                if (!(p->fts_level >= 0L)) {
 4826|      0|                    goto while_break;
 4827|      0|                }
 4828|      0|                freep = p;
 4829|      0|                if ((unsigned long)p->fts_link != (unsigned long)((void *)0)) {
 4830|      0|                    p = p->fts_link;
 4831|      0|                }
 4832|      0|                else {
 4833|      0|                    p = p->fts_parent;
 4834|      0|                }
 4835|      0|                free((void *)freep);
 4836|      0|            }
 4837|      0|while_break:
 4838|      0|            free((void *)p);
 4839|      0|        }
 4840|      2|        if (sp->fts_child) {
 4841|      0|            fts_lfree(sp->fts_child);
 4842|      0|        }
 4843|      2|        free((void *)sp->fts_array);
 4844|      2|        free((void *)sp->fts_path);
 4845|      2|        if (sp->fts_options & 512) {
 4846|      2|            if (0 <= sp->fts_cwd_fd) {
 4847|      0|                tmp___0 = close(sp->fts_cwd_fd);
 4848|      0|                if (tmp___0) {
 4849|      0|                    tmp = __errno_location();
 4850|      0|                    saved_errno = *tmp;
 4851|      0|                }
 4852|      0|            }
 4853|      2|        }
 4854|      0|        else {
 4855|      0|            if (!(sp->fts_options & 4)) {
 4856|      0|                tmp___2 = fchdir(sp->fts_rfd);
 4857|      0|                if (tmp___2) {
 4858|      0|                    tmp___1 = __errno_location();
 4859|      0|                    saved_errno = *tmp___1;
 4860|      0|                }
 4861|      0|                tmp___4 = close(sp->fts_rfd);
 4862|      0|                if (tmp___4) {
 4863|      0|                    if (saved_errno == 0) {
 4864|      0|                        tmp___3 = __errno_location();
 4865|      0|                        saved_errno = *tmp___3;
 4866|      0|                    }
 4867|      0|                }
 4868|      0|            }
 4869|      0|        }
 4870|      2|        fd_ring_clear(&sp->fts_fd_ring);
 4871|      2|        if (sp->fts_leaf_optimization_works_ht) {
 4872|      0|            hash_free(sp->fts_leaf_optimization_works_ht);
 4873|      0|        }
 4874|      2|        free_dir(sp);
 4875|      2|        free((void *)sp);
 4876|      2|        if (saved_errno) {
 4877|      0|            tmp___5 = __errno_location();
 4878|      0|            *tmp___5 = saved_errno;
 4879|      0|            return (-1);
 4880|      0|        }
 4881|      2|        return (0);
 4882|      2|    }
 4883|      2|}
 4884|       |extern __attribute__((__nothrow__)) int(__attribute__((
 4885|       |        __nonnull__(2), __leaf__)) fstatfs)(int __fildes, struct statfs *__buf);
 4886|       |static _Bool dirent_inode_sort_may_be_useful(int dir_fd)
 4887|      0|{
 4888|      0|    struct statfs fs_buf;
 4889|      0|    int tmp;
 4890|       |
 4891|      0|    {
 4892|      0|        tmp = fstatfs(dir_fd, &fs_buf);
 4893|      0|        if (tmp != 0) {
 4894|      0|            return ((_Bool)1);
 4895|      0|        }
 4896|      0|        if (fs_buf.f_type == 16914836L) {
 4897|      0|            goto case_16914836;
 4898|      0|        }
 4899|      0|        if (fs_buf.f_type == 26985L) {
 4900|      0|            goto case_16914836;
 4901|      0|        }
 4902|      0|        goto switch_default;
 4903|      0|case_16914836:
 4904|      0|        return ((_Bool)0);
 4905|      0|switch_default:
 4906|      0|        return ((_Bool)1);
 4907|       |
 4908|      0|        return ((_Bool)0);
 4909|      0|    }
 4910|      0|}
 4911|       |static _Bool leaf_optimization_applies(int dir_fd)
 4912|      0|{
 4913|      0|    struct statfs fs_buf;
 4914|      0|    int tmp;
 4915|       |
 4916|      0|    {
 4917|      0|        tmp = fstatfs(dir_fd, &fs_buf);
 4918|      0|        if (tmp != 0) {
 4919|      0|            return ((_Bool)0);
 4920|      0|        }
 4921|      0|        if (fs_buf.f_type == 1382369651L) {
 4922|      0|            goto case_1382369651;
 4923|      0|        }
 4924|      0|        goto switch_default;
 4925|      0|case_1382369651:
 4926|      0|        return ((_Bool)1);
 4927|      0|switch_default:
 4928|      0|        return ((_Bool)0);
 4929|       |
 4930|      0|        return ((_Bool)0);
 4931|      0|    }
 4932|      0|}
 4933|       |static size_t LCO_hash(void const *x, size_t table_size)
 4934|      0|{
 4935|      0|    struct LCO_ent const *ax;
 4936|       |
 4937|      0|    {
 4938|      0|        ax = (struct LCO_ent const *)x;
 4939|      0|        return ((uintmax_t)ax->st_dev % table_size);
 4940|      0|    }
 4941|      0|}
 4942|       |static _Bool LCO_compare(void const *x, void const *y)
 4943|      0|{
 4944|      0|    struct LCO_ent const *ax;
 4945|      0|    struct LCO_ent const *ay;
 4946|       |
 4947|      0|    {
 4948|      0|        ax = (struct LCO_ent const *)x;
 4949|      0|        ay = (struct LCO_ent const *)y;
 4950|      0|        return ((_Bool)(ax->st_dev == ay->st_dev));
 4951|      0|    }
 4952|      0|}
 4953|       |static _Bool link_count_optimize_ok(FTSENT const *p)
 4954|      0|{
 4955|      0|    FTS *sp;
 4956|      0|    Hash_table *h;
 4957|      0|    struct LCO_ent tmp;
 4958|      0|    struct LCO_ent *ent;
 4959|      0|    _Bool opt_ok;
 4960|      0|    struct LCO_ent *t2;
 4961|      0|    struct hash_table *tmp___0;
 4962|       |
 4963|      0|    {
 4964|      0|        sp = (FTS *)p->fts_fts;
 4965|      0|        h = sp->fts_leaf_optimization_works_ht;
 4966|      0|        if (!(sp->fts_options & 512)) {
 4967|      0|            return ((_Bool)0);
 4968|      0|        }
 4969|      0|        if ((unsigned long)h == (unsigned long)((void *)0)) {
 4970|      0|            tmp___0 =
 4971|      0|                hash_initialize((size_t)13, (Hash_tuning const *)((void *)0),
 4972|      0|                                &LCO_hash, &LCO_compare, (void (*)(void *))(&free));
 4973|      0|            sp->fts_leaf_optimization_works_ht = tmp___0;
 4974|      0|            h = tmp___0;
 4975|      0|            if ((unsigned long)h == (unsigned long)((void *)0)) {
 4976|      0|                return ((_Bool)0);
 4977|      0|            }
 4978|      0|        }
 4979|      0|        tmp.st_dev = (dev_t)p->fts_statp[0].st_dev;
 4980|      0|        ent = (struct LCO_ent *)hash_lookup((Hash_table const *)h,
 4981|      0|                                            (void const *)(&tmp));
 4982|      0|        if (ent) {
 4983|      0|            return (ent->opt_ok);
 4984|      0|        }
 4985|      0|        t2 = (struct LCO_ent *)malloc(sizeof(*t2));
 4986|      0|        if ((unsigned long)t2 == (unsigned long)((void *)0)) {
 4987|      0|            return ((_Bool)0);
 4988|      0|        }
 4989|      0|        opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
 4990|      0|        t2->opt_ok = opt_ok;
 4991|      0|        t2->st_dev = (dev_t)p->fts_statp[0].st_dev;
 4992|      0|        ent = (struct LCO_ent *)hash_insert(h, (void const *)t2);
 4993|      0|        if ((unsigned long)ent == (unsigned long)((void *)0)) {
 4994|      0|            free((void *)t2);
 4995|      0|            return ((_Bool)0);
 4996|      0|        }
 4997|      0|        while (1) {
 4998|       |
 4999|      0|            if (!((unsigned long)ent == (unsigned long)t2)) {
 5000|      0|                abort();
 5001|      0|            }
 5002|      0|            goto while_break;
 5003|      0|        }
 5004|      0|while_break:
 5005|      0|        ;
 5006|      0|        return (opt_ok);
 5007|      0|    }
 5008|      0|}
 5009|       |__attribute__((__nothrow__))
 5010|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp);
 5011|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp)
 5012|     10|{
 5013|     10|    FTSENT *p;
 5014|     10|    FTSENT *tmp;
 5015|     10|    unsigned short instr;
 5016|     10|    char *t;
 5017|     10|    int *tmp___0;
 5018|     10|    int tmp___1;
 5019|     10|    int *tmp___2;
 5020|     10|    int tmp___3;
 5021|     10|    struct _ftsent *tmp___4;
 5022|     10|    int tmp___5;
 5023|     10|    int tmp___6;
 5024|     10|    int tmp___7;
 5025|     10|    int tmp___8;
 5026|     10|    int tmp___9;
 5027|     10|    int *tmp___10;
 5028|     10|    int tmp___11;
 5029|     10|    size_t tmp___12;
 5030|     10|    char *tmp___13;
 5031|     10|    FTSENT *parent;
 5032|     10|    _Bool tmp___14;
 5033|     10|    int *tmp___15;
 5034|     10|    _Bool tmp___16;
 5035|     10|    int *tmp___17;
 5036|     10|    struct _ftsent *tmp___18;
 5037|     10|    int *tmp___19;
 5038|     10|    int tmp___20;
 5039|     10|    int tmp___21;
 5040|     10|    int tmp___22;
 5041|     10|    int tmp___23;
 5042|     10|    int tmp___24;
 5043|     10|    int saved_errno;
 5044|     10|    int *tmp___25;
 5045|     10|    int *tmp___26;
 5046|     10|    int *tmp___27;
 5047|     10|    int tmp___28;
 5048|     10|    int tmp___29;
 5049|     10|    int *tmp___30;
 5050|     10|    int tmp___31;
 5051|     10|    FTSENT *tmp___32;
 5052|       |
 5053|     10|    {
 5054|     10|        if ((unsigned long)sp->fts_cur == (unsigned long)((void *)0)) {
 5055|      0|            return ((FTSENT *)((void *)0));
 5056|      0|        }
 5057|     10|        else {
 5058|     10|            if (sp->fts_options & 8192) {
 5059|      0|                return ((FTSENT *)((void *)0));
 5060|      0|            }
 5061|     10|        }
 5062|     10|        p = sp->fts_cur;
 5063|     10|        instr = p->fts_instr;
 5064|     10|        p->fts_instr = (unsigned short)3;
 5065|     10|        if ((int)instr == 1) {
 5066|      0|            p->fts_info = fts_stat(sp, p, (_Bool)0);
 5067|      0|            return (p);
 5068|      0|        }
 5069|     10|        if ((int)instr == 2) {
 5070|      0|            if ((int)p->fts_info == 12) {
 5071|      0|                goto _L;
 5072|      0|            }
 5073|      0|            else {
 5074|      0|                if ((int)p->fts_info == 13) {
 5075|      0|_L:
 5076|      0|                    p->fts_info = fts_stat(sp, p, (_Bool)1);
 5077|      0|                    if ((int)p->fts_info == 1) {
 5078|      0|                        if (!(sp->fts_options & 4)) {
 5079|      0|                            tmp___1 = diropen((FTS const *)sp, ".");
 5080|      0|                            p->fts_symfd = tmp___1;
 5081|      0|                            if (tmp___1 < 0) {
 5082|      0|                                tmp___0 = __errno_location();
 5083|      0|                                p->fts_errno = *tmp___0;
 5084|      0|                                p->fts_info = (unsigned short)7;
 5085|      0|                            }
 5086|      0|                            else {
 5087|      0|                                p->fts_flags = (unsigned short)((int)p->fts_flags | 2);
 5088|      0|                            }
 5089|      0|                        }
 5090|      0|                    }
 5091|      0|                    goto check_for_dir;
 5092|      0|                }
 5093|      0|            }
 5094|      0|        }
 5095|     10|        if ((int)p->fts_info == 1) {
 5096|      2|            if ((int)instr == 4) {
 5097|      0|                goto _L___0;
 5098|      0|            }
 5099|      2|            else {
 5100|      2|                if (sp->fts_options & 64) {
 5101|      0|                    if (p->fts_statp[0].st_dev != sp->fts_dev) {
 5102|      0|_L___0:
 5103|      0|                        if ((int)p->fts_flags & 2) {
 5104|      0|                            close(p->fts_symfd);
 5105|      0|                        }
 5106|      0|                        if (sp->fts_child) {
 5107|      0|                            fts_lfree(sp->fts_child);
 5108|      0|                            sp->fts_child = (struct _ftsent *)((void *)0);
 5109|      0|                        }
 5110|      0|                        p->fts_info = (unsigned short)6;
 5111|      0|                        while (1) {
 5112|      0|                            leave_dir(sp, p);
 5113|      0|                            goto while_break;
 5114|      0|                        }
 5115|      0|while_break:
 5116|      0|                        ;
 5117|      0|                        return (p);
 5118|      0|                    }
 5119|      0|                }
 5120|      2|            }
 5121|      2|            if ((unsigned long)sp->fts_child != (unsigned long)((void *)0)) {
 5122|      0|                if (sp->fts_options & 4096) {
 5123|      0|                    sp->fts_options &= -4097;
 5124|      0|                    fts_lfree(sp->fts_child);
 5125|      0|                    sp->fts_child = (struct _ftsent *)((void *)0);
 5126|      0|                }
 5127|      0|            }
 5128|      2|            if ((unsigned long)sp->fts_child != (unsigned long)((void *)0)) {
 5129|      0|                tmp___3 = fts_safe_changedir(sp, p, -1, (char const *)p->fts_accpath);
 5130|      0|                if (tmp___3) {
 5131|      0|                    tmp___2 = __errno_location();
 5132|      0|                    p->fts_errno = *tmp___2;
 5133|      0|                    p->fts_flags = (unsigned short)((int)p->fts_flags | 1);
 5134|      0|                    p = sp->fts_child;
 5135|      0|                    while (1) {
 5136|       |
 5137|      0|                        if (!((unsigned long)p != (unsigned long)((void *)0))) {
 5138|      0|                            goto while_break___0;
 5139|      0|                        }
 5140|      0|                        p->fts_accpath = (p->fts_parent)->fts_accpath;
 5141|      0|                        p = p->fts_link;
 5142|      0|                    }
 5143|      0|while_break___0:
 5144|      0|                    ;
 5145|      0|                }
 5146|      0|            }
 5147|      2|            else {
 5148|      2|                tmp___4 = fts_build(sp, 3);
 5149|      2|                sp->fts_child = tmp___4;
 5150|      2|                if ((unsigned long)tmp___4 == (unsigned long)((void *)0)) {
 5151|      0|                    if (sp->fts_options & 8192) {
 5152|      0|                        return ((FTSENT *)((void *)0));
 5153|      0|                    }
 5154|      0|                    if (p->fts_errno) {
 5155|      0|                        if ((int)p->fts_info != 4) {
 5156|      0|                            p->fts_info = (unsigned short)7;
 5157|      0|                        }
 5158|      0|                    }
 5159|      0|                    while (1) {
 5160|      0|                        leave_dir(sp, p);
 5161|      0|                        goto while_break___1;
 5162|      0|                    }
 5163|      0|while_break___1:
 5164|      0|                    ;
 5165|      0|                    return (p);
 5166|      0|                }
 5167|      2|            }
 5168|      2|            p = sp->fts_child;
 5169|      2|            sp->fts_child = (struct _ftsent *)((void *)0);
 5170|      2|            goto name;
 5171|      2|        }
 5172|      8|next:
 5173|      8|        tmp = p;
 5174|      8|        p = p->fts_link;
 5175|      8|        if ((unsigned long)p != (unsigned long)((void *)0)) {
 5176|      4|            sp->fts_cur = p;
 5177|      4|            free((void *)tmp);
 5178|      4|            if (p->fts_level == 0L) {
 5179|      2|                fd_ring_clear(&sp->fts_fd_ring);
 5180|      2|                if (!(sp->fts_options & 4)) {
 5181|      2|                    if (sp->fts_options & 512) {
 5182|      2|                        if (sp->fts_options & 512) {
 5183|      2|                            tmp___5 = -100;
 5184|      2|                        }
 5185|      0|                        else {
 5186|      0|                            tmp___5 = sp->fts_rfd;
 5187|      0|                        }
 5188|      2|                        cwd_advance_fd(sp, tmp___5, (_Bool)1);
 5189|      2|                        tmp___8 = 0;
 5190|      2|                    }
 5191|      0|                    else {
 5192|      0|                        if (sp->fts_options & 512) {
 5193|      0|                            tmp___6 = -100;
 5194|      0|                        }
 5195|      0|                        else {
 5196|      0|                            tmp___6 = sp->fts_rfd;
 5197|      0|                        }
 5198|      0|                        tmp___7 = fchdir(tmp___6);
 5199|      0|                        tmp___8 = tmp___7;
 5200|      0|                    }
 5201|      2|                    if (tmp___8) {
 5202|      0|                        tmp___9 = 1;
 5203|      0|                    }
 5204|      2|                    else {
 5205|      2|                        tmp___9 = 0;
 5206|      2|                    }
 5207|      2|                }
 5208|      0|                else {
 5209|      0|                    tmp___9 = 0;
 5210|      0|                }
 5211|      2|                if (tmp___9) {
 5212|      0|                    sp->fts_options |= 8192;
 5213|      0|                    return ((FTSENT *)((void *)0));
 5214|      0|                }
 5215|      2|                free_dir(sp);
 5216|      2|                fts_load(sp, p);
 5217|      2|                setup_dir(sp);
 5218|      2|                goto check_for_dir;
 5219|      2|            }
 5220|      2|            if ((int)p->fts_instr == 4) {
 5221|      0|                goto next;
 5222|      0|            }
 5223|      2|            if ((int)p->fts_instr == 2) {
 5224|      0|                p->fts_info = fts_stat(sp, p, (_Bool)1);
 5225|      0|                if ((int)p->fts_info == 1) {
 5226|      0|                    if (!(sp->fts_options & 4)) {
 5227|      0|                        tmp___11 = diropen((FTS const *)sp, ".");
 5228|      0|                        p->fts_symfd = tmp___11;
 5229|      0|                        if (tmp___11 < 0) {
 5230|      0|                            tmp___10 = __errno_location();
 5231|      0|                            p->fts_errno = *tmp___10;
 5232|      0|                            p->fts_info = (unsigned short)7;
 5233|      0|                        }
 5234|      0|                        else {
 5235|      0|                            p->fts_flags = (unsigned short)((int)p->fts_flags | 2);
 5236|      0|                        }
 5237|      0|                    }
 5238|      0|                }
 5239|      0|                p->fts_instr = (unsigned short)3;
 5240|      0|            }
 5241|      4|name:
 5242|      4|            if ((int)*((p->fts_parent)->fts_path +
 5243|      4|                       ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
 5244|      4|                tmp___12 = (p->fts_parent)->fts_pathlen - 1UL;
 5245|      4|            }
 5246|      0|            else {
 5247|      0|                tmp___12 = (p->fts_parent)->fts_pathlen;
 5248|      0|            }
 5249|      4|            t = sp->fts_path + tmp___12;
 5250|      4|            tmp___13 = t;
 5251|      4|            t++;
 5252|      4|            *tmp___13 = (char)'/';
 5253|      4|            memmove((void *)t, (void const *)(p->fts_name), p->fts_namelen + 1UL);
 5254|      6|check_for_dir:
 5255|      6|            sp->fts_cur = p;
 5256|      6|            if ((int)p->fts_info == 11) {
 5257|      4|                if (p->fts_statp[0].st_size == 2L) {
 5258|      0|                    parent = p->fts_parent;
 5259|      0|                    if (0L < p->fts_level) {
 5260|      0|                        if (parent->fts_n_dirs_remaining == 0UL) {
 5261|      0|                            if (sp->fts_options & 8) {
 5262|      0|                                if (sp->fts_options & 16) {
 5263|      0|                                    tmp___14 = link_count_optimize_ok((FTSENT const *)parent);
 5264|      0|                                    if (!tmp___14) {
 5265|      0|                                        goto _L___4;
 5266|      0|                                    }
 5267|      0|                                }
 5268|      0|                                else {
 5269|      0|                                    goto _L___4;
 5270|      0|                                }
 5271|      0|                            }
 5272|      0|                            else {
 5273|      0|                                goto _L___4;
 5274|      0|                            }
 5275|      0|                        }
 5276|      0|                        else {
 5277|      0|                            goto _L___4;
 5278|      0|                        }
 5279|      0|                    }
 5280|      0|                    else {
 5281|      0|_L___4:
 5282|      0|                        p->fts_info = fts_stat(sp, p, (_Bool)0);
 5283|      0|                        if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
 5284|      0|                            if (p->fts_level != 0L) {
 5285|      0|                                if (parent->fts_n_dirs_remaining) {
 5286|      0|                                    (parent->fts_n_dirs_remaining)--;
 5287|      0|                                }
 5288|      0|                            }
 5289|      0|                        }
 5290|      0|                    }
 5291|      0|                }
 5292|      4|                else {
 5293|      4|                    while (1) {
 5294|       |
 5295|      4|                        if (!(p->fts_statp[0].st_size == 1L)) {
 5296|      0|                            abort();
 5297|      0|                        }
 5298|      4|                        goto while_break___2;
 5299|      4|                    }
 5300|      4|while_break___2:
 5301|      4|                    ;
 5302|      4|                }
 5303|      4|            }
 5304|      6|            if ((int)p->fts_info == 1) {
 5305|      2|                if (p->fts_level == 0L) {
 5306|      2|                    sp->fts_dev = p->fts_statp[0].st_dev;
 5307|      2|                }
 5308|      2|                tmp___16 = enter_dir(sp, p);
 5309|      2|                if (!tmp___16) {
 5310|      0|                    tmp___15 = __errno_location();
 5311|      0|                    *tmp___15 = 12;
 5312|      0|                    return ((FTSENT *)((void *)0));
 5313|      0|                }
 5314|      2|            }
 5315|      6|            return (p);
 5316|      6|        }
 5317|      4|        p = tmp->fts_parent;
 5318|      4|        sp->fts_cur = p;
 5319|      4|        free((void *)tmp);
 5320|      4|        if (p->fts_level == -1L) {
 5321|      2|            free((void *)p);
 5322|      2|            tmp___17 = __errno_location();
 5323|      2|            *tmp___17 = 0;
 5324|      2|            tmp___18 = (struct _ftsent *)((void *)0);
 5325|      2|            sp->fts_cur = tmp___18;
 5326|      2|            return (tmp___18);
 5327|      2|        }
 5328|      2|        while (1) {
 5329|       |
 5330|      2|            if (!((int)p->fts_info != 11)) {
 5331|      0|                abort();
 5332|      0|            }
 5333|      2|            goto while_break___3;
 5334|      2|        }
 5335|      2|while_break___3:
 5336|      2|        *(sp->fts_path + p->fts_pathlen) = (char)'\000';
 5337|      2|        if (p->fts_level == 0L) {
 5338|      2|            fd_ring_clear(&sp->fts_fd_ring);
 5339|      2|            if (!(sp->fts_options & 4)) {
 5340|      2|                if (sp->fts_options & 512) {
 5341|      2|                    if (sp->fts_options & 512) {
 5342|      2|                        tmp___20 = -100;
 5343|      2|                    }
 5344|      0|                    else {
 5345|      0|                        tmp___20 = sp->fts_rfd;
 5346|      0|                    }
 5347|      2|                    cwd_advance_fd(sp, tmp___20, (_Bool)1);
 5348|      2|                    tmp___23 = 0;
 5349|      2|                }
 5350|      0|                else {
 5351|      0|                    if (sp->fts_options & 512) {
 5352|      0|                        tmp___21 = -100;
 5353|      0|                    }
 5354|      0|                    else {
 5355|      0|                        tmp___21 = sp->fts_rfd;
 5356|      0|                    }
 5357|      0|                    tmp___22 = fchdir(tmp___21);
 5358|      0|                    tmp___23 = tmp___22;
 5359|      0|                }
 5360|      2|                if (tmp___23) {
 5361|      0|                    tmp___24 = 1;
 5362|      0|                }
 5363|      2|                else {
 5364|      2|                    tmp___24 = 0;
 5365|      2|                }
 5366|      2|            }
 5367|      0|            else {
 5368|      0|                tmp___24 = 0;
 5369|      0|            }
 5370|      2|            if (tmp___24) {
 5371|      0|                tmp___19 = __errno_location();
 5372|      0|                p->fts_errno = *tmp___19;
 5373|      0|                sp->fts_options |= 8192;
 5374|      0|            }
 5375|      2|        }
 5376|      0|        else {
 5377|      0|            if ((int)p->fts_flags & 2) {
 5378|      0|                if (!(sp->fts_options & 4)) {
 5379|      0|                    if (sp->fts_options & 512) {
 5380|      0|                        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
 5381|      0|                        tmp___29 = 0;
 5382|      0|                    }
 5383|      0|                    else {
 5384|      0|                        tmp___28 = fchdir(p->fts_symfd);
 5385|      0|                        tmp___29 = tmp___28;
 5386|      0|                    }
 5387|      0|                    if (tmp___29) {
 5388|      0|                        tmp___25 = __errno_location();
 5389|      0|                        saved_errno = *tmp___25;
 5390|      0|                        close(p->fts_symfd);
 5391|      0|                        tmp___26 = __errno_location();
 5392|      0|                        *tmp___26 = saved_errno;
 5393|      0|                        tmp___27 = __errno_location();
 5394|      0|                        p->fts_errno = *tmp___27;
 5395|      0|                        sp->fts_options |= 8192;
 5396|      0|                    }
 5397|      0|                }
 5398|      0|                close(p->fts_symfd);
 5399|      0|            }
 5400|      0|            else {
 5401|      0|                if (!((int)p->fts_flags & 1)) {
 5402|      0|                    tmp___31 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
 5403|      0|                    if (tmp___31) {
 5404|      0|                        tmp___30 = __errno_location();
 5405|      0|                        p->fts_errno = *tmp___30;
 5406|      0|                        sp->fts_options |= 8192;
 5407|      0|                    }
 5408|      0|                }
 5409|      0|            }
 5410|      0|        }
 5411|      2|        if (p->fts_errno) {
 5412|      0|            p->fts_info = (unsigned short)7;
 5413|      0|        }
 5414|      2|        else {
 5415|      2|            p->fts_info = (unsigned short)6;
 5416|      2|        }
 5417|      2|        if (p->fts_errno == 0) {
 5418|      2|            while (1) {
 5419|      2|                leave_dir(sp, p);
 5420|      2|                goto while_break___4;
 5421|      2|            }
 5422|      2|while_break___4:
 5423|      2|            ;
 5424|      2|        }
 5425|      2|        if (sp->fts_options & 8192) {
 5426|      0|            tmp___32 = (FTSENT *)((void *)0);
 5427|      0|        }
 5428|      2|        else {
 5429|      2|            tmp___32 = p;
 5430|      2|        }
 5431|      2|        return (tmp___32);
 5432|      2|    }
 5433|      2|}
 5434|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__)) fts_set)(
 5435|       |    FTS *sp __attribute__((__unused__)), FTSENT *p, int instr);
 5436|       |int(__attribute__((__leaf__)) fts_set)(FTS *sp __attribute__((__unused__)),
 5437|       |                                       FTSENT *p, int instr)
 5438|      0|{
 5439|      0|    int *tmp;
 5440|       |
 5441|      0|    {
 5442|      0|        if (instr != 0) {
 5443|      0|            if (instr != 1) {
 5444|      0|                if (instr != 2) {
 5445|      0|                    if (instr != 3) {
 5446|      0|                        if (instr != 4) {
 5447|      0|                            tmp = __errno_location();
 5448|      0|                            *tmp = 22;
 5449|      0|                            return (1);
 5450|      0|                        }
 5451|      0|                    }
 5452|      0|                }
 5453|      0|            }
 5454|      0|        }
 5455|      0|        p->fts_instr = (unsigned short)instr;
 5456|      0|        return (0);
 5457|      0|    }
 5458|      0|}
 5459|       |static int fts_compare_ino(struct _ftsent const **a, struct _ftsent const **b)
 5460|      0|{
 5461|      0|    int tmp;
 5462|      0|    int tmp___0;
 5463|       |
 5464|      0|    {
 5465|      0|        if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
 5466|      0|            tmp___0 = -1;
 5467|      0|        }
 5468|      0|        else {
 5469|      0|            if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
 5470|      0|                tmp = 1;
 5471|      0|            }
 5472|      0|            else {
 5473|      0|                tmp = 0;
 5474|      0|            }
 5475|      0|            tmp___0 = tmp;
 5476|      0|        }
 5477|      0|        return (tmp___0);
 5478|      0|    }
 5479|      0|}
 5480|       |static void set_stat_type(struct stat *st, unsigned int dtype)
 5481|      4|{
 5482|      4|    mode_t type;
 5483|       |
 5484|      4|    {
 5485|      4|        if (dtype == 6U) {
 5486|      0|            goto case_6;
 5487|      0|        }
 5488|      4|        if (dtype == 2U) {
 5489|      0|            goto case_2;
 5490|      0|        }
 5491|      4|        if (dtype == 4U) {
 5492|      0|            goto case_4;
 5493|      0|        }
 5494|      4|        if (dtype == 1U) {
 5495|      0|            goto case_1;
 5496|      0|        }
 5497|      4|        if (dtype == 10U) {
 5498|      0|            goto case_10;
 5499|      0|        }
 5500|      4|        if (dtype == 8U) {
 5501|      4|            goto case_8;
 5502|      4|        }
 5503|      0|        if (dtype == 12U) {
 5504|      0|            goto case_12;
 5505|      0|        }
 5506|      0|        goto switch_default;
 5507|      0|case_6:
 5508|      0|        type = (mode_t)24576;
 5509|      0|        goto switch_break;
 5510|      0|case_2:
 5511|      0|        type = (mode_t)8192;
 5512|      0|        goto switch_break;
 5513|      0|case_4:
 5514|      0|        type = (mode_t)16384;
 5515|      0|        goto switch_break;
 5516|      0|case_1:
 5517|      0|        type = (mode_t)4096;
 5518|      0|        goto switch_break;
 5519|      0|case_10:
 5520|      0|        type = (mode_t)40960;
 5521|      0|        goto switch_break;
 5522|      4|case_8:
 5523|      4|        type = (mode_t)32768;
 5524|      4|        goto switch_break;
 5525|      0|case_12:
 5526|      0|        type = (mode_t)49152;
 5527|      0|        goto switch_break;
 5528|      0|switch_default:
 5529|      0|        type = (mode_t)0;
 5530|      4|switch_break:
 5531|      4|        st->st_mode = type;
 5532|      4|        return;
 5533|      0|    }
 5534|      0|}
 5535|       |static FTSENT *fts_build(FTS *sp, int type)
 5536|      2|{
 5537|      2|    struct dirent *dp;
 5538|      2|    FTSENT *p;
 5539|      2|    FTSENT *head;
 5540|      2|    size_t nitems;
 5541|      2|    FTSENT *cur;
 5542|      2|    FTSENT *tail;
 5543|      2|    DIR *dirp;
 5544|      2|    void *oldaddr;
 5545|      2|    int saved_errno;
 5546|      2|    _Bool descend;
 5547|      2|    _Bool doadjust;
 5548|      2|    ptrdiff_t level;
 5549|      2|    nlink_t nlinks;
 5550|      2|    _Bool nostat;
 5551|      2|    size_t len;
 5552|      2|    size_t maxlen;
 5553|      2|    size_t new_len;
 5554|      2|    char *cp;
 5555|      2|    int *tmp;
 5556|      2|    DIR *tmp___0;
 5557|      2|    DIR *tmp___1;
 5558|      2|    int *tmp___2;
 5559|      2|    _Bool tmp___3;
 5560|      2|    int tmp___4;
 5561|      2|    int dir_fd;
 5562|      2|    int tmp___5;
 5563|      2|    int *tmp___6;
 5564|      2|    int tmp___7;
 5565|      2|    char *tmp___8;
 5566|      2|    _Bool is_dir;
 5567|      2|    size_t tmp___9;
 5568|      2|    int *tmp___10;
 5569|      2|    int *tmp___11;
 5570|      2|    size_t tmp___12;
 5571|      2|    _Bool tmp___13;
 5572|      2|    size_t tmp___14;
 5573|      2|    size_t tmp___15;
 5574|      2|    int *tmp___16;
 5575|      2|    _Bool skip_stat;
 5576|      2|    int tmp___17;
 5577|      2|    int tmp___18;
 5578|      2|    int tmp___19;
 5579|      2|    int tmp___20;
 5580|      2|    int tmp___21;
 5581|      2|    int tmp___22;
 5582|      2|    int tmp___23;
 5583|      2|    int tmp___24;
 5584|      2|    int tmp___25;
 5585|      2|    int tmp___26;
 5586|      2|    _Bool tmp___27;
 5587|       |
 5588|      2|    {
 5589|      2|        cur = sp->fts_cur;
 5590|      2|        if (!(sp->fts_options & 4)) {
 5591|      2|            if (sp->fts_options & 512) {
 5592|      2|                tmp___0 = opendirat(sp->fts_cwd_fd, (char const *)cur->fts_accpath);
 5593|      2|                dirp = tmp___0;
 5594|      2|            }
 5595|      0|            else {
 5596|      0|                tmp___1 = opendir_safer((char const *)cur->fts_accpath);
 5597|      0|                dirp = tmp___1;
 5598|      0|            }
 5599|      2|        }
 5600|      0|        else {
 5601|      0|            tmp___1 = opendir_safer((char const *)cur->fts_accpath);
 5602|      0|            dirp = tmp___1;
 5603|      0|        }
 5604|      2|        if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 5605|      0|            if (type == 3) {
 5606|      0|                cur->fts_info = (unsigned short)4;
 5607|      0|                tmp = __errno_location();
 5608|      0|                cur->fts_errno = *tmp;
 5609|      0|            }
 5610|      0|            return ((FTSENT *)((void *)0));
 5611|      0|        }
 5612|      2|        if ((int)cur->fts_info == 11) {
 5613|      0|            cur->fts_info = fts_stat(sp, cur, (_Bool)0);
 5614|      0|        }
 5615|      2|        else {
 5616|      2|            if (sp->fts_options & 256) {
 5617|      0|                while (1) {
 5618|      0|                    leave_dir(sp, cur);
 5619|      0|                    goto while_break;
 5620|      0|                }
 5621|      0|while_break:
 5622|      0|                fts_stat(sp, cur, (_Bool)0);
 5623|      0|                tmp___3 = enter_dir(sp, cur);
 5624|      0|                if (!tmp___3) {
 5625|      0|                    tmp___2 = __errno_location();
 5626|      0|                    *tmp___2 = 12;
 5627|      0|                    return ((FTSENT *)((void *)0));
 5628|      0|                }
 5629|      0|            }
 5630|      2|        }
 5631|      2|        if (type == 2) {
 5632|      0|            nlinks = (nlink_t)0;
 5633|      0|            nostat = (_Bool)0;
 5634|      0|        }
 5635|      2|        else {
 5636|      2|            if (sp->fts_options & 8) {
 5637|      2|                if (sp->fts_options & 16) {
 5638|      2|                    if (sp->fts_options & 32) {
 5639|      0|                        tmp___4 = 0;
 5640|      0|                    }
 5641|      2|                    else {
 5642|      2|                        tmp___4 = 2;
 5643|      2|                    }
 5644|      2|                    nlinks = cur->fts_statp[0].st_nlink - (__nlink_t)tmp___4;
 5645|      2|                    nostat = (_Bool)1;
 5646|      2|                }
 5647|      0|                else {
 5648|      0|                    nlinks = (nlink_t)-1;
 5649|      0|                    nostat = (_Bool)0;
 5650|      0|                }
 5651|      2|            }
 5652|      0|            else {
 5653|      0|                nlinks = (nlink_t)-1;
 5654|      0|                nostat = (_Bool)0;
 5655|      0|            }
 5656|      2|        }
 5657|      2|        if (nlinks) {
 5658|      0|            goto _L___0;
 5659|      0|        }
 5660|      2|        else {
 5661|      2|            if (type == 3) {
 5662|      2|_L___0:
 5663|      2|                tmp___5 = dirfd(dirp);
 5664|      2|                dir_fd = tmp___5;
 5665|      2|                if (sp->fts_options & 512) {
 5666|      2|                    if (0 <= dir_fd) {
 5667|      2|                        dir_fd = dup_safer(dir_fd);
 5668|      2|                        set_cloexec_flag(dir_fd, (_Bool)1);
 5669|      2|                    }
 5670|      2|                }
 5671|      2|                if (dir_fd < 0) {
 5672|      0|                    goto _L;
 5673|      0|                }
 5674|      2|                else {
 5675|      2|                    tmp___7 =
 5676|      2|                        fts_safe_changedir(sp, cur, dir_fd, (char const *)((void *)0));
 5677|      2|                    if (tmp___7) {
 5678|      0|_L:
 5679|      0|                        if (nlinks) {
 5680|      0|                            if (type == 3) {
 5681|      0|                                tmp___6 = __errno_location();
 5682|      0|                                cur->fts_errno = *tmp___6;
 5683|      0|                            }
 5684|      0|                        }
 5685|      0|                        cur->fts_flags = (unsigned short)((int)cur->fts_flags | 1);
 5686|      0|                        descend = (_Bool)0;
 5687|      0|                        closedir(dirp);
 5688|      0|                        if (sp->fts_options & 512) {
 5689|      0|                            if (0 <= dir_fd) {
 5690|      0|                                close(dir_fd);
 5691|      0|                            }
 5692|      0|                        }
 5693|      0|                        dirp = (DIR *)((void *)0);
 5694|      0|                    }
 5695|      2|                    else {
 5696|      2|                        descend = (_Bool)1;
 5697|      2|                    }
 5698|      2|                }
 5699|      2|            }
 5700|      0|            else {
 5701|      0|                descend = (_Bool)0;
 5702|      0|            }
 5703|      2|        }
 5704|      2|        if ((int)*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
 5705|      2|            len = cur->fts_pathlen - 1UL;
 5706|      2|        }
 5707|      0|        else {
 5708|      0|            len = cur->fts_pathlen;
 5709|      0|        }
 5710|      2|        if (sp->fts_options & 4) {
 5711|      0|            cp = sp->fts_path + len;
 5712|      0|            tmp___8 = cp;
 5713|      0|            cp++;
 5714|      0|            *tmp___8 = (char)'/';
 5715|      0|        }
 5716|      2|        else {
 5717|      2|            cp = (char *)((void *)0);
 5718|      2|        }
 5719|      2|        len++;
 5720|      2|        maxlen = sp->fts_pathlen - len;
 5721|      2|        level = cur->fts_level + 1L;
 5722|      2|        doadjust = (_Bool)0;
 5723|      2|        tail = (FTSENT *)((void *)0);
 5724|      2|        head = tail;
 5725|      2|        nitems = (size_t)0;
 5726|     10|        while (1) {
 5727|       |
 5728|     10|            if (dirp) {
 5729|     10|                dp = readdir(dirp);
 5730|     10|                if (!dp) {
 5731|      2|                    goto while_break___0;
 5732|      2|                }
 5733|     10|            }
 5734|      0|            else {
 5735|      0|                goto while_break___0;
 5736|      0|            }
 5737|      8|            if (!(sp->fts_options & 32)) {
 5738|      8|                if ((int)dp->d_name[0] == 46) {
 5739|      4|                    if (!dp->d_name[1]) {
 5740|      2|                        goto __Cont;
 5741|      2|                    }
 5742|      2|                    else {
 5743|      2|                        if ((int)dp->d_name[1] == 46) {
 5744|      2|                            if (!dp->d_name[2]) {
 5745|      2|                                goto __Cont;
 5746|      2|                            }
 5747|      2|                        }
 5748|      2|                    }
 5749|      4|                }
 5750|      8|            }
 5751|      4|            tmp___9 = strlen((char const *)(dp->d_name));
 5752|      4|            p = fts_alloc(sp, (char const *)(dp->d_name), tmp___9);
 5753|      4|            if ((unsigned long)p == (unsigned long)((void *)0)) {
 5754|      0|                goto mem1;
 5755|      0|            }
 5756|      4|            tmp___14 = strlen((char const *)(dp->d_name));
 5757|      4|            if (tmp___14 >= maxlen) {
 5758|      0|                oldaddr = (void *)sp->fts_path;
 5759|      0|                tmp___12 = strlen((char const *)(dp->d_name));
 5760|      0|                tmp___13 = fts_palloc(sp, (tmp___12 + len) + 1UL);
 5761|      0|                if (!tmp___13) {
 5762|      0|mem1:
 5763|      0|                    tmp___10 = __errno_location();
 5764|      0|                    saved_errno = *tmp___10;
 5765|      0|                    free((void *)p);
 5766|      0|                    fts_lfree(head);
 5767|      0|                    closedir(dirp);
 5768|      0|                    cur->fts_info = (unsigned short)7;
 5769|      0|                    sp->fts_options |= 8192;
 5770|      0|                    tmp___11 = __errno_location();
 5771|      0|                    *tmp___11 = saved_errno;
 5772|      0|                    return ((FTSENT *)((void *)0));
 5773|      0|                }
 5774|      0|                if ((unsigned long)oldaddr != (unsigned long)sp->fts_path) {
 5775|      0|                    doadjust = (_Bool)1;
 5776|      0|                    if (sp->fts_options & 4) {
 5777|      0|                        cp = sp->fts_path + len;
 5778|      0|                    }
 5779|      0|                }
 5780|      0|                maxlen = sp->fts_pathlen - len;
 5781|      0|            }
 5782|      4|            tmp___15 = strlen((char const *)(dp->d_name));
 5783|      4|            new_len = len + tmp___15;
 5784|      4|            if (new_len < len) {
 5785|      0|                free((void *)p);
 5786|      0|                fts_lfree(head);
 5787|      0|                closedir(dirp);
 5788|      0|                cur->fts_info = (unsigned short)7;
 5789|      0|                sp->fts_options |= 8192;
 5790|      0|                tmp___16 = __errno_location();
 5791|      0|                *tmp___16 = 36;
 5792|      0|                return ((FTSENT *)((void *)0));
 5793|      0|            }
 5794|      4|            p->fts_level = level;
 5795|      4|            p->fts_parent = sp->fts_cur;
 5796|      4|            p->fts_pathlen = new_len;
 5797|      4|            p->fts_statp[0].st_ino = dp->d_ino;
 5798|      4|            if (sp->fts_options & 4) {
 5799|      0|                p->fts_accpath = p->fts_path;
 5800|      0|                memmove((void *)cp, (void const *)(p->fts_name), p->fts_namelen + 1UL);
 5801|      0|            }
 5802|      4|            else {
 5803|      4|                p->fts_accpath = p->fts_name;
 5804|      4|            }
 5805|      4|            if ((unsigned long)sp->fts_compar == (unsigned long)((void *)0) ||
 5806|      4|                    sp->fts_options & 1024) {
 5807|      4|                if (sp->fts_options & 16) {
 5808|      4|                    if (sp->fts_options & 8) {
 5809|      4|                        if ((int)dp->d_type != 0) {
 5810|      4|                            if (!((int)dp->d_type == 4)) {
 5811|      4|                                tmp___17 = 1;
 5812|      4|                            }
 5813|      0|                            else {
 5814|      0|                                tmp___17 = 0;
 5815|      0|                            }
 5816|      4|                        }
 5817|      0|                        else {
 5818|      0|                            tmp___17 = 0;
 5819|      0|                        }
 5820|      4|                    }
 5821|      0|                    else {
 5822|      0|                        tmp___17 = 0;
 5823|      0|                    }
 5824|      4|                }
 5825|      0|                else {
 5826|      0|                    tmp___17 = 0;
 5827|      0|                }
 5828|      4|                skip_stat = (_Bool)tmp___17;
 5829|      4|                p->fts_info = (unsigned short)11;
 5830|      4|                set_stat_type(p->fts_statp, (unsigned int)dp->d_type);
 5831|      4|                fts_set_stat_required(p, (_Bool)(!skip_stat));
 5832|      4|                if (sp->fts_options & 16) {
 5833|      4|                    if ((int)dp->d_type == 4) {
 5834|      0|                        tmp___18 = 1;
 5835|      0|                    }
 5836|      4|                    else {
 5837|      4|                        tmp___18 = 0;
 5838|      4|                    }
 5839|      4|                }
 5840|      0|                else {
 5841|      0|                    tmp___18 = 0;
 5842|      0|                }
 5843|      4|                is_dir = (_Bool)tmp___18;
 5844|      4|            }
 5845|      0|            else {
 5846|      0|                p->fts_info = fts_stat(sp, p, (_Bool)0);
 5847|      0|                if ((int)p->fts_info == 1) {
 5848|      0|                    tmp___19 = 1;
 5849|      0|                }
 5850|      0|                else {
 5851|      0|                    if ((int)p->fts_info == 2) {
 5852|      0|                        tmp___19 = 1;
 5853|      0|                    }
 5854|      0|                    else {
 5855|      0|                        if ((int)p->fts_info == 5) {
 5856|      0|                            tmp___19 = 1;
 5857|      0|                        }
 5858|      0|                        else {
 5859|      0|                            tmp___19 = 0;
 5860|      0|                        }
 5861|      0|                    }
 5862|      0|                }
 5863|      0|                is_dir = (_Bool)tmp___19;
 5864|      0|            }
 5865|      4|            if (nlinks > 0UL) {
 5866|      0|                if (is_dir) {
 5867|      0|                    nlinks -= (nlink_t)nostat;
 5868|      0|                }
 5869|      0|            }
 5870|      4|            p->fts_link = (struct _ftsent *)((void *)0);
 5871|      4|            if ((unsigned long)head == (unsigned long)((void *)0)) {
 5872|      2|                tail = p;
 5873|      2|                head = tail;
 5874|      2|            }
 5875|      2|            else {
 5876|      2|                tail->fts_link = p;
 5877|      2|                tail = p;
 5878|      2|            }
 5879|      4|            nitems++;
 5880|      8|__Cont:
 5881|      8|            ;
 5882|      8|        }
 5883|      2|while_break___0:
 5884|      2|        ;
 5885|      2|        if (dirp) {
 5886|      2|            closedir(dirp);
 5887|      2|        }
 5888|      2|        if (doadjust) {
 5889|      0|            fts_padjust(sp, head);
 5890|      0|        }
 5891|      2|        if (sp->fts_options & 4) {
 5892|      0|            if (len == sp->fts_pathlen) {
 5893|      0|                cp--;
 5894|      0|            }
 5895|      0|            else {
 5896|      0|                if (nitems == 0UL) {
 5897|      0|                    cp--;
 5898|      0|                }
 5899|      0|            }
 5900|      0|            *cp = (char)'\000';
 5901|      0|        }
 5902|      2|        if (descend) {
 5903|      2|            if (type == 1 || !nitems) {
 5904|      0|                if (cur->fts_level == 0L) {
 5905|      0|                    fd_ring_clear(&sp->fts_fd_ring);
 5906|      0|                    if (!(sp->fts_options & 4)) {
 5907|      0|                        if (sp->fts_options & 512) {
 5908|      0|                            if (sp->fts_options & 512) {
 5909|      0|                                tmp___20 = -100;
 5910|      0|                            }
 5911|      0|                            else {
 5912|      0|                                tmp___20 = sp->fts_rfd;
 5913|      0|                            }
 5914|      0|                            cwd_advance_fd(sp, tmp___20, (_Bool)1);
 5915|      0|                            tmp___23 = 0;
 5916|      0|                        }
 5917|      0|                        else {
 5918|      0|                            if (sp->fts_options & 512) {
 5919|      0|                                tmp___21 = -100;
 5920|      0|                            }
 5921|      0|                            else {
 5922|      0|                                tmp___21 = sp->fts_rfd;
 5923|      0|                            }
 5924|      0|                            tmp___22 = fchdir(tmp___21);
 5925|      0|                            tmp___23 = tmp___22;
 5926|      0|                        }
 5927|      0|                        if (tmp___23) {
 5928|      0|                            tmp___24 = 1;
 5929|      0|                        }
 5930|      0|                        else {
 5931|      0|                            tmp___24 = 0;
 5932|      0|                        }
 5933|      0|                    }
 5934|      0|                    else {
 5935|      0|                        tmp___24 = 0;
 5936|      0|                    }
 5937|      0|                    tmp___26 = tmp___24;
 5938|      0|                }
 5939|      0|                else {
 5940|      0|                    tmp___25 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
 5941|      0|                    tmp___26 = tmp___25;
 5942|      0|                }
 5943|      0|                if (tmp___26) {
 5944|      0|                    cur->fts_info = (unsigned short)7;
 5945|      0|                    sp->fts_options |= 8192;
 5946|      0|                    fts_lfree(head);
 5947|      0|                    return ((FTSENT *)((void *)0));
 5948|      0|                }
 5949|      0|            }
 5950|      2|        }
 5951|      2|        if (!nitems) {
 5952|      0|            if (type == 3) {
 5953|      0|                cur->fts_info = (unsigned short)6;
 5954|      0|            }
 5955|      0|            fts_lfree(head);
 5956|      0|            return ((FTSENT *)((void *)0));
 5957|      0|        }
 5958|      2|        if (nitems > 10000UL) {
 5959|      0|            if (!sp->fts_compar) {
 5960|      0|                if (sp->fts_options & 512) {
 5961|      0|                    tmp___27 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
 5962|      0|                    if (tmp___27) {
 5963|      0|                        sp->fts_compar = &fts_compare_ino;
 5964|      0|                        head = fts_sort(sp, head, nitems);
 5965|      0|                        sp->fts_compar = (int (*)(struct _ftsent const **,
 5966|      0|                                                  struct _ftsent const **))((void *)0);
 5967|      0|                    }
 5968|      0|                }
 5969|      0|            }
 5970|      0|        }
 5971|      2|        if (sp->fts_compar) {
 5972|      0|            if (nitems > 1UL) {
 5973|      0|                head = fts_sort(sp, head, nitems);
 5974|      0|            }
 5975|      0|        }
 5976|      2|        return (head);
 5977|      2|    }
 5978|      2|}
 5979|       |static unsigned short fts_stat(FTS *sp, FTSENT *p, _Bool follow)
 5980|      2|{
 5981|      2|    struct stat *sbp;
 5982|      2|    int saved_errno;
 5983|      2|    int *tmp;
 5984|      2|    int *tmp___0;
 5985|      2|    int *tmp___1;
 5986|      2|    int tmp___2;
 5987|      2|    int tmp___3;
 5988|      2|    int *tmp___4;
 5989|      2|    int tmp___5;
 5990|      2|    int tmp___6;
 5991|      2|    int tmp___7;
 5992|       |
 5993|      2|    {
 5994|      2|        sbp = p->fts_statp;
 5995|      2|        if (p->fts_level == 0L) {
 5996|      2|            if (sp->fts_options & 1) {
 5997|      0|                follow = (_Bool)1;
 5998|      0|            }
 5999|      2|        }
 6000|      2|        if (sp->fts_options & 2) {
 6001|      0|            goto _L;
 6002|      0|        }
 6003|      2|        else {
 6004|      2|            if (follow) {
 6005|      0|_L:
 6006|      0|                tmp___3 = stat((char const *)p->fts_accpath, sbp);
 6007|      0|                if (tmp___3) {
 6008|      0|                    tmp = __errno_location();
 6009|      0|                    saved_errno = *tmp;
 6010|      0|                    tmp___1 = __errno_location();
 6011|      0|                    if (*tmp___1 == 2) {
 6012|      0|                        tmp___2 = lstat((char const *)p->fts_accpath, sbp);
 6013|      0|                        if (tmp___2 == 0) {
 6014|      0|                            tmp___0 = __errno_location();
 6015|      0|                            *tmp___0 = 0;
 6016|      0|                            return ((unsigned short)13);
 6017|      0|                        }
 6018|      0|                    }
 6019|      0|                    p->fts_errno = saved_errno;
 6020|      0|                    goto err;
 6021|      0|                }
 6022|      0|            }
 6023|      2|            else {
 6024|      2|                tmp___5 =
 6025|      2|                    fstatat(sp->fts_cwd_fd, (char const *)p->fts_accpath, sbp, 256);
 6026|      2|                if (tmp___5) {
 6027|      0|                    tmp___4 = __errno_location();
 6028|      0|                    p->fts_errno = *tmp___4;
 6029|      0|err:
 6030|      0|                    memset((void *)sbp, 0, sizeof(struct stat));
 6031|      0|                    return ((unsigned short)10);
 6032|      0|                }
 6033|      2|            }
 6034|      2|        }
 6035|      2|        if ((sbp->st_mode & 61440U) == 16384U) {
 6036|      2|            if (sp->fts_options & 32) {
 6037|      0|                tmp___6 = 0;
 6038|      0|            }
 6039|      2|            else {
 6040|      2|                tmp___6 = 2;
 6041|      2|            }
 6042|      2|            p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t)tmp___6;
 6043|      2|            if ((int)p->fts_name[0] == 46) {
 6044|      0|                if (!p->fts_name[1]) {
 6045|      0|                    goto _L___0;
 6046|      0|                }
 6047|      0|                else {
 6048|      0|                    if ((int)p->fts_name[1] == 46) {
 6049|      0|                        if (!p->fts_name[2]) {
 6050|      0|_L___0:
 6051|      0|                            if (p->fts_level == 0L) {
 6052|      0|                                tmp___7 = 1;
 6053|      0|                            }
 6054|      0|                            else {
 6055|      0|                                tmp___7 = 5;
 6056|      0|                            }
 6057|      0|                            return ((unsigned short)tmp___7);
 6058|      0|                        }
 6059|      0|                    }
 6060|      0|                }
 6061|      0|            }
 6062|      2|            return ((unsigned short)1);
 6063|      2|        }
 6064|      0|        if ((sbp->st_mode & 61440U) == 40960U) {
 6065|      0|            return ((unsigned short)12);
 6066|      0|        }
 6067|      0|        if ((sbp->st_mode & 61440U) == 32768U) {
 6068|      0|            return ((unsigned short)8);
 6069|      0|        }
 6070|      0|        return ((unsigned short)3);
 6071|      0|    }
 6072|      0|}
 6073|       |static int fts_compar(void const *a, void const *b)
 6074|      0|{
 6075|      0|    FTSENT const **pa;
 6076|      0|    FTSENT const **pb;
 6077|      0|    int tmp;
 6078|       |
 6079|      0|    {
 6080|      0|        pa = (FTSENT const **)a;
 6081|      0|        pb = (FTSENT const **)b;
 6082|      0|        tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
 6083|      0|        return (tmp);
 6084|      0|    }
 6085|      0|}
 6086|       |static FTSENT *fts_sort(FTS *sp, FTSENT *head, size_t nitems)
 6087|      0|{
 6088|      0|    FTSENT **ap;
 6089|      0|    FTSENT *p;
 6090|      0|    FTSENT *dummy = 0;
 6091|      0|    int (*compare)(void const *, void const *);
 6092|      0|    int (*tmp)(void const *, void const *);
 6093|      0|    FTSENT **a;
 6094|      0|    FTSENT **tmp___0;
 6095|       |
 6096|      0|    {
 6097|      0|        if (sizeof(&dummy) == sizeof(void *)) {
 6098|      0|            if ((long)(&dummy) == (long)((void *)(&dummy))) {
 6099|      0|                tmp = (int (*)(void const *, void const *))sp->fts_compar;
 6100|      0|            }
 6101|      0|            else {
 6102|      0|                tmp = &fts_compar;
 6103|      0|            }
 6104|      0|        }
 6105|      0|        else {
 6106|      0|            tmp = &fts_compar;
 6107|      0|        }
 6108|      0|        compare = tmp;
 6109|      0|        if (nitems > sp->fts_nitems) {
 6110|      0|            sp->fts_nitems = nitems + 40UL;
 6111|      0|            if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
 6112|      0|                free((void *)sp->fts_array);
 6113|      0|                sp->fts_array = (struct _ftsent **)((void *)0);
 6114|      0|                sp->fts_nitems = (size_t)0;
 6115|      0|                return (head);
 6116|      0|            }
 6117|      0|            else {
 6118|      0|                a = (FTSENT **)realloc((void *)sp->fts_array,
 6119|      0|                                       sp->fts_nitems * sizeof(*a));
 6120|      0|                if (!a) {
 6121|      0|                    free((void *)sp->fts_array);
 6122|      0|                    sp->fts_array = (struct _ftsent **)((void *)0);
 6123|      0|                    sp->fts_nitems = (size_t)0;
 6124|      0|                    return (head);
 6125|      0|                }
 6126|      0|            }
 6127|      0|            sp->fts_array = a;
 6128|      0|        }
 6129|      0|        ap = sp->fts_array;
 6130|      0|        p = head;
 6131|      0|        while (1) {
 6132|       |
 6133|      0|            if (!p) {
 6134|      0|                goto while_break;
 6135|      0|            }
 6136|      0|            tmp___0 = ap;
 6137|      0|            ap++;
 6138|      0|            *tmp___0 = p;
 6139|      0|            p = p->fts_link;
 6140|      0|        }
 6141|      0|while_break:
 6142|      0|        qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
 6143|      0|        ap = sp->fts_array;
 6144|      0|        head = *ap;
 6145|      0|        while (1) {
 6146|      0|            nitems--;
 6147|      0|            if (!nitems) {
 6148|      0|                goto while_break___0;
 6149|      0|            }
 6150|      0|            (*(ap + 0))->fts_link = *(ap + 1);
 6151|      0|            ap++;
 6152|      0|        }
 6153|      0|while_break___0:
 6154|      0|        (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
 6155|      0|        return (head);
 6156|      0|    }
 6157|      0|}
 6158|       |static FTSENT *fts_alloc(FTS *sp, char const *name, size_t namelen)
 6159|     10|{
 6160|     10|    FTSENT *p;
 6161|     10|    size_t len;
 6162|       |
 6163|     10|    {
 6164|     10|        len = sizeof(FTSENT) + namelen;
 6165|     10|        p = (FTSENT *)malloc(len);
 6166|     10|        if ((unsigned long)p == (unsigned long)((void *)0)) {
 6167|      0|            return ((FTSENT *)((void *)0));
 6168|      0|        }
 6169|     10|        memmove((void *)(p->fts_name), (void const *)name, namelen);
 6170|     10|        p->fts_name[namelen] = (char)'\000';
 6171|     10|        p->fts_namelen = namelen;
 6172|     10|        p->fts_fts = sp;
 6173|     10|        p->fts_path = sp->fts_path;
 6174|     10|        p->fts_errno = 0;
 6175|     10|        p->fts_flags = (unsigned short)0;
 6176|     10|        p->fts_instr = (unsigned short)3;
 6177|     10|        p->fts_number = 0L;
 6178|     10|        p->fts_pointer = (void *)0;
 6179|     10|        return (p);
 6180|     10|    }
 6181|     10|}
 6182|       |static void fts_lfree(FTSENT *head)
 6183|      0|{
 6184|      0|    FTSENT *p;
 6185|       |
 6186|      0|    {
 6187|      0|        while (1) {
 6188|      0|            p = head;
 6189|      0|            if (!p) {
 6190|      0|                goto while_break;
 6191|      0|            }
 6192|      0|            head = head->fts_link;
 6193|      0|            free((void *)p);
 6194|      0|        }
 6195|      0|while_break:
 6196|      0|        ;
 6197|      0|        return;
 6198|      0|    }
 6199|      0|}
 6200|       |static _Bool fts_palloc(FTS *sp, size_t more)
 6201|      2|{
 6202|      2|    char *p;
 6203|      2|    size_t new_len;
 6204|      2|    int *tmp;
 6205|       |
 6206|      2|    {
 6207|      2|        new_len = (sp->fts_pathlen + more) + 256UL;
 6208|      2|        if (new_len < sp->fts_pathlen) {
 6209|      0|            free((void *)sp->fts_path);
 6210|      0|            sp->fts_path = (char *)((void *)0);
 6211|      0|            tmp = __errno_location();
 6212|      0|            *tmp = 36;
 6213|      0|            return ((_Bool)0);
 6214|      0|        }
 6215|      2|        sp->fts_pathlen = new_len;
 6216|      2|        p = (char *)realloc((void *)sp->fts_path, sp->fts_pathlen);
 6217|      2|        if ((unsigned long)p == (unsigned long)((void *)0)) {
 6218|      0|            free((void *)sp->fts_path);
 6219|      0|            sp->fts_path = (char *)((void *)0);
 6220|      0|            return ((_Bool)0);
 6221|      0|        }
 6222|      2|        sp->fts_path = p;
 6223|      2|        return ((_Bool)1);
 6224|      2|    }
 6225|      2|}
 6226|       |static void fts_padjust(FTS *sp, FTSENT *head)
 6227|      0|{
 6228|      0|    FTSENT *p;
 6229|      0|    char *addr;
 6230|       |
 6231|      0|    {
 6232|      0|        addr = sp->fts_path;
 6233|      0|        p = sp->fts_child;
 6234|      0|        while (1) {
 6235|       |
 6236|      0|            if (!p) {
 6237|      0|                goto while_break;
 6238|      0|            }
 6239|      0|            while (1) {
 6240|       |
 6241|      0|                if ((unsigned long)p->fts_accpath != (unsigned long)(p->fts_name)) {
 6242|      0|                    p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
 6243|      0|                }
 6244|      0|                p->fts_path = addr;
 6245|      0|                goto while_break___0;
 6246|      0|            }
 6247|      0|while_break___0:
 6248|      0|            p = p->fts_link;
 6249|      0|        }
 6250|      0|while_break:
 6251|      0|        p = head;
 6252|      0|        while (1) {
 6253|       |
 6254|      0|            if (!(p->fts_level >= 0L)) {
 6255|      0|                goto while_break___1;
 6256|      0|            }
 6257|      0|            while (1) {
 6258|       |
 6259|      0|                if ((unsigned long)p->fts_accpath != (unsigned long)(p->fts_name)) {
 6260|      0|                    p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
 6261|      0|                }
 6262|      0|                p->fts_path = addr;
 6263|      0|                goto while_break___2;
 6264|      0|            }
 6265|      0|while_break___2:
 6266|      0|            ;
 6267|      0|            if (p->fts_link) {
 6268|      0|                p = p->fts_link;
 6269|      0|            }
 6270|      0|            else {
 6271|      0|                p = p->fts_parent;
 6272|      0|            }
 6273|      0|        }
 6274|      0|while_break___1:
 6275|      0|        ;
 6276|      0|        return;
 6277|      0|    }
 6278|      0|}
 6279|       |static size_t fts_maxarglen(char *const *argv)
 6280|      2|{
 6281|      2|    size_t len;
 6282|      2|    size_t max;
 6283|       |
 6284|      2|    {
 6285|      2|        max = (size_t)0;
 6286|      4|        while (1) {
 6287|       |
 6288|      4|            if (!*argv) {
 6289|      2|                goto while_break;
 6290|      2|            }
 6291|      2|            len = strlen((char const *)*argv);
 6292|      2|            if (len > max) {
 6293|      2|                max = len;
 6294|      2|            }
 6295|      2|            argv++;
 6296|      2|        }
 6297|      2|while_break:
 6298|      2|        ;
 6299|      2|        return (max + 1UL);
 6300|      2|    }
 6301|      2|}
 6302|       |static int fts_safe_changedir(FTS *sp, FTSENT *p, int fd, char const *dir)
 6303|      2|{
 6304|      2|    int ret;
 6305|      2|    _Bool is_dotdot;
 6306|      2|    int tmp;
 6307|      2|    int tmp___0;
 6308|      2|    int newfd;
 6309|      2|    int parent_fd;
 6310|      2|    _Bool tmp___1;
 6311|      2|    struct stat sb;
 6312|      2|    int tmp___2;
 6313|      2|    int *tmp___3;
 6314|      2|    int tmp___4;
 6315|      2|    int oerrno;
 6316|      2|    int *tmp___5;
 6317|      2|    int *tmp___6;
 6318|       |
 6319|      2|    {
 6320|      2|        if (dir) {
 6321|      0|            tmp = strcmp(dir, "..");
 6322|      0|            if (tmp == 0) {
 6323|      0|                tmp___0 = 1;
 6324|      0|            }
 6325|      0|            else {
 6326|      0|                tmp___0 = 0;
 6327|      0|            }
 6328|      0|        }
 6329|      2|        else {
 6330|      2|            tmp___0 = 0;
 6331|      2|        }
 6332|      2|        is_dotdot = (_Bool)tmp___0;
 6333|      2|        if (sp->fts_options & 4) {
 6334|      0|            if (sp->fts_options & 512) {
 6335|      0|                if (0 <= fd) {
 6336|      0|                    close(fd);
 6337|      0|                }
 6338|      0|            }
 6339|      0|            return (0);
 6340|      0|        }
 6341|      2|        if (fd < 0) {
 6342|      0|            if (is_dotdot) {
 6343|      0|                if (sp->fts_options & 512) {
 6344|      0|                    tmp___1 = i_ring_empty((I_ring const *)(&sp->fts_fd_ring));
 6345|      0|                    if (!tmp___1) {
 6346|      0|                        parent_fd = i_ring_pop(&sp->fts_fd_ring);
 6347|      0|                        is_dotdot = (_Bool)1;
 6348|      0|                        if (0 <= parent_fd) {
 6349|      0|                            fd = parent_fd;
 6350|      0|                            dir = (char const *)((void *)0);
 6351|      0|                        }
 6352|      0|                    }
 6353|      0|                }
 6354|      0|            }
 6355|      0|        }
 6356|      2|        newfd = fd;
 6357|      2|        if (fd < 0) {
 6358|      0|            newfd = diropen((FTS const *)sp, dir);
 6359|      0|            if (newfd < 0) {
 6360|      0|                return (-1);
 6361|      0|            }
 6362|      0|        }
 6363|      2|        if (sp->fts_options & 2) {
 6364|      0|            goto _L;
 6365|      0|        }
 6366|      2|        else {
 6367|      2|            if (dir) {
 6368|      0|                tmp___4 = strcmp(dir, "..");
 6369|      0|                if (tmp___4 == 0) {
 6370|      0|_L:
 6371|      0|                    tmp___2 = fstat(newfd, &sb);
 6372|      0|                    if (tmp___2) {
 6373|      0|                        ret = -1;
 6374|      0|                        goto bail;
 6375|      0|                    }
 6376|      0|                    if (p->fts_statp[0].st_dev != sb.st_dev) {
 6377|      0|                        tmp___3 = __errno_location();
 6378|      0|                        *tmp___3 = 2;
 6379|      0|                        ret = -1;
 6380|      0|                        goto bail;
 6381|      0|                    }
 6382|      0|                    else {
 6383|      0|                        if (p->fts_statp[0].st_ino != sb.st_ino) {
 6384|      0|                            tmp___3 = __errno_location();
 6385|      0|                            *tmp___3 = 2;
 6386|      0|                            ret = -1;
 6387|      0|                            goto bail;
 6388|      0|                        }
 6389|      0|                    }
 6390|      0|                }
 6391|      0|            }
 6392|      2|        }
 6393|      2|        if (sp->fts_options & 512) {
 6394|      2|            cwd_advance_fd(sp, newfd, (_Bool)(!is_dotdot));
 6395|      2|            return (0);
 6396|      2|        }
 6397|      0|        ret = fchdir(newfd);
 6398|      0|bail:
 6399|      0|        if (fd < 0) {
 6400|      0|            tmp___5 = __errno_location();
 6401|      0|            oerrno = *tmp___5;
 6402|      0|            close(newfd);
 6403|      0|            tmp___6 = __errno_location();
 6404|      0|            *tmp___6 = oerrno;
 6405|      0|        }
 6406|      0|        return (ret);
 6407|      0|    }
 6408|      0|}
 6409|       |#pragma weak pthread_key_create
 6410|       |#pragma weak pthread_getspecific
 6411|       |#pragma weak pthread_setspecific
 6412|       |#pragma weak pthread_key_delete
 6413|       |#pragma weak pthread_self
 6414|       |#pragma weak pthread_cancel
 6415|       |#pragma weak pthread_mutex_init
 6416|       |#pragma weak pthread_mutex_lock
 6417|       |#pragma weak pthread_mutex_unlock
 6418|       |#pragma weak pthread_mutex_destroy
 6419|       |#pragma weak pthread_rwlock_init
 6420|       |#pragma weak pthread_rwlock_rdlock
 6421|       |#pragma weak pthread_rwlock_wrlock
 6422|       |#pragma weak pthread_rwlock_unlock
 6423|       |#pragma weak pthread_rwlock_destroy
 6424|       |#pragma weak pthread_once
 6425|       |#pragma weak pthread_cond_init
 6426|       |#pragma weak pthread_cond_wait
 6427|       |#pragma weak pthread_cond_signal
 6428|       |#pragma weak pthread_cond_broadcast
 6429|       |#pragma weak pthread_cond_destroy
 6430|       |#pragma weak pthread_mutexattr_init
 6431|       |#pragma weak pthread_mutexattr_settype
 6432|       |#pragma weak pthread_mutexattr_destroy
 6433|       |#pragma weak pthread_self
 6434|       |#pragma weak pthread_cancel
 6435|       |char const *Version = "8.2";
 6436|       |extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2),
 6437|       |                                        __leaf__)) fchownat)(
 6438|       |                                                int __fd, char const *__file, __uid_t __owner, __gid_t __group, int __flag);
 6439|       |__inline static int chownat(int fd, char const *file, uid_t owner,
 6440|       |                            gid_t group)
 6441|      0|{
 6442|      0|    int tmp;
 6443|       |
 6444|      0|    {
 6445|      0|        tmp = fchownat(fd, file, owner, group, 0);
 6446|      0|        return (tmp);
 6447|      0|    }
 6448|      0|}
 6449|       |__inline static int lchownat(int fd, char const *file, uid_t owner,
 6450|       |                             gid_t group)
 6451|      6|{
 6452|      6|    int tmp;
 6453|       |
 6454|      6|    {
 6455|      6|        tmp = fchownat(fd, file, owner, group, 256);
 6456|      6|        return (tmp);
 6457|      6|    }
 6458|      6|}
 6459|       |extern void chopt_init(struct Chown_option *chopt);
 6460|       |extern void chopt_free(struct Chown_option *chopt __attribute__((__unused__)));
 6461|       |extern char *gid_to_name(gid_t gid);
 6462|       |extern char *uid_to_name(uid_t uid);
 6463|       |extern _Bool chown_files(char **files, int bit_flags, uid_t uid, gid_t gid,
 6464|       |                         uid_t required_uid, gid_t required_gid,
 6465|       |                         struct Chown_option const *chopt);
 6466|       |__inline static void ignore_ptr(void *p)
 6467|      0|{
 6468|       |
 6469|      0|    {
 6470|      0|        return;
 6471|      0|    }
 6472|      0|}
 6473|       |extern void chopt_init(struct Chown_option *chopt)
 6474|      2|{
 6475|       |
 6476|      2|    {
 6477|      2|        chopt->verbosity = (enum Verbosity)2;
 6478|      2|        chopt->root_dev_ino = (struct dev_ino *)((void *)0);
 6479|      2|        chopt->affect_symlink_referent = (_Bool)1;
 6480|      2|        chopt->recurse = (_Bool)0;
 6481|      2|        chopt->force_silent = (_Bool)0;
 6482|      2|        chopt->user_name = (char *)((void *)0);
 6483|      2|        chopt->group_name = (char *)((void *)0);
 6484|      2|        return;
 6485|      2|    }
 6486|      2|}
 6487|       |extern void chopt_free(struct Chown_option *chopt __attribute__((__unused__)))
 6488|      2|{
 6489|       |
 6490|      2|    {
 6491|      2|        return;
 6492|      2|    }
 6493|      2|}
 6494|       |extern char *gid_to_name(gid_t gid)
 6495|      0|{
 6496|      0|    char
 6497|      0|    buf___1[((((sizeof(intmax_t) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL) +
 6498|      0|                                 1UL];
 6499|      0|    struct group *grp;
 6500|      0|    struct group *tmp;
 6501|      0|    char *tmp___1;
 6502|      0|    char *tmp___2;
 6503|      0|    char *tmp___3;
 6504|       |
 6505|      0|    {
 6506|      0|        tmp = getgrgid(gid);
 6507|      0|        grp = tmp;
 6508|      0|        if (grp) {
 6509|      0|            tmp___2 = grp->gr_name;
 6510|      0|        }
 6511|      0|        else {
 6512|      0|            tmp___1 = umaxtostr((uintmax_t)gid, buf___1);
 6513|      0|            tmp___2 = tmp___1;
 6514|      0|        }
 6515|      0|        tmp___3 = xstrdup((char const *)tmp___2);
 6516|      0|        return (tmp___3);
 6517|      0|    }
 6518|      0|}
 6519|       |extern char *uid_to_name(uid_t uid)
 6520|      0|{
 6521|      0|    char
 6522|      0|    buf___1[((((sizeof(intmax_t) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL) +
 6523|      0|                                 1UL];
 6524|      0|    struct passwd *pwd;
 6525|      0|    struct passwd *tmp;
 6526|      0|    char *tmp___1;
 6527|      0|    char *tmp___2;
 6528|      0|    char *tmp___3;
 6529|       |
 6530|      0|    {
 6531|      0|        tmp = getpwuid(uid);
 6532|      0|        pwd = tmp;
 6533|      0|        if (pwd) {
 6534|      0|            tmp___2 = pwd->pw_name;
 6535|      0|        }
 6536|      0|        else {
 6537|      0|            tmp___1 = umaxtostr((uintmax_t)uid, buf___1);
 6538|      0|            tmp___2 = tmp___1;
 6539|      0|        }
 6540|      0|        tmp___3 = xstrdup((char const *)tmp___2);
 6541|      0|        return (tmp___3);
 6542|      0|    }
 6543|      0|}
 6544|       |static void describe_change(char const *file, enum Change_status changed,
 6545|       |                            char const *user, char const *group)
 6546|      0|{
 6547|      0|    char const *fmt;
 6548|      0|    char const *spec;
 6549|      0|    char *spec_allocated;
 6550|      0|    char const *tmp;
 6551|      0|    char *tmp___0;
 6552|      0|    size_t tmp___1;
 6553|      0|    size_t tmp___2;
 6554|      0|    char *tmp___3;
 6555|      0|    char *tmp___4;
 6556|      0|    char *tmp___5;
 6557|      0|    char *tmp___6;
 6558|      0|    char *tmp___7;
 6559|      0|    char *tmp___8;
 6560|      0|    char *tmp___9;
 6561|      0|    char *tmp___10;
 6562|      0|    char *tmp___11;
 6563|      0|    char *tmp___12;
 6564|      0|    char *tmp___13;
 6565|      0|    char *tmp___14;
 6566|      0|    char *tmp___15;
 6567|      0|    char *tmp___16;
 6568|      0|    char const *tmp___17;
 6569|       |
 6570|      0|    {
 6571|      0|        spec_allocated = (char *)((void *)0);
 6572|      0|        if ((unsigned int)changed == 1U) {
 6573|      0|            tmp = quote(file);
 6574|      0|            tmp___0 =
 6575|      0|                gettext("neither symbolic link %s nor referent has been changed\n");
 6576|      0|            printf((char const *)tmp___0, tmp);
 6577|      0|            return;
 6578|      0|        }
 6579|      0|        if (user) {
 6580|      0|            if (group) {
 6581|      0|                tmp___1 = strlen(user);
 6582|      0|                tmp___2 = strlen(group);
 6583|      0|                spec_allocated = (char *)xmalloc(((tmp___1 + 1UL) + tmp___2) + 1UL);
 6584|      0|                tmp___3 = stpcpy(spec_allocated, user);
 6585|      0|                tmp___4 = stpcpy(tmp___3, ":");
 6586|      0|                stpcpy(tmp___4, group);
 6587|      0|                spec = (char const *)spec_allocated;
 6588|      0|            }
 6589|      0|            else {
 6590|      0|                spec = user;
 6591|      0|            }
 6592|      0|        }
 6593|      0|        else {
 6594|      0|            spec = group;
 6595|      0|        }
 6596|      0|        if ((unsigned int)changed == 2U) {
 6597|      0|            goto case_2;
 6598|      0|        }
 6599|      0|        if ((unsigned int)changed == 3U) {
 6600|      0|            goto case_3;
 6601|      0|        }
 6602|      0|        if ((unsigned int)changed == 4U) {
 6603|      0|            goto case_4;
 6604|      0|        }
 6605|      0|        goto switch_default;
 6606|      0|case_2:
 6607|      0|        if (user) {
 6608|      0|            tmp___5 = gettext("changed ownership of %s to %s\n");
 6609|      0|            fmt = (char const *)tmp___5;
 6610|      0|        }
 6611|      0|        else {
 6612|      0|            if (group) {
 6613|      0|                tmp___6 = gettext("changed group of %s to %s\n");
 6614|      0|                tmp___8 = tmp___6;
 6615|      0|            }
 6616|      0|            else {
 6617|      0|                tmp___7 = gettext("no change to ownership of %s\n");
 6618|      0|                tmp___8 = tmp___7;
 6619|      0|            }
 6620|      0|            fmt = (char const *)tmp___8;
 6621|      0|        }
 6622|      0|        goto switch_break;
 6623|      0|case_3:
 6624|      0|        if (user) {
 6625|      0|            tmp___9 = gettext("failed to change ownership of %s to %s\n");
 6626|      0|            fmt = (char const *)tmp___9;
 6627|      0|        }
 6628|      0|        else {
 6629|      0|            if (group) {
 6630|      0|                tmp___10 = gettext("failed to change group of %s to %s\n");
 6631|      0|                tmp___12 = tmp___10;
 6632|      0|            }
 6633|      0|            else {
 6634|      0|                tmp___11 = gettext("failed to change ownership of %s\n");
 6635|      0|                tmp___12 = tmp___11;
 6636|      0|            }
 6637|      0|            fmt = (char const *)tmp___12;
 6638|      0|        }
 6639|      0|        goto switch_break;
 6640|      0|case_4:
 6641|      0|        if (user) {
 6642|      0|            tmp___13 = gettext("ownership of %s retained as %s\n");
 6643|      0|            fmt = (char const *)tmp___13;
 6644|      0|        }
 6645|      0|        else {
 6646|      0|            if (group) {
 6647|      0|                tmp___14 = gettext("group of %s retained as %s\n");
 6648|      0|                tmp___16 = tmp___14;
 6649|      0|            }
 6650|      0|            else {
 6651|      0|                tmp___15 = gettext("ownership of %s retained\n");
 6652|      0|                tmp___16 = tmp___15;
 6653|      0|            }
 6654|      0|            fmt = (char const *)tmp___16;
 6655|      0|        }
 6656|      0|        goto switch_break;
 6657|      0|switch_default:
 6658|      0|        abort();
 6659|      0|switch_break:
 6660|      0|        tmp___17 = quote(file);
 6661|      0|        printf(fmt, tmp___17, spec);
 6662|      0|        free((void *)spec_allocated);
 6663|      0|        return;
 6664|      0|    }
 6665|      0|}
 6666|       |static enum RCH_status restricted_chown(int cwd_fd, char const *file,
 6667|       |                                        struct stat const *orig_st, uid_t uid,
 6668|       |                                        gid_t gid, uid_t required_uid,
 6669|       |                                        gid_t required_gid)
 6670|      0|{
 6671|      0|    enum RCH_status status;
 6672|      0|    struct stat st;
 6673|      0|    int open_flags;
 6674|      0|    int fd;
 6675|      0|    int tmp___0;
 6676|      0|    int *tmp___1;
 6677|      0|    int *tmp___2;
 6678|      0|    int tmp___4;
 6679|      0|    int tmp___5;
 6680|      0|    int tmp___6;
 6681|      0|    int saved_errno;
 6682|      0|    int *tmp___7;
 6683|      0|    int *tmp___8;
 6684|       |
 6685|      0|    {
 6686|      0|        status = (enum RCH_status)2;
 6687|      0|        open_flags = 2304;
 6688|      0|        if (required_uid == 4294967295U) {
 6689|      0|            if (required_gid == 4294967295U) {
 6690|      0|                return ((enum RCH_status)5);
 6691|      0|            }
 6692|      0|        }
 6693|      0|        if (!((orig_st->st_mode & 61440U) == 32768U)) {
 6694|      0|            if ((orig_st->st_mode & 61440U) == 16384U) {
 6695|      0|                open_flags |= 65536;
 6696|      0|            }
 6697|      0|            else {
 6698|      0|                return ((enum RCH_status)5);
 6699|      0|            }
 6700|      0|        }
 6701|      0|        fd = openat(cwd_fd, file, open_flags);
 6702|      0|        if (!(0 <= fd)) {
 6703|      0|            tmp___2 = __errno_location();
 6704|      0|            if (*tmp___2 == 13) {
 6705|      0|                if ((orig_st->st_mode & 61440U) == 32768U) {
 6706|      0|                    fd = openat(cwd_fd, file, 1 | open_flags);
 6707|      0|                    if (!(0 <= fd)) {
 6708|      0|                        goto _L___0;
 6709|      0|                    }
 6710|      0|                }
 6711|      0|                else {
 6712|      0|                    goto _L___0;
 6713|      0|                }
 6714|      0|            }
 6715|      0|            else {
 6716|      0|_L___0:
 6717|      0|                tmp___1 = __errno_location();
 6718|      0|                if (*tmp___1 == 13) {
 6719|      0|                    tmp___0 = 5;
 6720|      0|                }
 6721|      0|                else {
 6722|      0|                    tmp___0 = 6;
 6723|      0|                }
 6724|      0|                return ((enum RCH_status)tmp___0);
 6725|      0|            }
 6726|      0|        }
 6727|      0|        tmp___6 = fstat(fd, &st);
 6728|      0|        if (tmp___6 != 0) {
 6729|      0|            status = (enum RCH_status)6;
 6730|      0|        }
 6731|      0|        else {
 6732|      0|            if (orig_st->st_ino == (__ino_t const)st.st_ino) {
 6733|      0|                if (orig_st->st_dev == (__dev_t const)st.st_dev) {
 6734|      0|                    if (required_uid == 4294967295U) {
 6735|      0|                        goto _L___2;
 6736|      0|                    }
 6737|      0|                    else {
 6738|      0|                        if (required_uid == st.st_uid) {
 6739|      0|_L___2:
 6740|      0|                            if (required_gid == 4294967295U) {
 6741|      0|                                goto _L___1;
 6742|      0|                            }
 6743|      0|                            else {
 6744|      0|                                if (required_gid == st.st_gid) {
 6745|      0|_L___1:
 6746|      0|                                    tmp___5 = fchown(fd, uid, gid);
 6747|      0|                                    if (tmp___5 == 0) {
 6748|      0|                                        tmp___4 = close(fd);
 6749|      0|                                        if (tmp___4 == 0) {
 6750|      0|                                            status = (enum RCH_status)2;
 6751|      0|                                        }
 6752|      0|                                        else {
 6753|      0|                                            status = (enum RCH_status)6;
 6754|      0|                                        }
 6755|      0|                                        return (status);
 6756|      0|                                    }
 6757|      0|                                    else {
 6758|      0|                                        status = (enum RCH_status)6;
 6759|      0|                                    }
 6760|      0|                                }
 6761|      0|                            }
 6762|      0|                        }
 6763|      0|                    }
 6764|      0|                }
 6765|      0|                else {
 6766|      0|                    status = (enum RCH_status)4;
 6767|      0|                }
 6768|      0|            }
 6769|      0|            else {
 6770|      0|                status = (enum RCH_status)4;
 6771|      0|            }
 6772|      0|        }
 6773|      0|        tmp___7 = __errno_location();
 6774|      0|        saved_errno = *tmp___7;
 6775|      0|        close(fd);
 6776|      0|        tmp___8 = __errno_location();
 6777|      0|        *tmp___8 = saved_errno;
 6778|      0|        return (status);
 6779|      0|    }
 6780|      0|}
 6781|       |static _Bool change_file_owner(FTS *fts, FTSENT *ent, uid_t uid, gid_t gid,
 6782|       |                               uid_t required_uid, gid_t required_gid,
 6783|       |                               struct Chown_option const *chopt)
 6784|      8|{
 6785|      8|    char const *file_full_name;
 6786|      8|    char const *file;
 6787|      8|    struct stat const *file_stats;
 6788|      8|    struct stat stat_buf;
 6789|      8|    _Bool ok;
 6790|      8|    _Bool do_chown;
 6791|      8|    _Bool symlink_changed;
 6792|      8|    char const *tmp;
 6793|      8|    char *tmp___0;
 6794|      8|    char const *tmp___1;
 6795|      8|    char const *tmp___2;
 6796|      8|    char *tmp___3;
 6797|      8|    int tmp___4;
 6798|      8|    char *tmp___5;
 6799|      8|    FTSENT *tmp___6;
 6800|      8|    char const *tmp___7;
 6801|      8|    char *tmp___8;
 6802|      8|    char const *tmp___9;
 6803|      8|    char *tmp___10;
 6804|      8|    char const *tmp___11;
 6805|      8|    char *tmp___12;
 6806|      8|    char const *tmp___13;
 6807|      8|    char *tmp___14;
 6808|      8|    _Bool tmp___15;
 6809|      8|    char const *tmp___16;
 6810|      8|    char *tmp___17;
 6811|      8|    int *tmp___18;
 6812|      8|    int tmp___19;
 6813|      8|    int tmp___20;
 6814|      8|    char const *tmp___21;
 6815|      8|    char *tmp___22;
 6816|      8|    char const *tmp___23;
 6817|      8|    char const *tmp___24;
 6818|      8|    char *tmp___25;
 6819|      8|    int tmp___26;
 6820|      8|    char *tmp___27;
 6821|      8|    int tmp___28;
 6822|      8|    int *tmp___29;
 6823|      8|    enum RCH_status err;
 6824|      8|    enum RCH_status tmp___30;
 6825|      8|    int tmp___31;
 6826|      8|    char const *tmp___32;
 6827|      8|    char *tmp___33;
 6828|      8|    char *tmp___34;
 6829|      8|    char *tmp___35;
 6830|      8|    int *tmp___36;
 6831|      8|    _Bool changed;
 6832|      8|    int tmp___37;
 6833|      8|    enum Change_status ch_status;
 6834|      8|    int tmp___38;
 6835|      8|    int tmp___39;
 6836|      8|    int tmp___40;
 6837|       |
 6838|      8|    {
 6839|      8|        file_full_name = (char const *)ent->fts_path;
 6840|      8|        file = (char const *)ent->fts_accpath;
 6841|      8|        ok = (_Bool)1;
 6842|      8|        symlink_changed = (_Bool)1;
 6843|      8|        if ((int)ent->fts_info == 1) {
 6844|      2|            goto case_1;
 6845|      2|        }
 6846|      6|        if ((int)ent->fts_info == 6) {
 6847|      2|            goto case_6;
 6848|      2|        }
 6849|      4|        if ((int)ent->fts_info == 10) {
 6850|      0|            goto case_10;
 6851|      0|        }
 6852|      4|        if ((int)ent->fts_info == 7) {
 6853|      0|            goto case_7;
 6854|      0|        }
 6855|      4|        if ((int)ent->fts_info == 4) {
 6856|      0|            goto case_4;
 6857|      0|        }
 6858|      4|        if ((int)ent->fts_info == 2) {
 6859|      0|            goto case_2;
 6860|      0|        }
 6861|      4|        goto switch_default;
 6862|      4|case_1:
 6863|      2|        if (chopt->recurse) {
 6864|      2|            if (chopt->root_dev_ino) {
 6865|      0|                if (ent->fts_statp[0].st_ino == (chopt->root_dev_ino)->st_ino) {
 6866|      0|                    if (ent->fts_statp[0].st_dev == (chopt->root_dev_ino)->st_dev) {
 6867|      0|                        while (1) {
 6868|      0|                            tmp___4 = strcmp(file_full_name, "/");
 6869|      0|                            if (tmp___4 == 0) {
 6870|      0|                                tmp = quote(file_full_name);
 6871|      0|                                tmp___0 =
 6872|      0|                                    gettext("it is dangerous to operate recursively on %s");
 6873|      0|                                error(0, 0, (char const *)tmp___0, tmp);
 6874|      0|                            }
 6875|      0|                            else {
 6876|      0|                                tmp___1 = quote_n(1, "/");
 6877|      0|                                tmp___2 = quote_n(0, file_full_name);
 6878|      0|                                tmp___3 = gettext("it is dangerous to operate recursively on "
 6879|      0|                                                  "%s (same as %s)");
 6880|      0|                                error(0, 0, (char const *)tmp___3, tmp___2, tmp___1);
 6881|      0|                            }
 6882|      0|                            tmp___5 =
 6883|      0|                                gettext("use --no-preserve-root to override this failsafe");
 6884|      0|                            error(0, 0, (char const *)tmp___5);
 6885|      0|                            goto while_break;
 6886|      0|                        }
 6887|      0|while_break:
 6888|      0|                        fts_set(fts, ent, 4);
 6889|      0|                        tmp___6 = fts_read(fts);
 6890|      0|                        ignore_ptr((void *)tmp___6);
 6891|      0|                        return ((_Bool)0);
 6892|      0|                    }
 6893|      0|                }
 6894|      0|            }
 6895|      2|            return ((_Bool)1);
 6896|      2|        }
 6897|      0|        goto switch_break;
 6898|      2|case_6:
 6899|      2|        if (!chopt->recurse) {
 6900|      0|            return ((_Bool)1);
 6901|      0|        }
 6902|      2|        goto switch_break;
 6903|      2|case_10:
 6904|      0|        if (ent->fts_level == 0L) {
 6905|      0|            if (ent->fts_number == 0L) {
 6906|      0|                ent->fts_number = 1L;
 6907|      0|                fts_set(fts, ent, 1);
 6908|      0|                return ((_Bool)1);
 6909|      0|            }
 6910|      0|        }
 6911|      0|        if (!chopt->force_silent) {
 6912|      0|            tmp___7 = quote(file_full_name);
 6913|      0|            tmp___8 = gettext("cannot access %s");
 6914|      0|            error(0, ent->fts_errno, (char const *)tmp___8, tmp___7);
 6915|      0|        }
 6916|      0|        ok = (_Bool)0;
 6917|      0|        goto switch_break;
 6918|      0|case_7:
 6919|      0|        if (!chopt->force_silent) {
 6920|      0|            tmp___9 = quote(file_full_name);
 6921|      0|            tmp___10 = gettext("%s");
 6922|      0|            error(0, ent->fts_errno, (char const *)tmp___10, tmp___9);
 6923|      0|        }
 6924|      0|        ok = (_Bool)0;
 6925|      0|        goto switch_break;
 6926|      0|case_4:
 6927|      0|        if (!chopt->force_silent) {
 6928|      0|            tmp___11 = quote(file_full_name);
 6929|      0|            tmp___12 = gettext("cannot read directory %s");
 6930|      0|            error(0, ent->fts_errno, (char const *)tmp___12, tmp___11);
 6931|      0|        }
 6932|      0|        ok = (_Bool)0;
 6933|      0|        goto switch_break;
 6934|      0|case_2:
 6935|      0|        tmp___15 = cycle_warning_required((FTS const *)fts, (FTSENT const *)ent);
 6936|      0|        if (tmp___15) {
 6937|      0|            while (1) {
 6938|      0|                tmp___13 = quote(file_full_name);
 6939|      0|                tmp___14 = gettext(
 6940|      0|                               "WARNING: Circular directory structure.\nThis almost certainly "
 6941|      0|                               "means that you have a corrupted file system.\nNOTIFY YOUR SYSTEM "
 6942|      0|                               "MANAGER.\nThe following directory is part of the cycle:\n  %s\n");
 6943|      0|                error(0, 0, (char const *)tmp___14, tmp___13);
 6944|      0|                goto while_break___0;
 6945|      0|            }
 6946|      0|while_break___0:
 6947|      0|            ;
 6948|      0|            return ((_Bool)0);
 6949|      0|        }
 6950|      0|        goto switch_break;
 6951|      4|switch_default:
 6952|      4|        goto switch_break;
 6953|      6|switch_break:
 6954|      6|        ;
 6955|      6|        if (!ok) {
 6956|      0|            do_chown = (_Bool)0;
 6957|      0|            file_stats = (struct stat const *)((void *)0);
 6958|      0|        }
 6959|      6|        else {
 6960|      6|            if (required_uid == 4294967295U) {
 6961|      6|                if (required_gid == 4294967295U) {
 6962|      6|                    if ((unsigned int const)chopt->verbosity == 2U) {
 6963|      6|                        if (!chopt->root_dev_ino) {
 6964|      6|                            if (!chopt->affect_symlink_referent) {
 6965|      6|                                do_chown = (_Bool)1;
 6966|      6|                                file_stats = (struct stat const *)(ent->fts_statp);
 6967|      6|                            }
 6968|      0|                            else {
 6969|      0|                                goto _L___3;
 6970|      0|                            }
 6971|      6|                        }
 6972|      0|                        else {
 6973|      0|                            goto _L___3;
 6974|      0|                        }
 6975|      6|                    }
 6976|      0|                    else {
 6977|      0|                        goto _L___3;
 6978|      0|                    }
 6979|      6|                }
 6980|      0|                else {
 6981|      0|                    goto _L___3;
 6982|      0|                }
 6983|      6|            }
 6984|      0|            else {
 6985|      0|_L___3:
 6986|      0|                file_stats = (struct stat const *)(ent->fts_statp);
 6987|      0|                if (chopt->affect_symlink_referent) {
 6988|      0|                    if ((file_stats->st_mode & 61440U) == 40960U) {
 6989|      0|                        tmp___19 = fstatat(fts->fts_cwd_fd, file, &stat_buf, 0);
 6990|      0|                        if (tmp___19 != 0) {
 6991|      0|                            if (!chopt->force_silent) {
 6992|      0|                                tmp___16 = quote(file_full_name);
 6993|      0|                                tmp___17 = gettext("cannot dereference %s");
 6994|      0|                                tmp___18 = __errno_location();
 6995|      0|                                error(0, *tmp___18, (char const *)tmp___17, tmp___16);
 6996|      0|                            }
 6997|      0|                            ok = (_Bool)0;
 6998|      0|                        }
 6999|      0|                        file_stats = (struct stat const *)(&stat_buf);
 7000|      0|                    }
 7001|      0|                }
 7002|      0|                if (ok) {
 7003|      0|                    if (required_uid == 4294967295U) {
 7004|      0|                        goto _L;
 7005|      0|                    }
 7006|      0|                    else {
 7007|      0|                        if (required_uid == (uid_t)file_stats->st_uid) {
 7008|      0|_L:
 7009|      0|                            if (required_gid == 4294967295U) {
 7010|      0|                                tmp___20 = 1;
 7011|      0|                            }
 7012|      0|                            else {
 7013|      0|                                if (required_gid == (gid_t)file_stats->st_gid) {
 7014|      0|                                    tmp___20 = 1;
 7015|      0|                                }
 7016|      0|                                else {
 7017|      0|                                    tmp___20 = 0;
 7018|      0|                                }
 7019|      0|                            }
 7020|      0|                        }
 7021|      0|                        else {
 7022|      0|                            tmp___20 = 0;
 7023|      0|                        }
 7024|      0|                    }
 7025|      0|                }
 7026|      0|                else {
 7027|      0|                    tmp___20 = 0;
 7028|      0|                }
 7029|      0|                do_chown = (_Bool)tmp___20;
 7030|      0|            }
 7031|      6|        }
 7032|      6|        if (ok) {
 7033|      6|            if ((int)ent->fts_info == 1) {
 7034|      0|                goto _L___4;
 7035|      0|            }
 7036|      6|            else {
 7037|      6|                if ((int)ent->fts_info == 2) {
 7038|      0|                    goto _L___4;
 7039|      0|                }
 7040|      6|                else {
 7041|      6|                    if ((int)ent->fts_info == 6) {
 7042|      2|                        goto _L___4;
 7043|      2|                    }
 7044|      4|                    else {
 7045|      4|                        if ((int)ent->fts_info == 4) {
 7046|      2|_L___4:
 7047|      2|                            if (chopt->root_dev_ino) {
 7048|      0|                                if (file_stats->st_ino ==
 7049|      0|                                        (__ino_t const)(chopt->root_dev_ino)->st_ino) {
 7050|      0|                                    if (file_stats->st_dev ==
 7051|      0|                                            (__dev_t const)(chopt->root_dev_ino)->st_dev) {
 7052|      0|                                        while (1) {
 7053|      0|                                            tmp___26 = strcmp(file_full_name, "/");
 7054|      0|                                            if (tmp___26 == 0) {
 7055|      0|                                                tmp___21 = quote(file_full_name);
 7056|      0|                                                tmp___22 = gettext(
 7057|      0|                                                               "it is dangerous to operate recursively on %s");
 7058|      0|                                                error(0, 0, (char const *)tmp___22, tmp___21);
 7059|      0|                                            }
 7060|      0|                                            else {
 7061|      0|                                                tmp___23 = quote_n(1, "/");
 7062|      0|                                                tmp___24 = quote_n(0, file_full_name);
 7063|      0|                                                tmp___25 = gettext("it is dangerous to operate "
 7064|      0|                                                                   "recursively on %s (same as %s)");
 7065|      0|                                                error(0, 0, (char const *)tmp___25, tmp___24, tmp___23);
 7066|      0|                                            }
 7067|      0|                                            tmp___27 = gettext(
 7068|      0|                                                           "use --no-preserve-root to override this failsafe");
 7069|      0|                                            error(0, 0, (char const *)tmp___27);
 7070|      0|                                            goto while_break___1;
 7071|      0|                                        }
 7072|      0|while_break___1:
 7073|      0|                                        ;
 7074|      0|                                        return ((_Bool)0);
 7075|      0|                                    }
 7076|      0|                                }
 7077|      0|                            }
 7078|      2|                        }
 7079|      4|                    }
 7080|      6|                }
 7081|      6|            }
 7082|      6|        }
 7083|      6|        if (do_chown) {
 7084|      6|            if (!chopt->affect_symlink_referent) {
 7085|      6|                tmp___28 = lchownat(fts->fts_cwd_fd, file, uid, gid);
 7086|      6|                ok = (_Bool)(tmp___28 == 0);
 7087|      6|                if (!ok) {
 7088|      0|                    tmp___29 = __errno_location();
 7089|      0|                    if (*tmp___29 == 95) {
 7090|      0|                        ok = (_Bool)1;
 7091|      0|                        symlink_changed = (_Bool)0;
 7092|      0|                    }
 7093|      0|                }
 7094|      6|            }
 7095|      0|            else {
 7096|      0|                tmp___30 = restricted_chown(fts->fts_cwd_fd, file, file_stats, uid, gid,
 7097|      0|                                            required_uid, required_gid);
 7098|      0|                err = tmp___30;
 7099|      0|                if ((unsigned int)err == 2U) {
 7100|      0|                    goto case_2___0;
 7101|      0|                }
 7102|      0|                if ((unsigned int)err == 5U) {
 7103|      0|                    goto case_5;
 7104|      0|                }
 7105|      0|                if ((unsigned int)err == 6U) {
 7106|      0|                    goto case_6___0;
 7107|      0|                }
 7108|      0|                if ((unsigned int)err == 4U) {
 7109|      0|                    goto case_4___0;
 7110|      0|                }
 7111|      0|                if ((unsigned int)err == 3U) {
 7112|      0|                    goto case_4___0;
 7113|      0|                }
 7114|      0|                goto switch_default___0;
 7115|      0|case_2___0:
 7116|      0|                goto switch_break___0;
 7117|      0|case_5:
 7118|      0|                tmp___31 = chownat(fts->fts_cwd_fd, file, uid, gid);
 7119|      0|                ok = (_Bool)(tmp___31 == 0);
 7120|      0|                goto switch_break___0;
 7121|      0|case_6___0:
 7122|      0|                ok = (_Bool)0;
 7123|      0|                goto switch_break___0;
 7124|      0|case_4___0:
 7125|      0|                do_chown = (_Bool)0;
 7126|      0|                ok = (_Bool)0;
 7127|      0|                goto switch_break___0;
 7128|      0|switch_default___0:
 7129|      0|                abort();
 7130|      0|switch_break___0:
 7131|      0|                ;
 7132|      0|            }
 7133|      6|            if (do_chown) {
 7134|      6|                if (!ok) {
 7135|      0|                    if (!chopt->force_silent) {
 7136|      0|                        tmp___32 = quote(file_full_name);
 7137|      0|                        if (uid != 4294967295U) {
 7138|      0|                            tmp___33 = gettext("changing ownership of %s");
 7139|      0|                            tmp___35 = tmp___33;
 7140|      0|                        }
 7141|      0|                        else {
 7142|      0|                            tmp___34 = gettext("changing group of %s");
 7143|      0|                            tmp___35 = tmp___34;
 7144|      0|                        }
 7145|      0|                        tmp___36 = __errno_location();
 7146|      0|                        error(0, *tmp___36, (char const *)tmp___35, tmp___32);
 7147|      0|                    }
 7148|      0|                }
 7149|      6|            }
 7150|      6|        }
 7151|      6|        if ((unsigned int const)chopt->verbosity != 2U) {
 7152|      0|            if (do_chown) {
 7153|      0|                if (ok) {
 7154|      0|                    if (symlink_changed) {
 7155|      0|                        if (uid == 4294967295U) {
 7156|      0|                            goto _L___5;
 7157|      0|                        }
 7158|      0|                        else {
 7159|      0|                            if (uid == (uid_t)file_stats->st_uid) {
 7160|      0|_L___5:
 7161|      0|                                if (gid == 4294967295U) {
 7162|      0|                                    tmp___37 = 0;
 7163|      0|                                }
 7164|      0|                                else {
 7165|      0|                                    if (gid == (gid_t)file_stats->st_gid) {
 7166|      0|                                        tmp___37 = 0;
 7167|      0|                                    }
 7168|      0|                                    else {
 7169|      0|                                        tmp___37 = 1;
 7170|      0|                                    }
 7171|      0|                                }
 7172|      0|                            }
 7173|      0|                            else {
 7174|      0|                                tmp___37 = 1;
 7175|      0|                            }
 7176|      0|                        }
 7177|      0|                    }
 7178|      0|                    else {
 7179|      0|                        tmp___37 = 0;
 7180|      0|                    }
 7181|      0|                }
 7182|      0|                else {
 7183|      0|                    tmp___37 = 0;
 7184|      0|                }
 7185|      0|            }
 7186|      0|            else {
 7187|      0|                tmp___37 = 0;
 7188|      0|            }
 7189|      0|            changed = (_Bool)tmp___37;
 7190|      0|            if (changed) {
 7191|      0|                goto _L___6;
 7192|      0|            }
 7193|      0|            else {
 7194|      0|                if ((unsigned int const)chopt->verbosity == 0U) {
 7195|      0|_L___6:
 7196|      0|                    if (!ok) {
 7197|      0|                        tmp___40 = 3;
 7198|      0|                    }
 7199|      0|                    else {
 7200|      0|                        if (!symlink_changed) {
 7201|      0|                            tmp___39 = 1;
 7202|      0|                        }
 7203|      0|                        else {
 7204|      0|                            if (!changed) {
 7205|      0|                                tmp___38 = 4;
 7206|      0|                            }
 7207|      0|                            else {
 7208|      0|                                tmp___38 = 2;
 7209|      0|                            }
 7210|      0|                            tmp___39 = tmp___38;
 7211|      0|                        }
 7212|      0|                        tmp___40 = tmp___39;
 7213|      0|                    }
 7214|      0|                    ch_status = (enum Change_status)tmp___40;
 7215|      0|                    describe_change(file_full_name, ch_status,
 7216|      0|                                    (char const *)chopt->user_name,
 7217|      0|                                    (char const *)chopt->group_name);
 7218|      0|                }
 7219|      0|            }
 7220|      0|        }
 7221|      6|        if (!chopt->recurse) {
 7222|      0|            fts_set(fts, ent, 4);
 7223|      0|        }
 7224|      6|        return (ok);
 7225|      6|    }
 7226|      6|}
 7227|       |extern _Bool chown_files(char **files, int bit_flags, uid_t uid, gid_t gid,
 7228|       |                         uid_t required_uid, gid_t required_gid,
 7229|       |                         struct Chown_option const *chopt)
 7230|      2|{
 7231|      2|    _Bool ok;
 7232|      2|    int stat_flags;
 7233|      2|    int tmp;
 7234|      2|    FTS *fts;
 7235|      2|    FTS *tmp___0;
 7236|      2|    FTSENT *ent;
 7237|      2|    char *tmp___1;
 7238|      2|    int *tmp___2;
 7239|      2|    int *tmp___3;
 7240|      2|    _Bool tmp___4;
 7241|      2|    char *tmp___5;
 7242|      2|    int *tmp___6;
 7243|      2|    int tmp___7;
 7244|       |
 7245|      2|    {
 7246|      2|        ok = (_Bool)1;
 7247|      2|        if (required_uid != 4294967295U) {
 7248|      0|            tmp = 0;
 7249|      0|        }
 7250|      2|        else {
 7251|      2|            if (required_gid != 4294967295U) {
 7252|      0|                tmp = 0;
 7253|      0|            }
 7254|      2|            else {
 7255|      2|                if (chopt->affect_symlink_referent) {
 7256|      0|                    tmp = 0;
 7257|      0|                }
 7258|      2|                else {
 7259|      2|                    if ((unsigned int const)chopt->verbosity != 2U) {
 7260|      0|                        tmp = 0;
 7261|      0|                    }
 7262|      2|                    else {
 7263|      2|                        tmp = 8;
 7264|      2|                    }
 7265|      2|                }
 7266|      2|            }
 7267|      2|        }
 7268|      2|        stat_flags = tmp;
 7269|      2|        tmp___0 = xfts_open((char *const *)files, bit_flags | stat_flags,
 7270|      2|                            (int (*)(FTSENT const **, FTSENT const **))((void *)0));
 7271|      2|        fts = tmp___0;
 7272|     10|        while (1) {
 7273|     10|            ent = fts_read(fts);
 7274|     10|            if ((unsigned long)ent == (unsigned long)((void *)0)) {
 7275|      2|                tmp___3 = __errno_location();
 7276|      2|                if (*tmp___3 != 0) {
 7277|      0|                    if (!chopt->force_silent) {
 7278|      0|                        tmp___1 = gettext("fts_read failed");
 7279|      0|                        tmp___2 = __errno_location();
 7280|      0|                        error(0, *tmp___2, (char const *)tmp___1);
 7281|      0|                    }
 7282|      0|                    ok = (_Bool)0;
 7283|      0|                }
 7284|      2|                goto while_break;
 7285|      2|            }
 7286|      8|            tmp___4 = change_file_owner(fts, ent, uid, gid, required_uid,
 7287|      8|                                        required_gid, chopt);
 7288|      8|            ok = (_Bool)((int)ok & (int)tmp___4);
 7289|      8|        }
 7290|      2|while_break:
 7291|      2|        tmp___7 = fts_close(fts);
 7292|      2|        if (tmp___7 != 0) {
 7293|      0|            tmp___5 = gettext("fts_close failed");
 7294|      0|            tmp___6 = __errno_location();
 7295|      0|            error(0, *tmp___6, (char const *)tmp___5);
 7296|      0|            ok = (_Bool)0;
 7297|      0|        }
 7298|      2|        return (ok);
 7299|      2|    }
 7300|      2|}
 7301|       |extern char *optarg;
 7302|       |extern __attribute__((__nothrow__)) int(
 7303|       |    __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void));
 7304|       |extern __attribute__((__nothrow__)) char *(
 7305|       |    __attribute__((__leaf__)) textdomain)(char const *__domainname);
 7306|       |extern __attribute__((__nothrow__)) char *(__attribute__((
 7307|       |            __leaf__)) bindtextdomain)(char const *__domainname, char const *__dirname);
 7308|       |__inline static void emit_ancillary_info(void)
 7309|      0|{
 7310|      0|    char *tmp;
 7311|      0|    char *tmp___0;
 7312|      0|    char *tmp___1;
 7313|      0|    char *tmp___2;
 7314|      0|    char const *lc_messages;
 7315|      0|    char const *tmp___3;
 7316|      0|    char *tmp___4;
 7317|      0|    char *tmp___5;
 7318|      0|    int tmp___6;
 7319|      0|    char *tmp___7;
 7320|      0|    char *tmp___8;
 7321|       |
 7322|      0|    {
 7323|      0|        tmp = last_component(program_name);
 7324|      0|        tmp___0 = gettext("\nReport %s bugs to %s\n");
 7325|      0|        printf((char const *)tmp___0, tmp, "bug-coreutils@gnu.org");
 7326|      0|        tmp___1 = gettext("%s home page: <http://www.gnu.org/software/%s/>\n");
 7327|      0|        printf((char const *)tmp___1, "GNU coreutils", "coreutils");
 7328|      0|        tmp___2 = gettext(
 7329|      0|                      "General help using GNU software: <http://www.gnu.org/gethelp/>\n");
 7330|      0|        fputs_unlocked((char const *)tmp___2, stdout);
 7331|      0|        tmp___3 = (char const *)setlocale(5, (char const *)((void *)0));
 7332|      0|        lc_messages = tmp___3;
 7333|      0|        if (lc_messages) {
 7334|      0|            tmp___6 = strncmp(lc_messages, "en_", (size_t)3);
 7335|      0|            if (tmp___6) {
 7336|      0|                tmp___4 = last_component(program_name);
 7337|      0|                tmp___5 = gettext("Report %s translation bugs to "
 7338|      0|                                  "<http://translationproject.org/team/>\n");
 7339|      0|                printf((char const *)tmp___5, tmp___4);
 7340|      0|            }
 7341|      0|        }
 7342|      0|        tmp___7 = last_component(program_name);
 7343|      0|        tmp___8 = gettext(
 7344|      0|                      "For complete documentation, run: info coreutils \'%s invocation\'\n");
 7345|      0|        printf((char const *)tmp___8, tmp___7);
 7346|      0|        return;
 7347|      0|    }
 7348|      0|}
 7349|       |__inline static char *bad_cast(char const *s)
 7350|      0|{
 7351|       |
 7352|      0|    {
 7353|      0|        return ((char *)s);
 7354|      0|    }
 7355|      0|}
 7356|       |static char *reference_file;
 7357|       |static struct option const long_options___1[14] = {
 7358|       |    {"recursive", 0, (int *)((void *)0), 'R'},
 7359|       |    {"changes", 0, (int *)((void *)0), 'c'},
 7360|       |    {"dereference", 0, (int *)((void *)0), 128},
 7361|       |    {"from", 1, (int *)((void *)0), 129},
 7362|       |    {"no-dereference", 0, (int *)((void *)0), 'h'},
 7363|       |    {"no-preserve-root", 0, (int *)((void *)0), 130},
 7364|       |    {"preserve-root", 0, (int *)((void *)0), 131},
 7365|       |    {"quiet", 0, (int *)((void *)0), 'f'},
 7366|       |    {"silent", 0, (int *)((void *)0), 'f'},
 7367|       |    {"reference", 1, (int *)((void *)0), 132},
 7368|       |    {"verbose", 0, (int *)((void *)0), 'v'},
 7369|       |    {"help", 0, (int *)((void *)0), -130},
 7370|       |    {"version", 0, (int *)((void *)0), -131},
 7371|       |    {(char const *)((void *)0), 0, (int *)((void *)0), 0}
 7372|       |};
 7373|       |__attribute__((__noreturn__)) void usage(int status);
 7374|       |void usage(int status)
 7375|      0|{
 7376|      0|    char *tmp;
 7377|      0|    char *tmp___0;
 7378|      0|    char *tmp___1;
 7379|      0|    char *tmp___2;
 7380|      0|    char *tmp___3;
 7381|      0|    char *tmp___4;
 7382|      0|    char *tmp___5;
 7383|      0|    char *tmp___6;
 7384|      0|    char *tmp___7;
 7385|      0|    char *tmp___8;
 7386|      0|    char *tmp___9;
 7387|      0|    char *tmp___10;
 7388|       |
 7389|      0|    {
 7390|      0|        if (status != 0) {
 7391|      0|            tmp = gettext("Try `%s --help\' for more information.\n");
 7392|      0|            fprintf(stderr, (char const *)tmp, program_name);
 7393|      0|        }
 7394|      0|        else {
 7395|      0|            tmp___0 = gettext("Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n  "
 7396|      0|                              "or:  %s [OPTION]... --reference=RFILE FILE...\n");
 7397|      0|            printf((char const *)tmp___0, program_name, program_name);
 7398|      0|            tmp___1 = gettext(
 7399|      0|                          "Change the owner and/or group of each FILE to OWNER and/or "
 7400|      0|                          "GROUP.\nWith --reference, change the owner and group of each FILE "
 7401|      0|                          "to those of RFILE.\n\n  -c, --changes          like verbose but "
 7402|      0|                          "report only when a change is made\n      --dereference      affect "
 7403|      0|                          "the referent of each symbolic link (this is\n                       "
 7404|      0|                          "  the default), rather than the symbolic link itself\n");
 7405|      0|            fputs_unlocked((char const *)tmp___1, stdout);
 7406|      0|            tmp___2 = gettext("  -h, --no-dereference   affect each symbolic link "
 7407|      0|                              "instead of any referenced\n                         "
 7408|      0|                              "file (useful only on systems that can change the\n    "
 7409|      0|                              "                     ownership of a symlink)\n");
 7410|      0|            fputs_unlocked((char const *)tmp___2, stdout);
 7411|      0|            tmp___3 =
 7412|      0|                gettext("      --from=CURRENT_OWNER:CURRENT_GROUP\n                  "
 7413|      0|                        "       change the owner and/or group of each file only if\n "
 7414|      0|                        "                        its current owner and/or group "
 7415|      0|                        "match those specified\n                         here.  "
 7416|      0|                        "Either may be omitted, in which case a match\n              "
 7417|      0|                        "           is not required for the omitted attribute.\n");
 7418|      0|            fputs_unlocked((char const *)tmp___3, stdout);
 7419|      0|            tmp___4 = gettext("      --no-preserve-root  do not treat `/\' specially "
 7420|      0|                              "(the default)\n      --preserve-root    fail to "
 7421|      0|                              "operate recursively on `/\'\n");
 7422|      0|            fputs_unlocked((char const *)tmp___4, stdout);
 7423|      0|            tmp___5 = gettext(
 7424|      0|                          "  -f, --silent, --quiet  suppress most error messages\n      "
 7425|      0|                          "--reference=RFILE  use RFILE\'s owner and group rather than\n       "
 7426|      0|                          "                  specifying OWNER:GROUP values\n  -R, --recursive  "
 7427|      0|                          "      operate on files and directories recursively\n  -v, --verbose "
 7428|      0|                          "         output a diagnostic for every file processed\n\n");
 7429|      0|            fputs_unlocked((char const *)tmp___5, stdout);
 7430|      0|            tmp___6 = gettext(
 7431|      0|                          "The following options modify how a hierarchy is traversed when the "
 7432|      0|                          "-R\noption is also specified.  If more than one is specified, only "
 7433|      0|                          "the final\none takes effect.\n\n  -H                     if a "
 7434|      0|                          "command line argument is a symbolic link\n                         "
 7435|      0|                          "to a directory, traverse it\n  -L                     traverse "
 7436|      0|                          "every symbolic link to a directory\n                         "
 7437|      0|                          "encountered\n  -P                     do not traverse any symbolic "
 7438|      0|                          "links (default)\n\n");
 7439|      0|            fputs_unlocked((char const *)tmp___6, stdout);
 7440|      0|            tmp___7 = gettext("      --help     display this help and exit\n");
 7441|      0|            fputs_unlocked((char const *)tmp___7, stdout);
 7442|      0|            tmp___8 =
 7443|      0|                gettext("      --version  output version information and exit\n");
 7444|      0|            fputs_unlocked((char const *)tmp___8, stdout);
 7445|      0|            tmp___9 = gettext("\nOwner is unchanged if missing.  Group is unchanged "
 7446|      0|                              "if missing, but changed\nto login group if implied by "
 7447|      0|                              "a `:\' following a symbolic OWNER.\nOWNER and GROUP "
 7448|      0|                              "may be numeric as well as symbolic.\n");
 7449|      0|            fputs_unlocked((char const *)tmp___9, stdout);
 7450|      0|            tmp___10 =
 7451|      0|                gettext("\nExamples:\n  %s root /u        Change the owner of /u to "
 7452|      0|                        "\"root\".\n  %s root:staff /u  Likewise, but also change "
 7453|      0|                        "its group to \"staff\".\n  %s -hR root /u    Change the "
 7454|      0|                        "owner of /u and subfiles to \"root\".\n");
 7455|      0|            printf((char const *)tmp___10, program_name, program_name, program_name);
 7456|      0|            emit_ancillary_info();
 7457|      0|        }
 7458|      0|        exit(status);
 7459|      0|    }
 7460|      0|}
 7461|       |static struct dev_ino dev_ino_buf;
 7462|       |int main(int argc, char **argv)
 7463|      2|{
 7464|      2|    _Bool preserve_root;
 7465|      2|    uid_t uid;
 7466|      2|    gid_t gid;
 7467|      2|    uid_t required_uid;
 7468|      2|    gid_t required_gid;
 7469|      2|    int bit_flags;
 7470|      2|    int dereference;
 7471|      2|    struct Chown_option chopt;
 7472|      2|    _Bool ok;
 7473|      2|    int optc;
 7474|      2|    char *u_dummy;
 7475|      2|    char *g_dummy;
 7476|      2|    char const *e;
 7477|      2|    char const *tmp;
 7478|      2|    char const *tmp___0;
 7479|      2|    char *tmp___1;
 7480|      2|    char *tmp___2;
 7481|      2|    char const *tmp___3;
 7482|      2|    char *tmp___4;
 7483|      2|    int tmp___5;
 7484|      2|    struct stat ref_stats;
 7485|      2|    char const *tmp___6;
 7486|      2|    char *tmp___7;
 7487|      2|    int *tmp___8;
 7488|      2|    int tmp___9;
 7489|      2|    char const *e___0;
 7490|      2|    char const *tmp___10;
 7491|      2|    char const *tmp___11;
 7492|      2|    char const *tmp___12;
 7493|      2|    char *tmp___13;
 7494|      2|    int *tmp___14;
 7495|      2|    int tmp___15;
 7496|       |
 7497|      2|    {
 7498|      2|        preserve_root = (_Bool)0;
 7499|      2|        uid = (uid_t)-1;
 7500|      2|        gid = (gid_t)-1;
 7501|      2|        required_uid = (uid_t)-1;
 7502|      2|        required_gid = (gid_t)-1;
 7503|      2|        bit_flags = 16;
 7504|      2|        dereference = -1;
 7505|      2|        set_program_name((char const *)*(argv + 0));
 7506|      2|        setlocale(6, "");
 7507|      2|        bindtextdomain("coreutils", "/usr/local/share/locale");
 7508|      2|        textdomain("coreutils");
 7509|      2|        atexit(&close_stdout);
 7510|      2|        chopt_init(&chopt);
 7511|      4|        while (1) {
 7512|      4|            optc = getopt_long(argc, (char *const *)argv, "HLPRcfhv",
 7513|      4|                               long_options___1, (int *)((void *)0));
 7514|      4|            if (!(optc != -1)) {
 7515|      2|                goto while_break;
 7516|      2|            }
 7517|      2|            if (optc == 72) {
 7518|      0|                goto case_72;
 7519|      0|            }
 7520|      2|            if (optc == 76) {
 7521|      0|                goto case_76;
 7522|      0|            }
 7523|      2|            if (optc == 80) {
 7524|      0|                goto case_80;
 7525|      0|            }
 7526|      2|            if (optc == 104) {
 7527|      0|                goto case_104;
 7528|      0|            }
 7529|      2|            if (optc == 128) {
 7530|      0|                goto case_128;
 7531|      0|            }
 7532|      2|            if (optc == 130) {
 7533|      0|                goto case_130;
 7534|      0|            }
 7535|      2|            if (optc == 131) {
 7536|      0|                goto case_131;
 7537|      0|            }
 7538|      2|            if (optc == 132) {
 7539|      0|                goto case_132;
 7540|      0|            }
 7541|      2|            if (optc == 129) {
 7542|      0|                goto case_129;
 7543|      0|            }
 7544|      2|            if (optc == 82) {
 7545|      2|                goto case_82;
 7546|      2|            }
 7547|      0|            if (optc == 99) {
 7548|      0|                goto case_99;
 7549|      0|            }
 7550|      0|            if (optc == 102) {
 7551|      0|                goto case_102;
 7552|      0|            }
 7553|      0|            if (optc == 118) {
 7554|      0|                goto case_118;
 7555|      0|            }
 7556|      0|            if (optc == -130) {
 7557|      0|                goto case_neg_130;
 7558|      0|            }
 7559|      0|            if (optc == -131) {
 7560|      0|                goto case_neg_131;
 7561|      0|            }
 7562|      0|            goto switch_default;
 7563|      0|case_72:
 7564|      0|            bit_flags = 17;
 7565|      0|            goto switch_break;
 7566|      0|case_76:
 7567|      0|            bit_flags = 2;
 7568|      0|            goto switch_break;
 7569|      0|case_80:
 7570|      0|            bit_flags = 16;
 7571|      0|            goto switch_break;
 7572|      0|case_104:
 7573|      0|            dereference = 0;
 7574|      0|            goto switch_break;
 7575|      0|case_128:
 7576|      0|            dereference = 1;
 7577|      0|            goto switch_break;
 7578|      0|case_130:
 7579|      0|            preserve_root = (_Bool)0;
 7580|      0|            goto switch_break;
 7581|      0|case_131:
 7582|      0|            preserve_root = (_Bool)1;
 7583|      0|            goto switch_break;
 7584|      0|case_132:
 7585|      0|            reference_file = optarg;
 7586|      0|            goto switch_break;
 7587|      0|case_129:
 7588|      0|            tmp = parse_user_spec((char const *)optarg, &required_uid, &required_gid,
 7589|      0|                                  &u_dummy, &g_dummy);
 7590|      0|            e = tmp;
 7591|      0|            if (e) {
 7592|      0|                tmp___0 = quote((char const *)optarg);
 7593|      0|                error(1, 0, "%s: %s", e, tmp___0);
 7594|      0|            }
 7595|      0|            goto switch_break;
 7596|      2|case_82:
 7597|      2|            chopt.recurse = (_Bool)1;
 7598|      2|            goto switch_break;
 7599|      0|case_99:
 7600|      0|            chopt.verbosity = (enum Verbosity)1;
 7601|      0|            goto switch_break;
 7602|      0|case_102:
 7603|      0|            chopt.force_silent = (_Bool)1;
 7604|      0|            goto switch_break;
 7605|      0|case_118:
 7606|      0|            chopt.verbosity = (enum Verbosity)0;
 7607|      0|            goto switch_break;
 7608|      0|case_neg_130:
 7609|      0|            usage(0);
 7610|      0|            goto switch_break;
 7611|      0|case_neg_131:
 7612|      0|            version_etc(stdout, "chown", "GNU coreutils", Version, "David MacKenzie",
 7613|      0|                        "Jim Meyering", (char *)((void *)0));
 7614|      0|            exit(0);
 7615|      0|            goto switch_break;
 7616|      0|switch_default:
 7617|      0|            usage(1);
 7618|      2|switch_break:
 7619|      2|            ;
 7620|      2|        }
 7621|      2|while_break:
 7622|      2|        ;
 7623|      2|        if (chopt.recurse) {
 7624|      2|            if (bit_flags == 16) {
 7625|      2|                if (dereference == 1) {
 7626|      0|                    tmp___1 = gettext("-R --dereference requires either -H or -L");
 7627|      0|                    error(1, 0, (char const *)tmp___1);
 7628|      0|                }
 7629|      2|                dereference = 0;
 7630|      2|            }
 7631|      2|        }
 7632|      0|        else {
 7633|      0|            bit_flags = 16;
 7634|      0|        }
 7635|      2|        chopt.affect_symlink_referent = (_Bool)(dereference != 0);
 7636|      2|        if (reference_file) {
 7637|      0|            tmp___5 = 1;
 7638|      0|        }
 7639|      2|        else {
 7640|      2|            tmp___5 = 2;
 7641|      2|        }
 7642|      2|        if (argc - optind < tmp___5) {
 7643|      0|            if (argc <= optind) {
 7644|      0|                tmp___2 = gettext("missing operand");
 7645|      0|                error(0, 0, (char const *)tmp___2);
 7646|      0|            }
 7647|      0|            else {
 7648|      0|                tmp___3 = quote((char const *)*(argv + (argc - 1)));
 7649|      0|                tmp___4 = gettext("missing operand after %s");
 7650|      0|                error(0, 0, (char const *)tmp___4, tmp___3);
 7651|      0|            }
 7652|      0|            usage(1);
 7653|      0|        }
 7654|      2|        if (reference_file) {
 7655|      0|            tmp___9 = stat((char const *)reference_file, &ref_stats);
 7656|      0|            if (tmp___9) {
 7657|      0|                tmp___6 = quote((char const *)reference_file);
 7658|      0|                tmp___7 = gettext("failed to get attributes of %s");
 7659|      0|                tmp___8 = __errno_location();
 7660|      0|                error(1, *tmp___8, (char const *)tmp___7, tmp___6);
 7661|      0|            }
 7662|      0|            uid = ref_stats.st_uid;
 7663|      0|            gid = ref_stats.st_gid;
 7664|      0|            chopt.user_name = uid_to_name(ref_stats.st_uid);
 7665|      0|            chopt.group_name = gid_to_name(ref_stats.st_gid);
 7666|      0|        }
 7667|      2|        else {
 7668|      2|            tmp___10 = parse_user_spec((char const *)*(argv + optind), &uid, &gid,
 7669|      2|                                       &chopt.user_name, &chopt.group_name);
 7670|      2|            e___0 = tmp___10;
 7671|      2|            if (e___0) {
 7672|      0|                tmp___11 = quote((char const *)*(argv + optind));
 7673|      0|                error(1, 0, "%s: %s", e___0, tmp___11);
 7674|      0|            }
 7675|      2|            if (!chopt.user_name) {
 7676|      0|                if (chopt.group_name) {
 7677|      0|                    chopt.user_name = bad_cast("");
 7678|      0|                }
 7679|      0|            }
 7680|      2|            optind++;
 7681|      2|        }
 7682|      2|        if (chopt.recurse) {
 7683|      2|            if (preserve_root) {
 7684|      0|                chopt.root_dev_ino = get_root_dev_ino(&dev_ino_buf);
 7685|      0|                if ((unsigned long)chopt.root_dev_ino == (unsigned long)((void *)0)) {
 7686|      0|                    tmp___12 = quote("/");
 7687|      0|                    tmp___13 = gettext("failed to get attributes of %s");
 7688|      0|                    tmp___14 = __errno_location();
 7689|      0|                    error(1, *tmp___14, (char const *)tmp___13, tmp___12);
 7690|      0|                }
 7691|      0|            }
 7692|      2|        }
 7693|      2|        bit_flags |= 1024;
 7694|      2|        ok = chown_files(argv + optind, bit_flags, uid, gid, required_uid,
 7695|      2|                         required_gid, (struct Chown_option const *)(&chopt));
 7696|      2|        chopt_free(&chopt);
 7697|      2|        if (ok) {
 7698|      2|            tmp___15 = 0;
 7699|      2|        }
 7700|      0|        else {
 7701|      0|            tmp___15 = 1;
 7702|      0|        }
 7703|      2|        exit(tmp___15);
 7704|      2|    }
 7705|      2|}


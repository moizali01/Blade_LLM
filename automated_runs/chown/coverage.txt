    1|       |
    2|       |typedef unsigned long size_t;
    3|       |typedef long __off_t;
    4|       |typedef long __off64_t;
    5|       |struct _IO_FILE;
    6|       |struct _IO_FILE;
    7|       |struct _IO_FILE;
    8|       |typedef struct _IO_FILE FILE;
    9|       |typedef void _IO_lock_t;
   10|       |struct _IO_marker {
   11|       |    struct _IO_marker *_next;
   12|       |    struct _IO_FILE *_sbuf;
   13|       |    int _pos;
   14|       |};
   15|       |struct _IO_FILE {
   16|       |    int _flags;
   17|       |    char *_IO_read_ptr;
   18|       |    char *_IO_read_end;
   19|       |    char *_IO_read_base;
   20|       |    char *_IO_write_base;
   21|       |    char *_IO_write_ptr;
   22|       |    char *_IO_write_end;
   23|       |    char *_IO_buf_base;
   24|       |    char *_IO_buf_end;
   25|       |    char *_IO_save_base;
   26|       |    char *_IO_backup_base;
   27|       |    char *_IO_save_end;
   28|       |    struct _IO_marker *_markers;
   29|       |    struct _IO_FILE *_chain;
   30|       |    int _fileno;
   31|       |    int _flags2;
   32|       |    __off_t _old_offset;
   33|       |    unsigned short _cur_column;
   34|       |    signed char _vtable_offset;
   35|       |    char _shortbuf[1];
   36|       |    _IO_lock_t *_lock;
   37|       |    __off64_t _offset;
   38|       |    void *__pad1;
   39|       |    void *__pad2;
   40|       |    void *__pad3;
   41|       |    void *__pad4;
   42|       |    size_t __pad5;
   43|       |    int _mode;
   44|       |    char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
   45|       |};
   46|       |typedef long __time_t;
   47|       |typedef unsigned long __dev_t;
   48|       |typedef unsigned int __uid_t;
   49|       |typedef unsigned int __gid_t;
   50|       |typedef unsigned long __ino_t;
   51|       |typedef unsigned int __mode_t;
   52|       |typedef unsigned long __nlink_t;
   53|       |typedef long __blksize_t;
   54|       |typedef long __blkcnt_t;
   55|       |typedef long __syscall_slong_t;
   56|       |typedef __mode_t mode_t;
   57|       |struct timespec {
   58|       |    __time_t tv_sec;
   59|       |    __syscall_slong_t tv_nsec;
   60|       |};
   61|       |struct stat {
   62|       |    __dev_t st_dev;
   63|       |    __ino_t st_ino;
   64|       |    __nlink_t st_nlink;
   65|       |    __mode_t st_mode;
   66|       |    __uid_t st_uid;
   67|       |    __gid_t st_gid;
   68|       |    int __pad0;
   69|       |    __dev_t st_rdev;
   70|       |    __off_t st_size;
   71|       |    __blksize_t st_blksize;
   72|       |    __blkcnt_t st_blocks;
   73|       |    struct timespec st_atim;
   74|       |    struct timespec st_mtim;
   75|       |    struct timespec st_ctim;
   76|       |    __syscall_slong_t __glibc_reserved[3];
   77|       |};
   78|       |typedef __ino_t ino_t;
   79|       |typedef __dev_t dev_t;
   80|       |struct hash_table;
   81|       |struct hash_table;
   82|       |struct hash_table;
   83|       |typedef struct hash_table Hash_table;
   84|       |struct F_triple {
   85|       |    char *name;
   86|       |    ino_t st_ino;
   87|       |    dev_t st_dev;
   88|       |};
   89|       |struct __dirstream;
   90|       |struct __dirstream;
   91|       |struct __dirstream;
   92|       |typedef struct __dirstream DIR;
   93|       |typedef int wchar_t;
   94|       |union __anonunion___value_4 {
   95|       |    unsigned int __wch;
   96|       |    char __wchb[4];
   97|       |};
   98|       |struct __anonstruct___mbstate_t_3 {
   99|       |    int __count;
  100|       |    union __anonunion___value_4 __value;
  101|       |};
  102|       |typedef struct __anonstruct___mbstate_t_3 __mbstate_t;
  103|       |typedef unsigned int wint_t;
  104|       |struct hash_tuning {
  105|       |    float shrink_threshold;
  106|       |    float shrink_factor;
  107|       |    float growth_threshold;
  108|       |    float growth_factor;
  109|       |    _Bool is_n_buckets;
  110|       |};
  111|       |typedef struct hash_tuning Hash_tuning;
  112|       |typedef __mbstate_t mbstate_t;
  113|       |struct mbchar {
  114|       |    char const *ptr;
  115|       |    size_t bytes;
  116|       |    _Bool wc_valid;
  117|       |    wchar_t wc;
  118|       |    char buf[24];
  119|       |};
  120|       |struct mbuiter_multi {
  121|       |    _Bool in_shift;
  122|       |    mbstate_t state;
  123|       |    _Bool next_done;
  124|       |    struct mbchar cur;
  125|       |};
  126|       |typedef struct mbuiter_multi mbui_iterator_t;
  127|       |typedef __gid_t gid_t;
  128|       |typedef __uid_t uid_t;
  129|       |typedef unsigned long uintmax_t;
  130|       |struct dev_ino {
  131|       |    ino_t st_ino;
  132|       |    dev_t st_dev;
  133|       |};
  134|       |struct cycle_check_state {
  135|       |    struct dev_ino dev_ino;
  136|       |    uintmax_t chdir_counter;
  137|       |    int magic;
  138|       |};
  139|       |typedef long ptrdiff_t;
  140|       |struct dirent {
  141|       |    __ino_t d_ino;
  142|       |    __off_t d_off;
  143|       |    unsigned short d_reclen;
  144|       |    unsigned char d_type;
  145|       |    char d_name[256];
  146|       |};
  147|       |typedef __builtin_va_list __gnuc_va_list;
  148|       |typedef __gnuc_va_list va_list;
  149|       |enum quoting_style {
  150|       |    literal_quoting_style = 0,
  151|       |    shell_quoting_style = 1,
  152|       |    shell_always_quoting_style = 2,
  153|       |    c_quoting_style = 3,
  154|       |    c_maybe_quoting_style = 4,
  155|       |    escape_quoting_style = 5,
  156|       |    locale_quoting_style = 6,
  157|       |    clocale_quoting_style = 7,
  158|       |    custom_quoting_style = 8
  159|       |};
  160|       |enum strtol_error {
  161|       |    LONGINT_OK = 0,
  162|       |    LONGINT_OVERFLOW = 1,
  163|       |    LONGINT_INVALID_SUFFIX_CHAR = 2,
  164|       |    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
  165|       |    LONGINT_INVALID = 4
  166|       |};
  167|       |typedef enum strtol_error strtol_error;
  168|       |struct option {
  169|       |    char const *name;
  170|       |    int has_arg;
  171|       |    int *flag;
  172|       |    int val;
  173|       |};
  174|       |typedef long intmax_t;
  175|       |typedef __nlink_t nlink_t;
  176|       |struct I_ring {
  177|       |    int ir_data[4];
  178|       |    int ir_default_val;
  179|       |    unsigned int ir_front;
  180|       |    unsigned int ir_back;
  181|       |    _Bool ir_empty;
  182|       |};
  183|       |typedef struct I_ring I_ring;
  184|       |struct _ftsent;
  185|       |struct _ftsent;
  186|       |struct _ftsent;
  187|       |union __anonunion_fts_cycle_29 {
  188|       |    struct hash_table *ht;
  189|       |    struct cycle_check_state *state;
  190|       |};
  191|       |struct __anonstruct_FTS_28 {
  192|       |    struct _ftsent *fts_cur;
  193|       |    struct _ftsent *fts_child;
  194|       |    struct _ftsent **fts_array;
  195|       |    dev_t fts_dev;
  196|       |    char *fts_path;
  197|       |    int fts_rfd;
  198|       |    int fts_cwd_fd;
  199|       |    size_t fts_pathlen;
  200|       |    size_t fts_nitems;
  201|       |    int (*fts_compar)(struct _ftsent const **, struct _ftsent const **);
  202|       |    int fts_options;
  203|       |    struct hash_table *fts_leaf_optimization_works_ht;
  204|       |    union __anonunion_fts_cycle_29 fts_cycle;
  205|       |    I_ring fts_fd_ring;
  206|       |};
  207|       |typedef struct __anonstruct_FTS_28 FTS;
  208|       |struct _ftsent {
  209|       |    struct _ftsent *fts_cycle;
  210|       |    struct _ftsent *fts_parent;
  211|       |    struct _ftsent *fts_link;
  212|       |    long fts_number;
  213|       |    void *fts_pointer;
  214|       |    char *fts_accpath;
  215|       |    char *fts_path;
  216|       |    int fts_errno;
  217|       |    int fts_symfd;
  218|       |    size_t fts_pathlen;
  219|       |    FTS *fts_fts;
  220|       |    ptrdiff_t fts_level;
  221|       |    size_t fts_namelen;
  222|       |    nlink_t fts_n_dirs_remaining;
  223|       |    unsigned short fts_info;
  224|       |    unsigned short fts_flags;
  225|       |    unsigned short fts_instr;
  226|       |    struct stat fts_statp[1];
  227|       |    char fts_name[1];
  228|       |};
  229|       |typedef struct _ftsent FTSENT;
  230|       |struct passwd {
  231|       |    char *pw_name;
  232|       |    char *pw_passwd;
  233|       |    __uid_t pw_uid;
  234|       |    __gid_t pw_gid;
  235|       |    char *pw_gecos;
  236|       |    char *pw_dir;
  237|       |    char *pw_shell;
  238|       |};
  239|       |struct group {
  240|       |    char *gr_name;
  241|       |    char *gr_passwd;
  242|       |    __gid_t gr_gid;
  243|       |    char **gr_mem;
  244|       |};
  245|       |typedef unsigned long reg_syntax_t;
  246|       |struct quoting_options;
  247|       |struct quoting_options;
  248|       |struct quoting_options;
  249|       |struct quoting_options {
  250|       |    enum quoting_style style;
  251|       |    int flags;
  252|       |    unsigned int quote_these_too[255UL / (sizeof(int) * 8UL) + 1UL];
  253|       |    char const *left_quote;
  254|       |    char const *right_quote;
  255|       |};
  256|       |struct slotvec {
  257|       |    size_t size;
  258|       |    char *val;
  259|       |};
  260|       |struct hash_entry {
  261|       |    void *data;
  262|       |    struct hash_entry *next;
  263|       |};
  264|       |struct hash_table {
  265|       |    struct hash_entry *bucket;
  266|       |    struct hash_entry const *bucket_limit;
  267|       |    size_t n_buckets;
  268|       |    size_t n_buckets_used;
  269|       |    size_t n_entries;
  270|       |    Hash_tuning const *tuning;
  271|       |    size_t (*hasher)(void const *, size_t);
  272|       |    _Bool (*comparator)(void const *, void const *);
  273|       |    void (*data_freer)(void *);
  274|       |    struct hash_entry *free_entry_list;
  275|       |};
  276|       |struct __anonstruct___fsid_t_1 {
  277|       |    int __val[2];
  278|       |};
  279|       |typedef struct __anonstruct___fsid_t_1 __fsid_t;
  280|       |typedef unsigned long __fsblkcnt_t;
  281|       |typedef unsigned long __fsfilcnt_t;
  282|       |typedef long __fsword_t;
  283|       |struct Active_dir {
  284|       |    dev_t dev;
  285|       |    ino_t ino;
  286|       |    FTSENT *fts_ent;
  287|       |};
  288|       |struct statfs {
  289|       |    __fsword_t f_type;
  290|       |    __fsword_t f_bsize;
  291|       |    __fsblkcnt_t f_blocks;
  292|       |    __fsblkcnt_t f_bfree;
  293|       |    __fsblkcnt_t f_bavail;
  294|       |    __fsfilcnt_t f_files;
  295|       |    __fsfilcnt_t f_ffree;
  296|       |    __fsid_t f_fsid;
  297|       |    __fsword_t f_namelen;
  298|       |    __fsword_t f_frsize;
  299|       |    __fsword_t f_flags;
  300|       |    __fsword_t f_spare[4];
  301|       |};
  302|       |struct LCO_ent {
  303|       |    dev_t st_dev;
  304|       |    _Bool opt_ok;
  305|       |};
  306|       |enum Change_status {
  307|       |    CH_NOT_APPLIED = 1,
  308|       |    CH_SUCCEEDED = 2,
  309|       |    CH_FAILED = 3,
  310|       |    CH_NO_CHANGE_REQUESTED = 4
  311|       |};
  312|       |enum Verbosity { V_high = 0, V_changes_only = 1, V_off = 2 };
  313|       |struct Chown_option {
  314|       |    enum Verbosity verbosity;
  315|       |    _Bool recurse;
  316|       |    struct dev_ino *root_dev_ino;
  317|       |    _Bool affect_symlink_referent;
  318|       |    _Bool force_silent;
  319|       |    char *user_name;
  320|       |    char *group_name;
  321|       |};
  322|       |enum RCH_status {
  323|       |    RC_ok = 2,
  324|       |    RC_excluded = 3,
  325|       |    RC_inode_changed = 4,
  326|       |    RC_do_ordinary_chown = 5,
  327|       |    RC_error = 6
  328|       |};
  329|       |extern __attribute__((__nothrow__)) int *(
  330|       |    __attribute__((__leaf__)) __errno_location)(void)__attribute__((__const__));
  331|       |extern int close(int __fd);
  332|       |extern int(__attribute__((__nonnull__(1))) open)(char const *__file,
  333|       |        int __oflag, ...);
  334|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) tolower)(
  335|       |    int __c);
  336|       |extern __attribute__((__nothrow__))
  337|       |size_t(__attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s)
  338|       |__attribute__((__pure__));
  339|       |extern int fclose(FILE *__stream);
  340|       |int dup_safer(int fd);
  341|       |extern __attribute__((__nothrow__)) int(__attribute__((
  342|       |        __nonnull__(1, 2), __leaf__)) strcmp)(char const *__s1, char const *__s2)
  343|       |__attribute__((__pure__));
  344|       |extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2),
  345|       |                                        __leaf__)) strncmp)(
  346|       |                                                char const *__s1, char const *__s2, size_t __n) __attribute__((__pure__));
  347|       |__attribute__((__noreturn__)) void xalloc_die(void);
  348|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__)) malloc)(
  349|       |    size_t __size) __attribute__((__malloc__));
  350|       |char *last_component(char const *name);
  351|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) gettext)(
  352|       |    char const *__msgid) __attribute__((__format_arg__(1)));
  353|       |void *hash_lookup(Hash_table const *table___0, void const *entry);
  354|       |void *(__attribute__((__warn_unused_result__)) hash_insert)(
  355|       |    Hash_table *table___0, void const *entry);
  356|       |void triple_free(void *x);
  357|       |void *xmalloc(size_t n) __attribute__((__malloc__));
  358|       |char *xstrdup(char const *string) __attribute__((__malloc__));
  359|       |extern DIR *fdopendir(int __fd);
  360|       |DIR *rpl_fdopendir(int fd);
  361|       |extern __attribute__((__nothrow__)) int(__attribute__((
  362|       |        __nonnull__(2), __leaf__)) fstat)(int __fd, struct stat *__buf);
  363|       |DIR *rpl_fdopendir(int fd)
  364|      3|{
  365|      3|    struct stat st;
  366|      3|    int tmp;
  367|      3|    int *tmp___0;
  368|      3|    DIR *tmp___1;
  369|       |
  370|      3|    {
  371|      3|        tmp = fstat(fd, &st);
  372|      3|        if (tmp) {
  373|      0|            return ((DIR *)((void *)0));
  374|      0|        }
  375|      3|        if (!((st.st_mode & 61440U) == 16384U)) {
  376|      0|            tmp___0 = __errno_location();
  377|      0|            *tmp___0 = 20;
  378|      0|            return ((DIR *)((void *)0));
  379|      0|        }
  380|      3|        tmp___1 = fdopendir(fd);
  381|      3|        return (tmp___1);
  382|      3|    }
  383|      3|}
  384|       |int fd_safer(int fd);
  385|       |int fd_safer(int fd)
  386|      3|{
  387|      3|    int f;
  388|      3|    int tmp;
  389|      3|    int e;
  390|      3|    int *tmp___0;
  391|      3|    int *tmp___1;
  392|       |
  393|      3|    {
  394|      3|        if (0 <= fd) {
  395|      3|            if (fd <= 2) {
  396|      0|                tmp = dup_safer(fd);
  397|      0|                f = tmp;
  398|      0|                tmp___0 = __errno_location();
  399|      0|                e = *tmp___0;
  400|      0|                close(fd);
  401|      0|                tmp___1 = __errno_location();
  402|      0|                *tmp___1 = e;
  403|      0|                fd = f;
  404|      0|            }
  405|      3|        }
  406|      3|        return (fd);
  407|      3|    }
  408|      3|}
  409|       |int volatile exit_failure;
  410|       |int volatile exit_failure = (int volatile)1;
  411|       |extern __attribute__((__nothrow__)) unsigned short const **(
  412|       |    __attribute__((__leaf__)) __ctype_b_loc)(void)__attribute__((__const__));
  413|       |extern __attribute__((__nothrow__)) int(
  414|       |    __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream);
  415|       |extern __attribute__((__nothrow__))
  416|       |size_t(__attribute__((__leaf__)) __ctype_get_mb_cur_max)(void);
  417|       |extern __attribute__((__nothrow__)) void(__attribute__((__leaf__)) free)(
  418|       |    void *__ptr);
  419|       |extern
  420|       |__attribute__((__nothrow__,
  421|       |               __noreturn__)) void(__attribute__((__leaf__)) abort)(void);
  422|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  423|       |            __nonnull__(1), __leaf__)) memset)(void *__s, int __c, size_t __n);
  424|       |extern __attribute__((__nothrow__)) char *(
  425|       |    __attribute__((__nonnull__(1), __leaf__)) strchr)(char const *__s, int __c)
  426|       |__attribute__((__pure__));
  427|       |extern __attribute__((__nothrow__)) char *(
  428|       |    __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const *__s, int __c)
  429|       |__attribute__((__pure__));
  430|       |int mbscasecmp(char const *s1, char const *s2);
  431|       |extern __attribute__((__nothrow__))
  432|       |wint_t(__attribute__((__leaf__)) towlower)(wint_t __wc);
  433|       |size_t hash_string(char const *string, size_t n_buckets);
  434|       |Hash_table *(__attribute__((__warn_unused_result__)) hash_initialize)(
  435|       |    size_t candidate, Hash_tuning const *tuning,
  436|       |    size_t (*hasher)(void const *, size_t),
  437|       |    _Bool (*comparator)(void const *, void const *),
  438|       |    void (*data_freer)(void *));
  439|       |void hash_free(Hash_table *table___0);
  440|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((
  441|       |            __leaf__)) __assert_fail)(char const *__assertion, char const *__file,
  442|       |                                      unsigned int __line, char const *__function);
  443|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) mbsinit)(
  444|       |    mbstate_t const *__ps) __attribute__((__pure__));
  445|       |extern __attribute__((__nothrow__)) size_t(__attribute__((__leaf__)) mbrtowc)(
  446|       |    wchar_t *__restrict __pwc, char const *__restrict __s, size_t __n,
  447|       |    mbstate_t *__restrict __p);
  448|       |unsigned int const is_basic_table[8];
  449|       |__inline static _Bool is_basic(char c)
  450|      0|{
  451|       |
  452|      0|    {
  453|      0|        return ((_Bool)((is_basic_table[(int)((unsigned char)c) >> 5] >>
  454|      0|                         ((int)((unsigned char)c) & 31)) &
  455|      0|                        1U));
  456|      0|    }
  457|      0|}
  458|       |size_t strnlen1(char const *string, size_t maxlen);
  459|       |__inline static void mbuiter_multi_next(struct mbuiter_multi *iter)
  460|      0|{
  461|      0|    int tmp;
  462|      0|    size_t tmp___0;
  463|      0|    size_t tmp___1;
  464|      0|    int tmp___2;
  465|      0|    _Bool tmp___3;
  466|       |
  467|      0|    {
  468|      0|        if (iter->next_done) {
  469|      0|            return;
  470|      0|        }
  471|      0|        if (iter->in_shift) {
  472|      0|            goto with_shift;
  473|      0|        }
  474|      0|        tmp___3 = is_basic((char)*(iter->cur.ptr));
  475|      0|        if (tmp___3) {
  476|      0|            iter->cur.bytes = (size_t)1;
  477|      0|            iter->cur.wc = (wchar_t) * (iter->cur.ptr);
  478|      0|            iter->cur.wc_valid = (_Bool)1;
  479|      0|        }
  480|      0|        else {
  481|      0|            tmp = mbsinit((mbstate_t const *)(&iter->state));
  482|      0|            if (!tmp) {
  483|      0|                __assert_fail("mbsinit (&iter->state)",
  484|      0|                              "/home/khheo/project/program-reduce/benchmark/"
  485|      0|                              "coreutils-8.2/lib/mbuiter.h",
  486|      0|                              142U, "mbuiter_multi_next");
  487|      0|            }
  488|      0|            iter->in_shift = (_Bool)1;
  489|      0|with_shift:
  490|      0|            tmp___0 = __ctype_get_mb_cur_max();
  491|      0|            tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
  492|      0|            iter->cur.bytes =
  493|      0|                mbrtowc(&iter->cur.wc, iter->cur.ptr, tmp___1, &iter->state);
  494|      0|            if (iter->cur.bytes == 0xffffffffffffffffUL) {
  495|      0|                iter->cur.bytes = (size_t)1;
  496|      0|                iter->cur.wc_valid = (_Bool)0;
  497|      0|            }
  498|      0|            else {
  499|      0|                if (iter->cur.bytes == 0xfffffffffffffffeUL) {
  500|      0|                    iter->cur.bytes = strlen(iter->cur.ptr);
  501|      0|                    iter->cur.wc_valid = (_Bool)0;
  502|      0|                }
  503|      0|                else {
  504|      0|                    if (iter->cur.bytes == 0UL) {
  505|      0|                        iter->cur.bytes = (size_t)1;
  506|      0|                        if (!((int const) * (iter->cur.ptr) == 0)) {
  507|      0|                            __assert_fail("*iter->cur.ptr == \'\\0\'",
  508|      0|                                          "/home/khheo/project/program-reduce/benchmark/"
  509|      0|                                          "coreutils-8.2/lib/mbuiter.h",
  510|      0|                                          170U, "mbuiter_multi_next");
  511|      0|                        }
  512|      0|                        if (!(iter->cur.wc == 0)) {
  513|      0|                            __assert_fail("iter->cur.wc == 0",
  514|      0|                                          "/home/khheo/project/program-reduce/benchmark/"
  515|      0|                                          "coreutils-8.2/lib/mbuiter.h",
  516|      0|                                          171U, "mbuiter_multi_next");
  517|      0|                        }
  518|      0|                    }
  519|      0|                    iter->cur.wc_valid = (_Bool)1;
  520|      0|                    tmp___2 = mbsinit((mbstate_t const *)(&iter->state));
  521|      0|                    if (tmp___2) {
  522|      0|                        iter->in_shift = (_Bool)0;
  523|      0|                    }
  524|      0|                }
  525|      0|            }
  526|      0|        }
  527|      0|        iter->next_done = (_Bool)1;
  528|      0|        return;
  529|      0|    }
  530|      0|}
  531|       |void *xrealloc(void *p, size_t n);
  532|       |extern int fcntl(int __fd, int __cmd, ...);
  533|       |int dup_safer(int fd)
  534|      3|{
  535|      3|    int tmp;
  536|       |
  537|      3|    {
  538|      3|        tmp = fcntl(fd, 0, 3);
  539|      3|        return (tmp);
  540|      3|    }
  541|      3|}
  542|       |extern __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1, 2),
  543|       |        __leaf__)) memcpy)(
  544|       |            void *__restrict __dest, void const *__restrict __src, size_t __n);
  545|       |extern __attribute__((__nothrow__)) int(__attribute__((
  546|       |        __nonnull__(1, 2), __leaf__)) stat)(char const *__restrict __file,
  547|       |                struct stat *__restrict __buf);
  548|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) fchown)(
  549|       |    int __fd, __uid_t __owner, __gid_t __group);
  550|       |char const diacrit_base[256];
  551|       |char const diacrit_diac[256];
  552|       |char const diacrit_base[256] = {
  553|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  554|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  555|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  556|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  557|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  558|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  559|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  560|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  561|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  562|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  563|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  564|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  565|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  566|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  567|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  568|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  569|       |    (char const)0,   (char const)'A', (char const)'B', (char const)'C',
  570|       |    (char const)'D', (char const)'E', (char const)'F', (char const)'G',
  571|       |    (char const)'H', (char const)'I', (char const)'J', (char const)'K',
  572|       |    (char const)'L', (char const)'M', (char const)'N', (char const)'O',
  573|       |    (char const)'P', (char const)'Q', (char const)'R', (char const)'S',
  574|       |    (char const)'T', (char const)'U', (char const)'V', (char const)'W',
  575|       |    (char const)'X', (char const)'Y', (char const)'Z', (char const)0,
  576|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  577|       |    (char const)0,   (char const)'a', (char const)'b', (char const)'c',
  578|       |    (char const)'d', (char const)'e', (char const)'f', (char const)'g',
  579|       |    (char const)'h', (char const)'i', (char const)'j', (char const)'k',
  580|       |    (char const)'l', (char const)'m', (char const)'n', (char const)'o',
  581|       |    (char const)'p', (char const)'q', (char const)'r', (char const)'s',
  582|       |    (char const)'t', (char const)'u', (char const)'v', (char const)'w',
  583|       |    (char const)'x', (char const)'y', (char const)'z', (char const)0,
  584|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  585|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  586|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  587|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  588|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  589|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  590|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  591|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  592|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  593|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  594|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  595|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  596|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  597|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  598|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  599|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  600|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  601|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'A',
  602|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'C',
  603|       |    (char const)'E', (char const)'E', (char const)'E', (char const)'E',
  604|       |    (char const)'I', (char const)'I', (char const)'I', (char const)'I',
  605|       |    (char const)0,   (char const)'N', (char const)'O', (char const)'O',
  606|       |    (char const)'O', (char const)'O', (char const)'O', (char const)0,
  607|       |    (char const)'O', (char const)'U', (char const)'U', (char const)'U',
  608|       |    (char const)'U', (char const)'Y', (char const)0,   (char const)0,
  609|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'a',
  610|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'c',
  611|       |    (char const)'e', (char const)'e', (char const)'e', (char const)'e',
  612|       |    (char const)'i', (char const)'i', (char const)'i', (char const)'i',
  613|       |    (char const)0,   (char const)'n', (char const)'o', (char const)'o',
  614|       |    (char const)'o', (char const)'o', (char const)'o', (char const)0,
  615|       |    (char const)'o', (char const)'u', (char const)'u', (char const)'u',
  616|       |    (char const)'u', (char const)'y', (char const)0,   (char const)'y'
  617|       |};
  618|       |char const diacrit_diac[256] = {
  619|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  620|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  621|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  622|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  623|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  624|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  625|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  626|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  627|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  628|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  629|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  630|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  631|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  632|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  633|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  634|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  635|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  636|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  637|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)4,
  638|       |    (char const)0, (char const)3, (char const)0, (char const)0, (char const)0,
  639|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  640|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  641|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  642|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  643|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  644|       |    (char const)0, (char const)6, (char const)0, (char const)0, (char const)0,
  645|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  646|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  647|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  648|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  649|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  650|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  651|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  652|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  653|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  654|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  655|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  656|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  657|       |    (char const)0, (char const)0, (char const)3, (char const)2, (char const)4,
  658|       |    (char const)6, (char const)5, (char const)8, (char const)1, (char const)7,
  659|       |    (char const)3, (char const)2, (char const)4, (char const)5, (char const)3,
  660|       |    (char const)2, (char const)4, (char const)5, (char const)0, (char const)6,
  661|       |    (char const)3, (char const)2, (char const)4, (char const)6, (char const)5,
  662|       |    (char const)0, (char const)9, (char const)3, (char const)2, (char const)4,
  663|       |    (char const)5, (char const)2, (char const)0, (char const)0, (char const)3,
  664|       |    (char const)2, (char const)4, (char const)6, (char const)5, (char const)8,
  665|       |    (char const)1, (char const)7, (char const)3, (char const)2, (char const)4,
  666|       |    (char const)5, (char const)3, (char const)2, (char const)4, (char const)5,
  667|       |    (char const)0, (char const)6, (char const)3, (char const)2, (char const)4,
  668|       |    (char const)6, (char const)5, (char const)0, (char const)9, (char const)3,
  669|       |    (char const)2, (char const)4, (char const)5, (char const)2, (char const)0,
  670|       |    (char const)0
  671|       |};
  672|       |void cycle_check_init(struct cycle_check_state *state);
  673|       |_Bool cycle_check(struct cycle_check_state *state, struct stat const *sb);
  674|       |__inline static _Bool is_zero_or_power_of_two(uintmax_t i)
  675|      3|{
  676|       |
  677|      3|    {
  678|      3|        return ((_Bool)((i & (i - 1UL)) == 0UL));
  679|      3|    }
  680|      3|}
  681|       |void cycle_check_init(struct cycle_check_state *state)
  682|      2|{
  683|       |
  684|      2|    {
  685|      2|        state->chdir_counter = (uintmax_t)0;
  686|      2|        state->magic = 9827862;
  687|      2|        return;
  688|      2|    }
  689|      2|}
  690|       |_Bool cycle_check(struct cycle_check_state *state, struct stat const *sb)
  691|      3|{
  692|      3|    _Bool tmp;
  693|       |
  694|      3|    {
  695|      3|        if (!(state->magic == 9827862)) {
  696|      0|            __assert_fail("state->magic == 9827862",
  697|      0|                          "/home/khheo/project/program-reduce/benchmark/"
  698|      0|                          "coreutils-8.2/lib/cycle-check.c",
  699|      0|                          60U, "cycle_check");
  700|      0|        }
  701|      3|        if (state->chdir_counter) {
  702|      2|            if (sb->st_ino == (__ino_t const)state->dev_ino.st_ino) {
  703|      0|                if (sb->st_dev == (__dev_t const)state->dev_ino.st_dev) {
  704|      0|                    return ((_Bool)1);
  705|      0|                }
  706|      0|            }
  707|      2|        }
  708|      3|        (state->chdir_counter)++;
  709|      3|        tmp = is_zero_or_power_of_two(state->chdir_counter);
  710|      3|        if (tmp) {
  711|      2|            if (state->chdir_counter == 0UL) {
  712|      0|                return ((_Bool)1);
  713|      0|            }
  714|      2|            state->dev_ino.st_dev = (dev_t)sb->st_dev;
  715|      2|            state->dev_ino.st_ino = (ino_t)sb->st_ino;
  716|      2|        }
  717|      3|        return ((_Bool)0);
  718|      3|    }
  719|      3|}
  720|       |extern void error(int __status, int __errnum, char const *__format, ...);
  721|       |char const *quote(char const *name);
  722|       |void close_stdout(void);
  723|       |extern struct _IO_FILE *stdout;
  724|       |extern struct _IO_FILE *stderr;
  725|       |extern __attribute__((__noreturn__)) void _exit(int __status);
  726|       |int close_stream(FILE *stream);
  727|       |char *quotearg_colon(char const *arg);
  728|       |static char const *file_name;
  729|       |static _Bool ignore_EPIPE;
  730|       |void close_stdout(void)
  731|      1|{
  732|      1|    char const *write_error;
  733|      1|    char const *tmp;
  734|      1|    char *tmp___0;
  735|      1|    int *tmp___1;
  736|      1|    int *tmp___2;
  737|      1|    int tmp___3;
  738|      1|    int *tmp___4;
  739|      1|    int tmp___5;
  740|       |
  741|      1|    {
  742|      1|        tmp___3 = close_stream(stdout);
  743|      1|        if (tmp___3 != 0) {
  744|      0|            if (ignore_EPIPE) {
  745|      0|                tmp___4 = __errno_location();
  746|      0|                if (!(*tmp___4 == 32)) {
  747|      0|                    goto _L;
  748|      0|                }
  749|      0|            }
  750|      0|            else {
  751|      0|_L:
  752|      0|                tmp = (char const *)gettext("write error");
  753|      0|                write_error = tmp;
  754|      0|                if (file_name) {
  755|      0|                    tmp___0 = quotearg_colon(file_name);
  756|      0|                    tmp___1 = __errno_location();
  757|      0|                    error(0, *tmp___1, "%s: %s", tmp___0, write_error);
  758|      0|                }
  759|      0|                else {
  760|      0|                    tmp___2 = __errno_location();
  761|      0|                    error(0, *tmp___2, "%s", write_error);
  762|      0|                }
  763|      0|                _exit((int)exit_failure);
  764|      0|            }
  765|      0|        }
  766|      1|        tmp___5 = close_stream(stderr);
  767|      1|        if (tmp___5 != 0) {
  768|      0|            _exit((int)exit_failure);
  769|      0|        }
  770|      1|        return;
  771|      1|    }
  772|      1|}
  773|       |extern __attribute__((__nothrow__))
  774|       |size_t(__attribute__((__leaf__)) __fpending)(FILE *__fp);
  775|       |int close_stream(FILE *stream)
  776|      2|{
  777|      2|    _Bool some_pending;
  778|      2|    size_t tmp;
  779|      2|    _Bool prev_fail;
  780|      2|    int tmp___0;
  781|      2|    _Bool fclose_fail;
  782|      2|    int tmp___1;
  783|      2|    int *tmp___2;
  784|      2|    int *tmp___3;
  785|       |
  786|      2|    {
  787|      2|        tmp = __fpending(stream);
  788|      2|        some_pending = (_Bool)(tmp != 0UL);
  789|      2|        tmp___0 = ferror_unlocked(stream);
  790|      2|        prev_fail = (_Bool)(tmp___0 != 0);
  791|      2|        tmp___1 = fclose(stream);
  792|      2|        fclose_fail = (_Bool)(tmp___1 != 0);
  793|      2|        if (prev_fail) {
  794|      0|            goto _L___0;
  795|      0|        }
  796|      2|        else {
  797|      2|            if (fclose_fail) {
  798|      0|                if (some_pending) {
  799|      0|                    goto _L___0;
  800|      0|                }
  801|      0|                else {
  802|      0|                    tmp___3 = __errno_location();
  803|      0|                    if (*tmp___3 != 9) {
  804|      0|_L___0:
  805|      0|                        if (!fclose_fail) {
  806|      0|                            tmp___2 = __errno_location();
  807|      0|                            *tmp___2 = 0;
  808|      0|                        }
  809|      0|                        return (-1);
  810|      0|                    }
  811|      0|                }
  812|      0|            }
  813|      2|        }
  814|      2|        return (0);
  815|      2|    }
  816|      2|}
  817|       |int set_cloexec_flag(int desc, _Bool value);
  818|       |int set_cloexec_flag(int desc, _Bool value)
  819|      6|{
  820|      6|    int flags;
  821|      6|    int tmp;
  822|      6|    int newflags;
  823|      6|    int tmp___0;
  824|      6|    int tmp___1;
  825|       |
  826|      6|    {
  827|      6|        tmp = fcntl(desc, 1, 0);
  828|      6|        flags = tmp;
  829|      6|        if (0 <= flags) {
  830|      6|            if (value) {
  831|      6|                tmp___0 = flags | 1;
  832|      6|            }
  833|      0|            else {
  834|      0|                tmp___0 = flags & -2;
  835|      0|            }
  836|      6|            newflags = tmp___0;
  837|      6|            if (flags == newflags) {
  838|      0|                return (0);
  839|      0|            }
  840|      6|            else {
  841|      6|                tmp___1 = fcntl(desc, 2, newflags);
  842|      6|                if (tmp___1 != -1) {
  843|      6|                    return (0);
  844|      6|                }
  845|      6|            }
  846|      6|        }
  847|      0|        return (-1);
  848|      6|    }
  849|      6|}
  850|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) fchdir)(
  851|       |    int __fd);
  852|       |extern int(__attribute__((__nonnull__(2))) openat)(int __fd, char const *__file,
  853|       |        int __oflag, ...);
  854|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  855|       |            __nonnull__(1), __leaf__)) memchr)(void const *__s, int __c, size_t __n)
  856|       |__attribute__((__pure__));
  857|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  858|       |            __nonnull__(1, 2), __leaf__)) memmove)(void *__dest, void const *__src,
  859|       |                    size_t __n);
  860|       |extern __attribute__((__nothrow__)) int(__attribute__((
  861|       |        __nonnull__(1, 2), __leaf__)) lstat)(char const *__restrict __file,
  862|       |                struct stat *__restrict __buf);
  863|       |size_t triple_hash(void const *x, size_t table_size);
  864|       |_Bool triple_compare_ino_str(void const *x, void const *y);
  865|       |char *last_component(char const *name)
  866|      0|{
  867|      0|    char const *base;
  868|      0|    char const *p;
  869|      0|    _Bool saw_slash;
  870|       |
  871|      0|    {
  872|      0|        base = name + 0;
  873|      0|        saw_slash = (_Bool)0;
  874|      0|        while (1) {
  875|       |
  876|      0|            if (!((int const) * base == 47)) {
  877|      0|                goto while_break;
  878|      0|            }
  879|      0|            base++;
  880|      0|        }
  881|      0|while_break:
  882|      0|        p = base;
  883|      0|        while (1) {
  884|       |
  885|      0|            if (!*p) {
  886|      0|                goto while_break___0;
  887|      0|            }
  888|      0|            if ((int const) * p == 47) {
  889|      0|                saw_slash = (_Bool)1;
  890|      0|            }
  891|      0|            else {
  892|      0|                if (saw_slash) {
  893|      0|                    base = p;
  894|      0|                    saw_slash = (_Bool)0;
  895|      0|                }
  896|      0|            }
  897|      0|            p++;
  898|      0|        }
  899|      0|while_break___0:
  900|      0|        ;
  901|      0|        return ((char *)base);
  902|      0|    }
  903|      0|}
  904|       |char const *simple_backup_suffix;
  905|       |void (*argmatch_die)(void);
  906|       |extern __attribute__((__nothrow__)) int(__attribute__((
  907|       |        __nonnull__(1, 2), __leaf__)) memcmp)(void const *__s1, void const *__s2,
  908|       |                size_t __n) __attribute__((__pure__));
  909|       |extern int(__attribute__((__nonnull__(1))) closedir)(DIR *__dirp);
  910|       |extern struct dirent *(__attribute__((__nonnull__(1))) readdir)(DIR *__dirp);
  911|       |DIR *opendir_safer(char const *name);
  912|       |char const *simple_backup_suffix = "~";
  913|       |extern int fprintf(FILE *__restrict __stream, char const *__restrict __format,
  914|       |                   ...);
  915|       |char *quotearg_n_style(int n, enum quoting_style s, char const *arg);
  916|       |char const *quote_n(int n, char const *name);
  917|       |__attribute__((__noreturn__)) void usage(int status);
  918|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  919|       |            __warn_unused_result__, __leaf__)) realloc)(void *__ptr, size_t __size);
  920|       |__inline static void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__));
  921|       |__inline static void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__));
  922|       |__inline static void *xnmalloc(size_t n, size_t s)
  923|      0|{
  924|      0|    int tmp;
  925|      0|    void *tmp___0;
  926|      0|
  927|      0|    {
  928|      0|        if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
  929|      0|            tmp = -1;
  930|      0|        }
  931|      0|        else {
  932|      0|            tmp = -2;
  933|      0|        }
  934|      0|        if ((size_t)tmp / s < n) {
  935|      0|            xalloc_die();
  936|      0|        }
  937|      0|        tmp___0 = xmalloc(n * s);
  938|      0|        return (tmp___0);
  939|      0|    }
  940|      0|}
  941|       |strtol_error xstrtoul(char const *s, char **ptr, int strtol_base,
  942|       |                      unsigned long *val, char const *valid_suffixes);
  943|       |extern __attribute__((__nothrow__)) unsigned long(__attribute__((
  944|       |            __nonnull__(1), __leaf__)) strtoul)(char const *__restrict __nptr,
  945|       |                    char **__restrict __endptr, int __base);
  946|       |static strtol_error bkm_scale___0(unsigned long *x, int scale_factor)
  947|      0|{
  948|       |
  949|      0|    {
  950|      0|        if (0xffffffffffffffffUL / (unsigned long)scale_factor < *x) {
  951|      0|            *x = 0xffffffffffffffffUL;
  952|      0|            return ((strtol_error)1);
  953|      0|        }
  954|      0|        *x *= (unsigned long)scale_factor;
  955|      0|        return ((strtol_error)0);
  956|      0|    }
  957|      0|}
  958|       |static strtol_error bkm_scale_by_power___0(unsigned long *x, int base,
  959|       |        int power)
  960|      0|{
  961|      0|    strtol_error err;
  962|      0|    strtol_error tmp;
  963|      0|    int tmp___0;
  964|       |
  965|      0|    {
  966|      0|        err = (strtol_error)0;
  967|      0|        while (1) {
  968|      0|            tmp___0 = power;
  969|      0|            power--;
  970|      0|            if (!tmp___0) {
  971|      0|                goto while_break;
  972|      0|            }
  973|      0|            tmp = bkm_scale___0(x, base);
  974|      0|            err = (strtol_error)((unsigned int)err | (unsigned int)tmp);
  975|      0|        }
  976|      0|while_break:
  977|      0|        ;
  978|      0|        return (err);
  979|      0|    }
  980|      0|}
  981|       |strtol_error xstrtoul(char const *s, char **ptr, int strtol_base,
  982|       |                      unsigned long *val, char const *valid_suffixes)
  983|      0|{
  984|      0|    char *t_ptr;
  985|      0|    char **p;
  986|      0|    unsigned long tmp;
  987|      0|    strtol_error err;
  988|      0|    char const *q;
  989|      0|    unsigned char ch;
  990|      0|    unsigned short const **tmp___0;
  991|      0|    int *tmp___1;
  992|      0|    char *tmp___2;
  993|      0|    int *tmp___3;
  994|      0|    int *tmp___4;
  995|      0|    int base;
  996|      0|    int suffixes;
  997|      0|    strtol_error overflow;
  998|      0|    char *tmp___5;
  999|      0|    char *tmp___6;
 1000|       |
 1001|      0|    {
 1002|      0|        err = (strtol_error)0;
 1003|      0|        if (0 <= strtol_base) {
 1004|      0|            if (!(strtol_base <= 36)) {
 1005|      0|                __assert_fail("0 <= strtol_base && strtol_base <= 36",
 1006|      0|                              "/home/khheo/project/program-reduce/benchmark/"
 1007|      0|                              "coreutils-8.2/lib/xstrtol.c",
 1008|      0|                              83U, "xstrtoul");
 1009|      0|            }
 1010|      0|        }
 1011|      0|        else {
 1012|      0|            __assert_fail("0 <= strtol_base && strtol_base <= 36",
 1013|      0|                          "/home/khheo/project/program-reduce/benchmark/"
 1014|      0|                          "coreutils-8.2/lib/xstrtol.c",
 1015|      0|                          83U, "xstrtoul");
 1016|      0|        }
 1017|      0|        if (ptr) {
 1018|      0|            p = ptr;
 1019|      0|        }
 1020|      0|        else {
 1021|      0|            p = &t_ptr;
 1022|      0|        }
 1023|      0|        q = s;
 1024|      0|        ch = (unsigned char)*q;
 1025|      0|        while (1) {
 1026|      0|            tmp___0 = __ctype_b_loc();
 1027|      0|            if (!((int const) * (*tmp___0 + (int)ch) & 8192)) {
 1028|      0|                goto while_break;
 1029|      0|            }
 1030|      0|            q++;
 1031|      0|            ch = (unsigned char)*q;
 1032|      0|        }
 1033|      0|while_break:
 1034|      0|        ;
 1035|      0|        if ((int)ch == 45) {
 1036|      0|            return ((strtol_error)4);
 1037|      0|        }
 1038|      0|        tmp___1 = __errno_location();
 1039|      0|        *tmp___1 = 0;
 1040|      0|        tmp = strtoul(s, p, strtol_base);
 1041|      0|        if ((unsigned long)*p == (unsigned long)s) {
 1042|      0|            if (valid_suffixes) {
 1043|      0|                if (*(*p)) {
 1044|      0|                    tmp___2 = strchr(valid_suffixes, (int)*(*p));
 1045|      0|                    if (tmp___2) {
 1046|      0|                        tmp = 1UL;
 1047|      0|                    }
 1048|      0|                    else {
 1049|      0|                        return ((strtol_error)4);
 1050|      0|                    }
 1051|      0|                }
 1052|      0|                else {
 1053|      0|                    return ((strtol_error)4);
 1054|      0|                }
 1055|      0|            }
 1056|      0|            else {
 1057|      0|                return ((strtol_error)4);
 1058|      0|            }
 1059|      0|        }
 1060|      0|        else {
 1061|      0|            tmp___4 = __errno_location();
 1062|      0|            if (*tmp___4 != 0) {
 1063|      0|                tmp___3 = __errno_location();
 1064|      0|                if (*tmp___3 != 34) {
 1065|      0|                    return ((strtol_error)4);
 1066|      0|                }
 1067|      0|                err = (strtol_error)1;
 1068|      0|            }
 1069|      0|        }
 1070|      0|        if (!valid_suffixes) {
 1071|      0|            *val = tmp;
 1072|      0|            return (err);
 1073|      0|        }
 1074|      0|        if ((int)*(*p) != 0) {
 1075|      0|            base = 1024;
 1076|      0|            suffixes = 1;
 1077|      0|            tmp___5 = strchr(valid_suffixes, (int)*(*p));
 1078|      0|            if (!tmp___5) {
 1079|      0|                *val = tmp;
 1080|      0|                return ((strtol_error)((unsigned int)err | 2U));
 1081|      0|            }
 1082|      0|            tmp___6 = strchr(valid_suffixes, '0');
 1083|      0|            if (tmp___6) {
 1084|      0|                if ((int)*(*(p + 0) + 1) == 105) {
 1085|      0|                    goto case_105;
 1086|      0|                }
 1087|      0|                if ((int)*(*(p + 0) + 1) == 66) {
 1088|      0|                    goto case_66;
 1089|      0|                }
 1090|      0|                if ((int)*(*(p + 0) + 1) == 68) {
 1091|      0|                    goto case_66;
 1092|      0|                }
 1093|      0|                goto switch_break;
 1094|      0|case_105:
 1095|      0|                if ((int)*(*(p + 0) + 2) == 66) {
 1096|      0|                    suffixes += 2;
 1097|      0|                }
 1098|      0|                goto switch_break;
 1099|      0|case_66:
 1100|      0|                base = 1000;
 1101|      0|                suffixes++;
 1102|      0|                goto switch_break;
 1103|      0|switch_break:
 1104|      0|                ;
 1105|      0|            }
 1106|      0|            if ((int)*(*p) == 98) {
 1107|      0|                goto case_98;
 1108|      0|            }
 1109|      0|            if ((int)*(*p) == 66) {
 1110|      0|                goto case_66___0;
 1111|      0|            }
 1112|      0|            if ((int)*(*p) == 99) {
 1113|      0|                goto case_99;
 1114|      0|            }
 1115|      0|            if ((int)*(*p) == 69) {
 1116|      0|                goto case_69;
 1117|      0|            }
 1118|      0|            if ((int)*(*p) == 71) {
 1119|      0|                goto case_71;
 1120|      0|            }
 1121|      0|            if ((int)*(*p) == 103) {
 1122|      0|                goto case_71;
 1123|      0|            }
 1124|      0|            if ((int)*(*p) == 107) {
 1125|      0|                goto case_107;
 1126|      0|            }
 1127|      0|            if ((int)*(*p) == 75) {
 1128|      0|                goto case_107;
 1129|      0|            }
 1130|      0|            if ((int)*(*p) == 77) {
 1131|      0|                goto case_77;
 1132|      0|            }
 1133|      0|            if ((int)*(*p) == 109) {
 1134|      0|                goto case_77;
 1135|      0|            }
 1136|      0|            if ((int)*(*p) == 80) {
 1137|      0|                goto case_80;
 1138|      0|            }
 1139|      0|            if ((int)*(*p) == 84) {
 1140|      0|                goto case_84;
 1141|      0|            }
 1142|      0|            if ((int)*(*p) == 116) {
 1143|      0|                goto case_84;
 1144|      0|            }
 1145|      0|            if ((int)*(*p) == 119) {
 1146|      0|                goto case_119;
 1147|      0|            }
 1148|      0|            if ((int)*(*p) == 89) {
 1149|      0|                goto case_89;
 1150|      0|            }
 1151|      0|            if ((int)*(*p) == 90) {
 1152|      0|                goto case_90;
 1153|      0|            }
 1154|      0|            goto switch_default;
 1155|      0|case_98:
 1156|      0|            overflow = bkm_scale___0(&tmp, 512);
 1157|      0|            goto switch_break___0;
 1158|      0|case_66___0:
 1159|      0|            overflow = bkm_scale___0(&tmp, 1024);
 1160|      0|            goto switch_break___0;
 1161|      0|case_99:
 1162|      0|            overflow = (strtol_error)0;
 1163|      0|            goto switch_break___0;
 1164|      0|case_69:
 1165|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 6);
 1166|      0|            goto switch_break___0;
 1167|      0|case_71:
 1168|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 3);
 1169|      0|            goto switch_break___0;
 1170|      0|case_107:
 1171|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 1);
 1172|      0|            goto switch_break___0;
 1173|      0|case_77:
 1174|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 2);
 1175|      0|            goto switch_break___0;
 1176|      0|case_80:
 1177|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 5);
 1178|      0|            goto switch_break___0;
 1179|      0|case_84:
 1180|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 4);
 1181|      0|            goto switch_break___0;
 1182|      0|case_119:
 1183|      0|            overflow = bkm_scale___0(&tmp, 2);
 1184|      0|            goto switch_break___0;
 1185|      0|case_89:
 1186|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 8);
 1187|      0|            goto switch_break___0;
 1188|      0|case_90:
 1189|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 7);
 1190|      0|            goto switch_break___0;
 1191|      0|switch_default:
 1192|      0|            *val = tmp;
 1193|      0|            return ((strtol_error)((unsigned int)err | 2U));
 1194|      0|switch_break___0:
 1195|      0|            err = (strtol_error)((unsigned int)err | (unsigned int)overflow);
 1196|      0|            *p += suffixes;
 1197|      0|            if (*(*p)) {
 1198|      0|                err = (strtol_error)((unsigned int)err | 2U);
 1199|      0|            }
 1200|      0|        }
 1201|      0|        *val = tmp;
 1202|      0|        return (err);
 1203|      0|    }
 1204|      0|}
 1205|       |void *xmemdup(void const *p, size_t s) __attribute__((__malloc__));
 1206|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__)) calloc)(
 1207|       |    size_t __nmemb, size_t __size) __attribute__((__malloc__));
 1208|       |void *xmalloc(size_t n) __attribute__((__malloc__));
 1209|       |void *xmalloc(size_t n)
 1210|      2|{
 1211|      2|    void *p;
 1212|      2|    void *tmp;
 1213|       |
 1214|      2|    {
 1215|      2|        tmp = malloc(n);
 1216|      2|        p = tmp;
 1217|      2|        if (!p) {
 1218|      0|            if (n != 0UL) {
 1219|      0|                xalloc_die();
 1220|      0|            }
 1221|      0|        }
 1222|      2|        return (p);
 1223|      2|    }
 1224|      2|}
 1225|       |void *xrealloc(void *p, size_t n)
 1226|      0|{
 1227|       |
 1228|      0|    {
 1229|      0|        p = realloc(p, n);
 1230|      0|        if (!p) {
 1231|      0|            if (n != 0UL) {
 1232|      0|                xalloc_die();
 1233|      0|            }
 1234|      0|        }
 1235|      0|        return (p);
 1236|      0|    }
 1237|      0|}
 1238|       |void *xmemdup(void const *p, size_t s) __attribute__((__malloc__));
 1239|       |void *xmemdup(void const *p, size_t s)
 1240|      2|{
 1241|      2|    void *tmp;
 1242|      2|    void *tmp___0;
 1243|       |
 1244|      2|    {
 1245|      2|        tmp = xmalloc(s);
 1246|      2|        tmp___0 = memcpy(tmp, p, s);
 1247|      2|        return (tmp___0);
 1248|      2|    }
 1249|      2|}
 1250|       |char *xstrdup(char const *string) __attribute__((__malloc__));
 1251|       |char *xstrdup(char const *string)
 1252|      1|{
 1253|      1|    size_t tmp;
 1254|      1|    char *tmp___0;
 1255|       |
 1256|      1|    {
 1257|      1|        tmp = strlen(string);
 1258|      1|        tmp___0 = (char *)xmemdup((void const *)string, tmp + 1UL);
 1259|      1|        return (tmp___0);
 1260|      1|    }
 1261|      1|}
 1262|       |__attribute__((__nothrow__))
 1263|       |FTS *(__attribute__((__warn_unused_result__, __leaf__)) fts_open)(
 1264|       |    char *const *argv, int options,
 1265|       |    int (*compar)(FTSENT const **, FTSENT const **));
 1266|       |FTS *xfts_open(char *const *argv, int options,
 1267|       |               int (*compar)(FTSENT const **, FTSENT const **));
 1268|       |_Bool cycle_warning_required(FTS const *fts, FTSENT const *ent);
 1269|       |FTS *xfts_open(char *const *argv, int options,
 1270|       |               int (*compar)(FTSENT const **, FTSENT const **))
 1271|      1|{
 1272|      1|    FTS *fts;
 1273|      1|    FTS *tmp;
 1274|      1|    int *tmp___0;
 1275|       |
 1276|      1|    {
 1277|      1|        tmp = fts_open(argv, options | 512, compar);
 1278|      1|        fts = tmp;
 1279|      1|        if ((unsigned long)fts == (unsigned long)((void *)0)) {
 1280|      0|            tmp___0 = __errno_location();
 1281|      0|            if (!(*tmp___0 != 22)) {
 1282|      0|                __assert_fail("(*__errno_location ()) != 22",
 1283|      0|                              "/home/khheo/project/program-reduce/benchmark/"
 1284|      0|                              "coreutils-8.2/lib/xfts.c",
 1285|      0|                              41U, "xfts_open");
 1286|      0|            }
 1287|      0|            xalloc_die();
 1288|      0|        }
 1289|      1|        return (fts);
 1290|      1|    }
 1291|      1|}
 1292|       |_Bool cycle_warning_required(FTS const *fts, FTSENT const *ent)
 1293|      0|{
 1294|      0|    int tmp;
 1295|       |
 1296|      0|    {
 1297|      0|        if (fts->fts_options & 16) {
 1298|      0|            if (!(fts->fts_options & 1)) {
 1299|      0|                tmp = 1;
 1300|      0|            }
 1301|      0|            else {
 1302|      0|                goto _L;
 1303|      0|            }
 1304|      0|        }
 1305|      0|        else {
 1306|      0|_L:
 1307|      0|            if (fts->fts_options & 16) {
 1308|      0|                if (fts->fts_options & 1) {
 1309|      0|                    if (ent->fts_level != 0L) {
 1310|      0|                        tmp = 1;
 1311|      0|                    }
 1312|      0|                    else {
 1313|      0|                        tmp = 0;
 1314|      0|                    }
 1315|      0|                }
 1316|      0|                else {
 1317|      0|                    tmp = 0;
 1318|      0|                }
 1319|      0|            }
 1320|      0|            else {
 1321|      0|                tmp = 0;
 1322|      0|            }
 1323|      0|        }
 1324|      0|        return ((_Bool)tmp);
 1325|      0|    }
 1326|      0|}
 1327|       |__attribute__((__noreturn__)) void xalloc_die(void);
 1328|       |void xalloc_die(void)
 1329|      0|{
 1330|      0|    char *tmp;
 1331|       |
 1332|      0|    {
 1333|      0|        tmp = gettext("memory exhausted");
 1334|      0|        error((int)exit_failure, 0, "%s", tmp);
 1335|      0|        abort();
 1336|      0|    }
 1337|      0|}
 1338|       |extern int printf(char const *__restrict __format, ...);
 1339|       |extern int fputs_unlocked(char const *__restrict __s,
 1340|       |                          FILE *__restrict __stream);
 1341|       |char const version_etc_copyright[47];
 1342|       |void version_etc_arn(FILE *stream, char const *command_name,
 1343|       |                     char const *package, char const *version,
 1344|       |                     char const *const *authors, size_t n_authors);
 1345|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 1346|       |                    char const *version, va_list authors);
 1347|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1348|       |                 char const *version, ...) __attribute__((__sentinel__));
 1349|       |void version_etc_arn(FILE *stream, char const *command_name,
 1350|       |                     char const *package, char const *version,
 1351|       |                     char const *const *authors, size_t n_authors)
 1352|      0|{
 1353|      0|    char *tmp;
 1354|      0|    char *tmp___0;
 1355|      0|    char *tmp___1;
 1356|      0|    char *tmp___2;
 1357|      0|    char *tmp___3;
 1358|      0|    char *tmp___4;
 1359|      0|    char *tmp___5;
 1360|      0|    char *tmp___6;
 1361|      0|    char *tmp___7;
 1362|      0|    char *tmp___8;
 1363|      0|    char *tmp___9;
 1364|      0|    char *tmp___10;
 1365|       |
 1366|      0|    {
 1367|      0|        if (command_name) {
 1368|      0|            fprintf(stream, "%s (%s) %s\n", command_name, package, version);
 1369|      0|        }
 1370|      0|        else {
 1371|      0|            fprintf(stream, "%s %s\n", package, version);
 1372|      0|        }
 1373|      0|        tmp = gettext("(C)");
 1374|      0|        fprintf(stream, version_etc_copyright, tmp, 2009);
 1375|      0|        tmp___0 =
 1376|      0|            gettext("\nLicense GPLv3+: GNU GPL version 3 or later "
 1377|      0|                    "<http://gnu.org/licenses/gpl.html>.\nThis is free software: "
 1378|      0|                    "you are free to change and redistribute it.\nThere is NO "
 1379|      0|                    "WARRANTY, to the extent permitted by law.\n\n");
 1380|      0|        fputs_unlocked((char const *)tmp___0, stream);
 1381|      0|        if (n_authors == 0UL) {
 1382|      0|            goto case_0;
 1383|      0|        }
 1384|      0|        if (n_authors == 1UL) {
 1385|      0|            goto case_1;
 1386|      0|        }
 1387|      0|        if (n_authors == 2UL) {
 1388|      0|            goto case_2;
 1389|      0|        }
 1390|      0|        if (n_authors == 3UL) {
 1391|      0|            goto case_3;
 1392|      0|        }
 1393|      0|        if (n_authors == 4UL) {
 1394|      0|            goto case_4;
 1395|      0|        }
 1396|      0|        if (n_authors == 5UL) {
 1397|      0|            goto case_5;
 1398|      0|        }
 1399|      0|        if (n_authors == 6UL) {
 1400|      0|            goto case_6;
 1401|      0|        }
 1402|      0|        if (n_authors == 7UL) {
 1403|      0|            goto case_7;
 1404|      0|        }
 1405|      0|        if (n_authors == 8UL) {
 1406|      0|            goto case_8;
 1407|      0|        }
 1408|      0|        if (n_authors == 9UL) {
 1409|      0|            goto case_9;
 1410|      0|        }
 1411|      0|        goto switch_default;
 1412|      0|case_0:
 1413|      0|        abort();
 1414|      0|case_1:
 1415|      0|        tmp___1 = gettext("Written by %s.\n");
 1416|      0|        fprintf(stream, (char const *)tmp___1, *(authors + 0));
 1417|      0|        goto switch_break;
 1418|      0|case_2:
 1419|      0|        tmp___2 = gettext("Written by %s and %s.\n");
 1420|      0|        fprintf(stream, (char const *)tmp___2, *(authors + 0), *(authors + 1));
 1421|      0|        goto switch_break;
 1422|      0|case_3:
 1423|      0|        tmp___3 = gettext("Written by %s, %s, and %s.\n");
 1424|      0|        fprintf(stream, (char const *)tmp___3, *(authors + 0), *(authors + 1),
 1425|      0|                *(authors + 2));
 1426|      0|        goto switch_break;
 1427|      0|case_4:
 1428|      0|        tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
 1429|      0|        fprintf(stream, (char const *)tmp___4, *(authors + 0), *(authors + 1),
 1430|      0|                *(authors + 2), *(authors + 3));
 1431|      0|        goto switch_break;
 1432|      0|case_5:
 1433|      0|        tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
 1434|      0|        fprintf(stream, (char const *)tmp___5, *(authors + 0), *(authors + 1),
 1435|      0|                *(authors + 2), *(authors + 3), *(authors + 4));
 1436|      0|        goto switch_break;
 1437|      0|case_6:
 1438|      0|        tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
 1439|      0|        fprintf(stream, (char const *)tmp___6, *(authors + 0), *(authors + 1),
 1440|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5));
 1441|      0|        goto switch_break;
 1442|      0|case_7:
 1443|      0|        tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
 1444|      0|        fprintf(stream, (char const *)tmp___7, *(authors + 0), *(authors + 1),
 1445|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1446|      0|                *(authors + 6));
 1447|      0|        goto switch_break;
 1448|      0|case_8:
 1449|      0|        tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
 1450|      0|        fprintf(stream, (char const *)tmp___8, *(authors + 0), *(authors + 1),
 1451|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1452|      0|                *(authors + 6), *(authors + 7));
 1453|      0|        goto switch_break;
 1454|      0|case_9:
 1455|      0|        tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
 1456|      0|        fprintf(stream, (char const *)tmp___9, *(authors + 0), *(authors + 1),
 1457|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1458|      0|                *(authors + 6), *(authors + 7), *(authors + 8));
 1459|      0|        goto switch_break;
 1460|      0|switch_default:
 1461|      0|        tmp___10 = gettext(
 1462|      0|                       "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
 1463|      0|        fprintf(stream, (char const *)tmp___10, *(authors + 0), *(authors + 1),
 1464|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1465|      0|                *(authors + 6), *(authors + 7), *(authors + 8));
 1466|      0|        goto switch_break;
 1467|      0|switch_break:
 1468|      0|        ;
 1469|      0|        return;
 1470|      0|    }
 1471|      0|}
 1472|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 1473|       |                    char const *version, va_list authors)
 1474|      0|{
 1475|      0|    size_t n_authors;
 1476|      0|    char const *authtab[10];
 1477|      0|    char const *tmp;
 1478|       |
 1479|      0|    {
 1480|      0|        n_authors = (size_t)0;
 1481|      0|        while (1) {
 1482|       |
 1483|      0|            if (n_authors < 10UL) {
 1484|      0|                tmp = __builtin_va_arg(authors, char const *);
 1485|      0|                authtab[n_authors] = tmp;
 1486|      0|                if (!((unsigned long)tmp != (unsigned long)((void *)0))) {
 1487|      0|                    goto while_break;
 1488|      0|                }
 1489|      0|            }
 1490|      0|            else {
 1491|      0|                goto while_break;
 1492|      0|            }
 1493|      0|            n_authors++;
 1494|      0|        }
 1495|      0|while_break:
 1496|      0|        version_etc_arn(stream, command_name, package, version,
 1497|      0|                        (char const *const *)(authtab), n_authors);
 1498|      0|        return;
 1499|      0|    }
 1500|      0|}
 1501|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1502|       |                 char const *version, ...) __attribute__((__sentinel__));
 1503|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1504|       |                 char const *version, ...)
 1505|      0|{
 1506|      0|    va_list authors;
 1507|       |
 1508|      0|    {
 1509|      0|        __builtin_va_start(authors, version);
 1510|      0|        version_etc_va(stream, command_name, package, version, authors);
 1511|      0|        __builtin_va_end(authors);
 1512|      0|        return;
 1513|      0|    }
 1514|      0|}
 1515|       |char const version_etc_copyright[47] = {
 1516|       |    (char const)'C', (char const)'o', (char const)'p',   (char const)'y',
 1517|       |    (char const)'r', (char const)'i', (char const)'g',   (char const)'h',
 1518|       |    (char const)'t', (char const)' ', (char const)'%',   (char const)'s',
 1519|       |    (char const)' ', (char const)'%', (char const)'d',   (char const)' ',
 1520|       |    (char const)'F', (char const)'r', (char const)'e',   (char const)'e',
 1521|       |    (char const)' ', (char const)'S', (char const)'o',   (char const)'f',
 1522|       |    (char const)'t', (char const)'w', (char const)'a',   (char const)'r',
 1523|       |    (char const)'e', (char const)' ', (char const)'F',   (char const)'o',
 1524|       |    (char const)'u', (char const)'n', (char const)'d',   (char const)'a',
 1525|       |    (char const)'t', (char const)'i', (char const)'o',   (char const)'n',
 1526|       |    (char const)',', (char const)' ', (char const)'I',   (char const)'n',
 1527|       |    (char const)'c', (char const)'.', (char const)'\000'
 1528|       |};
 1529|       |char const *parse_user_spec(char const *spec, uid_t *uid, gid_t *gid,
 1530|       |                            char **username, char **groupname);
 1531|       |extern void endpwent(void);
 1532|       |extern struct passwd *getpwnam(char const *__name);
 1533|       |extern void endgrent(void);
 1534|       |extern struct group *getgrgid(__gid_t __gid);
 1535|       |extern struct group *getgrnam(char const *__name);
 1536|       |char *(__attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i,
 1537|       |        char *buf___1);
 1538|       |static char const *parse_with_separator(char const *spec, char const *separator,
 1539|       |                                        uid_t *uid, gid_t *gid, char **username,
 1540|       |                                        char **groupname);
 1541|       |static char const *E_invalid_user = "invalid user";
 1542|       |static char const *E_invalid_group = "invalid group";
 1543|       |static char const *E_bad_spec = "invalid spec";
 1544|       |static char const *parse_with_separator(char const *spec, char const *separator,
 1545|       |                                        uid_t *uid, gid_t *gid, char **username,
 1546|       |                                        char **groupname)
 1547|      1|{
 1548|      1|    char const *error_msg;
 1549|      1|    struct passwd *pwd;
 1550|      1|    struct group *grp;
 1551|      1|    char *u;
 1552|      1|    char const *g;
 1553|      1|    char *gname;
 1554|      1|    uid_t unum;
 1555|      1|    gid_t gnum;
 1556|      1|    char *tmp;
 1557|      1|    size_t ulen;
 1558|      1|    struct passwd *tmp___0;
 1559|      1|    _Bool use_login_group;
 1560|      1|    int tmp___1;
 1561|      1|    unsigned long tmp___2;
 1562|      1|    strtol_error tmp___3;
 1563|      1|    char buf___1[(((sizeof(uintmax_t) * 8UL) * 146UL) / 485UL + 1UL) + 1UL];
 1564|      1|    char *tmp___4;
 1565|      1|    char *tmp___5;
 1566|      1|    struct group *tmp___6;
 1567|      1|    unsigned long tmp___7;
 1568|      1|    strtol_error tmp___8;
 1569|      1|    char const *tmp___9;
 1570|       |
 1571|      1|    {
 1572|      1|        gname = (char *)((void *)0);
 1573|      1|        unum = *uid;
 1574|      1|        gnum = *gid;
 1575|      1|        error_msg = (char const *)((void *)0);
 1576|      1|        tmp = (char *)((void *)0);
 1577|      1|        *groupname = tmp;
 1578|      1|        *username = tmp;
 1579|      1|        u = (char *)((void *)0);
 1580|      1|        if ((unsigned long)separator == (unsigned long)((void *)0)) {
 1581|      0|            if (*spec) {
 1582|      0|                u = xstrdup(spec);
 1583|      0|            }
 1584|      0|        }
 1585|      1|        else {
 1586|      1|            ulen = (size_t)(separator - spec);
 1587|      1|            if (ulen != 0UL) {
 1588|      1|                u = (char *)xmemdup((void const *)spec, ulen + 1UL);
 1589|      1|                *(u + ulen) = (char)'\000';
 1590|      1|            }
 1591|      1|        }
 1592|      1|        if ((unsigned long)separator == (unsigned long)((void *)0)) {
 1593|      0|            g = (char const *)((void *)0);
 1594|      0|        }
 1595|      1|        else {
 1596|      1|            if ((int const) * (separator + 1) == 0) {
 1597|      0|                g = (char const *)((void *)0);
 1598|      0|            }
 1599|      1|            else {
 1600|      1|                g = separator + 1;
 1601|      1|            }
 1602|      1|        }
 1603|      1|        if ((unsigned long)u != (unsigned long)((void *)0)) {
 1604|      1|            if ((int)*u == 43) {
 1605|      0|                pwd = (struct passwd *)((void *)0);
 1606|      0|            }
 1607|      1|            else {
 1608|      1|                tmp___0 = getpwnam((char const *)u);
 1609|      1|                pwd = tmp___0;
 1610|      1|            }
 1611|      1|            if ((unsigned long)pwd == (unsigned long)((void *)0)) {
 1612|      0|                if ((unsigned long)separator != (unsigned long)((void *)0)) {
 1613|      0|                    if ((unsigned long)g == (unsigned long)((void *)0)) {
 1614|      0|                        tmp___1 = 1;
 1615|      0|                    }
 1616|      0|                    else {
 1617|      0|                        tmp___1 = 0;
 1618|      0|                    }
 1619|      0|                }
 1620|      0|                else {
 1621|      0|                    tmp___1 = 0;
 1622|      0|                }
 1623|      0|                use_login_group = (_Bool)tmp___1;
 1624|      0|                if (use_login_group) {
 1625|      0|                    error_msg = E_bad_spec;
 1626|      0|                }
 1627|      0|                else {
 1628|      0|                    tmp___3 =
 1629|      0|                        xstrtoul((char const *)u, (char **)((void *)0), 10, &tmp___2, "");
 1630|      0|                    if ((unsigned int)tmp___3 == 0U) {
 1631|      0|                        if (tmp___2 <= 4294967295UL) {
 1632|      0|                            if ((uid_t)tmp___2 != 4294967295U) {
 1633|      0|                                unum = (uid_t)tmp___2;
 1634|      0|                            }
 1635|      0|                            else {
 1636|      0|                                error_msg = E_invalid_user;
 1637|      0|                            }
 1638|      0|                        }
 1639|      0|                        else {
 1640|      0|                            error_msg = E_invalid_user;
 1641|      0|                        }
 1642|      0|                    }
 1643|      0|                    else {
 1644|      0|                        error_msg = E_invalid_user;
 1645|      0|                    }
 1646|      0|                }
 1647|      0|            }
 1648|      1|            else {
 1649|      1|                unum = pwd->pw_uid;
 1650|      1|                if ((unsigned long)g == (unsigned long)((void *)0)) {
 1651|      0|                    if ((unsigned long)separator != (unsigned long)((void *)0)) {
 1652|      0|                        gnum = pwd->pw_gid;
 1653|      0|                        grp = getgrgid(gnum);
 1654|      0|                        if (grp) {
 1655|      0|                            tmp___5 = grp->gr_name;
 1656|      0|                        }
 1657|      0|                        else {
 1658|      0|                            tmp___4 = umaxtostr((uintmax_t)gnum, buf___1);
 1659|      0|                            tmp___5 = tmp___4;
 1660|      0|                        }
 1661|      0|                        gname = xstrdup((char const *)tmp___5);
 1662|      0|                        endgrent();
 1663|      0|                    }
 1664|      0|                }
 1665|      1|            }
 1666|      1|            endpwent();
 1667|      1|        }
 1668|      1|        if ((unsigned long)g != (unsigned long)((void *)0)) {
 1669|      1|            if ((unsigned long)error_msg == (unsigned long)((void *)0)) {
 1670|      1|                if ((int const) * g == 43) {
 1671|      0|                    grp = (struct group *)((void *)0);
 1672|      0|                }
 1673|      1|                else {
 1674|      1|                    tmp___6 = getgrnam(g);
 1675|      1|                    grp = tmp___6;
 1676|      1|                }
 1677|      1|                if ((unsigned long)grp == (unsigned long)((void *)0)) {
 1678|      0|                    tmp___8 = xstrtoul(g, (char **)((void *)0), 10, &tmp___7, "");
 1679|      0|                    if ((unsigned int)tmp___8 == 0U) {
 1680|      0|                        if (tmp___7 <= 4294967295UL) {
 1681|      0|                            if ((gid_t)tmp___7 != 4294967295U) {
 1682|      0|                                gnum = (gid_t)tmp___7;
 1683|      0|                            }
 1684|      0|                            else {
 1685|      0|                                error_msg = E_invalid_group;
 1686|      0|                            }
 1687|      0|                        }
 1688|      0|                        else {
 1689|      0|                            error_msg = E_invalid_group;
 1690|      0|                        }
 1691|      0|                    }
 1692|      0|                    else {
 1693|      0|                        error_msg = E_invalid_group;
 1694|      0|                    }
 1695|      0|                }
 1696|      1|                else {
 1697|      1|                    gnum = grp->gr_gid;
 1698|      1|                }
 1699|      1|                endgrent();
 1700|      1|                gname = xstrdup(g);
 1701|      1|            }
 1702|      1|        }
 1703|      1|        if ((unsigned long)error_msg == (unsigned long)((void *)0)) {
 1704|      1|            *uid = unum;
 1705|      1|            *gid = gnum;
 1706|      1|            *username = u;
 1707|      1|            *groupname = gname;
 1708|      1|            u = (char *)((void *)0);
 1709|      1|        }
 1710|      0|        else {
 1711|      0|            free((void *)gname);
 1712|      0|        }
 1713|      1|        free((void *)u);
 1714|      1|        tmp___9 = (char const *)gettext(error_msg);
 1715|      1|        return (tmp___9);
 1716|      1|    }
 1717|      1|}
 1718|       |char const *parse_user_spec(char const *spec, uid_t *uid, gid_t *gid,
 1719|       |                            char **username, char **groupname)
 1720|      1|{
 1721|      1|    char const *colon;
 1722|      1|    char const *tmp;
 1723|      1|    char const *error_msg;
 1724|      1|    char const *tmp___0;
 1725|      1|    char const *dot;
 1726|      1|    char const *tmp___1;
 1727|      1|    char const *tmp___2;
 1728|       |
 1729|      1|    {
 1730|      1|        tmp = (char const *)strchr(spec, ':');
 1731|      1|        colon = tmp;
 1732|      1|        tmp___0 = parse_with_separator(spec, colon, uid, gid, username, groupname);
 1733|      1|        error_msg = tmp___0;
 1734|      1|        if (!colon) {
 1735|      0|            if (error_msg) {
 1736|      0|                tmp___1 = (char const *)strchr(spec, '.');
 1737|      0|                dot = tmp___1;
 1738|      0|                if (dot) {
 1739|      0|                    tmp___2 =
 1740|      0|                        parse_with_separator(spec, dot, uid, gid, username, groupname);
 1741|      0|                    if (!tmp___2) {
 1742|      0|                        error_msg = (char const *)((void *)0);
 1743|      0|                    }
 1744|      0|                }
 1745|      0|            }
 1746|      0|        }
 1747|      1|        return (error_msg);
 1748|      1|    }
 1749|      1|}
 1750|       |char *(__attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i,
 1751|       |        char *buf___1)
 1752|      0|{
 1753|      0|    char *p;
 1754|       |
 1755|      0|    {
 1756|      0|        p = buf___1 + (((sizeof(uintmax_t) * 8UL) * 146UL) / 485UL + 1UL);
 1757|      0|        *p = (char)0;
 1758|      0|        while (1) {
 1759|      0|            p--;
 1760|      0|            *p = (char)(48UL + i % 10UL);
 1761|      0|            i /= 10UL;
 1762|      0|            if (!(i != 0UL)) {
 1763|      0|                goto while_break;
 1764|      0|            }
 1765|      0|        }
 1766|      0|while_break:
 1767|      0|        ;
 1768|      0|        return (p);
 1769|      0|    }
 1770|      0|}
 1771|       |#pragma weak pthread_key_create
 1772|       |#pragma weak pthread_getspecific
 1773|       |#pragma weak pthread_setspecific
 1774|       |#pragma weak pthread_key_delete
 1775|       |#pragma weak pthread_self
 1776|       |#pragma weak pthread_cancel
 1777|       |size_t strnlen1(char const *string, size_t maxlen)
 1778|      0|{
 1779|      0|    char const *end;
 1780|      0|    char const *tmp;
 1781|       |
 1782|      0|    {
 1783|      0|        tmp = (char const *)memchr((void const *)string, '\000', maxlen);
 1784|      0|        end = tmp;
 1785|      0|        if ((unsigned long)end != (unsigned long)((void *)0)) {
 1786|      0|            return ((size_t)((end - string) + 1L));
 1787|      0|        }
 1788|      0|        else {
 1789|      0|            return (maxlen);
 1790|      0|        }
 1791|      0|    }
 1792|      0|}
 1793|       |int open_safer(char const *file, int flags, ...);
 1794|       |struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i);
 1795|       |struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i)
 1796|      0|{
 1797|      0|    struct stat statbuf;
 1798|      0|    int tmp;
 1799|       |
 1800|      0|    {
 1801|      0|        tmp = lstat("/", &statbuf);
 1802|      0|        if (tmp) {
 1803|      0|            return ((struct dev_ino *)((void *)0));
 1804|      0|        }
 1805|      0|        root_d_i->st_ino = statbuf.st_ino;
 1806|      0|        root_d_i->st_dev = statbuf.st_dev;
 1807|      0|        return (root_d_i);
 1808|      0|    }
 1809|      0|}
 1810|       |reg_syntax_t rpl_re_syntax_options;
 1811|       |char const *const quoting_style_args[9];
 1812|       |enum quoting_style const quoting_style_vals[8];
 1813|       |int set_char_quoting(struct quoting_options *o, char c, int i);
 1814|       |char *quotearg_char(char const *arg, char ch);
 1815|       |char *quotearg_char_mem(char const *arg, size_t argsize, char ch);
 1816|       |__inline static char *xcharalloc(size_t n) __attribute__((__malloc__));
 1817|       |__inline static char *xcharalloc(size_t n) __attribute__((__malloc__));
 1818|       |__inline static char *xcharalloc(size_t n)
 1819|      0|{
 1820|      0|    void *tmp;
 1821|      0|    void *tmp___0;
 1822|      0|    void *tmp___1;
 1823|       |
 1824|      0|    {
 1825|      0|        if (sizeof(char) == 1UL) {
 1826|      0|            tmp = xmalloc(n);
 1827|      0|            tmp___1 = tmp;
 1828|      0|        }
 1829|      0|        else {
 1830|      0|            tmp___0 = xnmalloc(n, sizeof(char));
 1831|      0|            tmp___1 = tmp___0;
 1832|      0|        }
 1833|      0|        return ((char *)tmp___1);
 1834|      0|    }
 1835|      0|}
 1836|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) iswprint)(
 1837|       |    wint_t __wc);
 1838|       |char const *const quoting_style_args[9] = {
 1839|       |    "literal", "shell",   "shell-always", "c", "c-maybe", "escape",
 1840|       |    "locale",  "clocale", (char const *)0
 1841|       |};
 1842|       |enum quoting_style const quoting_style_vals[8] = {
 1843|       |    (enum quoting_style const)0, (enum quoting_style const)1,
 1844|       |    (enum quoting_style const)2, (enum quoting_style const)3,
 1845|       |    (enum quoting_style const)4, (enum quoting_style const)5,
 1846|       |    (enum quoting_style const)6, (enum quoting_style const)7
 1847|       |};
 1848|       |static struct quoting_options default_quoting_options;
 1849|       |int set_char_quoting(struct quoting_options *o, char c, int i)
 1850|      0|{
 1851|      0|    unsigned char uc;
 1852|      0|    unsigned int *p;
 1853|      0|    struct quoting_options *tmp;
 1854|      0|    int shift;
 1855|      0|    int r;
 1856|       |
 1857|      0|    {
 1858|      0|        uc = (unsigned char)c;
 1859|      0|        if (o) {
 1860|      0|            tmp = o;
 1861|      0|        }
 1862|      0|        else {
 1863|      0|            tmp = &default_quoting_options;
 1864|      0|        }
 1865|      0|        p = tmp->quote_these_too + (unsigned long)uc / (sizeof(int) * 8UL);
 1866|      0|        shift = (int)((unsigned long)uc % (sizeof(int) * 8UL));
 1867|      0|        r = (int)((*p >> shift) & 1U);
 1868|      0|        *p ^= (unsigned int)(((i & 1) ^ r) << shift);
 1869|      0|        return (r);
 1870|      0|    }
 1871|      0|}
 1872|       |static struct quoting_options
 1873|       |quoting_options_from_style(enum quoting_style style)
 1874|      0|{
 1875|      0|    struct quoting_options o;
 1876|       |
 1877|      0|    {
 1878|      0|        o.style = style;
 1879|      0|        o.flags = 0;
 1880|      0|        memset((void *)(o.quote_these_too), 0, sizeof(o.quote_these_too));
 1881|      0|        return (o);
 1882|      0|    }
 1883|      0|}
 1884|       |static char const *gettext_quote(char const *msgid, enum quoting_style s)
 1885|      0|{
 1886|      0|    char const *translation;
 1887|      0|    char const *tmp;
 1888|       |
 1889|      0|    {
 1890|      0|        tmp = (char const *)gettext(msgid);
 1891|      0|        translation = tmp;
 1892|      0|        if ((unsigned long)translation == (unsigned long)msgid) {
 1893|      0|            if ((unsigned int)s == 7U) {
 1894|      0|                translation = "\"";
 1895|      0|            }
 1896|      0|        }
 1897|      0|        return (translation);
 1898|      0|    }
 1899|      0|}
 1900|       |static size_t
 1901|       |quotearg_buffer_restyled(char *buffer, size_t buffersize, char const *arg,
 1902|       |                         size_t argsize, enum quoting_style quoting_style,
 1903|       |                         int flags, unsigned int const *quote_these_too,
 1904|       |                         char const *left_quote, char const *right_quote)
 1905|      0|{
 1906|      0|    size_t i;
 1907|      0|    size_t len;
 1908|      0|    char const *quote_string;
 1909|      0|    size_t quote_string_len;
 1910|      0|    _Bool backslash_escapes;
 1911|      0|    _Bool unibyte_locale;
 1912|      0|    size_t tmp;
 1913|      0|    _Bool elide_outer_quotes;
 1914|      0|    unsigned char c;
 1915|      0|    unsigned char esc;
 1916|      0|    _Bool is_right_quote;
 1917|      0|    int tmp___0;
 1918|      0|    int tmp___1;
 1919|      0|    size_t m;
 1920|      0|    _Bool printable;
 1921|      0|    unsigned short const **tmp___2;
 1922|      0|    mbstate_t mbstate;
 1923|      0|    wchar_t w;
 1924|      0|    size_t bytes;
 1925|      0|    size_t tmp___3;
 1926|      0|    size_t j;
 1927|      0|    int tmp___4;
 1928|      0|    int tmp___5;
 1929|      0|    size_t ilim;
 1930|      0|    int tmp___6;
 1931|      0|    size_t tmp___7;
 1932|       |
 1933|      0|    {
 1934|      0|        len = (size_t)0;
 1935|      0|        quote_string = (char const *)0;
 1936|      0|        quote_string_len = (size_t)0;
 1937|      0|        backslash_escapes = (_Bool)0;
 1938|      0|        tmp = __ctype_get_mb_cur_max();
 1939|      0|        unibyte_locale = (_Bool)(tmp == 1UL);
 1940|      0|        elide_outer_quotes = (_Bool)((flags & 2) != 0);
 1941|      0|        if ((unsigned int)quoting_style == 4U) {
 1942|      0|            goto case_4;
 1943|      0|        }
 1944|      0|        if ((unsigned int)quoting_style == 3U) {
 1945|      0|            goto case_3;
 1946|      0|        }
 1947|      0|        if ((unsigned int)quoting_style == 5U) {
 1948|      0|            goto case_5;
 1949|      0|        }
 1950|      0|        if ((unsigned int)quoting_style == 6U) {
 1951|      0|            goto case_6;
 1952|      0|        }
 1953|      0|        if ((unsigned int)quoting_style == 7U) {
 1954|      0|            goto case_6;
 1955|      0|        }
 1956|      0|        if ((unsigned int)quoting_style == 8U) {
 1957|      0|            goto case_6;
 1958|      0|        }
 1959|      0|        if ((unsigned int)quoting_style == 1U) {
 1960|      0|            goto case_1;
 1961|      0|        }
 1962|      0|        if ((unsigned int)quoting_style == 2U) {
 1963|      0|            goto case_2;
 1964|      0|        }
 1965|      0|        if ((unsigned int)quoting_style == 0U) {
 1966|      0|            goto case_0;
 1967|      0|        }
 1968|      0|        goto switch_default;
 1969|      0|case_4:
 1970|      0|        quoting_style = (enum quoting_style)3;
 1971|      0|        elide_outer_quotes = (_Bool)1;
 1972|      0|case_3:
 1973|      0|        if (!elide_outer_quotes) {
 1974|      0|            while (1) {
 1975|       |
 1976|      0|                if (len < buffersize) {
 1977|      0|                    *(buffer + len) = (char)'\"';
 1978|      0|                }
 1979|      0|                len++;
 1980|      0|                goto while_break;
 1981|      0|            }
 1982|      0|while_break:
 1983|      0|            ;
 1984|      0|        }
 1985|      0|        backslash_escapes = (_Bool)1;
 1986|      0|        quote_string = "\"";
 1987|      0|        quote_string_len = (size_t)1;
 1988|      0|        goto switch_break;
 1989|      0|case_5:
 1990|      0|        backslash_escapes = (_Bool)1;
 1991|      0|        elide_outer_quotes = (_Bool)0;
 1992|      0|        goto switch_break;
 1993|      0|case_6:
 1994|      0|        if ((unsigned int)quoting_style != 8U) {
 1995|      0|            left_quote = gettext_quote("`", quoting_style);
 1996|      0|            right_quote = gettext_quote("\'", quoting_style);
 1997|      0|        }
 1998|      0|        if (!elide_outer_quotes) {
 1999|      0|            quote_string = left_quote;
 2000|      0|            while (1) {
 2001|       |
 2002|      0|                if (!*quote_string) {
 2003|      0|                    goto while_break___0;
 2004|      0|                }
 2005|      0|                while (1) {
 2006|       |
 2007|      0|                    if (len < buffersize) {
 2008|      0|                        *(buffer + len) = (char)*quote_string;
 2009|      0|                    }
 2010|      0|                    len++;
 2011|      0|                    goto while_break___1;
 2012|      0|                }
 2013|      0|while_break___1:
 2014|      0|                quote_string++;
 2015|      0|            }
 2016|      0|while_break___0:
 2017|      0|            ;
 2018|      0|        }
 2019|      0|        backslash_escapes = (_Bool)1;
 2020|      0|        quote_string = right_quote;
 2021|      0|        quote_string_len = strlen(quote_string);
 2022|      0|        goto switch_break;
 2023|      0|case_1:
 2024|      0|        quoting_style = (enum quoting_style)2;
 2025|      0|        elide_outer_quotes = (_Bool)1;
 2026|      0|case_2:
 2027|      0|        if (!elide_outer_quotes) {
 2028|      0|            while (1) {
 2029|       |
 2030|      0|                if (len < buffersize) {
 2031|      0|                    *(buffer + len) = (char)'\'';
 2032|      0|                }
 2033|      0|                len++;
 2034|      0|                goto while_break___2;
 2035|      0|            }
 2036|      0|while_break___2:
 2037|      0|            ;
 2038|      0|        }
 2039|      0|        quote_string = "\'";
 2040|      0|        quote_string_len = (size_t)1;
 2041|      0|        goto switch_break;
 2042|      0|case_0:
 2043|      0|        elide_outer_quotes = (_Bool)0;
 2044|      0|        goto switch_break;
 2045|      0|switch_default:
 2046|      0|        abort();
 2047|      0|switch_break:
 2048|      0|        i = (size_t)0;
 2049|      0|        while (1) {
 2050|       |
 2051|      0|            if (argsize == 0xffffffffffffffffUL) {
 2052|      0|                tmp___6 = (int const) * (arg + i) == 0;
 2053|      0|            }
 2054|      0|            else {
 2055|      0|                tmp___6 = i == argsize;
 2056|      0|            }
 2057|      0|            if (tmp___6) {
 2058|      0|                goto while_break___3;
 2059|      0|            }
 2060|      0|            is_right_quote = (_Bool)0;
 2061|      0|            if (backslash_escapes) {
 2062|      0|                if (quote_string_len) {
 2063|      0|                    if (i + quote_string_len <= argsize) {
 2064|      0|                        tmp___0 = memcmp((void const *)(arg + i),
 2065|      0|                                         (void const *)quote_string, quote_string_len);
 2066|      0|                        if (tmp___0 == 0) {
 2067|      0|                            if (elide_outer_quotes) {
 2068|      0|                                goto force_outer_quoting_style;
 2069|      0|                            }
 2070|      0|                            is_right_quote = (_Bool)1;
 2071|      0|                        }
 2072|      0|                    }
 2073|      0|                }
 2074|      0|            }
 2075|      0|            c = (unsigned char)*(arg + i);
 2076|      0|            if ((int)c == 0) {
 2077|      0|                goto case_0___0;
 2078|      0|            }
 2079|      0|            if ((int)c == 63) {
 2080|      0|                goto case_63;
 2081|      0|            }
 2082|      0|            if ((int)c == 7) {
 2083|      0|                goto case_7___0;
 2084|      0|            }
 2085|      0|            if ((int)c == 8) {
 2086|      0|                goto case_8___0;
 2087|      0|            }
 2088|      0|            if ((int)c == 12) {
 2089|      0|                goto case_12;
 2090|      0|            }
 2091|      0|            if ((int)c == 10) {
 2092|      0|                goto case_10;
 2093|      0|            }
 2094|      0|            if ((int)c == 13) {
 2095|      0|                goto case_13;
 2096|      0|            }
 2097|      0|            if ((int)c == 9) {
 2098|      0|                goto case_9;
 2099|      0|            }
 2100|      0|            if ((int)c == 11) {
 2101|      0|                goto case_11;
 2102|      0|            }
 2103|      0|            if ((int)c == 92) {
 2104|      0|                goto case_92;
 2105|      0|            }
 2106|      0|            if ((int)c == 123) {
 2107|      0|                goto case_123;
 2108|      0|            }
 2109|      0|            if ((int)c == 125) {
 2110|      0|                goto case_123;
 2111|      0|            }
 2112|      0|            if ((int)c == 35) {
 2113|      0|                goto case_35;
 2114|      0|            }
 2115|      0|            if ((int)c == 126) {
 2116|      0|                goto case_35;
 2117|      0|            }
 2118|      0|            if ((int)c == 32) {
 2119|      0|                goto case_32;
 2120|      0|            }
 2121|      0|            if ((int)c == 33) {
 2122|      0|                goto case_32;
 2123|      0|            }
 2124|      0|            if ((int)c == 34) {
 2125|      0|                goto case_32;
 2126|      0|            }
 2127|      0|            if ((int)c == 36) {
 2128|      0|                goto case_32;
 2129|      0|            }
 2130|      0|            if ((int)c == 38) {
 2131|      0|                goto case_32;
 2132|      0|            }
 2133|      0|            if ((int)c == 40) {
 2134|      0|                goto case_32;
 2135|      0|            }
 2136|      0|            if ((int)c == 41) {
 2137|      0|                goto case_32;
 2138|      0|            }
 2139|      0|            if ((int)c == 42) {
 2140|      0|                goto case_32;
 2141|      0|            }
 2142|      0|            if ((int)c == 59) {
 2143|      0|                goto case_32;
 2144|      0|            }
 2145|      0|            if ((int)c == 60) {
 2146|      0|                goto case_32;
 2147|      0|            }
 2148|      0|            if ((int)c == 61) {
 2149|      0|                goto case_32;
 2150|      0|            }
 2151|      0|            if ((int)c == 62) {
 2152|      0|                goto case_32;
 2153|      0|            }
 2154|      0|            if ((int)c == 91) {
 2155|      0|                goto case_32;
 2156|      0|            }
 2157|      0|            if ((int)c == 94) {
 2158|      0|                goto case_32;
 2159|      0|            }
 2160|      0|            if ((int)c == 96) {
 2161|      0|                goto case_32;
 2162|      0|            }
 2163|      0|            if ((int)c == 124) {
 2164|      0|                goto case_32;
 2165|      0|            }
 2166|      0|            if ((int)c == 39) {
 2167|      0|                goto case_39___0;
 2168|      0|            }
 2169|      0|            if ((int)c == 37) {
 2170|      0|                goto case_37;
 2171|      0|            }
 2172|      0|            if ((int)c == 43) {
 2173|      0|                goto case_37;
 2174|      0|            }
 2175|      0|            if ((int)c == 44) {
 2176|      0|                goto case_37;
 2177|      0|            }
 2178|      0|            if ((int)c == 45) {
 2179|      0|                goto case_37;
 2180|      0|            }
 2181|      0|            if ((int)c == 46) {
 2182|      0|                goto case_37;
 2183|      0|            }
 2184|      0|            if ((int)c == 47) {
 2185|      0|                goto case_37;
 2186|      0|            }
 2187|      0|            if ((int)c == 48) {
 2188|      0|                goto case_37;
 2189|      0|            }
 2190|      0|            if ((int)c == 49) {
 2191|      0|                goto case_37;
 2192|      0|            }
 2193|      0|            if ((int)c == 50) {
 2194|      0|                goto case_37;
 2195|      0|            }
 2196|      0|            if ((int)c == 51) {
 2197|      0|                goto case_37;
 2198|      0|            }
 2199|      0|            if ((int)c == 52) {
 2200|      0|                goto case_37;
 2201|      0|            }
 2202|      0|            if ((int)c == 53) {
 2203|      0|                goto case_37;
 2204|      0|            }
 2205|      0|            if ((int)c == 54) {
 2206|      0|                goto case_37;
 2207|      0|            }
 2208|      0|            if ((int)c == 55) {
 2209|      0|                goto case_37;
 2210|      0|            }
 2211|      0|            if ((int)c == 56) {
 2212|      0|                goto case_37;
 2213|      0|            }
 2214|      0|            if ((int)c == 57) {
 2215|      0|                goto case_37;
 2216|      0|            }
 2217|      0|            if ((int)c == 58) {
 2218|      0|                goto case_37;
 2219|      0|            }
 2220|      0|            if ((int)c == 65) {
 2221|      0|                goto case_37;
 2222|      0|            }
 2223|      0|            if ((int)c == 66) {
 2224|      0|                goto case_37;
 2225|      0|            }
 2226|      0|            if ((int)c == 67) {
 2227|      0|                goto case_37;
 2228|      0|            }
 2229|      0|            if ((int)c == 68) {
 2230|      0|                goto case_37;
 2231|      0|            }
 2232|      0|            if ((int)c == 69) {
 2233|      0|                goto case_37;
 2234|      0|            }
 2235|      0|            if ((int)c == 70) {
 2236|      0|                goto case_37;
 2237|      0|            }
 2238|      0|            if ((int)c == 71) {
 2239|      0|                goto case_37;
 2240|      0|            }
 2241|      0|            if ((int)c == 72) {
 2242|      0|                goto case_37;
 2243|      0|            }
 2244|      0|            if ((int)c == 73) {
 2245|      0|                goto case_37;
 2246|      0|            }
 2247|      0|            if ((int)c == 74) {
 2248|      0|                goto case_37;
 2249|      0|            }
 2250|      0|            if ((int)c == 75) {
 2251|      0|                goto case_37;
 2252|      0|            }
 2253|      0|            if ((int)c == 76) {
 2254|      0|                goto case_37;
 2255|      0|            }
 2256|      0|            if ((int)c == 77) {
 2257|      0|                goto case_37;
 2258|      0|            }
 2259|      0|            if ((int)c == 78) {
 2260|      0|                goto case_37;
 2261|      0|            }
 2262|      0|            if ((int)c == 79) {
 2263|      0|                goto case_37;
 2264|      0|            }
 2265|      0|            if ((int)c == 80) {
 2266|      0|                goto case_37;
 2267|      0|            }
 2268|      0|            if ((int)c == 81) {
 2269|      0|                goto case_37;
 2270|      0|            }
 2271|      0|            if ((int)c == 82) {
 2272|      0|                goto case_37;
 2273|      0|            }
 2274|      0|            if ((int)c == 83) {
 2275|      0|                goto case_37;
 2276|      0|            }
 2277|      0|            if ((int)c == 84) {
 2278|      0|                goto case_37;
 2279|      0|            }
 2280|      0|            if ((int)c == 85) {
 2281|      0|                goto case_37;
 2282|      0|            }
 2283|      0|            if ((int)c == 86) {
 2284|      0|                goto case_37;
 2285|      0|            }
 2286|      0|            if ((int)c == 87) {
 2287|      0|                goto case_37;
 2288|      0|            }
 2289|      0|            if ((int)c == 88) {
 2290|      0|                goto case_37;
 2291|      0|            }
 2292|      0|            if ((int)c == 89) {
 2293|      0|                goto case_37;
 2294|      0|            }
 2295|      0|            if ((int)c == 90) {
 2296|      0|                goto case_37;
 2297|      0|            }
 2298|      0|            if ((int)c == 93) {
 2299|      0|                goto case_37;
 2300|      0|            }
 2301|      0|            if ((int)c == 95) {
 2302|      0|                goto case_37;
 2303|      0|            }
 2304|      0|            if ((int)c == 97) {
 2305|      0|                goto case_37;
 2306|      0|            }
 2307|      0|            if ((int)c == 98) {
 2308|      0|                goto case_37;
 2309|      0|            }
 2310|      0|            if ((int)c == 99) {
 2311|      0|                goto case_37;
 2312|      0|            }
 2313|      0|            if ((int)c == 100) {
 2314|      0|                goto case_37;
 2315|      0|            }
 2316|      0|            if ((int)c == 101) {
 2317|      0|                goto case_37;
 2318|      0|            }
 2319|      0|            if ((int)c == 102) {
 2320|      0|                goto case_37;
 2321|      0|            }
 2322|      0|            if ((int)c == 103) {
 2323|      0|                goto case_37;
 2324|      0|            }
 2325|      0|            if ((int)c == 104) {
 2326|      0|                goto case_37;
 2327|      0|            }
 2328|      0|            if ((int)c == 105) {
 2329|      0|                goto case_37;
 2330|      0|            }
 2331|      0|            if ((int)c == 106) {
 2332|      0|                goto case_37;
 2333|      0|            }
 2334|      0|            if ((int)c == 107) {
 2335|      0|                goto case_37;
 2336|      0|            }
 2337|      0|            if ((int)c == 108) {
 2338|      0|                goto case_37;
 2339|      0|            }
 2340|      0|            if ((int)c == 109) {
 2341|      0|                goto case_37;
 2342|      0|            }
 2343|      0|            if ((int)c == 110) {
 2344|      0|                goto case_37;
 2345|      0|            }
 2346|      0|            if ((int)c == 111) {
 2347|      0|                goto case_37;
 2348|      0|            }
 2349|      0|            if ((int)c == 112) {
 2350|      0|                goto case_37;
 2351|      0|            }
 2352|      0|            if ((int)c == 113) {
 2353|      0|                goto case_37;
 2354|      0|            }
 2355|      0|            if ((int)c == 114) {
 2356|      0|                goto case_37;
 2357|      0|            }
 2358|      0|            if ((int)c == 115) {
 2359|      0|                goto case_37;
 2360|      0|            }
 2361|      0|            if ((int)c == 116) {
 2362|      0|                goto case_37;
 2363|      0|            }
 2364|      0|            if ((int)c == 117) {
 2365|      0|                goto case_37;
 2366|      0|            }
 2367|      0|            if ((int)c == 118) {
 2368|      0|                goto case_37;
 2369|      0|            }
 2370|      0|            if ((int)c == 119) {
 2371|      0|                goto case_37;
 2372|      0|            }
 2373|      0|            if ((int)c == 120) {
 2374|      0|                goto case_37;
 2375|      0|            }
 2376|      0|            if ((int)c == 121) {
 2377|      0|                goto case_37;
 2378|      0|            }
 2379|      0|            if ((int)c == 122) {
 2380|      0|                goto case_37;
 2381|      0|            }
 2382|      0|            goto switch_default___2;
 2383|      0|case_0___0:
 2384|      0|            if (backslash_escapes) {
 2385|      0|                if (elide_outer_quotes) {
 2386|      0|                    goto force_outer_quoting_style;
 2387|      0|                }
 2388|      0|                while (1) {
 2389|       |
 2390|      0|                    if (len < buffersize) {
 2391|      0|                        *(buffer + len) = (char)'\\';
 2392|      0|                    }
 2393|      0|                    len++;
 2394|      0|                    goto while_break___4;
 2395|      0|                }
 2396|      0|while_break___4:
 2397|      0|                ;
 2398|      0|                if (i + 1UL < argsize) {
 2399|      0|                    if (48 <= (int)*(arg + (i + 1UL))) {
 2400|      0|                        if ((int const) * (arg + (i + 1UL)) <= 57) {
 2401|      0|                            while (1) {
 2402|       |
 2403|      0|                                if (len < buffersize) {
 2404|      0|                                    *(buffer + len) = (char)'0';
 2405|      0|                                }
 2406|      0|                                len++;
 2407|      0|                                goto while_break___5;
 2408|      0|                            }
 2409|      0|while_break___5:
 2410|      0|                            ;
 2411|      0|                            while (1) {
 2412|       |
 2413|      0|                                if (len < buffersize) {
 2414|      0|                                    *(buffer + len) = (char)'0';
 2415|      0|                                }
 2416|      0|                                len++;
 2417|      0|                                goto while_break___6;
 2418|      0|                            }
 2419|      0|while_break___6:
 2420|      0|                            ;
 2421|      0|                        }
 2422|      0|                    }
 2423|      0|                }
 2424|      0|                c = (unsigned char)'0';
 2425|      0|            }
 2426|      0|            else {
 2427|      0|                if (flags & 1) {
 2428|      0|                    goto __Cont;
 2429|      0|                }
 2430|      0|            }
 2431|      0|            goto switch_break___0;
 2432|      0|case_63:
 2433|      0|            if ((unsigned int)quoting_style == 2U) {
 2434|      0|                goto case_2___0;
 2435|      0|            }
 2436|      0|            if ((unsigned int)quoting_style == 3U) {
 2437|      0|                goto case_3___0;
 2438|      0|            }
 2439|      0|            goto switch_default___1;
 2440|      0|case_2___0:
 2441|      0|            if (elide_outer_quotes) {
 2442|      0|                goto force_outer_quoting_style;
 2443|      0|            }
 2444|      0|            goto switch_break___1;
 2445|      0|case_3___0:
 2446|      0|            if (flags & 4) {
 2447|      0|                if (i + 2UL < argsize) {
 2448|      0|                    if ((int const) * (arg + (i + 1UL)) == 63) {
 2449|      0|                        if ((int const) * (arg + (i + 2UL)) == 33) {
 2450|      0|                            goto case_33;
 2451|      0|                        }
 2452|      0|                        if ((int const) * (arg + (i + 2UL)) == 39) {
 2453|      0|                            goto case_33;
 2454|      0|                        }
 2455|      0|                        if ((int const) * (arg + (i + 2UL)) == 40) {
 2456|      0|                            goto case_33;
 2457|      0|                        }
 2458|      0|                        if ((int const) * (arg + (i + 2UL)) == 41) {
 2459|      0|                            goto case_33;
 2460|      0|                        }
 2461|      0|                        if ((int const) * (arg + (i + 2UL)) == 45) {
 2462|      0|                            goto case_33;
 2463|      0|                        }
 2464|      0|                        if ((int const) * (arg + (i + 2UL)) == 47) {
 2465|      0|                            goto case_33;
 2466|      0|                        }
 2467|      0|                        if ((int const) * (arg + (i + 2UL)) == 60) {
 2468|      0|                            goto case_33;
 2469|      0|                        }
 2470|      0|                        if ((int const) * (arg + (i + 2UL)) == 61) {
 2471|      0|                            goto case_33;
 2472|      0|                        }
 2473|      0|                        if ((int const) * (arg + (i + 2UL)) == 62) {
 2474|      0|                            goto case_33;
 2475|      0|                        }
 2476|      0|                        goto switch_default___0;
 2477|      0|case_33:
 2478|      0|                        if (elide_outer_quotes) {
 2479|      0|                            goto force_outer_quoting_style;
 2480|      0|                        }
 2481|      0|                        c = (unsigned char)*(arg + (i + 2UL));
 2482|      0|                        i += 2UL;
 2483|      0|                        while (1) {
 2484|       |
 2485|      0|                            if (len < buffersize) {
 2486|      0|                                *(buffer + len) = (char)'?';
 2487|      0|                            }
 2488|      0|                            len++;
 2489|      0|                            goto while_break___7;
 2490|      0|                        }
 2491|      0|while_break___7:
 2492|      0|                        ;
 2493|      0|                        while (1) {
 2494|       |
 2495|      0|                            if (len < buffersize) {
 2496|      0|                                *(buffer + len) = (char)'\"';
 2497|      0|                            }
 2498|      0|                            len++;
 2499|      0|                            goto while_break___8;
 2500|      0|                        }
 2501|      0|while_break___8:
 2502|      0|                        ;
 2503|      0|                        while (1) {
 2504|       |
 2505|      0|                            if (len < buffersize) {
 2506|      0|                                *(buffer + len) = (char)'\"';
 2507|      0|                            }
 2508|      0|                            len++;
 2509|      0|                            goto while_break___9;
 2510|      0|                        }
 2511|      0|while_break___9:
 2512|      0|                        ;
 2513|      0|                        while (1) {
 2514|       |
 2515|      0|                            if (len < buffersize) {
 2516|      0|                                *(buffer + len) = (char)'?';
 2517|      0|                            }
 2518|      0|                            len++;
 2519|      0|                            goto while_break___10;
 2520|      0|                        }
 2521|      0|while_break___10:
 2522|      0|                        ;
 2523|      0|                        goto switch_break___2;
 2524|      0|switch_default___0:
 2525|      0|                        goto switch_break___2;
 2526|      0|switch_break___2:
 2527|      0|                        ;
 2528|      0|                    }
 2529|      0|                }
 2530|      0|            }
 2531|      0|            goto switch_break___1;
 2532|      0|switch_default___1:
 2533|      0|            goto switch_break___1;
 2534|      0|switch_break___1:
 2535|      0|            ;
 2536|      0|            goto switch_break___0;
 2537|      0|case_7___0:
 2538|      0|            esc = (unsigned char)'a';
 2539|      0|            goto c_escape;
 2540|      0|case_8___0:
 2541|      0|            esc = (unsigned char)'b';
 2542|      0|            goto c_escape;
 2543|      0|case_12:
 2544|      0|            esc = (unsigned char)'f';
 2545|      0|            goto c_escape;
 2546|      0|case_10:
 2547|      0|            esc = (unsigned char)'n';
 2548|      0|            goto c_and_shell_escape;
 2549|      0|case_13:
 2550|      0|            esc = (unsigned char)'r';
 2551|      0|            goto c_and_shell_escape;
 2552|      0|case_9:
 2553|      0|            esc = (unsigned char)'t';
 2554|      0|            goto c_and_shell_escape;
 2555|      0|case_11:
 2556|      0|            esc = (unsigned char)'v';
 2557|      0|            goto c_escape;
 2558|      0|case_92:
 2559|      0|            esc = c;
 2560|      0|            if (backslash_escapes) {
 2561|      0|                if (elide_outer_quotes) {
 2562|      0|                    if (quote_string_len) {
 2563|      0|                        goto store_c;
 2564|      0|                    }
 2565|      0|                }
 2566|      0|            }
 2567|      0|c_and_shell_escape:
 2568|      0|            if ((unsigned int)quoting_style == 2U) {
 2569|      0|                if (elide_outer_quotes) {
 2570|      0|                    goto force_outer_quoting_style;
 2571|      0|                }
 2572|      0|            }
 2573|      0|c_escape:
 2574|      0|            if (backslash_escapes) {
 2575|      0|                c = esc;
 2576|      0|                goto store_escape;
 2577|      0|            }
 2578|      0|            goto switch_break___0;
 2579|      0|case_123:
 2580|      0|            if (argsize == 0xffffffffffffffffUL) {
 2581|      0|                tmp___1 = (int const) * (arg + 1) == 0;
 2582|      0|            }
 2583|      0|            else {
 2584|      0|                tmp___1 = argsize == 1UL;
 2585|      0|            }
 2586|      0|            if (!tmp___1) {
 2587|      0|                goto switch_break___0;
 2588|      0|            }
 2589|      0|case_35:
 2590|      0|            if (i != 0UL) {
 2591|      0|                goto switch_break___0;
 2592|      0|            }
 2593|      0|case_32:
 2594|      0|            if ((unsigned int)quoting_style == 2U) {
 2595|      0|                if (elide_outer_quotes) {
 2596|      0|                    goto force_outer_quoting_style;
 2597|      0|                }
 2598|      0|            }
 2599|      0|            goto switch_break___0;
 2600|      0|case_39___0:
 2601|      0|            if ((unsigned int)quoting_style == 2U) {
 2602|      0|                if (elide_outer_quotes) {
 2603|      0|                    goto force_outer_quoting_style;
 2604|      0|                }
 2605|      0|                while (1) {
 2606|       |
 2607|      0|                    if (len < buffersize) {
 2608|      0|                        *(buffer + len) = (char)'\'';
 2609|      0|                    }
 2610|      0|                    len++;
 2611|      0|                    goto while_break___11;
 2612|      0|                }
 2613|      0|while_break___11:
 2614|      0|                ;
 2615|      0|                while (1) {
 2616|       |
 2617|      0|                    if (len < buffersize) {
 2618|      0|                        *(buffer + len) = (char)'\\';
 2619|      0|                    }
 2620|      0|                    len++;
 2621|      0|                    goto while_break___12;
 2622|      0|                }
 2623|      0|while_break___12:
 2624|      0|                ;
 2625|      0|                while (1) {
 2626|       |
 2627|      0|                    if (len < buffersize) {
 2628|      0|                        *(buffer + len) = (char)'\'';
 2629|      0|                    }
 2630|      0|                    len++;
 2631|      0|                    goto while_break___13;
 2632|      0|                }
 2633|      0|while_break___13:
 2634|      0|                ;
 2635|      0|            }
 2636|      0|            goto switch_break___0;
 2637|      0|case_37:
 2638|      0|            goto switch_break___0;
 2639|      0|switch_default___2:
 2640|      0|            if (unibyte_locale) {
 2641|      0|                m = (size_t)1;
 2642|      0|                tmp___2 = __ctype_b_loc();
 2643|      0|                printable = (_Bool)(((int const) * (*tmp___2 + (int)c) & 16384) != 0);
 2644|      0|            }
 2645|      0|            else {
 2646|      0|                memset((void *)(&mbstate), 0, sizeof(mbstate));
 2647|      0|                m = (size_t)0;
 2648|      0|                printable = (_Bool)1;
 2649|      0|                if (argsize == 0xffffffffffffffffUL) {
 2650|      0|                    argsize = strlen(arg);
 2651|      0|                }
 2652|      0|                while (1) {
 2653|      0|                    tmp___3 = mbrtowc(&w, arg + (i + m), argsize - (i + m), &mbstate);
 2654|      0|                    bytes = tmp___3;
 2655|      0|                    if (bytes == 0UL) {
 2656|      0|                        goto while_break___14;
 2657|      0|                    }
 2658|      0|                    else {
 2659|      0|                        if (bytes == 0xffffffffffffffffUL) {
 2660|      0|                            printable = (_Bool)0;
 2661|      0|                            goto while_break___14;
 2662|      0|                        }
 2663|      0|                        else {
 2664|      0|                            if (bytes == 0xfffffffffffffffeUL) {
 2665|      0|                                printable = (_Bool)0;
 2666|      0|                                while (1) {
 2667|       |
 2668|      0|                                    if (i + m < argsize) {
 2669|      0|                                        if (!*(arg + (i + m))) {
 2670|      0|                                            goto while_break___15;
 2671|      0|                                        }
 2672|      0|                                    }
 2673|      0|                                    else {
 2674|      0|                                        goto while_break___15;
 2675|      0|                                    }
 2676|      0|                                    m++;
 2677|      0|                                }
 2678|      0|while_break___15:
 2679|      0|                                ;
 2680|      0|                                goto while_break___14;
 2681|      0|                            }
 2682|      0|                            else {
 2683|      0|                                if (elide_outer_quotes) {
 2684|      0|                                    if ((unsigned int)quoting_style == 2U) {
 2685|      0|                                        j = (size_t)1;
 2686|      0|                                        while (1) {
 2687|       |
 2688|      0|                                            if (!(j < bytes)) {
 2689|      0|                                                goto while_break___16;
 2690|      0|                                            }
 2691|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 91) {
 2692|      0|                                                goto case_91___0;
 2693|      0|                                            }
 2694|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 92) {
 2695|      0|                                                goto case_91___0;
 2696|      0|                                            }
 2697|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 94) {
 2698|      0|                                                goto case_91___0;
 2699|      0|                                            }
 2700|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 96) {
 2701|      0|                                                goto case_91___0;
 2702|      0|                                            }
 2703|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 124) {
 2704|      0|                                                goto case_91___0;
 2705|      0|                                            }
 2706|      0|                                            goto switch_default___3;
 2707|      0|case_91___0:
 2708|      0|                                            goto force_outer_quoting_style;
 2709|      0|switch_default___3:
 2710|      0|                                            goto switch_break___3;
 2711|      0|switch_break___3:
 2712|      0|                                            j++;
 2713|      0|                                        }
 2714|      0|while_break___16:
 2715|      0|                                        ;
 2716|      0|                                    }
 2717|      0|                                }
 2718|      0|                                tmp___4 = iswprint((wint_t)w);
 2719|      0|                                if (!tmp___4) {
 2720|      0|                                    printable = (_Bool)0;
 2721|      0|                                }
 2722|      0|                                m += bytes;
 2723|      0|                            }
 2724|      0|                        }
 2725|      0|                    }
 2726|      0|                    tmp___5 = mbsinit((mbstate_t const *)(&mbstate));
 2727|      0|                    if (tmp___5) {
 2728|      0|                        goto while_break___14;
 2729|      0|                    }
 2730|      0|                }
 2731|      0|while_break___14:
 2732|      0|                ;
 2733|      0|            }
 2734|      0|            if (1UL < m) {
 2735|      0|                goto _L___0;
 2736|      0|            }
 2737|      0|            else {
 2738|      0|                if (backslash_escapes) {
 2739|      0|                    if (!printable) {
 2740|      0|_L___0:
 2741|      0|                        ilim = i + m;
 2742|      0|                        while (1) {
 2743|       |
 2744|      0|                            if (backslash_escapes) {
 2745|      0|                                if (!printable) {
 2746|      0|                                    if (elide_outer_quotes) {
 2747|      0|                                        goto force_outer_quoting_style;
 2748|      0|                                    }
 2749|      0|                                    while (1) {
 2750|       |
 2751|      0|                                        if (len < buffersize) {
 2752|      0|                                            *(buffer + len) = (char)'\\';
 2753|      0|                                        }
 2754|      0|                                        len++;
 2755|      0|                                        goto while_break___18;
 2756|      0|                                    }
 2757|      0|while_break___18:
 2758|      0|                                    ;
 2759|      0|                                    while (1) {
 2760|       |
 2761|      0|                                        if (len < buffersize) {
 2762|      0|                                            *(buffer + len) = (char)(48 + ((int)c >> 6));
 2763|      0|                                        }
 2764|      0|                                        len++;
 2765|      0|                                        goto while_break___19;
 2766|      0|                                    }
 2767|      0|while_break___19:
 2768|      0|                                    ;
 2769|      0|                                    while (1) {
 2770|       |
 2771|      0|                                        if (len < buffersize) {
 2772|      0|                                            *(buffer + len) = (char)(48 + (((int)c >> 3) & 7));
 2773|      0|                                        }
 2774|      0|                                        len++;
 2775|      0|                                        goto while_break___20;
 2776|      0|                                    }
 2777|      0|while_break___20:
 2778|      0|                                    c = (unsigned char)(48 + ((int)c & 7));
 2779|      0|                                }
 2780|      0|                                else {
 2781|      0|                                    goto _L;
 2782|      0|                                }
 2783|      0|                            }
 2784|      0|                            else {
 2785|      0|_L:
 2786|      0|                                if (is_right_quote) {
 2787|      0|                                    while (1) {
 2788|       |
 2789|      0|                                        if (len < buffersize) {
 2790|      0|                                            *(buffer + len) = (char)'\\';
 2791|      0|                                        }
 2792|      0|                                        len++;
 2793|      0|                                        goto while_break___21;
 2794|      0|                                    }
 2795|      0|while_break___21:
 2796|      0|                                    is_right_quote = (_Bool)0;
 2797|      0|                                }
 2798|      0|                            }
 2799|      0|                            if (ilim <= i + 1UL) {
 2800|      0|                                goto while_break___17;
 2801|      0|                            }
 2802|      0|                            while (1) {
 2803|       |
 2804|      0|                                if (len < buffersize) {
 2805|      0|                                    *(buffer + len) = (char)c;
 2806|      0|                                }
 2807|      0|                                len++;
 2808|      0|                                goto while_break___22;
 2809|      0|                            }
 2810|      0|while_break___22:
 2811|      0|                            i++;
 2812|      0|                            c = (unsigned char)*(arg + i);
 2813|      0|                        }
 2814|      0|while_break___17:
 2815|      0|                        ;
 2816|      0|                        goto store_c;
 2817|      0|                    }
 2818|      0|                }
 2819|      0|            }
 2820|      0|switch_break___0:
 2821|      0|            ;
 2822|      0|            if (backslash_escapes) {
 2823|      0|                goto _L___3;
 2824|      0|            }
 2825|      0|            else {
 2826|      0|                if (elide_outer_quotes) {
 2827|      0|_L___3:
 2828|      0|                    if (quote_these_too) {
 2829|      0|                        if (!(*(quote_these_too + (unsigned long)c / (sizeof(int) * 8UL)) &
 2830|      0|                                (unsigned int const)(1 << (unsigned long)c %
 2831|      0|                                                     (sizeof(int) * 8UL)))) {
 2832|      0|                            goto _L___2;
 2833|      0|                        }
 2834|      0|                    }
 2835|      0|                    else {
 2836|      0|                        goto _L___2;
 2837|      0|                    }
 2838|      0|                }
 2839|      0|                else {
 2840|      0|_L___2:
 2841|      0|                    if (!is_right_quote) {
 2842|      0|                        goto store_c;
 2843|      0|                    }
 2844|      0|                }
 2845|      0|            }
 2846|      0|store_escape:
 2847|      0|            if (elide_outer_quotes) {
 2848|      0|                goto force_outer_quoting_style;
 2849|      0|            }
 2850|      0|            while (1) {
 2851|       |
 2852|      0|                if (len < buffersize) {
 2853|      0|                    *(buffer + len) = (char)'\\';
 2854|      0|                }
 2855|      0|                len++;
 2856|      0|                goto while_break___23;
 2857|      0|            }
 2858|      0|while_break___23:
 2859|      0|            ;
 2860|      0|store_c:
 2861|      0|            while (1) {
 2862|       |
 2863|      0|                if (len < buffersize) {
 2864|      0|                    *(buffer + len) = (char)c;
 2865|      0|                }
 2866|      0|                len++;
 2867|      0|                goto while_break___24;
 2868|      0|            }
 2869|      0|while_break___24:
 2870|      0|            ;
 2871|      0|__Cont:
 2872|      0|            i++;
 2873|      0|        }
 2874|      0|while_break___3:
 2875|      0|        ;
 2876|      0|        if (len == 0UL) {
 2877|      0|            if ((unsigned int)quoting_style == 2U) {
 2878|      0|                if (elide_outer_quotes) {
 2879|      0|                    goto force_outer_quoting_style;
 2880|      0|                }
 2881|      0|            }
 2882|      0|        }
 2883|      0|        if (quote_string) {
 2884|      0|            if (!elide_outer_quotes) {
 2885|      0|                while (1) {
 2886|       |
 2887|      0|                    if (!*quote_string) {
 2888|      0|                        goto while_break___25;
 2889|      0|                    }
 2890|      0|                    while (1) {
 2891|       |
 2892|      0|                        if (len < buffersize) {
 2893|      0|                            *(buffer + len) = (char)*quote_string;
 2894|      0|                        }
 2895|      0|                        len++;
 2896|      0|                        goto while_break___26;
 2897|      0|                    }
 2898|      0|while_break___26:
 2899|      0|                    quote_string++;
 2900|      0|                }
 2901|      0|while_break___25:
 2902|      0|                ;
 2903|      0|            }
 2904|      0|        }
 2905|      0|        if (len < buffersize) {
 2906|      0|            *(buffer + len) = (char)'\000';
 2907|      0|        }
 2908|      0|        return (len);
 2909|      0|force_outer_quoting_style:
 2910|      0|        tmp___7 = quotearg_buffer_restyled(
 2911|      0|                      buffer, buffersize, arg, argsize, quoting_style, flags & -3,
 2912|      0|                      (unsigned int const *)((void *)0), left_quote, right_quote);
 2913|      0|        return (tmp___7);
 2914|      0|    }
 2915|      0|}
 2916|       |static char slot0[256];
 2917|       |static unsigned int nslots = 1U;
 2918|       |static struct slotvec slotvec0 = {sizeof(slot0), slot0};
 2919|       |static struct slotvec *slotvec = &slotvec0;
 2920|       |static char *quotearg_n_options(int n, char const *arg, size_t argsize,
 2921|       |                                struct quoting_options const *options)
 2922|      0|{
 2923|      0|    int e;
 2924|      0|    int *tmp;
 2925|      0|    unsigned int n0;
 2926|      0|    struct slotvec *sv;
 2927|      0|    size_t n1;
 2928|      0|    _Bool preallocated;
 2929|      0|    int tmp___0;
 2930|      0|    struct slotvec *tmp___1;
 2931|      0|    size_t size;
 2932|      0|    char *val;
 2933|      0|    int flags;
 2934|      0|    size_t qsize;
 2935|      0|    size_t tmp___2;
 2936|      0|    int *tmp___3;
 2937|       |
 2938|      0|    {
 2939|      0|        tmp = __errno_location();
 2940|      0|        e = *tmp;
 2941|      0|        n0 = (unsigned int)n;
 2942|      0|        sv = slotvec;
 2943|      0|        if (n < 0) {
 2944|      0|            abort();
 2945|      0|        }
 2946|      0|        if (nslots <= n0) {
 2947|      0|            n1 = (size_t)(n0 + 1U);
 2948|      0|            preallocated = (_Bool)((unsigned long)sv == (unsigned long)(&slotvec0));
 2949|      0|            if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 2950|      0|                tmp___0 = -1;
 2951|      0|            }
 2952|      0|            else {
 2953|      0|                tmp___0 = -2;
 2954|      0|            }
 2955|      0|            if ((size_t)tmp___0 / sizeof(*sv) < n1) {
 2956|      0|                xalloc_die();
 2957|      0|            }
 2958|      0|            if (preallocated) {
 2959|      0|                tmp___1 = (struct slotvec *)((void *)0);
 2960|      0|            }
 2961|      0|            else {
 2962|      0|                tmp___1 = sv;
 2963|      0|            }
 2964|      0|            sv = (struct slotvec *)xrealloc((void *)tmp___1, n1 * sizeof(*sv));
 2965|      0|            slotvec = sv;
 2966|      0|            if (preallocated) {
 2967|      0|                *sv = slotvec0;
 2968|      0|            }
 2969|      0|            memset((void *)(sv + nslots), 0, (n1 - (size_t)nslots) * sizeof(*sv));
 2970|      0|            nslots = (unsigned int)n1;
 2971|      0|        }
 2972|      0|        size = (sv + n)->size;
 2973|      0|        val = (sv + n)->val;
 2974|      0|        flags = (int)(options->flags | 1);
 2975|      0|        tmp___2 = quotearg_buffer_restyled(
 2976|      0|                      val, size, arg, argsize, (enum quoting_style)options->style, flags,
 2977|      0|                      (unsigned int const *)(options->quote_these_too),
 2978|      0|                      (char const *)options->left_quote, (char const *)options->right_quote);
 2979|      0|        qsize = tmp___2;
 2980|      0|        if (size <= qsize) {
 2981|      0|            size = qsize + 1UL;
 2982|      0|            (sv + n)->size = size;
 2983|      0|            if ((unsigned long)val != (unsigned long)(slot0)) {
 2984|      0|                free((void *)val);
 2985|      0|            }
 2986|      0|            val = xcharalloc(size);
 2987|      0|            (sv + n)->val = val;
 2988|      0|            quotearg_buffer_restyled(val, size, arg, argsize,
 2989|      0|                                     (enum quoting_style)options->style, flags,
 2990|      0|                                     (unsigned int const *)(options->quote_these_too),
 2991|      0|                                     (char const *)options->left_quote,
 2992|      0|                                     (char const *)options->right_quote);
 2993|      0|        }
 2994|      0|        tmp___3 = __errno_location();
 2995|      0|        *tmp___3 = e;
 2996|      0|        return (val);
 2997|      0|    }
 2998|      0|}
 2999|       |char *quotearg_n_style(int n, enum quoting_style s, char const *arg)
 3000|      0|{
 3001|      0|    struct quoting_options o;
 3002|      0|    struct quoting_options tmp;
 3003|      0|    char *tmp___0;
 3004|       |
 3005|      0|    {
 3006|      0|        tmp = quoting_options_from_style(s);
 3007|      0|        o = tmp;
 3008|      0|        tmp___0 = quotearg_n_options(n, arg, (size_t)-1,
 3009|      0|                                     (struct quoting_options const *)(&o));
 3010|      0|        return (tmp___0);
 3011|      0|    }
 3012|      0|}
 3013|       |char *quotearg_char_mem(char const *arg, size_t argsize, char ch)
 3014|      0|{
 3015|      0|    struct quoting_options options;
 3016|      0|    char *tmp;
 3017|       |
 3018|      0|    {
 3019|      0|        options = default_quoting_options;
 3020|      0|        set_char_quoting(&options, ch, 1);
 3021|      0|        tmp = quotearg_n_options(0, arg, argsize,
 3022|      0|                                 (struct quoting_options const *)(&options));
 3023|      0|        return (tmp);
 3024|      0|    }
 3025|      0|}
 3026|       |char *quotearg_char(char const *arg, char ch)
 3027|      0|{
 3028|      0|    char *tmp;
 3029|       |
 3030|      0|    {
 3031|      0|        tmp = quotearg_char_mem(arg, (size_t)-1, ch);
 3032|      0|        return (tmp);
 3033|      0|    }
 3034|      0|}
 3035|       |char *quotearg_colon(char const *arg)
 3036|      0|{
 3037|      0|    char *tmp;
 3038|       |
 3039|      0|    {
 3040|      0|        tmp = quotearg_char(arg, (char)':');
 3041|      0|        return (tmp);
 3042|      0|    }
 3043|      0|}
 3044|       |char const *quote_n(int n, char const *name)
 3045|      0|{
 3046|      0|    char const *tmp;
 3047|       |
 3048|      0|    {
 3049|      0|        tmp = (char const *)quotearg_n_style(n, (enum quoting_style)6, name);
 3050|      0|        return (tmp);
 3051|      0|    }
 3052|      0|}
 3053|       |char const *quote(char const *name)
 3054|      0|{
 3055|      0|    char const *tmp;
 3056|       |
 3057|      0|    {
 3058|      0|        tmp = quote_n(0, name);
 3059|      0|        return (tmp);
 3060|      0|    }
 3061|      0|}
 3062|       |char const *program_name;
 3063|       |void set_program_name(char const *argv0);
 3064|       |extern char *program_invocation_name;
 3065|       |extern char *program_invocation_short_name;
 3066|       |extern int fputs(char const *__restrict __s, FILE *__restrict __stream);
 3067|       |char const *program_name = (char const *)((void *)0);
 3068|       |void set_program_name(char const *argv0)
 3069|      1|{
 3070|      1|    char const *slash;
 3071|      1|    char const *base;
 3072|      1|    int tmp;
 3073|      1|    int tmp___0;
 3074|       |
 3075|      1|    {
 3076|      1|        if ((unsigned long)argv0 == (unsigned long)((void *)0)) {
 3077|      0|            fputs("A NULL argv[0] was passed through an exec system call.\n", stderr);
 3078|      0|            abort();
 3079|      0|        }
 3080|      1|        slash = (char const *)strrchr(argv0, '/');
 3081|      1|        if ((unsigned long)slash != (unsigned long)((void *)0)) {
 3082|      1|            base = slash + 1;
 3083|      1|        }
 3084|      0|        else {
 3085|      0|            base = argv0;
 3086|      0|        }
 3087|      1|        if (base - argv0 >= 7L) {
 3088|      0|            tmp___0 = strncmp(base - 7, "/.libs/", (size_t)7);
 3089|      0|            if (tmp___0 == 0) {
 3090|      0|                argv0 = base;
 3091|      0|                tmp = strncmp(base, "lt-", (size_t)3);
 3092|      0|                if (tmp == 0) {
 3093|      0|                    argv0 = base + 3;
 3094|      0|                    program_invocation_short_name = (char *)argv0;
 3095|      0|                }
 3096|      0|            }
 3097|      0|        }
 3098|      1|        program_name = argv0;
 3099|      1|        program_invocation_name = (char *)argv0;
 3100|      1|        return;
 3101|      1|    }
 3102|      1|}
 3103|       |extern __attribute__((__nothrow__)) char *(__attribute__((
 3104|       |            __nonnull__(1, 2), __leaf__)) stpcpy)(char *__restrict __dest,
 3105|       |                    char const *__restrict __src);
 3106|       |extern DIR *(__attribute__((__nonnull__(1))) opendir)(char const *__name);
 3107|       |extern __attribute__((__nothrow__)) int(
 3108|       |    __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp);
 3109|       |DIR *opendir_safer(char const *name)
 3110|      0|{
 3111|      0|    DIR *dp;
 3112|      0|    DIR *tmp;
 3113|      0|    int fd;
 3114|      0|    int tmp___0;
 3115|      0|    DIR *newdp;
 3116|      0|    int e;
 3117|      0|    int f;
 3118|      0|    int tmp___1;
 3119|      0|    int *tmp___2;
 3120|      0|    int *tmp___3;
 3121|       |
 3122|      0|    {
 3123|      0|        tmp = opendir(name);
 3124|      0|        dp = tmp;
 3125|      0|        if (dp) {
 3126|      0|            tmp___0 = dirfd(dp);
 3127|      0|            fd = tmp___0;
 3128|      0|            if (0 <= fd) {
 3129|      0|                if (fd <= 2) {
 3130|      0|                    tmp___1 = dup_safer(fd);
 3131|      0|                    f = tmp___1;
 3132|      0|                    newdp = rpl_fdopendir(f);
 3133|      0|                    tmp___2 = __errno_location();
 3134|      0|                    e = *tmp___2;
 3135|      0|                    if (!newdp) {
 3136|      0|                        close(f);
 3137|      0|                    }
 3138|      0|                    closedir(dp);
 3139|      0|                    tmp___3 = __errno_location();
 3140|      0|                    *tmp___3 = e;
 3141|      0|                    dp = newdp;
 3142|      0|                }
 3143|      0|            }
 3144|      0|        }
 3145|      0|        return (dp);
 3146|      0|    }
 3147|      0|}
 3148|       |int openat_safer(int fd, char const *file, int flags, ...);
 3149|       |int openat_safer(int fd, char const *file, int flags, ...)
 3150|      3|{
 3151|      3|    mode_t mode;
 3152|      3|    va_list ap;
 3153|      3|    int tmp;
 3154|      3|    int tmp___0;
 3155|       |
 3156|      3|    {
 3157|      3|        mode = (mode_t)0;
 3158|      3|        if (flags & 64) {
 3159|      0|            __builtin_va_start(ap, flags);
 3160|      0|            mode = __builtin_va_arg(ap, mode_t);
 3161|      0|            __builtin_va_end(ap);
 3162|      0|        }
 3163|      3|        tmp = openat(fd, file, flags, mode);
 3164|      3|        tmp___0 = fd_safer(tmp);
 3165|      3|        return (tmp___0);
 3166|      3|    }
 3167|      3|}
 3168|       |int open_safer(char const *file, int flags, ...)
 3169|      0|{
 3170|      0|    mode_t mode;
 3171|      0|    va_list ap;
 3172|      0|    int tmp;
 3173|      0|    int tmp___0;
 3174|       |
 3175|      0|    {
 3176|      0|        mode = (mode_t)0;
 3177|      0|        if (flags & 64) {
 3178|      0|            __builtin_va_start(ap, flags);
 3179|      0|            mode = __builtin_va_arg(ap, mode_t);
 3180|      0|            __builtin_va_end(ap);
 3181|      0|        }
 3182|      0|        tmp = open(file, flags, mode);
 3183|      0|        tmp___0 = fd_safer(tmp);
 3184|      0|        return (tmp___0);
 3185|      0|    }
 3186|      0|}
 3187|       |int mbscasecmp(char const *s1, char const *s2)
 3188|      0|{
 3189|      0|    mbui_iterator_t iter1;
 3190|      0|    mbui_iterator_t iter2;
 3191|      0|    int cmp;
 3192|      0|    wint_t tmp;
 3193|      0|    wint_t tmp___0;
 3194|      0|    int tmp___1;
 3195|      0|    int tmp___2;
 3196|      0|    int tmp___4;
 3197|      0|    int tmp___5;
 3198|      0|    int tmp___7;
 3199|      0|    int tmp___8;
 3200|      0|    int tmp___9;
 3201|      0|    int tmp___10;
 3202|      0|    int tmp___11;
 3203|      0|    int tmp___12;
 3204|      0|    int tmp___13;
 3205|      0|    int tmp___14;
 3206|      0|    int tmp___15;
 3207|      0|    int tmp___16;
 3208|      0|    unsigned char const *p1;
 3209|      0|    unsigned char const *p2;
 3210|      0|    unsigned char c1;
 3211|      0|    unsigned char c2;
 3212|      0|    int tmp___18;
 3213|      0|    unsigned short const **tmp___19;
 3214|      0|    int tmp___21;
 3215|      0|    unsigned short const **tmp___22;
 3216|      0|    size_t tmp___25;
 3217|       |
 3218|      0|    {
 3219|      0|        if ((unsigned long)s1 == (unsigned long)s2) {
 3220|      0|            return (0);
 3221|      0|        }
 3222|      0|        tmp___25 = __ctype_get_mb_cur_max();
 3223|      0|        if (tmp___25 > 1UL) {
 3224|      0|            iter1.cur.ptr = s1;
 3225|      0|            iter1.in_shift = (_Bool)0;
 3226|      0|            memset((void *)(&iter1.state), '\000', sizeof(mbstate_t));
 3227|      0|            iter1.next_done = (_Bool)0;
 3228|      0|            iter2.cur.ptr = s2;
 3229|      0|            iter2.in_shift = (_Bool)0;
 3230|      0|            memset((void *)(&iter2.state), '\000', sizeof(mbstate_t));
 3231|      0|            iter2.next_done = (_Bool)0;
 3232|      0|            while (1) {
 3233|      0|                mbuiter_multi_next(&iter1);
 3234|      0|                if (iter1.cur.wc_valid) {
 3235|      0|                    if (iter1.cur.wc == 0) {
 3236|      0|                        tmp___13 = 0;
 3237|      0|                    }
 3238|      0|                    else {
 3239|      0|                        tmp___13 = 1;
 3240|      0|                    }
 3241|      0|                }
 3242|      0|                else {
 3243|      0|                    tmp___13 = 1;
 3244|      0|                }
 3245|      0|                if (tmp___13) {
 3246|      0|                    mbuiter_multi_next(&iter2);
 3247|      0|                    if (iter2.cur.wc_valid) {
 3248|      0|                        if (iter2.cur.wc == 0) {
 3249|      0|                            tmp___14 = 0;
 3250|      0|                        }
 3251|      0|                        else {
 3252|      0|                            tmp___14 = 1;
 3253|      0|                        }
 3254|      0|                    }
 3255|      0|                    else {
 3256|      0|                        tmp___14 = 1;
 3257|      0|                    }
 3258|      0|                    if (!tmp___14) {
 3259|      0|                        goto while_break;
 3260|      0|                    }
 3261|      0|                }
 3262|      0|                else {
 3263|      0|                    goto while_break;
 3264|      0|                }
 3265|      0|                if (iter1.cur.wc_valid) {
 3266|      0|                    if (iter2.cur.wc_valid) {
 3267|      0|                        tmp = towlower((wint_t)iter1.cur.wc);
 3268|      0|                        tmp___0 = towlower((wint_t)iter2.cur.wc);
 3269|      0|                        tmp___1 = (int)tmp - (int)tmp___0;
 3270|      0|                    }
 3271|      0|                    else {
 3272|      0|                        tmp___1 = -1;
 3273|      0|                    }
 3274|      0|                    tmp___12 = tmp___1;
 3275|      0|                }
 3276|      0|                else {
 3277|      0|                    if (iter2.cur.wc_valid) {
 3278|      0|                        tmp___11 = 1;
 3279|      0|                    }
 3280|      0|                    else {
 3281|      0|                        if (iter1.cur.bytes == iter2.cur.bytes) {
 3282|      0|                            tmp___2 = memcmp((void const *)iter1.cur.ptr,
 3283|      0|                                             (void const *)iter2.cur.ptr, iter1.cur.bytes);
 3284|      0|                            tmp___10 = tmp___2;
 3285|      0|                        }
 3286|      0|                        else {
 3287|      0|                            if (iter1.cur.bytes < iter2.cur.bytes) {
 3288|      0|                                tmp___5 = memcmp((void const *)iter1.cur.ptr,
 3289|      0|                                                 (void const *)iter2.cur.ptr, iter1.cur.bytes);
 3290|      0|                                if (tmp___5 > 0) {
 3291|      0|                                    tmp___4 = 1;
 3292|      0|                                }
 3293|      0|                                else {
 3294|      0|                                    tmp___4 = -1;
 3295|      0|                                }
 3296|      0|                                tmp___9 = tmp___4;
 3297|      0|                            }
 3298|      0|                            else {
 3299|      0|                                tmp___8 = memcmp((void const *)iter1.cur.ptr,
 3300|      0|                                                 (void const *)iter2.cur.ptr, iter2.cur.bytes);
 3301|      0|                                if (tmp___8 >= 0) {
 3302|      0|                                    tmp___7 = 1;
 3303|      0|                                }
 3304|      0|                                else {
 3305|      0|                                    tmp___7 = -1;
 3306|      0|                                }
 3307|      0|                                tmp___9 = tmp___7;
 3308|      0|                            }
 3309|      0|                            tmp___10 = tmp___9;
 3310|      0|                        }
 3311|      0|                        tmp___11 = tmp___10;
 3312|      0|                    }
 3313|      0|                    tmp___12 = tmp___11;
 3314|      0|                }
 3315|      0|                cmp = tmp___12;
 3316|      0|                if (cmp != 0) {
 3317|      0|                    return (cmp);
 3318|      0|                }
 3319|      0|                iter1.cur.ptr += iter1.cur.bytes;
 3320|      0|                iter1.next_done = (_Bool)0;
 3321|      0|                iter2.cur.ptr += iter2.cur.bytes;
 3322|      0|                iter2.next_done = (_Bool)0;
 3323|      0|            }
 3324|      0|while_break:
 3325|      0|            mbuiter_multi_next(&iter1);
 3326|      0|            if (iter1.cur.wc_valid) {
 3327|      0|                if (iter1.cur.wc == 0) {
 3328|      0|                    tmp___15 = 0;
 3329|      0|                }
 3330|      0|                else {
 3331|      0|                    tmp___15 = 1;
 3332|      0|                }
 3333|      0|            }
 3334|      0|            else {
 3335|      0|                tmp___15 = 1;
 3336|      0|            }
 3337|      0|            if (tmp___15) {
 3338|      0|                return (1);
 3339|      0|            }
 3340|      0|            mbuiter_multi_next(&iter2);
 3341|      0|            if (iter2.cur.wc_valid) {
 3342|      0|                if (iter2.cur.wc == 0) {
 3343|      0|                    tmp___16 = 0;
 3344|      0|                }
 3345|      0|                else {
 3346|      0|                    tmp___16 = 1;
 3347|      0|                }
 3348|      0|            }
 3349|      0|            else {
 3350|      0|                tmp___16 = 1;
 3351|      0|            }
 3352|      0|            if (tmp___16) {
 3353|      0|                return (-1);
 3354|      0|            }
 3355|      0|            return (0);
 3356|      0|        }
 3357|      0|        else {
 3358|      0|            p1 = (unsigned char const *)s1;
 3359|      0|            p2 = (unsigned char const *)s2;
 3360|      0|            while (1) {
 3361|      0|                tmp___19 = __ctype_b_loc();
 3362|      0|                if ((int const) * (*tmp___19 + (int)*p1) & 256) {
 3363|      0|                    tmp___18 = tolower((int)*p1);
 3364|      0|                    c1 = (unsigned char)tmp___18;
 3365|      0|                }
 3366|      0|                else {
 3367|      0|                    c1 = (unsigned char)*p1;
 3368|      0|                }
 3369|      0|                tmp___22 = __ctype_b_loc();
 3370|      0|                if ((int const) * (*tmp___22 + (int)*p2) & 256) {
 3371|      0|                    tmp___21 = tolower((int)*p2);
 3372|      0|                    c2 = (unsigned char)tmp___21;
 3373|      0|                }
 3374|      0|                else {
 3375|      0|                    c2 = (unsigned char)*p2;
 3376|      0|                }
 3377|      0|                if ((int)c1 == 0) {
 3378|      0|                    goto while_break___0;
 3379|      0|                }
 3380|      0|                p1++;
 3381|      0|                p2++;
 3382|      0|                if (!((int)c1 == (int)c2)) {
 3383|      0|                    goto while_break___0;
 3384|      0|                }
 3385|      0|            }
 3386|      0|while_break___0:
 3387|      0|            ;
 3388|      0|            return ((int)c1 - (int)c2);
 3389|      0|        }
 3390|      0|    }
 3391|      0|}
 3392|       |unsigned int const is_basic_table[8] = {
 3393|       |    (unsigned int const)6656, (unsigned int const)4294967279U,
 3394|       |    (unsigned int const)4294967294U, (unsigned int const)2147483646
 3395|       |};
 3396|       |extern __attribute__((__nothrow__, __noreturn__)) void(
 3397|       |    __attribute__((__leaf__)) exit)(int __status);
 3398|       |extern int optind;
 3399|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) getopt_long)(
 3400|       |    int ___argc, char *const *___argv, char const *__shortopts,
 3401|       |    struct option const *__longopts, int *__longind);
 3402|       |#pragma weak pthread_mutex_init
 3403|       |#pragma weak pthread_mutex_lock
 3404|       |#pragma weak pthread_mutex_unlock
 3405|       |#pragma weak pthread_mutex_destroy
 3406|       |#pragma weak pthread_rwlock_init
 3407|       |#pragma weak pthread_rwlock_rdlock
 3408|       |#pragma weak pthread_rwlock_wrlock
 3409|       |#pragma weak pthread_rwlock_unlock
 3410|       |#pragma weak pthread_rwlock_destroy
 3411|       |#pragma weak pthread_once
 3412|       |#pragma weak pthread_cond_init
 3413|       |#pragma weak pthread_cond_wait
 3414|       |#pragma weak pthread_cond_signal
 3415|       |#pragma weak pthread_cond_broadcast
 3416|       |#pragma weak pthread_cond_destroy
 3417|       |#pragma weak pthread_mutexattr_init
 3418|       |#pragma weak pthread_mutexattr_settype
 3419|       |#pragma weak pthread_mutexattr_destroy
 3420|       |#pragma weak pthread_self
 3421|       |#pragma weak pthread_cancel
 3422|       |extern struct passwd *getpwuid(__uid_t __uid);
 3423|       |void i_ring_init(I_ring *ir, int default_val);
 3424|       |int i_ring_push(I_ring *ir, int val);
 3425|       |int i_ring_pop(I_ring *ir);
 3426|       |_Bool i_ring_empty(I_ring const *ir);
 3427|       |void i_ring_init(I_ring *ir, int default_val)
 3428|      1|{
 3429|      1|    int i;
 3430|       |
 3431|      1|    {
 3432|      1|        ir->ir_empty = (_Bool)1;
 3433|      1|        ir->ir_front = 0U;
 3434|      1|        ir->ir_back = 0U;
 3435|      1|        i = 0;
 3436|      5|        while (1) {
 3437|       |
 3438|      5|            if (!(i < 4)) {
 3439|      1|                goto while_break;
 3440|      1|            }
 3441|      4|            ir->ir_data[i] = default_val;
 3442|      4|            i++;
 3443|      4|        }
 3444|      1|while_break:
 3445|      1|        ir->ir_default_val = default_val;
 3446|      1|        return;
 3447|      1|    }
 3448|      1|}
 3449|       |_Bool i_ring_empty(I_ring const *ir)
 3450|     13|{
 3451|       |
 3452|     13|    {
 3453|     13|        return ((_Bool)ir->ir_empty);
 3454|     13|    }
 3455|     13|}
 3456|       |int i_ring_push(I_ring *ir, int val)
 3457|      5|{
 3458|      5|    unsigned int dest_idx;
 3459|      5|    int old_val;
 3460|       |
 3461|      5|    {
 3462|      5|        dest_idx = (ir->ir_front + (unsigned int)(!ir->ir_empty)) % 4U;
 3463|      5|        old_val = ir->ir_data[dest_idx];
 3464|      5|        ir->ir_data[dest_idx] = val;
 3465|      5|        ir->ir_front = dest_idx;
 3466|      5|        if (dest_idx == ir->ir_back) {
 3467|      2|            ir->ir_back = (ir->ir_back + (unsigned int)(!ir->ir_empty)) % 4U;
 3468|      2|        }
 3469|      5|        ir->ir_empty = (_Bool)0;
 3470|      5|        return (old_val);
 3471|      5|    }
 3472|      5|}
 3473|       |int i_ring_pop(I_ring *ir)
 3474|      5|{
 3475|      5|    int top_val;
 3476|      5|    _Bool tmp;
 3477|       |
 3478|      5|    {
 3479|      5|        tmp = i_ring_empty((I_ring const *)ir);
 3480|      5|        if (tmp) {
 3481|      0|            abort();
 3482|      0|        }
 3483|      5|        top_val = ir->ir_data[ir->ir_front];
 3484|      5|        ir->ir_data[ir->ir_front] = ir->ir_default_val;
 3485|      5|        if (ir->ir_front == ir->ir_back) {
 3486|      2|            ir->ir_empty = (_Bool)1;
 3487|      2|        }
 3488|      3|        else {
 3489|      3|            ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
 3490|      3|        }
 3491|      5|        return (top_val);
 3492|      5|    }
 3493|      5|}
 3494|       |_Bool(__attribute__((__warn_unused_result__)) hash_rehash)(
 3495|       |    Hash_table *table___0, size_t candidate);
 3496|       |void *hash_delete(Hash_table *table___0, void const *entry);
 3497|       |__inline static size_t rotr_sz(size_t x, int n)
 3498|      0|{
 3499|       |
 3500|      0|    {
 3501|      0|        return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long)n))) &
 3502|      0|                0xffffffffffffffffUL);
 3503|      0|    }
 3504|      0|}
 3505|       |static struct hash_tuning const default_tuning = {
 3506|       |    (float)0.0, (float)1.0, (float)0.8, (float)1.414, (_Bool)0
 3507|       |};
 3508|       |void *hash_lookup(Hash_table const *table___0, void const *entry)
 3509|      0|{
 3510|      0|    struct hash_entry const *bucket;
 3511|      0|    size_t tmp;
 3512|      0|    struct hash_entry const *cursor;
 3513|      0|    _Bool tmp___0;
 3514|       |
 3515|      0|    {
 3516|      0|        tmp = (*(table___0->hasher))(entry, (size_t)table___0->n_buckets);
 3517|      0|        bucket = (struct hash_entry const *)(table___0->bucket + tmp);
 3518|      0|        if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3519|      0|            abort();
 3520|      0|        }
 3521|      0|        if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
 3522|      0|            return ((void *)0);
 3523|      0|        }
 3524|      0|        cursor = bucket;
 3525|      0|        while (1) {
 3526|       |
 3527|      0|            if (!cursor) {
 3528|      0|                goto while_break;
 3529|      0|            }
 3530|      0|            if ((unsigned long)entry == (unsigned long)cursor->data) {
 3531|      0|                return ((void *)cursor->data);
 3532|      0|            }
 3533|      0|            else {
 3534|      0|                tmp___0 = (*(table___0->comparator))(entry, (void const *)cursor->data);
 3535|      0|                if (tmp___0) {
 3536|      0|                    return ((void *)cursor->data);
 3537|      0|                }
 3538|      0|            }
 3539|      0|            cursor = (struct hash_entry const *)cursor->next;
 3540|      0|        }
 3541|      0|while_break:
 3542|      0|        ;
 3543|      0|        return ((void *)0);
 3544|      0|    }
 3545|      0|}
 3546|       |size_t hash_string(char const *string, size_t n_buckets)
 3547|      0|{
 3548|      0|    size_t value;
 3549|      0|    unsigned char ch;
 3550|       |
 3551|      0|    {
 3552|      0|        value = (size_t)0;
 3553|      0|        while (1) {
 3554|      0|            ch = (unsigned char)*string;
 3555|      0|            if (!ch) {
 3556|      0|                goto while_break;
 3557|      0|            }
 3558|      0|            value = (value * 31UL + (size_t)ch) % n_buckets;
 3559|      0|            string++;
 3560|      0|        }
 3561|      0|while_break:
 3562|      0|        ;
 3563|      0|        return (value);
 3564|      0|    }
 3565|      0|}
 3566|       |static _Bool is_prime(size_t candidate)
 3567|      0|{
 3568|      0|    size_t divisor;
 3569|      0|    size_t square;
 3570|      0|    int tmp;
 3571|       |
 3572|      0|    {
 3573|      0|        divisor = (size_t)3;
 3574|      0|        square = divisor * divisor;
 3575|      0|        while (1) {
 3576|       |
 3577|      0|            if (square < candidate) {
 3578|      0|                if (!(candidate % divisor)) {
 3579|      0|                    goto while_break;
 3580|      0|                }
 3581|      0|            }
 3582|      0|            else {
 3583|      0|                goto while_break;
 3584|      0|            }
 3585|      0|            divisor++;
 3586|      0|            square += 4UL * divisor;
 3587|      0|            divisor++;
 3588|      0|        }
 3589|      0|while_break:
 3590|      0|        ;
 3591|      0|        if (candidate % divisor) {
 3592|      0|            tmp = 1;
 3593|      0|        }
 3594|      0|        else {
 3595|      0|            tmp = 0;
 3596|      0|        }
 3597|      0|        return ((_Bool)tmp);
 3598|      0|    }
 3599|      0|}
 3600|       |static size_t next_prime(size_t candidate)
 3601|      0|{
 3602|      0|    _Bool tmp;
 3603|       |
 3604|      0|    {
 3605|      0|        if (candidate < 10UL) {
 3606|      0|            candidate = (size_t)10;
 3607|      0|        }
 3608|      0|        candidate |= 1UL;
 3609|      0|        while (1) {
 3610|       |
 3611|      0|            if (0xffffffffffffffffUL != candidate) {
 3612|      0|                tmp = is_prime(candidate);
 3613|      0|                if (tmp) {
 3614|      0|                    goto while_break;
 3615|      0|                }
 3616|      0|            }
 3617|      0|            else {
 3618|      0|                goto while_break;
 3619|      0|            }
 3620|      0|            candidate += 2UL;
 3621|      0|        }
 3622|      0|while_break:
 3623|      0|        ;
 3624|      0|        return (candidate);
 3625|      0|    }
 3626|      0|}
 3627|       |static size_t raw_hasher(void const *data, size_t n)
 3628|      0|{
 3629|      0|    size_t val;
 3630|      0|    size_t tmp;
 3631|       |
 3632|      0|    {
 3633|      0|        tmp = rotr_sz((size_t)data, 3);
 3634|      0|        val = tmp;
 3635|      0|        return (val % n);
 3636|      0|    }
 3637|      0|}
 3638|       |static _Bool raw_comparator(void const *a, void const *b)
 3639|      0|{
 3640|       |
 3641|      0|    {
 3642|      0|        return ((_Bool)((unsigned long)a == (unsigned long)b));
 3643|      0|    }
 3644|      0|}
 3645|       |static _Bool check_tuning(Hash_table *table___0)
 3646|      0|{
 3647|      0|    Hash_tuning const *tuning;
 3648|      0|    float epsilon;
 3649|       |
 3650|      0|    {
 3651|      0|        tuning = table___0->tuning;
 3652|      0|        if ((unsigned long)tuning == (unsigned long)(&default_tuning)) {
 3653|      0|            return ((_Bool)1);
 3654|      0|        }
 3655|      0|        epsilon = 0.1f;
 3656|      0|        if (epsilon < (float)tuning->growth_threshold) {
 3657|      0|            if (tuning->growth_threshold < (float const)((float)1 - epsilon)) {
 3658|      0|                if ((float)1 + epsilon < (float)tuning->growth_factor) {
 3659|      0|                    if ((float const)0 <= tuning->shrink_threshold) {
 3660|      0|                        if (tuning->shrink_threshold + (float const)epsilon <
 3661|      0|                                tuning->shrink_factor) {
 3662|      0|                            if (tuning->shrink_factor <= (float const)1) {
 3663|      0|                                if (tuning->shrink_threshold + (float const)epsilon <
 3664|      0|                                        tuning->growth_threshold) {
 3665|      0|                                    return ((_Bool)1);
 3666|      0|                                }
 3667|      0|                            }
 3668|      0|                        }
 3669|      0|                    }
 3670|      0|                }
 3671|      0|            }
 3672|      0|        }
 3673|      0|        table___0->tuning = &default_tuning;
 3674|      0|        return ((_Bool)0);
 3675|      0|    }
 3676|      0|}
 3677|       |static size_t compute_bucket_size(size_t candidate, Hash_tuning const *tuning)
 3678|      0|{
 3679|      0|    float new_candidate;
 3680|      0|    int tmp;
 3681|       |
 3682|      0|    {
 3683|      0|        if (!tuning->is_n_buckets) {
 3684|      0|            new_candidate =
 3685|      0|                (float)((float const)candidate / tuning->growth_threshold);
 3686|      0|            if ((float)0xffffffffffffffffUL <= new_candidate) {
 3687|      0|                return ((size_t)0);
 3688|      0|            }
 3689|      0|            candidate = (size_t)new_candidate;
 3690|      0|        }
 3691|      0|        candidate = next_prime(candidate);
 3692|      0|        if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 3693|      0|            tmp = -1;
 3694|      0|        }
 3695|      0|        else {
 3696|      0|            tmp = -2;
 3697|      0|        }
 3698|      0|        if ((size_t)tmp / sizeof(struct hash_entry *) < candidate) {
 3699|      0|            return ((size_t)0);
 3700|      0|        }
 3701|      0|        return (candidate);
 3702|      0|    }
 3703|      0|}
 3704|       |Hash_table *(__attribute__((__warn_unused_result__)) hash_initialize)(
 3705|       |    size_t candidate, Hash_tuning const *tuning,
 3706|       |    size_t (*hasher)(void const *, size_t),
 3707|       |    _Bool (*comparator)(void const *, void const *),
 3708|       |    void (*data_freer)(void *))
 3709|      0|{
 3710|      0|    Hash_table *table___0;
 3711|      0|    _Bool tmp;
 3712|       |
 3713|      0|    {
 3714|      0|        if ((unsigned long)hasher == (unsigned long)((void *)0)) {
 3715|      0|            hasher = &raw_hasher;
 3716|      0|        }
 3717|      0|        if ((unsigned long)comparator == (unsigned long)((void *)0)) {
 3718|      0|            comparator = &raw_comparator;
 3719|      0|        }
 3720|      0|        table___0 = (Hash_table *)malloc(sizeof(*table___0));
 3721|      0|        if ((unsigned long)table___0 == (unsigned long)((void *)0)) {
 3722|      0|            return ((Hash_table *)((void *)0));
 3723|      0|        }
 3724|      0|        if (!tuning) {
 3725|      0|            tuning = &default_tuning;
 3726|      0|        }
 3727|      0|        table___0->tuning = tuning;
 3728|      0|        tmp = check_tuning(table___0);
 3729|      0|        if (!tmp) {
 3730|      0|            goto fail;
 3731|      0|        }
 3732|      0|        table___0->n_buckets = compute_bucket_size(candidate, tuning);
 3733|      0|        if (!table___0->n_buckets) {
 3734|      0|            goto fail;
 3735|      0|        }
 3736|      0|        table___0->bucket = (struct hash_entry *)calloc(
 3737|      0|                                table___0->n_buckets, sizeof(*(table___0->bucket)));
 3738|      0|        if ((unsigned long)table___0->bucket == (unsigned long)((void *)0)) {
 3739|      0|            goto fail;
 3740|      0|        }
 3741|      0|        table___0->bucket_limit =
 3742|      0|            (struct hash_entry const *)(table___0->bucket + table___0->n_buckets);
 3743|      0|        table___0->n_buckets_used = (size_t)0;
 3744|      0|        table___0->n_entries = (size_t)0;
 3745|      0|        table___0->hasher = hasher;
 3746|      0|        table___0->comparator = comparator;
 3747|      0|        table___0->data_freer = data_freer;
 3748|      0|        table___0->free_entry_list = (struct hash_entry *)((void *)0);
 3749|      0|        return (table___0);
 3750|      0|fail:
 3751|      0|        free((void *)table___0);
 3752|      0|        return ((Hash_table *)((void *)0));
 3753|      0|    }
 3754|      0|}
 3755|       |void hash_free(Hash_table *table___0)
 3756|      0|{
 3757|      0|    struct hash_entry *bucket;
 3758|      0|    struct hash_entry *cursor;
 3759|      0|    struct hash_entry *next;
 3760|       |
 3761|      0|    {
 3762|      0|        if (table___0->data_freer) {
 3763|      0|            if (table___0->n_entries) {
 3764|      0|                bucket = table___0->bucket;
 3765|      0|                while (1) {
 3766|       |
 3767|      0|                    if (!((unsigned long)bucket <
 3768|      0|                            (unsigned long)table___0->bucket_limit)) {
 3769|      0|                        goto while_break;
 3770|      0|                    }
 3771|      0|                    if (bucket->data) {
 3772|      0|                        cursor = bucket;
 3773|      0|                        while (1) {
 3774|       |
 3775|      0|                            if (!cursor) {
 3776|      0|                                goto while_break___0;
 3777|      0|                            }
 3778|      0|                            (*(table___0->data_freer))(cursor->data);
 3779|      0|                            cursor = cursor->next;
 3780|      0|                        }
 3781|      0|while_break___0:
 3782|      0|                        ;
 3783|      0|                    }
 3784|      0|                    bucket++;
 3785|      0|                }
 3786|      0|while_break:
 3787|      0|                ;
 3788|      0|            }
 3789|      0|        }
 3790|      0|        bucket = table___0->bucket;
 3791|      0|        while (1) {
 3792|       |
 3793|      0|            if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3794|      0|                goto while_break___1;
 3795|      0|            }
 3796|      0|            cursor = bucket->next;
 3797|      0|            while (1) {
 3798|       |
 3799|      0|                if (!cursor) {
 3800|      0|                    goto while_break___2;
 3801|      0|                }
 3802|      0|                next = cursor->next;
 3803|      0|                free((void *)cursor);
 3804|      0|                cursor = next;
 3805|      0|            }
 3806|      0|while_break___2:
 3807|      0|            bucket++;
 3808|      0|        }
 3809|      0|while_break___1:
 3810|      0|        cursor = table___0->free_entry_list;
 3811|      0|        while (1) {
 3812|       |
 3813|      0|            if (!cursor) {
 3814|      0|                goto while_break___3;
 3815|      0|            }
 3816|      0|            next = cursor->next;
 3817|      0|            free((void *)cursor);
 3818|      0|            cursor = next;
 3819|      0|        }
 3820|      0|while_break___3:
 3821|      0|        free((void *)table___0->bucket);
 3822|      0|        free((void *)table___0);
 3823|      0|        return;
 3824|      0|    }
 3825|      0|}
 3826|       |static struct hash_entry *allocate_entry(Hash_table *table___0)
 3827|      0|{
 3828|      0|    struct hash_entry *new;
 3829|       |
 3830|      0|    {
 3831|      0|        if (table___0->free_entry_list) {
 3832|      0|            new = table___0->free_entry_list;
 3833|      0|            table___0->free_entry_list = new->next;
 3834|      0|        }
 3835|      0|        else {
 3836|      0|            new = (struct hash_entry *)malloc(sizeof(*new));
 3837|      0|        }
 3838|      0|        return (new);
 3839|      0|    }
 3840|      0|}
 3841|       |static void free_entry(Hash_table *table___0, struct hash_entry *entry)
 3842|      0|{
 3843|       |
 3844|      0|    {
 3845|      0|        entry->data = (void *)0;
 3846|      0|        entry->next = table___0->free_entry_list;
 3847|      0|        table___0->free_entry_list = entry;
 3848|      0|        return;
 3849|      0|    }
 3850|      0|}
 3851|       |static void *hash_find_entry(Hash_table *table___0, void const *entry,
 3852|       |                             struct hash_entry **bucket_head, _Bool delete)
 3853|      0|{
 3854|      0|    struct hash_entry *bucket;
 3855|      0|    size_t tmp;
 3856|      0|    struct hash_entry *cursor;
 3857|      0|    void *data;
 3858|      0|    struct hash_entry *next;
 3859|      0|    _Bool tmp___0;
 3860|      0|    void *data___0;
 3861|      0|    struct hash_entry *next___0;
 3862|      0|    _Bool tmp___1;
 3863|       |
 3864|      0|    {
 3865|      0|        tmp = (*(table___0->hasher))(entry, table___0->n_buckets);
 3866|      0|        bucket = table___0->bucket + tmp;
 3867|      0|        if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3868|      0|            abort();
 3869|      0|        }
 3870|      0|        *bucket_head = bucket;
 3871|      0|        if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
 3872|      0|            return ((void *)0);
 3873|      0|        }
 3874|      0|        if ((unsigned long)entry == (unsigned long)bucket->data) {
 3875|      0|            goto _L;
 3876|      0|        }
 3877|      0|        else {
 3878|      0|            tmp___0 = (*(table___0->comparator))(entry, (void const *)bucket->data);
 3879|      0|            if (tmp___0) {
 3880|      0|_L:
 3881|      0|                data = bucket->data;
 3882|      0|                if (delete) {
 3883|      0|                    if (bucket->next) {
 3884|      0|                        next = bucket->next;
 3885|      0|                        *bucket = *next;
 3886|      0|                        free_entry(table___0, next);
 3887|      0|                    }
 3888|      0|                    else {
 3889|      0|                        bucket->data = (void *)0;
 3890|      0|                    }
 3891|      0|                }
 3892|      0|                return (data);
 3893|      0|            }
 3894|      0|        }
 3895|      0|        cursor = bucket;
 3896|      0|        while (1) {
 3897|       |
 3898|      0|            if (!cursor->next) {
 3899|      0|                goto while_break;
 3900|      0|            }
 3901|      0|            if ((unsigned long)entry == (unsigned long)(cursor->next)->data) {
 3902|      0|                goto _L___0;
 3903|      0|            }
 3904|      0|            else {
 3905|      0|                tmp___1 = (*(table___0->comparator))(
 3906|      0|                              entry, (void const *)(cursor->next)->data);
 3907|      0|                if (tmp___1) {
 3908|      0|_L___0:
 3909|      0|                    data___0 = (cursor->next)->data;
 3910|      0|                    if (delete) {
 3911|      0|                        next___0 = cursor->next;
 3912|      0|                        cursor->next = next___0->next;
 3913|      0|                        free_entry(table___0, next___0);
 3914|      0|                    }
 3915|      0|                    return (data___0);
 3916|      0|                }
 3917|      0|            }
 3918|      0|            cursor = cursor->next;
 3919|      0|        }
 3920|      0|while_break:
 3921|      0|        ;
 3922|      0|        return ((void *)0);
 3923|      0|    }
 3924|      0|}
 3925|       |static _Bool transfer_entries(Hash_table *dst, Hash_table *src, _Bool safe)
 3926|      0|{
 3927|      0|    struct hash_entry *bucket;
 3928|      0|    struct hash_entry *cursor;
 3929|      0|    struct hash_entry *next;
 3930|      0|    void *data;
 3931|      0|    struct hash_entry *new_bucket;
 3932|      0|    size_t tmp;
 3933|      0|    size_t tmp___0;
 3934|      0|    struct hash_entry *new_entry;
 3935|      0|    struct hash_entry *tmp___1;
 3936|       |
 3937|      0|    {
 3938|      0|        bucket = src->bucket;
 3939|      0|        while (1) {
 3940|       |
 3941|      0|            if (!((unsigned long)bucket < (unsigned long)src->bucket_limit)) {
 3942|      0|                goto while_break;
 3943|      0|            }
 3944|      0|            if (bucket->data) {
 3945|      0|                cursor = bucket->next;
 3946|      0|                while (1) {
 3947|       |
 3948|      0|                    if (!cursor) {
 3949|      0|                        goto while_break___0;
 3950|      0|                    }
 3951|      0|                    data = cursor->data;
 3952|      0|                    tmp = (*(dst->hasher))((void const *)data, dst->n_buckets);
 3953|      0|                    new_bucket = dst->bucket + tmp;
 3954|      0|                    if (!((unsigned long)new_bucket < (unsigned long)dst->bucket_limit)) {
 3955|      0|                        abort();
 3956|      0|                    }
 3957|      0|                    next = cursor->next;
 3958|      0|                    if (new_bucket->data) {
 3959|      0|                        cursor->next = new_bucket->next;
 3960|      0|                        new_bucket->next = cursor;
 3961|      0|                    }
 3962|      0|                    else {
 3963|      0|                        new_bucket->data = data;
 3964|      0|                        (dst->n_buckets_used)++;
 3965|      0|                        free_entry(dst, cursor);
 3966|      0|                    }
 3967|      0|                    cursor = next;
 3968|      0|                }
 3969|      0|while_break___0:
 3970|      0|                data = bucket->data;
 3971|      0|                bucket->next = (struct hash_entry *)((void *)0);
 3972|      0|                if (safe) {
 3973|      0|                    goto __Cont;
 3974|      0|                }
 3975|      0|                tmp___0 = (*(dst->hasher))((void const *)data, dst->n_buckets);
 3976|      0|                new_bucket = dst->bucket + tmp___0;
 3977|      0|                if (!((unsigned long)new_bucket < (unsigned long)dst->bucket_limit)) {
 3978|      0|                    abort();
 3979|      0|                }
 3980|      0|                if (new_bucket->data) {
 3981|      0|                    tmp___1 = allocate_entry(dst);
 3982|      0|                    new_entry = tmp___1;
 3983|      0|                    if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 3984|      0|                        return ((_Bool)0);
 3985|      0|                    }
 3986|      0|                    new_entry->data = data;
 3987|      0|                    new_entry->next = new_bucket->next;
 3988|      0|                    new_bucket->next = new_entry;
 3989|      0|                }
 3990|      0|                else {
 3991|      0|                    new_bucket->data = data;
 3992|      0|                    (dst->n_buckets_used)++;
 3993|      0|                }
 3994|      0|                bucket->data = (void *)0;
 3995|      0|                (src->n_buckets_used)--;
 3996|      0|            }
 3997|      0|__Cont:
 3998|      0|            bucket++;
 3999|      0|        }
 4000|      0|while_break:
 4001|      0|        ;
 4002|      0|        return ((_Bool)1);
 4003|      0|    }
 4004|      0|}
 4005|       |_Bool(__attribute__((__warn_unused_result__)) hash_rehash)(
 4006|       |    Hash_table *table___0, size_t candidate)
 4007|      0|{
 4008|      0|    Hash_table storage;
 4009|      0|    Hash_table *new_table;
 4010|      0|    size_t new_size;
 4011|      0|    size_t tmp;
 4012|      0|    _Bool tmp___0;
 4013|      0|    _Bool tmp___1;
 4014|      0|    _Bool tmp___2;
 4015|       |
 4016|      0|    {
 4017|      0|        tmp = compute_bucket_size(candidate, table___0->tuning);
 4018|      0|        new_size = tmp;
 4019|      0|        if (!new_size) {
 4020|      0|            return ((_Bool)0);
 4021|      0|        }
 4022|      0|        if (new_size == table___0->n_buckets) {
 4023|      0|            return ((_Bool)1);
 4024|      0|        }
 4025|      0|        new_table = &storage;
 4026|      0|        new_table->bucket =
 4027|      0|            (struct hash_entry *)calloc(new_size, sizeof(*(new_table->bucket)));
 4028|      0|        if ((unsigned long)new_table->bucket == (unsigned long)((void *)0)) {
 4029|      0|            return ((_Bool)0);
 4030|      0|        }
 4031|      0|        new_table->n_buckets = new_size;
 4032|      0|        new_table->bucket_limit =
 4033|      0|            (struct hash_entry const *)(new_table->bucket + new_size);
 4034|      0|        new_table->n_buckets_used = (size_t)0;
 4035|      0|        new_table->n_entries = (size_t)0;
 4036|      0|        new_table->tuning = table___0->tuning;
 4037|      0|        new_table->hasher = table___0->hasher;
 4038|      0|        new_table->comparator = table___0->comparator;
 4039|      0|        new_table->data_freer = table___0->data_freer;
 4040|      0|        new_table->free_entry_list = table___0->free_entry_list;
 4041|      0|        tmp___0 = transfer_entries(new_table, table___0, (_Bool)0);
 4042|      0|        if (tmp___0) {
 4043|      0|            free((void *)table___0->bucket);
 4044|      0|            table___0->bucket = new_table->bucket;
 4045|      0|            table___0->bucket_limit = new_table->bucket_limit;
 4046|      0|            table___0->n_buckets = new_table->n_buckets;
 4047|      0|            table___0->n_buckets_used = new_table->n_buckets_used;
 4048|      0|            table___0->free_entry_list = new_table->free_entry_list;
 4049|      0|            return ((_Bool)1);
 4050|      0|        }
 4051|      0|        table___0->free_entry_list = new_table->free_entry_list;
 4052|      0|        tmp___1 = transfer_entries(table___0, new_table, (_Bool)1);
 4053|      0|        if (tmp___1) {
 4054|      0|            tmp___2 = transfer_entries(table___0, new_table, (_Bool)0);
 4055|      0|            if (!tmp___2) {
 4056|      0|                abort();
 4057|      0|            }
 4058|      0|        }
 4059|      0|        else {
 4060|      0|            abort();
 4061|      0|        }
 4062|      0|        free((void *)new_table->bucket);
 4063|      0|        return ((_Bool)0);
 4064|      0|    }
 4065|      0|}
 4066|       |void *(__attribute__((__warn_unused_result__)) hash_insert)(
 4067|       |    Hash_table *table___0, void const *entry)
 4068|      0|{
 4069|      0|    void *data;
 4070|      0|    struct hash_entry *bucket;
 4071|      0|    Hash_tuning const *tuning;
 4072|      0|    float candidate;
 4073|      0|    float tmp;
 4074|      0|    _Bool tmp___0;
 4075|      0|    void *tmp___1;
 4076|      0|    struct hash_entry *new_entry;
 4077|      0|    struct hash_entry *tmp___2;
 4078|       |
 4079|      0|    {
 4080|      0|        if (!entry) {
 4081|      0|            abort();
 4082|      0|        }
 4083|      0|        data = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 4084|      0|        if ((unsigned long)data != (unsigned long)((void *)0)) {
 4085|      0|            return (data);
 4086|      0|        }
 4087|      0|        if ((float const)table___0->n_buckets_used >
 4088|      0|                (table___0->tuning)->growth_threshold *
 4089|      0|                (float const)table___0->n_buckets) {
 4090|      0|            check_tuning(table___0);
 4091|      0|            if ((float const)table___0->n_buckets_used >
 4092|      0|                    (table___0->tuning)->growth_threshold *
 4093|      0|                    (float const)table___0->n_buckets) {
 4094|      0|                tuning = table___0->tuning;
 4095|      0|                if (tuning->is_n_buckets) {
 4096|      0|                    tmp = (float)((float const)table___0->n_buckets *
 4097|      0|                                  tuning->growth_factor);
 4098|      0|                }
 4099|      0|                else {
 4100|      0|                    tmp = (float)(((float const)table___0->n_buckets *
 4101|      0|                                   tuning->growth_factor) *
 4102|      0|                                  tuning->growth_threshold);
 4103|      0|                }
 4104|      0|                candidate = tmp;
 4105|      0|                if ((float)0xffffffffffffffffUL <= candidate) {
 4106|      0|                    return ((void *)0);
 4107|      0|                }
 4108|      0|                tmp___0 = hash_rehash(table___0, (size_t)candidate);
 4109|      0|                if (!tmp___0) {
 4110|      0|                    return ((void *)0);
 4111|      0|                }
 4112|      0|                tmp___1 = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 4113|      0|                if ((unsigned long)tmp___1 != (unsigned long)((void *)0)) {
 4114|      0|                    abort();
 4115|      0|                }
 4116|      0|            }
 4117|      0|        }
 4118|      0|        if (bucket->data) {
 4119|      0|            tmp___2 = allocate_entry(table___0);
 4120|      0|            new_entry = tmp___2;
 4121|      0|            if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 4122|      0|                return ((void *)0);
 4123|      0|            }
 4124|      0|            new_entry->data = (void *)entry;
 4125|      0|            new_entry->next = bucket->next;
 4126|      0|            bucket->next = new_entry;
 4127|      0|            (table___0->n_entries)++;
 4128|      0|            return ((void *)entry);
 4129|      0|        }
 4130|      0|        bucket->data = (void *)entry;
 4131|      0|        (table___0->n_entries)++;
 4132|      0|        (table___0->n_buckets_used)++;
 4133|      0|        return ((void *)entry);
 4134|      0|    }
 4135|      0|}
 4136|       |void *hash_delete(Hash_table *table___0, void const *entry)
 4137|      0|{
 4138|      0|    void *data;
 4139|      0|    struct hash_entry *bucket;
 4140|      0|    Hash_tuning const *tuning;
 4141|      0|    size_t candidate;
 4142|      0|    float tmp;
 4143|      0|    struct hash_entry *cursor;
 4144|      0|    struct hash_entry *next;
 4145|      0|    _Bool tmp___0;
 4146|       |
 4147|      0|    {
 4148|      0|        data = hash_find_entry(table___0, entry, &bucket, (_Bool)1);
 4149|      0|        if (!data) {
 4150|      0|            return ((void *)0);
 4151|      0|        }
 4152|      0|        (table___0->n_entries)--;
 4153|      0|        if (!bucket->data) {
 4154|      0|            (table___0->n_buckets_used)--;
 4155|      0|            if ((float const)table___0->n_buckets_used <
 4156|      0|                    (table___0->tuning)->shrink_threshold *
 4157|      0|                    (float const)table___0->n_buckets) {
 4158|      0|                check_tuning(table___0);
 4159|      0|                if ((float const)table___0->n_buckets_used <
 4160|      0|                        (table___0->tuning)->shrink_threshold *
 4161|      0|                        (float const)table___0->n_buckets) {
 4162|      0|                    tuning = table___0->tuning;
 4163|      0|                    if (tuning->is_n_buckets) {
 4164|      0|                        tmp = (float)((float const)table___0->n_buckets *
 4165|      0|                                      tuning->shrink_factor);
 4166|      0|                    }
 4167|      0|                    else {
 4168|      0|                        tmp = (float)(((float const)table___0->n_buckets *
 4169|      0|                                       tuning->shrink_factor) *
 4170|      0|                                      tuning->growth_threshold);
 4171|      0|                    }
 4172|      0|                    candidate = (size_t)tmp;
 4173|      0|                    tmp___0 = hash_rehash(table___0, candidate);
 4174|      0|                    if (!tmp___0) {
 4175|      0|                        cursor = table___0->free_entry_list;
 4176|      0|                        while (1) {
 4177|       |
 4178|      0|                            if (!cursor) {
 4179|      0|                                goto while_break;
 4180|      0|                            }
 4181|      0|                            next = cursor->next;
 4182|      0|                            free((void *)cursor);
 4183|      0|                            cursor = next;
 4184|      0|                        }
 4185|      0|while_break:
 4186|      0|                        ;
 4187|      0|                        table___0->free_entry_list = (struct hash_entry *)((void *)0);
 4188|      0|                    }
 4189|      0|                }
 4190|      0|            }
 4191|      0|        }
 4192|      0|        return (data);
 4193|      0|    }
 4194|      0|}
 4195|       |size_t hash_pjw(void const *x, size_t tablesize);
 4196|       |size_t triple_hash(void const *x, size_t table_size)
 4197|      0|{
 4198|      0|    struct F_triple const *p;
 4199|      0|    size_t tmp;
 4200|      0|    size_t tmp___0;
 4201|       |
 4202|      0|    {
 4203|      0|        p = (struct F_triple const *)x;
 4204|      0|        tmp___0 = hash_pjw((void const *)p->name, table_size);
 4205|      0|        tmp = tmp___0;
 4206|      0|        return ((tmp ^ (unsigned long)p->st_ino) % table_size);
 4207|      0|    }
 4208|      0|}
 4209|       |_Bool triple_compare_ino_str(void const *x, void const *y)
 4210|      0|{
 4211|      0|    struct F_triple const *a;
 4212|      0|    struct F_triple const *b;
 4213|      0|    int tmp___0;
 4214|      0|    int tmp___1;
 4215|       |
 4216|      0|    {
 4217|      0|        a = (struct F_triple const *)x;
 4218|      0|        b = (struct F_triple const *)y;
 4219|      0|        if (a->st_ino == b->st_ino) {
 4220|      0|            if (a->st_dev == b->st_dev) {
 4221|      0|                tmp___1 = strcmp((char const *)a->name, (char const *)b->name);
 4222|      0|                if (tmp___1 == 0) {
 4223|      0|                    tmp___0 = 1;
 4224|      0|                }
 4225|      0|                else {
 4226|      0|                    tmp___0 = 0;
 4227|      0|                }
 4228|      0|            }
 4229|      0|            else {
 4230|      0|                tmp___0 = 0;
 4231|      0|            }
 4232|      0|        }
 4233|      0|        else {
 4234|      0|            tmp___0 = 0;
 4235|      0|        }
 4236|      0|        return ((_Bool)tmp___0);
 4237|      0|    }
 4238|      0|}
 4239|       |void triple_free(void *x)
 4240|      0|{
 4241|      0|    struct F_triple *a;
 4242|       |
 4243|      0|    {
 4244|      0|        a = (struct F_triple *)x;
 4245|      0|        free((void *)a->name);
 4246|      0|        free((void *)a);
 4247|      0|        return;
 4248|      0|    }
 4249|      0|}
 4250|       |size_t hash_pjw(void const *x, size_t tablesize)
 4251|      0|{
 4252|      0|    char const *s;
 4253|      0|    size_t h;
 4254|       |
 4255|      0|    {
 4256|      0|        h = (size_t)0;
 4257|      0|        s = (char const *)x;
 4258|      0|        while (1) {
 4259|       |
 4260|      0|            if (!*s) {
 4261|      0|                goto while_break;
 4262|      0|            }
 4263|      0|            h = (unsigned long)*s + ((h << 9) | (h >> (sizeof(size_t) * 8UL - 9UL)));
 4264|      0|            s++;
 4265|      0|        }
 4266|      0|while_break:
 4267|      0|        ;
 4268|      0|        return (h % tablesize);
 4269|      0|    }
 4270|      0|}
 4271|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) setlocale)(
 4272|       |    int __category, char const *__locale);
 4273|       |extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2, 3),
 4274|       |                                        __leaf__)) fstatat)(
 4275|       |                                                int __fd, char const *__restrict __file, struct stat *__restrict __buf,
 4276|       |                                                int __flag);
 4277|       |__attribute__((__nothrow__)) int(__attribute__((__warn_unused_result__,
 4278|       |                                 __leaf__)) fts_close)(FTS *sp);
 4279|       |__attribute__((__nothrow__))
 4280|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp);
 4281|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__)) fts_set)(
 4282|       |    FTS *sp __attribute__((__unused__)), FTSENT *p, int instr);
 4283|       |extern void(__attribute__((__nonnull__(1, 4))) qsort)(
 4284|       |    void *__base, size_t __nmemb, size_t __size,
 4285|       |    int (*__compar)(void const *, void const *));
 4286|       |static FTSENT *fts_alloc(FTS *sp, char const *name, size_t namelen);
 4287|       |static FTSENT *fts_build(FTS *sp, int type);
 4288|       |static void fts_lfree(FTSENT *head);
 4289|       |static void fts_load(FTS *sp, FTSENT *p);
 4290|       |static size_t fts_maxarglen(char *const *argv);
 4291|       |static void fts_padjust(FTS *sp, FTSENT *head);
 4292|       |static _Bool fts_palloc(FTS *sp, size_t more);
 4293|       |static FTSENT *fts_sort(FTS *sp, FTSENT *head, size_t nitems);
 4294|       |static unsigned short fts_stat(FTS *sp, FTSENT *p, _Bool follow);
 4295|       |static int fts_safe_changedir(FTS *sp, FTSENT *p, int fd, char const *dir);
 4296|       |static _Bool AD_compare(void const *x, void const *y)
 4297|      0|{
 4298|      0|    struct Active_dir const *ax;
 4299|      0|    struct Active_dir const *ay;
 4300|      0|    int tmp;
 4301|       |
 4302|      0|    {
 4303|      0|        ax = (struct Active_dir const *)x;
 4304|      0|        ay = (struct Active_dir const *)y;
 4305|      0|        if (ax->ino == ay->ino) {
 4306|      0|            if (ax->dev == ay->dev) {
 4307|      0|                tmp = 1;
 4308|      0|            }
 4309|      0|            else {
 4310|      0|                tmp = 0;
 4311|      0|            }
 4312|      0|        }
 4313|      0|        else {
 4314|      0|            tmp = 0;
 4315|      0|        }
 4316|      0|        return ((_Bool)tmp);
 4317|      0|    }
 4318|      0|}
 4319|       |static size_t AD_hash(void const *x, size_t table_size)
 4320|      0|{
 4321|      0|    struct Active_dir const *ax;
 4322|       |
 4323|      0|    {
 4324|      0|        ax = (struct Active_dir const *)x;
 4325|      0|        return ((uintmax_t)ax->ino % table_size);
 4326|      0|    }
 4327|      0|}
 4328|       |static _Bool setup_dir(FTS *fts)
 4329|      2|{
 4330|       |
 4331|      2|    {
 4332|      2|        if (fts->fts_options & 258) {
 4333|      0|            fts->fts_cycle.ht =
 4334|      0|                hash_initialize((size_t)31, (Hash_tuning const *)((void *)0),
 4335|      0|                                &AD_hash, &AD_compare, (void (*)(void *))(&free));
 4336|      0|            if (!fts->fts_cycle.ht) {
 4337|      0|                return ((_Bool)0);
 4338|      0|            }
 4339|      0|        }
 4340|      2|        else {
 4341|      2|            fts->fts_cycle.state =
 4342|      2|                (struct cycle_check_state *)malloc(sizeof(*(fts->fts_cycle.state)));
 4343|      2|            if (!fts->fts_cycle.state) {
 4344|      0|                return ((_Bool)0);
 4345|      0|            }
 4346|      2|            cycle_check_init(fts->fts_cycle.state);
 4347|      2|        }
 4348|      2|        return ((_Bool)1);
 4349|      2|    }
 4350|      2|}
 4351|       |static _Bool enter_dir(FTS *fts, FTSENT *ent)
 4352|      3|{
 4353|      3|    struct stat const *st;
 4354|      3|    struct Active_dir *ad;
 4355|      3|    struct Active_dir *tmp;
 4356|      3|    struct Active_dir *ad_from_table;
 4357|      3|    _Bool tmp___0;
 4358|       |
 4359|      3|    {
 4360|      3|        if (fts->fts_options & 258) {
 4361|      0|            st = (struct stat const *)(ent->fts_statp);
 4362|      0|            tmp = (struct Active_dir *)malloc(sizeof(*ad));
 4363|      0|            ad = tmp;
 4364|      0|            if (!ad) {
 4365|      0|                return ((_Bool)0);
 4366|      0|            }
 4367|      0|            ad->dev = (dev_t)st->st_dev;
 4368|      0|            ad->ino = (ino_t)st->st_ino;
 4369|      0|            ad->fts_ent = ent;
 4370|      0|            ad_from_table =
 4371|      0|                (struct Active_dir *)hash_insert(fts->fts_cycle.ht, (void const *)ad);
 4372|      0|            if ((unsigned long)ad_from_table != (unsigned long)ad) {
 4373|      0|                free((void *)ad);
 4374|      0|                if (!ad_from_table) {
 4375|      0|                    return ((_Bool)0);
 4376|      0|                }
 4377|      0|                ent->fts_cycle = ad_from_table->fts_ent;
 4378|      0|                ent->fts_info = (unsigned short)2;
 4379|      0|            }
 4380|      0|        }
 4381|      3|        else {
 4382|      3|            tmp___0 = cycle_check(fts->fts_cycle.state,
 4383|      3|                                  (struct stat const *)(ent->fts_statp));
 4384|      3|            if (tmp___0) {
 4385|      0|                ent->fts_cycle = ent;
 4386|      0|                ent->fts_info = (unsigned short)2;
 4387|      0|            }
 4388|      3|        }
 4389|      3|        return ((_Bool)1);
 4390|      3|    }
 4391|      3|}
 4392|       |static void leave_dir(FTS *fts, FTSENT *ent)
 4393|      3|{
 4394|      3|    struct stat const *st;
 4395|      3|    struct Active_dir obj;
 4396|      3|    void *found;
 4397|      3|    FTSENT *parent;
 4398|       |
 4399|      3|    {
 4400|      3|        st = (struct stat const *)(ent->fts_statp);
 4401|      3|        if (fts->fts_options & 258) {
 4402|      0|            obj.dev = (dev_t)st->st_dev;
 4403|      0|            obj.ino = (ino_t)st->st_ino;
 4404|      0|            found = hash_delete(fts->fts_cycle.ht, (void const *)(&obj));
 4405|      0|            if (!found) {
 4406|      0|                abort();
 4407|      0|            }
 4408|      0|            free(found);
 4409|      0|        }
 4410|      3|        else {
 4411|      3|            parent = ent->fts_parent;
 4412|      3|            if ((unsigned long)parent != (unsigned long)((void *)0)) {
 4413|      3|                if (0L <= parent->fts_level) {
 4414|      2|                    while (1) {
 4415|       |
 4416|      2|                        if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
 4417|      0|                            abort();
 4418|      0|                        }
 4419|      2|                        if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t)st->st_ino) {
 4420|      1|                            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t)st->st_dev) {
 4421|      1|                                (fts->fts_cycle.state)->dev_ino.st_dev =
 4422|      1|                                    parent->fts_statp[0].st_dev;
 4423|      1|                                (fts->fts_cycle.state)->dev_ino.st_ino =
 4424|      1|                                    parent->fts_statp[0].st_ino;
 4425|      1|                            }
 4426|      1|                        }
 4427|      2|                        goto while_break;
 4428|      2|                    }
 4429|      2|while_break:
 4430|      2|                    ;
 4431|      2|                }
 4432|      3|            }
 4433|      3|        }
 4434|      3|        return;
 4435|      3|    }
 4436|      3|}
 4437|       |static void free_dir(FTS *sp)
 4438|      2|{
 4439|       |
 4440|      2|    {
 4441|      2|        if (sp->fts_options & 258) {
 4442|      0|            if (sp->fts_cycle.ht) {
 4443|      0|                hash_free(sp->fts_cycle.ht);
 4444|      0|            }
 4445|      0|        }
 4446|      2|        else {
 4447|      2|            free((void *)sp->fts_cycle.state);
 4448|      2|        }
 4449|      2|        return;
 4450|      2|    }
 4451|      2|}
 4452|       |static void fd_ring_clear(I_ring *fd_ring)
 4453|      3|{
 4454|      3|    int fd;
 4455|      3|    int tmp;
 4456|      3|    _Bool tmp___0;
 4457|       |
 4458|      3|    {
 4459|      6|        while (1) {
 4460|      6|            tmp___0 = i_ring_empty((I_ring const *)fd_ring);
 4461|      6|            if (tmp___0) {
 4462|      3|                goto while_break;
 4463|      3|            }
 4464|      3|            tmp = i_ring_pop(fd_ring);
 4465|      3|            fd = tmp;
 4466|      3|            if (0 <= fd) {
 4467|      1|                close(fd);
 4468|      1|            }
 4469|      3|        }
 4470|      3|while_break:
 4471|      3|        ;
 4472|      3|        return;
 4473|      3|    }
 4474|      3|}
 4475|       |static void fts_set_stat_required(FTSENT *p, _Bool required)
 4476|      6|{
 4477|       |
 4478|      6|    {
 4479|      6|        while (1) {
 4480|       |
 4481|      6|            if (!((int)p->fts_info == 11)) {
 4482|      0|                abort();
 4483|      0|            }
 4484|      6|            goto while_break;
 4485|      6|        }
 4486|      6|while_break:
 4487|      6|        ;
 4488|      6|        if (required) {
 4489|      2|            p->fts_statp[0].st_size = (__off_t)2;
 4490|      2|        }
 4491|      4|        else {
 4492|      4|            p->fts_statp[0].st_size = (__off_t)1;
 4493|      4|        }
 4494|      6|        return;
 4495|      6|    }
 4496|      6|}
 4497|       |__inline static DIR *opendirat(int fd, char const *dir)
 4498|      3|{
 4499|      3|    int new_fd;
 4500|      3|    int tmp;
 4501|      3|    DIR *dirp;
 4502|      3|    int saved_errno;
 4503|      3|    int *tmp___0;
 4504|      3|    int *tmp___1;
 4505|       |
 4506|      3|    {
 4507|      3|        tmp = openat_safer(fd, dir, 67840);
 4508|      3|        new_fd = tmp;
 4509|      3|        if (new_fd < 0) {
 4510|      0|            return ((DIR *)((void *)0));
 4511|      0|        }
 4512|      3|        set_cloexec_flag(new_fd, (_Bool)1);
 4513|      3|        dirp = rpl_fdopendir(new_fd);
 4514|      3|        if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 4515|      0|            tmp___0 = __errno_location();
 4516|      0|            saved_errno = *tmp___0;
 4517|      0|            close(new_fd);
 4518|      0|            tmp___1 = __errno_location();
 4519|      0|            *tmp___1 = saved_errno;
 4520|      0|        }
 4521|      3|        return (dirp);
 4522|      3|    }
 4523|      3|}
 4524|       |static void cwd_advance_fd(FTS *sp, int fd, _Bool chdir_down_one)
 4525|      7|{
 4526|      7|    int old;
 4527|      7|    int prev_fd_in_slot;
 4528|      7|    int tmp;
 4529|       |
 4530|      7|    {
 4531|      7|        old = sp->fts_cwd_fd;
 4532|      7|        while (1) {
 4533|       |
 4534|      7|            if (!(old != fd)) {
 4535|      1|                if (!(old == -100)) {
 4536|      0|                    abort();
 4537|      0|                }
 4538|      1|            }
 4539|      7|            goto while_break;
 4540|      7|        }
 4541|      7|while_break:
 4542|      7|        ;
 4543|      7|        if (chdir_down_one) {
 4544|      5|            tmp = i_ring_push(&sp->fts_fd_ring, old);
 4545|      5|            prev_fd_in_slot = tmp;
 4546|      5|            if (0 <= prev_fd_in_slot) {
 4547|      0|                close(prev_fd_in_slot);
 4548|      0|            }
 4549|      5|        }
 4550|      2|        else {
 4551|      2|            if (!(sp->fts_options & 4)) {
 4552|      2|                if (0 <= old) {
 4553|      2|                    close(old);
 4554|      2|                }
 4555|      2|            }
 4556|      2|        }
 4557|      7|        sp->fts_cwd_fd = fd;
 4558|      7|        return;
 4559|      7|    }
 4560|      7|}
 4561|       |__inline static int diropen(FTS const *sp, char const *dir)
 4562|      0|{
 4563|      0|    int open_flags;
 4564|      0|    int tmp;
 4565|      0|    int fd;
 4566|      0|    int tmp___0;
 4567|      0|    int tmp___1;
 4568|      0|    int tmp___2;
 4569|       |
 4570|      0|    {
 4571|      0|        if (sp->fts_options & 16) {
 4572|      0|            tmp = 131072;
 4573|      0|        }
 4574|      0|        else {
 4575|      0|            tmp = 0;
 4576|      0|        }
 4577|      0|        open_flags = 67840 | tmp;
 4578|      0|        if (sp->fts_options & 512) {
 4579|      0|            tmp___0 = openat_safer((int)sp->fts_cwd_fd, dir, open_flags);
 4580|      0|            tmp___2 = tmp___0;
 4581|      0|        }
 4582|      0|        else {
 4583|      0|            tmp___1 = open_safer(dir, open_flags);
 4584|      0|            tmp___2 = tmp___1;
 4585|      0|        }
 4586|      0|        fd = tmp___2;
 4587|      0|        if (0 <= fd) {
 4588|      0|            set_cloexec_flag(fd, (_Bool)1);
 4589|      0|        }
 4590|      0|        return (fd);
 4591|      0|    }
 4592|      0|}
 4593|       |__attribute__((__nothrow__))
 4594|       |FTS *(__attribute__((__warn_unused_result__, __leaf__)) fts_open)(
 4595|       |    char *const *argv, int options,
 4596|       |    int (*compar)(FTSENT const **, FTSENT const **));
 4597|       |FTS *(__attribute__((__warn_unused_result__, __leaf__)) fts_open)(
 4598|       |    char *const *argv, int options,
 4599|       |    int (*compar)(FTSENT const **, FTSENT const **))
 4600|      1|{
 4601|      1|    FTS *sp;
 4602|      1|    FTSENT *p;
 4603|      1|    FTSENT *root;
 4604|      1|    size_t nitems;
 4605|      1|    FTSENT *parent;
 4606|      1|    FTSENT *tmp;
 4607|      1|    _Bool defer_stat;
 4608|      1|    int *tmp___0;
 4609|      1|    int *tmp___1;
 4610|      1|    int *tmp___2;
 4611|      1|    size_t maxarglen;
 4612|      1|    size_t tmp___4;
 4613|      1|    size_t tmp___5;
 4614|      1|    _Bool tmp___6;
 4615|      1|    int tmp___7;
 4616|      1|    size_t len;
 4617|      1|    size_t tmp___8;
 4618|      1|    struct _ftsent *tmp___9;
 4619|      1|    _Bool tmp___10;
 4620|      1|    int tmp___11;
 4621|       |
 4622|      1|    {
 4623|      1|        parent = (FTSENT *)((void *)0);
 4624|      1|        tmp = (FTSENT *)((void *)0);
 4625|      1|        if (options & -2048) {
 4626|      0|            tmp___0 = __errno_location();
 4627|      0|            *tmp___0 = 22;
 4628|      0|            return ((FTS *)((void *)0));
 4629|      0|        }
 4630|      1|        if (options & 4) {
 4631|      0|            if (options & 512) {
 4632|      0|                tmp___1 = __errno_location();
 4633|      0|                *tmp___1 = 22;
 4634|      0|                return ((FTS *)((void *)0));
 4635|      0|            }
 4636|      0|        }
 4637|      1|        if (!(options & 18)) {
 4638|      0|            tmp___2 = __errno_location();
 4639|      0|            *tmp___2 = 22;
 4640|      0|            return ((FTS *)((void *)0));
 4641|      0|        }
 4642|      1|        sp = (FTS *)malloc(sizeof(FTS));
 4643|      1|        if ((unsigned long)sp == (unsigned long)((void *)0)) {
 4644|      0|            return ((FTS *)((void *)0));
 4645|      0|        }
 4646|      1|        memset((void *)sp, 0, sizeof(FTS));
 4647|      1|        sp->fts_compar = compar;
 4648|      1|        sp->fts_options = options;
 4649|      1|        if (sp->fts_options & 2) {
 4650|      0|            sp->fts_options |= 4;
 4651|      0|            sp->fts_options &= -513;
 4652|      0|        }
 4653|      1|        sp->fts_cwd_fd = -100;
 4654|      1|        tmp___4 = fts_maxarglen(argv);
 4655|      1|        maxarglen = tmp___4;
 4656|      1|        if (maxarglen > 4096UL) {
 4657|      0|            tmp___5 = maxarglen;
 4658|      0|        }
 4659|      1|        else {
 4660|      1|            tmp___5 = (size_t)4096;
 4661|      1|        }
 4662|      1|        tmp___6 = fts_palloc(sp, tmp___5);
 4663|      1|        if (!tmp___6) {
 4664|      0|            goto mem1;
 4665|      0|        }
 4666|      1|        if ((unsigned long)*argv != (unsigned long)((void *)0)) {
 4667|      1|            parent = fts_alloc(sp, "", (size_t)0);
 4668|      1|            if ((unsigned long)parent == (unsigned long)((void *)0)) {
 4669|      0|                goto mem2;
 4670|      0|            }
 4671|      1|            parent->fts_level = (ptrdiff_t)-1;
 4672|      1|        }
 4673|      1|        if ((unsigned long)compar == (unsigned long)((void *)0)) {
 4674|      1|            tmp___7 = 1;
 4675|      1|        }
 4676|      0|        else {
 4677|      0|            if (sp->fts_options & 1024) {
 4678|      0|                tmp___7 = 1;
 4679|      0|            }
 4680|      0|            else {
 4681|      0|                tmp___7 = 0;
 4682|      0|            }
 4683|      0|        }
 4684|      1|        defer_stat = (_Bool)tmp___7;
 4685|      1|        root = (FTSENT *)((void *)0);
 4686|      1|        nitems = (size_t)0;
 4687|      2|        while (1) {
 4688|       |
 4689|      2|            if (!((unsigned long)*argv != (unsigned long)((void *)0))) {
 4690|      1|                goto while_break;
 4691|      1|            }
 4692|      1|            tmp___8 = strlen((char const *)*argv);
 4693|      1|            len = tmp___8;
 4694|      1|            p = fts_alloc(sp, (char const *)*argv, len);
 4695|      1|            if ((unsigned long)p == (unsigned long)((void *)0)) {
 4696|      0|                goto mem3;
 4697|      0|            }
 4698|      1|            p->fts_level = (ptrdiff_t)0;
 4699|      1|            p->fts_parent = parent;
 4700|      1|            p->fts_accpath = p->fts_name;
 4701|      1|            if (defer_stat) {
 4702|      1|                if ((unsigned long)root != (unsigned long)((void *)0)) {
 4703|      0|                    p->fts_info = (unsigned short)11;
 4704|      0|                    fts_set_stat_required(p, (_Bool)1);
 4705|      0|                }
 4706|      1|                else {
 4707|      1|                    p->fts_info = fts_stat(sp, p, (_Bool)0);
 4708|      1|                }
 4709|      1|            }
 4710|      0|            else {
 4711|      0|                p->fts_info = fts_stat(sp, p, (_Bool)0);
 4712|      0|            }
 4713|      1|            if (compar) {
 4714|      0|                p->fts_link = root;
 4715|      0|                root = p;
 4716|      0|            }
 4717|      1|            else {
 4718|      1|                p->fts_link = (struct _ftsent *)((void *)0);
 4719|      1|                if ((unsigned long)root == (unsigned long)((void *)0)) {
 4720|      1|                    root = p;
 4721|      1|                    tmp = root;
 4722|      1|                }
 4723|      0|                else {
 4724|      0|                    tmp->fts_link = p;
 4725|      0|                    tmp = p;
 4726|      0|                }
 4727|      1|            }
 4728|      1|            argv++;
 4729|      1|            nitems++;
 4730|      1|        }
 4731|      1|while_break:
 4732|      1|        ;
 4733|      1|        if (compar) {
 4734|      0|            if (nitems > 1UL) {
 4735|      0|                root = fts_sort(sp, root, nitems);
 4736|      0|            }
 4737|      0|        }
 4738|      1|        tmp___9 = fts_alloc(sp, "", (size_t)0);
 4739|      1|        sp->fts_cur = tmp___9;
 4740|      1|        if ((unsigned long)tmp___9 == (unsigned long)((void *)0)) {
 4741|      0|            goto mem3;
 4742|      0|        }
 4743|      1|        (sp->fts_cur)->fts_link = root;
 4744|      1|        (sp->fts_cur)->fts_info = (unsigned short)9;
 4745|      1|        tmp___10 = setup_dir(sp);
 4746|      1|        if (!tmp___10) {
 4747|      0|            goto mem3;
 4748|      0|        }
 4749|      1|        if (!(sp->fts_options & 4)) {
 4750|      1|            if (!(sp->fts_options & 512)) {
 4751|      0|                tmp___11 = diropen((FTS const *)sp, ".");
 4752|      0|                sp->fts_rfd = tmp___11;
 4753|      0|                if (tmp___11 < 0) {
 4754|      0|                    sp->fts_options |= 4;
 4755|      0|                }
 4756|      0|            }
 4757|      1|        }
 4758|      1|        i_ring_init(&sp->fts_fd_ring, -1);
 4759|      1|        return (sp);
 4760|      0|mem3:
 4761|      0|        fts_lfree(root);
 4762|      0|        free((void *)parent);
 4763|      0|mem2:
 4764|      0|        free((void *)sp->fts_path);
 4765|      0|mem1:
 4766|      0|        free((void *)sp);
 4767|      0|        return ((FTS *)((void *)0));
 4768|      0|    }
 4769|      0|}
 4770|       |static void fts_load(FTS *sp, FTSENT *p)
 4771|      1|{
 4772|      1|    size_t len;
 4773|      1|    char *cp;
 4774|      1|    size_t tmp;
 4775|      1|    char *tmp___0;
 4776|       |
 4777|      1|    {
 4778|      1|        tmp = p->fts_namelen;
 4779|      1|        p->fts_pathlen = tmp;
 4780|      1|        len = tmp;
 4781|      1|        memmove((void *)sp->fts_path, (void const *)(p->fts_name), len + 1UL);
 4782|      1|        cp = strrchr((char const *)(p->fts_name), '/');
 4783|      1|        if (cp) {
 4784|      1|            if ((unsigned long)cp != (unsigned long)(p->fts_name)) {
 4785|      1|                cp++;
 4786|      1|                len = strlen((char const *)cp);
 4787|      1|                memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
 4788|      1|                p->fts_namelen = len;
 4789|      1|            }
 4790|      0|            else {
 4791|      0|                if (*(cp + 1)) {
 4792|      0|                    cp++;
 4793|      0|                    len = strlen((char const *)cp);
 4794|      0|                    memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
 4795|      0|                    p->fts_namelen = len;
 4796|      0|                }
 4797|      0|            }
 4798|      1|        }
 4799|      1|        tmp___0 = sp->fts_path;
 4800|      1|        p->fts_path = tmp___0;
 4801|      1|        p->fts_accpath = tmp___0;
 4802|      1|        return;
 4803|      1|    }
 4804|      1|}
 4805|       |__attribute__((__nothrow__)) int(__attribute__((__warn_unused_result__,
 4806|       |                                 __leaf__)) fts_close)(FTS *sp);
 4807|       |int(__attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp)
 4808|      1|{
 4809|      1|    FTSENT *freep;
 4810|      1|    FTSENT *p;
 4811|      1|    int saved_errno;
 4812|      1|    int *tmp;
 4813|      1|    int tmp___0;
 4814|      1|    int *tmp___1;
 4815|      1|    int tmp___2;
 4816|      1|    int *tmp___3;
 4817|      1|    int tmp___4;
 4818|      1|    int *tmp___5;
 4819|       |
 4820|      1|    {
 4821|      1|        saved_errno = 0;
 4822|      1|        if (sp->fts_cur) {
 4823|      0|            p = sp->fts_cur;
 4824|      0|            while (1) {
 4825|       |
 4826|      0|                if (!(p->fts_level >= 0L)) {
 4827|      0|                    goto while_break;
 4828|      0|                }
 4829|      0|                freep = p;
 4830|      0|                if ((unsigned long)p->fts_link != (unsigned long)((void *)0)) {
 4831|      0|                    p = p->fts_link;
 4832|      0|                }
 4833|      0|                else {
 4834|      0|                    p = p->fts_parent;
 4835|      0|                }
 4836|      0|                free((void *)freep);
 4837|      0|            }
 4838|      0|while_break:
 4839|      0|            free((void *)p);
 4840|      0|        }
 4841|      1|        if (sp->fts_child) {
 4842|      0|            fts_lfree(sp->fts_child);
 4843|      0|        }
 4844|      1|        free((void *)sp->fts_array);
 4845|      1|        free((void *)sp->fts_path);
 4846|      1|        if (sp->fts_options & 512) {
 4847|      1|            if (0 <= sp->fts_cwd_fd) {
 4848|      0|                tmp___0 = close(sp->fts_cwd_fd);
 4849|      0|                if (tmp___0) {
 4850|      0|                    tmp = __errno_location();
 4851|      0|                    saved_errno = *tmp;
 4852|      0|                }
 4853|      0|            }
 4854|      1|        }
 4855|      0|        else {
 4856|      0|            if (!(sp->fts_options & 4)) {
 4857|      0|                tmp___2 = fchdir(sp->fts_rfd);
 4858|      0|                if (tmp___2) {
 4859|      0|                    tmp___1 = __errno_location();
 4860|      0|                    saved_errno = *tmp___1;
 4861|      0|                }
 4862|      0|                tmp___4 = close(sp->fts_rfd);
 4863|      0|                if (tmp___4) {
 4864|      0|                    if (saved_errno == 0) {
 4865|      0|                        tmp___3 = __errno_location();
 4866|      0|                        saved_errno = *tmp___3;
 4867|      0|                    }
 4868|      0|                }
 4869|      0|            }
 4870|      0|        }
 4871|      1|        fd_ring_clear(&sp->fts_fd_ring);
 4872|      1|        if (sp->fts_leaf_optimization_works_ht) {
 4873|      0|            hash_free(sp->fts_leaf_optimization_works_ht);
 4874|      0|        }
 4875|      1|        free_dir(sp);
 4876|      1|        free((void *)sp);
 4877|      1|        if (saved_errno) {
 4878|      0|            tmp___5 = __errno_location();
 4879|      0|            *tmp___5 = saved_errno;
 4880|      0|            return (-1);
 4881|      0|        }
 4882|      1|        return (0);
 4883|      1|    }
 4884|      1|}
 4885|       |extern __attribute__((__nothrow__)) int(__attribute__((
 4886|       |        __nonnull__(2), __leaf__)) fstatfs)(int __fildes, struct statfs *__buf);
 4887|       |static _Bool dirent_inode_sort_may_be_useful(int dir_fd)
 4888|      0|{
 4889|      0|    struct statfs fs_buf;
 4890|      0|    int tmp;
 4891|       |
 4892|      0|    {
 4893|      0|        tmp = fstatfs(dir_fd, &fs_buf);
 4894|      0|        if (tmp != 0) {
 4895|      0|            return ((_Bool)1);
 4896|      0|        }
 4897|      0|        if (fs_buf.f_type == 16914836L) {
 4898|      0|            goto case_16914836;
 4899|      0|        }
 4900|      0|        if (fs_buf.f_type == 26985L) {
 4901|      0|            goto case_16914836;
 4902|      0|        }
 4903|      0|        goto switch_default;
 4904|      0|case_16914836:
 4905|      0|        return ((_Bool)0);
 4906|      0|switch_default:
 4907|      0|        return ((_Bool)1);
 4908|       |
 4909|      0|        return ((_Bool)0);
 4910|      0|    }
 4911|      0|}
 4912|       |static _Bool leaf_optimization_applies(int dir_fd)
 4913|      0|{
 4914|      0|    struct statfs fs_buf;
 4915|      0|    int tmp;
 4916|       |
 4917|      0|    {
 4918|      0|        tmp = fstatfs(dir_fd, &fs_buf);
 4919|      0|        if (tmp != 0) {
 4920|      0|            return ((_Bool)0);
 4921|      0|        }
 4922|      0|        if (fs_buf.f_type == 1382369651L) {
 4923|      0|            goto case_1382369651;
 4924|      0|        }
 4925|      0|        goto switch_default;
 4926|      0|case_1382369651:
 4927|      0|        return ((_Bool)1);
 4928|      0|switch_default:
 4929|      0|        return ((_Bool)0);
 4930|       |
 4931|      0|        return ((_Bool)0);
 4932|      0|    }
 4933|      0|}
 4934|       |static size_t LCO_hash(void const *x, size_t table_size)
 4935|      0|{
 4936|      0|    struct LCO_ent const *ax;
 4937|       |
 4938|      0|    {
 4939|      0|        ax = (struct LCO_ent const *)x;
 4940|      0|        return ((uintmax_t)ax->st_dev % table_size);
 4941|      0|    }
 4942|      0|}
 4943|       |static _Bool LCO_compare(void const *x, void const *y)
 4944|      0|{
 4945|      0|    struct LCO_ent const *ax;
 4946|      0|    struct LCO_ent const *ay;
 4947|       |
 4948|      0|    {
 4949|      0|        ax = (struct LCO_ent const *)x;
 4950|      0|        ay = (struct LCO_ent const *)y;
 4951|      0|        return ((_Bool)(ax->st_dev == ay->st_dev));
 4952|      0|    }
 4953|      0|}
 4954|       |static _Bool link_count_optimize_ok(FTSENT const *p)
 4955|      0|{
 4956|      0|    FTS *sp;
 4957|      0|    Hash_table *h;
 4958|      0|    struct LCO_ent tmp;
 4959|      0|    struct LCO_ent *ent;
 4960|      0|    _Bool opt_ok;
 4961|      0|    struct LCO_ent *t2;
 4962|      0|    struct hash_table *tmp___0;
 4963|       |
 4964|      0|    {
 4965|      0|        sp = (FTS *)p->fts_fts;
 4966|      0|        h = sp->fts_leaf_optimization_works_ht;
 4967|      0|        if (!(sp->fts_options & 512)) {
 4968|      0|            return ((_Bool)0);
 4969|      0|        }
 4970|      0|        if ((unsigned long)h == (unsigned long)((void *)0)) {
 4971|      0|            tmp___0 =
 4972|      0|                hash_initialize((size_t)13, (Hash_tuning const *)((void *)0),
 4973|      0|                                &LCO_hash, &LCO_compare, (void (*)(void *))(&free));
 4974|      0|            sp->fts_leaf_optimization_works_ht = tmp___0;
 4975|      0|            h = tmp___0;
 4976|      0|            if ((unsigned long)h == (unsigned long)((void *)0)) {
 4977|      0|                return ((_Bool)0);
 4978|      0|            }
 4979|      0|        }
 4980|      0|        tmp.st_dev = (dev_t)p->fts_statp[0].st_dev;
 4981|      0|        ent = (struct LCO_ent *)hash_lookup((Hash_table const *)h,
 4982|      0|                                            (void const *)(&tmp));
 4983|      0|        if (ent) {
 4984|      0|            return (ent->opt_ok);
 4985|      0|        }
 4986|      0|        t2 = (struct LCO_ent *)malloc(sizeof(*t2));
 4987|      0|        if ((unsigned long)t2 == (unsigned long)((void *)0)) {
 4988|      0|            return ((_Bool)0);
 4989|      0|        }
 4990|      0|        opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
 4991|      0|        t2->opt_ok = opt_ok;
 4992|      0|        t2->st_dev = (dev_t)p->fts_statp[0].st_dev;
 4993|      0|        ent = (struct LCO_ent *)hash_insert(h, (void const *)t2);
 4994|      0|        if ((unsigned long)ent == (unsigned long)((void *)0)) {
 4995|      0|            free((void *)t2);
 4996|      0|            return ((_Bool)0);
 4997|      0|        }
 4998|      0|        while (1) {
 4999|       |
 5000|      0|            if (!((unsigned long)ent == (unsigned long)t2)) {
 5001|      0|                abort();
 5002|      0|            }
 5003|      0|            goto while_break;
 5004|      0|        }
 5005|      0|while_break:
 5006|      0|        ;
 5007|      0|        return (opt_ok);
 5008|      0|    }
 5009|      0|}
 5010|       |__attribute__((__nothrow__))
 5011|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp);
 5012|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp)
 5013|     11|{
 5014|     11|    FTSENT *p;
 5015|     11|    FTSENT *tmp;
 5016|     11|    unsigned short instr;
 5017|     11|    char *t;
 5018|     11|    int *tmp___0;
 5019|     11|    int tmp___1;
 5020|     11|    int *tmp___2;
 5021|     11|    int tmp___3;
 5022|     11|    struct _ftsent *tmp___4;
 5023|     11|    int tmp___5;
 5024|     11|    int tmp___6;
 5025|     11|    int tmp___7;
 5026|     11|    int tmp___8;
 5027|     11|    int tmp___9;
 5028|     11|    int *tmp___10;
 5029|     11|    int tmp___11;
 5030|     11|    size_t tmp___12;
 5031|     11|    char *tmp___13;
 5032|     11|    FTSENT *parent;
 5033|     11|    _Bool tmp___14;
 5034|     11|    int *tmp___15;
 5035|     11|    _Bool tmp___16;
 5036|     11|    int *tmp___17;
 5037|     11|    struct _ftsent *tmp___18;
 5038|     11|    int *tmp___19;
 5039|     11|    int tmp___20;
 5040|     11|    int tmp___21;
 5041|     11|    int tmp___22;
 5042|     11|    int tmp___23;
 5043|     11|    int tmp___24;
 5044|     11|    int saved_errno;
 5045|     11|    int *tmp___25;
 5046|     11|    int *tmp___26;
 5047|     11|    int *tmp___27;
 5048|     11|    int tmp___28;
 5049|     11|    int tmp___29;
 5050|     11|    int *tmp___30;
 5051|     11|    int tmp___31;
 5052|     11|    FTSENT *tmp___32;
 5053|       |
 5054|     11|    {
 5055|     11|        if ((unsigned long)sp->fts_cur == (unsigned long)((void *)0)) {
 5056|      0|            return ((FTSENT *)((void *)0));
 5057|      0|        }
 5058|     11|        else {
 5059|     11|            if (sp->fts_options & 8192) {
 5060|      0|                return ((FTSENT *)((void *)0));
 5061|      0|            }
 5062|     11|        }
 5063|     11|        p = sp->fts_cur;
 5064|     11|        instr = p->fts_instr;
 5065|     11|        p->fts_instr = (unsigned short)3;
 5066|     11|        if ((int)instr == 1) {
 5067|      0|            p->fts_info = fts_stat(sp, p, (_Bool)0);
 5068|      0|            return (p);
 5069|      0|        }
 5070|     11|        if ((int)instr == 2) {
 5071|      0|            if ((int)p->fts_info == 12) {
 5072|      0|                goto _L;
 5073|      0|            }
 5074|      0|            else {
 5075|      0|                if ((int)p->fts_info == 13) {
 5076|      0|_L:
 5077|      0|                    p->fts_info = fts_stat(sp, p, (_Bool)1);
 5078|      0|                    if ((int)p->fts_info == 1) {
 5079|      0|                        if (!(sp->fts_options & 4)) {
 5080|      0|                            tmp___1 = diropen((FTS const *)sp, ".");
 5081|      0|                            p->fts_symfd = tmp___1;
 5082|      0|                            if (tmp___1 < 0) {
 5083|      0|                                tmp___0 = __errno_location();
 5084|      0|                                p->fts_errno = *tmp___0;
 5085|      0|                                p->fts_info = (unsigned short)7;
 5086|      0|                            }
 5087|      0|                            else {
 5088|      0|                                p->fts_flags = (unsigned short)((int)p->fts_flags | 2);
 5089|      0|                            }
 5090|      0|                        }
 5091|      0|                    }
 5092|      0|                    goto check_for_dir;
 5093|      0|                }
 5094|      0|            }
 5095|      0|        }
 5096|     11|        if ((int)p->fts_info == 1) {
 5097|      3|            if ((int)instr == 4) {
 5098|      0|                goto _L___0;
 5099|      0|            }
 5100|      3|            else {
 5101|      3|                if (sp->fts_options & 64) {
 5102|      0|                    if (p->fts_statp[0].st_dev != sp->fts_dev) {
 5103|      0|_L___0:
 5104|      0|                        if ((int)p->fts_flags & 2) {
 5105|      0|                            close(p->fts_symfd);
 5106|      0|                        }
 5107|      0|                        if (sp->fts_child) {
 5108|      0|                            fts_lfree(sp->fts_child);
 5109|      0|                            sp->fts_child = (struct _ftsent *)((void *)0);
 5110|      0|                        }
 5111|      0|                        p->fts_info = (unsigned short)6;
 5112|      0|                        while (1) {
 5113|      0|                            leave_dir(sp, p);
 5114|      0|                            goto while_break;
 5115|      0|                        }
 5116|      0|while_break:
 5117|      0|                        ;
 5118|      0|                        return (p);
 5119|      0|                    }
 5120|      0|                }
 5121|      3|            }
 5122|      3|            if ((unsigned long)sp->fts_child != (unsigned long)((void *)0)) {
 5123|      0|                if (sp->fts_options & 4096) {
 5124|      0|                    sp->fts_options &= -4097;
 5125|      0|                    fts_lfree(sp->fts_child);
 5126|      0|                    sp->fts_child = (struct _ftsent *)((void *)0);
 5127|      0|                }
 5128|      0|            }
 5129|      3|            if ((unsigned long)sp->fts_child != (unsigned long)((void *)0)) {
 5130|      0|                tmp___3 = fts_safe_changedir(sp, p, -1, (char const *)p->fts_accpath);
 5131|      0|                if (tmp___3) {
 5132|      0|                    tmp___2 = __errno_location();
 5133|      0|                    p->fts_errno = *tmp___2;
 5134|      0|                    p->fts_flags = (unsigned short)((int)p->fts_flags | 1);
 5135|      0|                    p = sp->fts_child;
 5136|      0|                    while (1) {
 5137|       |
 5138|      0|                        if (!((unsigned long)p != (unsigned long)((void *)0))) {
 5139|      0|                            goto while_break___0;
 5140|      0|                        }
 5141|      0|                        p->fts_accpath = (p->fts_parent)->fts_accpath;
 5142|      0|                        p = p->fts_link;
 5143|      0|                    }
 5144|      0|while_break___0:
 5145|      0|                    ;
 5146|      0|                }
 5147|      0|            }
 5148|      3|            else {
 5149|      3|                tmp___4 = fts_build(sp, 3);
 5150|      3|                sp->fts_child = tmp___4;
 5151|      3|                if ((unsigned long)tmp___4 == (unsigned long)((void *)0)) {
 5152|      0|                    if (sp->fts_options & 8192) {
 5153|      0|                        return ((FTSENT *)((void *)0));
 5154|      0|                    }
 5155|      0|                    if (p->fts_errno) {
 5156|      0|                        if ((int)p->fts_info != 4) {
 5157|      0|                            p->fts_info = (unsigned short)7;
 5158|      0|                        }
 5159|      0|                    }
 5160|      0|                    while (1) {
 5161|      0|                        leave_dir(sp, p);
 5162|      0|                        goto while_break___1;
 5163|      0|                    }
 5164|      0|while_break___1:
 5165|      0|                    ;
 5166|      0|                    return (p);
 5167|      0|                }
 5168|      3|            }
 5169|      3|            p = sp->fts_child;
 5170|      3|            sp->fts_child = (struct _ftsent *)((void *)0);
 5171|      3|            goto name;
 5172|      3|        }
 5173|      8|next:
 5174|      8|        tmp = p;
 5175|      8|        p = p->fts_link;
 5176|      8|        if ((unsigned long)p != (unsigned long)((void *)0)) {
 5177|      4|            sp->fts_cur = p;
 5178|      4|            free((void *)tmp);
 5179|      4|            if (p->fts_level == 0L) {
 5180|      1|                fd_ring_clear(&sp->fts_fd_ring);
 5181|      1|                if (!(sp->fts_options & 4)) {
 5182|      1|                    if (sp->fts_options & 512) {
 5183|      1|                        if (sp->fts_options & 512) {
 5184|      1|                            tmp___5 = -100;
 5185|      1|                        }
 5186|      0|                        else {
 5187|      0|                            tmp___5 = sp->fts_rfd;
 5188|      0|                        }
 5189|      1|                        cwd_advance_fd(sp, tmp___5, (_Bool)1);
 5190|      1|                        tmp___8 = 0;
 5191|      1|                    }
 5192|      0|                    else {
 5193|      0|                        if (sp->fts_options & 512) {
 5194|      0|                            tmp___6 = -100;
 5195|      0|                        }
 5196|      0|                        else {
 5197|      0|                            tmp___6 = sp->fts_rfd;
 5198|      0|                        }
 5199|      0|                        tmp___7 = fchdir(tmp___6);
 5200|      0|                        tmp___8 = tmp___7;
 5201|      0|                    }
 5202|      1|                    if (tmp___8) {
 5203|      0|                        tmp___9 = 1;
 5204|      0|                    }
 5205|      1|                    else {
 5206|      1|                        tmp___9 = 0;
 5207|      1|                    }
 5208|      1|                }
 5209|      0|                else {
 5210|      0|                    tmp___9 = 0;
 5211|      0|                }
 5212|      1|                if (tmp___9) {
 5213|      0|                    sp->fts_options |= 8192;
 5214|      0|                    return ((FTSENT *)((void *)0));
 5215|      0|                }
 5216|      1|                free_dir(sp);
 5217|      1|                fts_load(sp, p);
 5218|      1|                setup_dir(sp);
 5219|      1|                goto check_for_dir;
 5220|      1|            }
 5221|      3|            if ((int)p->fts_instr == 4) {
 5222|      0|                goto next;
 5223|      0|            }
 5224|      3|            if ((int)p->fts_instr == 2) {
 5225|      0|                p->fts_info = fts_stat(sp, p, (_Bool)1);
 5226|      0|                if ((int)p->fts_info == 1) {
 5227|      0|                    if (!(sp->fts_options & 4)) {
 5228|      0|                        tmp___11 = diropen((FTS const *)sp, ".");
 5229|      0|                        p->fts_symfd = tmp___11;
 5230|      0|                        if (tmp___11 < 0) {
 5231|      0|                            tmp___10 = __errno_location();
 5232|      0|                            p->fts_errno = *tmp___10;
 5233|      0|                            p->fts_info = (unsigned short)7;
 5234|      0|                        }
 5235|      0|                        else {
 5236|      0|                            p->fts_flags = (unsigned short)((int)p->fts_flags | 2);
 5237|      0|                        }
 5238|      0|                    }
 5239|      0|                }
 5240|      0|                p->fts_instr = (unsigned short)3;
 5241|      0|            }
 5242|      6|name:
 5243|      6|            if ((int)*((p->fts_parent)->fts_path +
 5244|      6|                       ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
 5245|      3|                tmp___12 = (p->fts_parent)->fts_pathlen - 1UL;
 5246|      3|            }
 5247|      3|            else {
 5248|      3|                tmp___12 = (p->fts_parent)->fts_pathlen;
 5249|      3|            }
 5250|      6|            t = sp->fts_path + tmp___12;
 5251|      6|            tmp___13 = t;
 5252|      6|            t++;
 5253|      6|            *tmp___13 = (char)'/';
 5254|      6|            memmove((void *)t, (void const *)(p->fts_name), p->fts_namelen + 1UL);
 5255|      7|check_for_dir:
 5256|      7|            sp->fts_cur = p;
 5257|      7|            if ((int)p->fts_info == 11) {
 5258|      6|                if (p->fts_statp[0].st_size == 2L) {
 5259|      2|                    parent = p->fts_parent;
 5260|      2|                    if (0L < p->fts_level) {
 5261|      2|                        if (parent->fts_n_dirs_remaining == 0UL) {
 5262|      0|                            if (sp->fts_options & 8) {
 5263|      0|                                if (sp->fts_options & 16) {
 5264|      0|                                    tmp___14 = link_count_optimize_ok((FTSENT const *)parent);
 5265|      0|                                    if (!tmp___14) {
 5266|      0|                                        goto _L___4;
 5267|      0|                                    }
 5268|      0|                                }
 5269|      0|                                else {
 5270|      0|                                    goto _L___4;
 5271|      0|                                }
 5272|      0|                            }
 5273|      0|                            else {
 5274|      0|                                goto _L___4;
 5275|      0|                            }
 5276|      0|                        }
 5277|      2|                        else {
 5278|      2|                            goto _L___4;
 5279|      2|                        }
 5280|      2|                    }
 5281|      0|                    else {
 5282|      2|_L___4:
 5283|      2|                        p->fts_info = fts_stat(sp, p, (_Bool)0);
 5284|      2|                        if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
 5285|      2|                            if (p->fts_level != 0L) {
 5286|      2|                                if (parent->fts_n_dirs_remaining) {
 5287|      2|                                    (parent->fts_n_dirs_remaining)--;
 5288|      2|                                }
 5289|      2|                            }
 5290|      2|                        }
 5291|      2|                    }
 5292|      2|                }
 5293|      4|                else {
 5294|      4|                    while (1) {
 5295|       |
 5296|      4|                        if (!(p->fts_statp[0].st_size == 1L)) {
 5297|      0|                            abort();
 5298|      0|                        }
 5299|      4|                        goto while_break___2;
 5300|      4|                    }
 5301|      4|while_break___2:
 5302|      4|                    ;
 5303|      4|                }
 5304|      6|            }
 5305|      7|            if ((int)p->fts_info == 1) {
 5306|      3|                if (p->fts_level == 0L) {
 5307|      1|                    sp->fts_dev = p->fts_statp[0].st_dev;
 5308|      1|                }
 5309|      3|                tmp___16 = enter_dir(sp, p);
 5310|      3|                if (!tmp___16) {
 5311|      0|                    tmp___15 = __errno_location();
 5312|      0|                    *tmp___15 = 12;
 5313|      0|                    return ((FTSENT *)((void *)0));
 5314|      0|                }
 5315|      3|            }
 5316|      7|            return (p);
 5317|      7|        }
 5318|      4|        p = tmp->fts_parent;
 5319|      4|        sp->fts_cur = p;
 5320|      4|        free((void *)tmp);
 5321|      4|        if (p->fts_level == -1L) {
 5322|      1|            free((void *)p);
 5323|      1|            tmp___17 = __errno_location();
 5324|      1|            *tmp___17 = 0;
 5325|      1|            tmp___18 = (struct _ftsent *)((void *)0);
 5326|      1|            sp->fts_cur = tmp___18;
 5327|      1|            return (tmp___18);
 5328|      1|        }
 5329|      3|        while (1) {
 5330|       |
 5331|      3|            if (!((int)p->fts_info != 11)) {
 5332|      0|                abort();
 5333|      0|            }
 5334|      3|            goto while_break___3;
 5335|      3|        }
 5336|      3|while_break___3:
 5337|      3|        *(sp->fts_path + p->fts_pathlen) = (char)'\000';
 5338|      3|        if (p->fts_level == 0L) {
 5339|      1|            fd_ring_clear(&sp->fts_fd_ring);
 5340|      1|            if (!(sp->fts_options & 4)) {
 5341|      1|                if (sp->fts_options & 512) {
 5342|      1|                    if (sp->fts_options & 512) {
 5343|      1|                        tmp___20 = -100;
 5344|      1|                    }
 5345|      0|                    else {
 5346|      0|                        tmp___20 = sp->fts_rfd;
 5347|      0|                    }
 5348|      1|                    cwd_advance_fd(sp, tmp___20, (_Bool)1);
 5349|      1|                    tmp___23 = 0;
 5350|      1|                }
 5351|      0|                else {
 5352|      0|                    if (sp->fts_options & 512) {
 5353|      0|                        tmp___21 = -100;
 5354|      0|                    }
 5355|      0|                    else {
 5356|      0|                        tmp___21 = sp->fts_rfd;
 5357|      0|                    }
 5358|      0|                    tmp___22 = fchdir(tmp___21);
 5359|      0|                    tmp___23 = tmp___22;
 5360|      0|                }
 5361|      1|                if (tmp___23) {
 5362|      0|                    tmp___24 = 1;
 5363|      0|                }
 5364|      1|                else {
 5365|      1|                    tmp___24 = 0;
 5366|      1|                }
 5367|      1|            }
 5368|      0|            else {
 5369|      0|                tmp___24 = 0;
 5370|      0|            }
 5371|      1|            if (tmp___24) {
 5372|      0|                tmp___19 = __errno_location();
 5373|      0|                p->fts_errno = *tmp___19;
 5374|      0|                sp->fts_options |= 8192;
 5375|      0|            }
 5376|      1|        }
 5377|      2|        else {
 5378|      2|            if ((int)p->fts_flags & 2) {
 5379|      0|                if (!(sp->fts_options & 4)) {
 5380|      0|                    if (sp->fts_options & 512) {
 5381|      0|                        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
 5382|      0|                        tmp___29 = 0;
 5383|      0|                    }
 5384|      0|                    else {
 5385|      0|                        tmp___28 = fchdir(p->fts_symfd);
 5386|      0|                        tmp___29 = tmp___28;
 5387|      0|                    }
 5388|      0|                    if (tmp___29) {
 5389|      0|                        tmp___25 = __errno_location();
 5390|      0|                        saved_errno = *tmp___25;
 5391|      0|                        close(p->fts_symfd);
 5392|      0|                        tmp___26 = __errno_location();
 5393|      0|                        *tmp___26 = saved_errno;
 5394|      0|                        tmp___27 = __errno_location();
 5395|      0|                        p->fts_errno = *tmp___27;
 5396|      0|                        sp->fts_options |= 8192;
 5397|      0|                    }
 5398|      0|                }
 5399|      0|                close(p->fts_symfd);
 5400|      0|            }
 5401|      2|            else {
 5402|      2|                if (!((int)p->fts_flags & 1)) {
 5403|      2|                    tmp___31 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
 5404|      2|                    if (tmp___31) {
 5405|      0|                        tmp___30 = __errno_location();
 5406|      0|                        p->fts_errno = *tmp___30;
 5407|      0|                        sp->fts_options |= 8192;
 5408|      0|                    }
 5409|      2|                }
 5410|      2|            }
 5411|      2|        }
 5412|      3|        if (p->fts_errno) {
 5413|      0|            p->fts_info = (unsigned short)7;
 5414|      0|        }
 5415|      3|        else {
 5416|      3|            p->fts_info = (unsigned short)6;
 5417|      3|        }
 5418|      3|        if (p->fts_errno == 0) {
 5419|      3|            while (1) {
 5420|      3|                leave_dir(sp, p);
 5421|      3|                goto while_break___4;
 5422|      3|            }
 5423|      3|while_break___4:
 5424|      3|            ;
 5425|      3|        }
 5426|      3|        if (sp->fts_options & 8192) {
 5427|      0|            tmp___32 = (FTSENT *)((void *)0);
 5428|      0|        }
 5429|      3|        else {
 5430|      3|            tmp___32 = p;
 5431|      3|        }
 5432|      3|        return (tmp___32);
 5433|      3|    }
 5434|      3|}
 5435|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__)) fts_set)(
 5436|       |    FTS *sp __attribute__((__unused__)), FTSENT *p, int instr);
 5437|       |int(__attribute__((__leaf__)) fts_set)(FTS *sp __attribute__((__unused__)),
 5438|       |                                       FTSENT *p, int instr)
 5439|      0|{
 5440|      0|    int *tmp;
 5441|       |
 5442|      0|    {
 5443|      0|        if (instr != 0) {
 5444|      0|            if (instr != 1) {
 5445|      0|                if (instr != 2) {
 5446|      0|                    if (instr != 3) {
 5447|      0|                        if (instr != 4) {
 5448|      0|                            tmp = __errno_location();
 5449|      0|                            *tmp = 22;
 5450|      0|                            return (1);
 5451|      0|                        }
 5452|      0|                    }
 5453|      0|                }
 5454|      0|            }
 5455|      0|        }
 5456|      0|        p->fts_instr = (unsigned short)instr;
 5457|      0|        return (0);
 5458|      0|    }
 5459|      0|}
 5460|       |static int fts_compare_ino(struct _ftsent const **a, struct _ftsent const **b)
 5461|      0|{
 5462|      0|    int tmp;
 5463|      0|    int tmp___0;
 5464|       |
 5465|      0|    {
 5466|      0|        if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
 5467|      0|            tmp___0 = -1;
 5468|      0|        }
 5469|      0|        else {
 5470|      0|            if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
 5471|      0|                tmp = 1;
 5472|      0|            }
 5473|      0|            else {
 5474|      0|                tmp = 0;
 5475|      0|            }
 5476|      0|            tmp___0 = tmp;
 5477|      0|        }
 5478|      0|        return (tmp___0);
 5479|      0|    }
 5480|      0|}
 5481|       |static void set_stat_type(struct stat *st, unsigned int dtype)
 5482|      6|{
 5483|      6|    mode_t type;
 5484|       |
 5485|      6|    {
 5486|      6|        if (dtype == 6U) {
 5487|      0|            goto case_6;
 5488|      0|        }
 5489|      6|        if (dtype == 2U) {
 5490|      0|            goto case_2;
 5491|      0|        }
 5492|      6|        if (dtype == 4U) {
 5493|      2|            goto case_4;
 5494|      2|        }
 5495|      4|        if (dtype == 1U) {
 5496|      0|            goto case_1;
 5497|      0|        }
 5498|      4|        if (dtype == 10U) {
 5499|      0|            goto case_10;
 5500|      0|        }
 5501|      4|        if (dtype == 8U) {
 5502|      4|            goto case_8;
 5503|      4|        }
 5504|      0|        if (dtype == 12U) {
 5505|      0|            goto case_12;
 5506|      0|        }
 5507|      0|        goto switch_default;
 5508|      0|case_6:
 5509|      0|        type = (mode_t)24576;
 5510|      0|        goto switch_break;
 5511|      0|case_2:
 5512|      0|        type = (mode_t)8192;
 5513|      0|        goto switch_break;
 5514|      2|case_4:
 5515|      2|        type = (mode_t)16384;
 5516|      2|        goto switch_break;
 5517|      0|case_1:
 5518|      0|        type = (mode_t)4096;
 5519|      0|        goto switch_break;
 5520|      0|case_10:
 5521|      0|        type = (mode_t)40960;
 5522|      0|        goto switch_break;
 5523|      4|case_8:
 5524|      4|        type = (mode_t)32768;
 5525|      4|        goto switch_break;
 5526|      0|case_12:
 5527|      0|        type = (mode_t)49152;
 5528|      0|        goto switch_break;
 5529|      0|switch_default:
 5530|      0|        type = (mode_t)0;
 5531|      6|switch_break:
 5532|      6|        st->st_mode = type;
 5533|      6|        return;
 5534|      0|    }
 5535|      0|}
 5536|       |static FTSENT *fts_build(FTS *sp, int type)
 5537|      3|{
 5538|      3|    struct dirent *dp;
 5539|      3|    FTSENT *p;
 5540|      3|    FTSENT *head;
 5541|      3|    size_t nitems;
 5542|      3|    FTSENT *cur;
 5543|      3|    FTSENT *tail;
 5544|      3|    DIR *dirp;
 5545|      3|    void *oldaddr;
 5546|      3|    int saved_errno;
 5547|      3|    _Bool descend;
 5548|      3|    _Bool doadjust;
 5549|      3|    ptrdiff_t level;
 5550|      3|    nlink_t nlinks;
 5551|      3|    _Bool nostat;
 5552|      3|    size_t len;
 5553|      3|    size_t maxlen;
 5554|      3|    size_t new_len;
 5555|      3|    char *cp;
 5556|      3|    int *tmp;
 5557|      3|    DIR *tmp___0;
 5558|      3|    DIR *tmp___1;
 5559|      3|    int *tmp___2;
 5560|      3|    _Bool tmp___3;
 5561|      3|    int tmp___4;
 5562|      3|    int dir_fd;
 5563|      3|    int tmp___5;
 5564|      3|    int *tmp___6;
 5565|      3|    int tmp___7;
 5566|      3|    char *tmp___8;
 5567|      3|    _Bool is_dir;
 5568|      3|    size_t tmp___9;
 5569|      3|    int *tmp___10;
 5570|      3|    int *tmp___11;
 5571|      3|    size_t tmp___12;
 5572|      3|    _Bool tmp___13;
 5573|      3|    size_t tmp___14;
 5574|      3|    size_t tmp___15;
 5575|      3|    int *tmp___16;
 5576|      3|    _Bool skip_stat;
 5577|      3|    int tmp___17;
 5578|      3|    int tmp___18;
 5579|      3|    int tmp___19;
 5580|      3|    int tmp___20;
 5581|      3|    int tmp___21;
 5582|      3|    int tmp___22;
 5583|      3|    int tmp___23;
 5584|      3|    int tmp___24;
 5585|      3|    int tmp___25;
 5586|      3|    int tmp___26;
 5587|      3|    _Bool tmp___27;
 5588|       |
 5589|      3|    {
 5590|      3|        cur = sp->fts_cur;
 5591|      3|        if (!(sp->fts_options & 4)) {
 5592|      3|            if (sp->fts_options & 512) {
 5593|      3|                tmp___0 = opendirat(sp->fts_cwd_fd, (char const *)cur->fts_accpath);
 5594|      3|                dirp = tmp___0;
 5595|      3|            }
 5596|      0|            else {
 5597|      0|                tmp___1 = opendir_safer((char const *)cur->fts_accpath);
 5598|      0|                dirp = tmp___1;
 5599|      0|            }
 5600|      3|        }
 5601|      0|        else {
 5602|      0|            tmp___1 = opendir_safer((char const *)cur->fts_accpath);
 5603|      0|            dirp = tmp___1;
 5604|      0|        }
 5605|      3|        if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 5606|      0|            if (type == 3) {
 5607|      0|                cur->fts_info = (unsigned short)4;
 5608|      0|                tmp = __errno_location();
 5609|      0|                cur->fts_errno = *tmp;
 5610|      0|            }
 5611|      0|            return ((FTSENT *)((void *)0));
 5612|      0|        }
 5613|      3|        if ((int)cur->fts_info == 11) {
 5614|      0|            cur->fts_info = fts_stat(sp, cur, (_Bool)0);
 5615|      0|        }
 5616|      3|        else {
 5617|      3|            if (sp->fts_options & 256) {
 5618|      0|                while (1) {
 5619|      0|                    leave_dir(sp, cur);
 5620|      0|                    goto while_break;
 5621|      0|                }
 5622|      0|while_break:
 5623|      0|                fts_stat(sp, cur, (_Bool)0);
 5624|      0|                tmp___3 = enter_dir(sp, cur);
 5625|      0|                if (!tmp___3) {
 5626|      0|                    tmp___2 = __errno_location();
 5627|      0|                    *tmp___2 = 12;
 5628|      0|                    return ((FTSENT *)((void *)0));
 5629|      0|                }
 5630|      0|            }
 5631|      3|        }
 5632|      3|        if (type == 2) {
 5633|      0|            nlinks = (nlink_t)0;
 5634|      0|            nostat = (_Bool)0;
 5635|      0|        }
 5636|      3|        else {
 5637|      3|            if (sp->fts_options & 8) {
 5638|      3|                if (sp->fts_options & 16) {
 5639|      3|                    if (sp->fts_options & 32) {
 5640|      0|                        tmp___4 = 0;
 5641|      0|                    }
 5642|      3|                    else {
 5643|      3|                        tmp___4 = 2;
 5644|      3|                    }
 5645|      3|                    nlinks = cur->fts_statp[0].st_nlink - (__nlink_t)tmp___4;
 5646|      3|                    nostat = (_Bool)1;
 5647|      3|                }
 5648|      0|                else {
 5649|      0|                    nlinks = (nlink_t)-1;
 5650|      0|                    nostat = (_Bool)0;
 5651|      0|                }
 5652|      3|            }
 5653|      0|            else {
 5654|      0|                nlinks = (nlink_t)-1;
 5655|      0|                nostat = (_Bool)0;
 5656|      0|            }
 5657|      3|        }
 5658|      3|        if (nlinks) {
 5659|      2|            goto _L___0;
 5660|      2|        }
 5661|      1|        else {
 5662|      1|            if (type == 3) {
 5663|      3|_L___0:
 5664|      3|                tmp___5 = dirfd(dirp);
 5665|      3|                dir_fd = tmp___5;
 5666|      3|                if (sp->fts_options & 512) {
 5667|      3|                    if (0 <= dir_fd) {
 5668|      3|                        dir_fd = dup_safer(dir_fd);
 5669|      3|                        set_cloexec_flag(dir_fd, (_Bool)1);
 5670|      3|                    }
 5671|      3|                }
 5672|      3|                if (dir_fd < 0) {
 5673|      0|                    goto _L;
 5674|      0|                }
 5675|      3|                else {
 5676|      3|                    tmp___7 =
 5677|      3|                        fts_safe_changedir(sp, cur, dir_fd, (char const *)((void *)0));
 5678|      3|                    if (tmp___7) {
 5679|      0|_L:
 5680|      0|                        if (nlinks) {
 5681|      0|                            if (type == 3) {
 5682|      0|                                tmp___6 = __errno_location();
 5683|      0|                                cur->fts_errno = *tmp___6;
 5684|      0|                            }
 5685|      0|                        }
 5686|      0|                        cur->fts_flags = (unsigned short)((int)cur->fts_flags | 1);
 5687|      0|                        descend = (_Bool)0;
 5688|      0|                        closedir(dirp);
 5689|      0|                        if (sp->fts_options & 512) {
 5690|      0|                            if (0 <= dir_fd) {
 5691|      0|                                close(dir_fd);
 5692|      0|                            }
 5693|      0|                        }
 5694|      0|                        dirp = (DIR *)((void *)0);
 5695|      0|                    }
 5696|      3|                    else {
 5697|      3|                        descend = (_Bool)1;
 5698|      3|                    }
 5699|      3|                }
 5700|      3|            }
 5701|      0|            else {
 5702|      0|                descend = (_Bool)0;
 5703|      0|            }
 5704|      1|        }
 5705|      3|        if ((int)*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
 5706|      1|            len = cur->fts_pathlen - 1UL;
 5707|      1|        }
 5708|      2|        else {
 5709|      2|            len = cur->fts_pathlen;
 5710|      2|        }
 5711|      3|        if (sp->fts_options & 4) {
 5712|      0|            cp = sp->fts_path + len;
 5713|      0|            tmp___8 = cp;
 5714|      0|            cp++;
 5715|      0|            *tmp___8 = (char)'/';
 5716|      0|        }
 5717|      3|        else {
 5718|      3|            cp = (char *)((void *)0);
 5719|      3|        }
 5720|      3|        len++;
 5721|      3|        maxlen = sp->fts_pathlen - len;
 5722|      3|        level = cur->fts_level + 1L;
 5723|      3|        doadjust = (_Bool)0;
 5724|      3|        tail = (FTSENT *)((void *)0);
 5725|      3|        head = tail;
 5726|      3|        nitems = (size_t)0;
 5727|     15|        while (1) {
 5728|       |
 5729|     15|            if (dirp) {
 5730|     15|                dp = readdir(dirp);
 5731|     15|                if (!dp) {
 5732|      3|                    goto while_break___0;
 5733|      3|                }
 5734|     15|            }
 5735|      0|            else {
 5736|      0|                goto while_break___0;
 5737|      0|            }
 5738|     12|            if (!(sp->fts_options & 32)) {
 5739|     12|                if ((int)dp->d_name[0] == 46) {
 5740|      6|                    if (!dp->d_name[1]) {
 5741|      3|                        goto __Cont;
 5742|      3|                    }
 5743|      3|                    else {
 5744|      3|                        if ((int)dp->d_name[1] == 46) {
 5745|      3|                            if (!dp->d_name[2]) {
 5746|      3|                                goto __Cont;
 5747|      3|                            }
 5748|      3|                        }
 5749|      3|                    }
 5750|      6|                }
 5751|     12|            }
 5752|      6|            tmp___9 = strlen((char const *)(dp->d_name));
 5753|      6|            p = fts_alloc(sp, (char const *)(dp->d_name), tmp___9);
 5754|      6|            if ((unsigned long)p == (unsigned long)((void *)0)) {
 5755|      0|                goto mem1;
 5756|      0|            }
 5757|      6|            tmp___14 = strlen((char const *)(dp->d_name));
 5758|      6|            if (tmp___14 >= maxlen) {
 5759|      0|                oldaddr = (void *)sp->fts_path;
 5760|      0|                tmp___12 = strlen((char const *)(dp->d_name));
 5761|      0|                tmp___13 = fts_palloc(sp, (tmp___12 + len) + 1UL);
 5762|      0|                if (!tmp___13) {
 5763|      0|mem1:
 5764|      0|                    tmp___10 = __errno_location();
 5765|      0|                    saved_errno = *tmp___10;
 5766|      0|                    free((void *)p);
 5767|      0|                    fts_lfree(head);
 5768|      0|                    closedir(dirp);
 5769|      0|                    cur->fts_info = (unsigned short)7;
 5770|      0|                    sp->fts_options |= 8192;
 5771|      0|                    tmp___11 = __errno_location();
 5772|      0|                    *tmp___11 = saved_errno;
 5773|      0|                    return ((FTSENT *)((void *)0));
 5774|      0|                }
 5775|      0|                if ((unsigned long)oldaddr != (unsigned long)sp->fts_path) {
 5776|      0|                    doadjust = (_Bool)1;
 5777|      0|                    if (sp->fts_options & 4) {
 5778|      0|                        cp = sp->fts_path + len;
 5779|      0|                    }
 5780|      0|                }
 5781|      0|                maxlen = sp->fts_pathlen - len;
 5782|      0|            }
 5783|      6|            tmp___15 = strlen((char const *)(dp->d_name));
 5784|      6|            new_len = len + tmp___15;
 5785|      6|            if (new_len < len) {
 5786|      0|                free((void *)p);
 5787|      0|                fts_lfree(head);
 5788|      0|                closedir(dirp);
 5789|      0|                cur->fts_info = (unsigned short)7;
 5790|      0|                sp->fts_options |= 8192;
 5791|      0|                tmp___16 = __errno_location();
 5792|      0|                *tmp___16 = 36;
 5793|      0|                return ((FTSENT *)((void *)0));
 5794|      0|            }
 5795|      6|            p->fts_level = level;
 5796|      6|            p->fts_parent = sp->fts_cur;
 5797|      6|            p->fts_pathlen = new_len;
 5798|      6|            p->fts_statp[0].st_ino = dp->d_ino;
 5799|      6|            if (sp->fts_options & 4) {
 5800|      0|                p->fts_accpath = p->fts_path;
 5801|      0|                memmove((void *)cp, (void const *)(p->fts_name), p->fts_namelen + 1UL);
 5802|      0|            }
 5803|      6|            else {
 5804|      6|                p->fts_accpath = p->fts_name;
 5805|      6|            }
 5806|      6|            if ((unsigned long)sp->fts_compar == (unsigned long)((void *)0) ||
 5807|      6|                    sp->fts_options & 1024) {
 5808|      6|                if (sp->fts_options & 16) {
 5809|      6|                    if (sp->fts_options & 8) {
 5810|      6|                        if ((int)dp->d_type != 0) {
 5811|      6|                            if (!((int)dp->d_type == 4)) {
 5812|      4|                                tmp___17 = 1;
 5813|      4|                            }
 5814|      2|                            else {
 5815|      2|                                tmp___17 = 0;
 5816|      2|                            }
 5817|      6|                        }
 5818|      0|                        else {
 5819|      0|                            tmp___17 = 0;
 5820|      0|                        }
 5821|      6|                    }
 5822|      0|                    else {
 5823|      0|                        tmp___17 = 0;
 5824|      0|                    }
 5825|      6|                }
 5826|      0|                else {
 5827|      0|                    tmp___17 = 0;
 5828|      0|                }
 5829|      6|                skip_stat = (_Bool)tmp___17;
 5830|      6|                p->fts_info = (unsigned short)11;
 5831|      6|                set_stat_type(p->fts_statp, (unsigned int)dp->d_type);
 5832|      6|                fts_set_stat_required(p, (_Bool)(!skip_stat));
 5833|      6|                if (sp->fts_options & 16) {
 5834|      6|                    if ((int)dp->d_type == 4) {
 5835|      2|                        tmp___18 = 1;
 5836|      2|                    }
 5837|      4|                    else {
 5838|      4|                        tmp___18 = 0;
 5839|      4|                    }
 5840|      6|                }
 5841|      0|                else {
 5842|      0|                    tmp___18 = 0;
 5843|      0|                }
 5844|      6|                is_dir = (_Bool)tmp___18;
 5845|      6|            }
 5846|      0|            else {
 5847|      0|                p->fts_info = fts_stat(sp, p, (_Bool)0);
 5848|      0|                if ((int)p->fts_info == 1) {
 5849|      0|                    tmp___19 = 1;
 5850|      0|                }
 5851|      0|                else {
 5852|      0|                    if ((int)p->fts_info == 2) {
 5853|      0|                        tmp___19 = 1;
 5854|      0|                    }
 5855|      0|                    else {
 5856|      0|                        if ((int)p->fts_info == 5) {
 5857|      0|                            tmp___19 = 1;
 5858|      0|                        }
 5859|      0|                        else {
 5860|      0|                            tmp___19 = 0;
 5861|      0|                        }
 5862|      0|                    }
 5863|      0|                }
 5864|      0|                is_dir = (_Bool)tmp___19;
 5865|      0|            }
 5866|      6|            if (nlinks > 0UL) {
 5867|      3|                if (is_dir) {
 5868|      2|                    nlinks -= (nlink_t)nostat;
 5869|      2|                }
 5870|      3|            }
 5871|      6|            p->fts_link = (struct _ftsent *)((void *)0);
 5872|      6|            if ((unsigned long)head == (unsigned long)((void *)0)) {
 5873|      3|                tail = p;
 5874|      3|                head = tail;
 5875|      3|            }
 5876|      3|            else {
 5877|      3|                tail->fts_link = p;
 5878|      3|                tail = p;
 5879|      3|            }
 5880|      6|            nitems++;
 5881|     12|__Cont:
 5882|     12|            ;
 5883|     12|        }
 5884|      3|while_break___0:
 5885|      3|        ;
 5886|      3|        if (dirp) {
 5887|      3|            closedir(dirp);
 5888|      3|        }
 5889|      3|        if (doadjust) {
 5890|      0|            fts_padjust(sp, head);
 5891|      0|        }
 5892|      3|        if (sp->fts_options & 4) {
 5893|      0|            if (len == sp->fts_pathlen) {
 5894|      0|                cp--;
 5895|      0|            }
 5896|      0|            else {
 5897|      0|                if (nitems == 0UL) {
 5898|      0|                    cp--;
 5899|      0|                }
 5900|      0|            }
 5901|      0|            *cp = (char)'\000';
 5902|      0|        }
 5903|      3|        if (descend) {
 5904|      3|            if (type == 1 || !nitems) {
 5905|      0|                if (cur->fts_level == 0L) {
 5906|      0|                    fd_ring_clear(&sp->fts_fd_ring);
 5907|      0|                    if (!(sp->fts_options & 4)) {
 5908|      0|                        if (sp->fts_options & 512) {
 5909|      0|                            if (sp->fts_options & 512) {
 5910|      0|                                tmp___20 = -100;
 5911|      0|                            }
 5912|      0|                            else {
 5913|      0|                                tmp___20 = sp->fts_rfd;
 5914|      0|                            }
 5915|      0|                            cwd_advance_fd(sp, tmp___20, (_Bool)1);
 5916|      0|                            tmp___23 = 0;
 5917|      0|                        }
 5918|      0|                        else {
 5919|      0|                            if (sp->fts_options & 512) {
 5920|      0|                                tmp___21 = -100;
 5921|      0|                            }
 5922|      0|                            else {
 5923|      0|                                tmp___21 = sp->fts_rfd;
 5924|      0|                            }
 5925|      0|                            tmp___22 = fchdir(tmp___21);
 5926|      0|                            tmp___23 = tmp___22;
 5927|      0|                        }
 5928|      0|                        if (tmp___23) {
 5929|      0|                            tmp___24 = 1;
 5930|      0|                        }
 5931|      0|                        else {
 5932|      0|                            tmp___24 = 0;
 5933|      0|                        }
 5934|      0|                    }
 5935|      0|                    else {
 5936|      0|                        tmp___24 = 0;
 5937|      0|                    }
 5938|      0|                    tmp___26 = tmp___24;
 5939|      0|                }
 5940|      0|                else {
 5941|      0|                    tmp___25 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
 5942|      0|                    tmp___26 = tmp___25;
 5943|      0|                }
 5944|      0|                if (tmp___26) {
 5945|      0|                    cur->fts_info = (unsigned short)7;
 5946|      0|                    sp->fts_options |= 8192;
 5947|      0|                    fts_lfree(head);
 5948|      0|                    return ((FTSENT *)((void *)0));
 5949|      0|                }
 5950|      0|            }
 5951|      3|        }
 5952|      3|        if (!nitems) {
 5953|      0|            if (type == 3) {
 5954|      0|                cur->fts_info = (unsigned short)6;
 5955|      0|            }
 5956|      0|            fts_lfree(head);
 5957|      0|            return ((FTSENT *)((void *)0));
 5958|      0|        }
 5959|      3|        if (nitems > 10000UL) {
 5960|      0|            if (!sp->fts_compar) {
 5961|      0|                if (sp->fts_options & 512) {
 5962|      0|                    tmp___27 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
 5963|      0|                    if (tmp___27) {
 5964|      0|                        sp->fts_compar = &fts_compare_ino;
 5965|      0|                        head = fts_sort(sp, head, nitems);
 5966|      0|                        sp->fts_compar = (int (*)(struct _ftsent const **,
 5967|      0|                                                  struct _ftsent const **))((void *)0);
 5968|      0|                    }
 5969|      0|                }
 5970|      0|            }
 5971|      0|        }
 5972|      3|        if (sp->fts_compar) {
 5973|      0|            if (nitems > 1UL) {
 5974|      0|                head = fts_sort(sp, head, nitems);
 5975|      0|            }
 5976|      0|        }
 5977|      3|        return (head);
 5978|      3|    }
 5979|      3|}
 5980|       |static unsigned short fts_stat(FTS *sp, FTSENT *p, _Bool follow)
 5981|      3|{
 5982|      3|    struct stat *sbp;
 5983|      3|    int saved_errno;
 5984|      3|    int *tmp;
 5985|      3|    int *tmp___0;
 5986|      3|    int *tmp___1;
 5987|      3|    int tmp___2;
 5988|      3|    int tmp___3;
 5989|      3|    int *tmp___4;
 5990|      3|    int tmp___5;
 5991|      3|    int tmp___6;
 5992|      3|    int tmp___7;
 5993|       |
 5994|      3|    {
 5995|      3|        sbp = p->fts_statp;
 5996|      3|        if (p->fts_level == 0L) {
 5997|      1|            if (sp->fts_options & 1) {
 5998|      0|                follow = (_Bool)1;
 5999|      0|            }
 6000|      1|        }
 6001|      3|        if (sp->fts_options & 2) {
 6002|      0|            goto _L;
 6003|      0|        }
 6004|      3|        else {
 6005|      3|            if (follow) {
 6006|      0|_L:
 6007|      0|                tmp___3 = stat((char const *)p->fts_accpath, sbp);
 6008|      0|                if (tmp___3) {
 6009|      0|                    tmp = __errno_location();
 6010|      0|                    saved_errno = *tmp;
 6011|      0|                    tmp___1 = __errno_location();
 6012|      0|                    if (*tmp___1 == 2) {
 6013|      0|                        tmp___2 = lstat((char const *)p->fts_accpath, sbp);
 6014|      0|                        if (tmp___2 == 0) {
 6015|      0|                            tmp___0 = __errno_location();
 6016|      0|                            *tmp___0 = 0;
 6017|      0|                            return ((unsigned short)13);
 6018|      0|                        }
 6019|      0|                    }
 6020|      0|                    p->fts_errno = saved_errno;
 6021|      0|                    goto err;
 6022|      0|                }
 6023|      0|            }
 6024|      3|            else {
 6025|      3|                tmp___5 =
 6026|      3|                    fstatat(sp->fts_cwd_fd, (char const *)p->fts_accpath, sbp, 256);
 6027|      3|                if (tmp___5) {
 6028|      0|                    tmp___4 = __errno_location();
 6029|      0|                    p->fts_errno = *tmp___4;
 6030|      0|err:
 6031|      0|                    memset((void *)sbp, 0, sizeof(struct stat));
 6032|      0|                    return ((unsigned short)10);
 6033|      0|                }
 6034|      3|            }
 6035|      3|        }
 6036|      3|        if ((sbp->st_mode & 61440U) == 16384U) {
 6037|      3|            if (sp->fts_options & 32) {
 6038|      0|                tmp___6 = 0;
 6039|      0|            }
 6040|      3|            else {
 6041|      3|                tmp___6 = 2;
 6042|      3|            }
 6043|      3|            p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t)tmp___6;
 6044|      3|            if ((int)p->fts_name[0] == 46) {
 6045|      0|                if (!p->fts_name[1]) {
 6046|      0|                    goto _L___0;
 6047|      0|                }
 6048|      0|                else {
 6049|      0|                    if ((int)p->fts_name[1] == 46) {
 6050|      0|                        if (!p->fts_name[2]) {
 6051|      0|_L___0:
 6052|      0|                            if (p->fts_level == 0L) {
 6053|      0|                                tmp___7 = 1;
 6054|      0|                            }
 6055|      0|                            else {
 6056|      0|                                tmp___7 = 5;
 6057|      0|                            }
 6058|      0|                            return ((unsigned short)tmp___7);
 6059|      0|                        }
 6060|      0|                    }
 6061|      0|                }
 6062|      0|            }
 6063|      3|            return ((unsigned short)1);
 6064|      3|        }
 6065|      0|        if ((sbp->st_mode & 61440U) == 40960U) {
 6066|      0|            return ((unsigned short)12);
 6067|      0|        }
 6068|      0|        if ((sbp->st_mode & 61440U) == 32768U) {
 6069|      0|            return ((unsigned short)8);
 6070|      0|        }
 6071|      0|        return ((unsigned short)3);
 6072|      0|    }
 6073|      0|}
 6074|       |static int fts_compar(void const *a, void const *b)
 6075|      0|{
 6076|      0|    FTSENT const **pa;
 6077|      0|    FTSENT const **pb;
 6078|      0|    int tmp;
 6079|       |
 6080|      0|    {
 6081|      0|        pa = (FTSENT const **)a;
 6082|      0|        pb = (FTSENT const **)b;
 6083|      0|        tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
 6084|      0|        return (tmp);
 6085|      0|    }
 6086|      0|}
 6087|       |static FTSENT *fts_sort(FTS *sp, FTSENT *head, size_t nitems)
 6088|      0|{
 6089|      0|    FTSENT **ap;
 6090|      0|    FTSENT *p;
 6091|      0|    FTSENT *dummy = 0;
 6092|      0|    int (*compare)(void const *, void const *);
 6093|      0|    int (*tmp)(void const *, void const *);
 6094|      0|    FTSENT **a;
 6095|      0|    FTSENT **tmp___0;
 6096|       |
 6097|      0|    {
 6098|      0|        if (sizeof(&dummy) == sizeof(void *)) {
 6099|      0|            if ((long)(&dummy) == (long)((void *)(&dummy))) {
 6100|      0|                tmp = (int (*)(void const *, void const *))sp->fts_compar;
 6101|      0|            }
 6102|      0|            else {
 6103|      0|                tmp = &fts_compar;
 6104|      0|            }
 6105|      0|        }
 6106|      0|        else {
 6107|      0|            tmp = &fts_compar;
 6108|      0|        }
 6109|      0|        compare = tmp;
 6110|      0|        if (nitems > sp->fts_nitems) {
 6111|      0|            sp->fts_nitems = nitems + 40UL;
 6112|      0|            if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
 6113|      0|                free((void *)sp->fts_array);
 6114|      0|                sp->fts_array = (struct _ftsent **)((void *)0);
 6115|      0|                sp->fts_nitems = (size_t)0;
 6116|      0|                return (head);
 6117|      0|            }
 6118|      0|            else {
 6119|      0|                a = (FTSENT **)realloc((void *)sp->fts_array,
 6120|      0|                                       sp->fts_nitems * sizeof(*a));
 6121|      0|                if (!a) {
 6122|      0|                    free((void *)sp->fts_array);
 6123|      0|                    sp->fts_array = (struct _ftsent **)((void *)0);
 6124|      0|                    sp->fts_nitems = (size_t)0;
 6125|      0|                    return (head);
 6126|      0|                }
 6127|      0|            }
 6128|      0|            sp->fts_array = a;
 6129|      0|        }
 6130|      0|        ap = sp->fts_array;
 6131|      0|        p = head;
 6132|      0|        while (1) {
 6133|       |
 6134|      0|            if (!p) {
 6135|      0|                goto while_break;
 6136|      0|            }
 6137|      0|            tmp___0 = ap;
 6138|      0|            ap++;
 6139|      0|            *tmp___0 = p;
 6140|      0|            p = p->fts_link;
 6141|      0|        }
 6142|      0|while_break:
 6143|      0|        qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
 6144|      0|        ap = sp->fts_array;
 6145|      0|        head = *ap;
 6146|      0|        while (1) {
 6147|      0|            nitems--;
 6148|      0|            if (!nitems) {
 6149|      0|                goto while_break___0;
 6150|      0|            }
 6151|      0|            (*(ap + 0))->fts_link = *(ap + 1);
 6152|      0|            ap++;
 6153|      0|        }
 6154|      0|while_break___0:
 6155|      0|        (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
 6156|      0|        return (head);
 6157|      0|    }
 6158|      0|}
 6159|       |static FTSENT *fts_alloc(FTS *sp, char const *name, size_t namelen)
 6160|      9|{
 6161|      9|    FTSENT *p;
 6162|      9|    size_t len;
 6163|       |
 6164|      9|    {
 6165|      9|        len = sizeof(FTSENT) + namelen;
 6166|      9|        p = (FTSENT *)malloc(len);
 6167|      9|        if ((unsigned long)p == (unsigned long)((void *)0)) {
 6168|      0|            return ((FTSENT *)((void *)0));
 6169|      0|        }
 6170|      9|        memmove((void *)(p->fts_name), (void const *)name, namelen);
 6171|      9|        p->fts_name[namelen] = (char)'\000';
 6172|      9|        p->fts_namelen = namelen;
 6173|      9|        p->fts_fts = sp;
 6174|      9|        p->fts_path = sp->fts_path;
 6175|      9|        p->fts_errno = 0;
 6176|      9|        p->fts_flags = (unsigned short)0;
 6177|      9|        p->fts_instr = (unsigned short)3;
 6178|      9|        p->fts_number = 0L;
 6179|      9|        p->fts_pointer = (void *)0;
 6180|      9|        return (p);
 6181|      9|    }
 6182|      9|}
 6183|       |static void fts_lfree(FTSENT *head)
 6184|      0|{
 6185|      0|    FTSENT *p;
 6186|       |
 6187|      0|    {
 6188|      0|        while (1) {
 6189|      0|            p = head;
 6190|      0|            if (!p) {
 6191|      0|                goto while_break;
 6192|      0|            }
 6193|      0|            head = head->fts_link;
 6194|      0|            free((void *)p);
 6195|      0|        }
 6196|      0|while_break:
 6197|      0|        ;
 6198|      0|        return;
 6199|      0|    }
 6200|      0|}
 6201|       |static _Bool fts_palloc(FTS *sp, size_t more)
 6202|      1|{
 6203|      1|    char *p;
 6204|      1|    size_t new_len;
 6205|      1|    int *tmp;
 6206|       |
 6207|      1|    {
 6208|      1|        new_len = (sp->fts_pathlen + more) + 256UL;
 6209|      1|        if (new_len < sp->fts_pathlen) {
 6210|      0|            free((void *)sp->fts_path);
 6211|      0|            sp->fts_path = (char *)((void *)0);
 6212|      0|            tmp = __errno_location();
 6213|      0|            *tmp = 36;
 6214|      0|            return ((_Bool)0);
 6215|      0|        }
 6216|      1|        sp->fts_pathlen = new_len;
 6217|      1|        p = (char *)realloc((void *)sp->fts_path, sp->fts_pathlen);
 6218|      1|        if ((unsigned long)p == (unsigned long)((void *)0)) {
 6219|      0|            free((void *)sp->fts_path);
 6220|      0|            sp->fts_path = (char *)((void *)0);
 6221|      0|            return ((_Bool)0);
 6222|      0|        }
 6223|      1|        sp->fts_path = p;
 6224|      1|        return ((_Bool)1);
 6225|      1|    }
 6226|      1|}
 6227|       |static void fts_padjust(FTS *sp, FTSENT *head)
 6228|      0|{
 6229|      0|    FTSENT *p;
 6230|      0|    char *addr;
 6231|       |
 6232|      0|    {
 6233|      0|        addr = sp->fts_path;
 6234|      0|        p = sp->fts_child;
 6235|      0|        while (1) {
 6236|       |
 6237|      0|            if (!p) {
 6238|      0|                goto while_break;
 6239|      0|            }
 6240|      0|            while (1) {
 6241|       |
 6242|      0|                if ((unsigned long)p->fts_accpath != (unsigned long)(p->fts_name)) {
 6243|      0|                    p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
 6244|      0|                }
 6245|      0|                p->fts_path = addr;
 6246|      0|                goto while_break___0;
 6247|      0|            }
 6248|      0|while_break___0:
 6249|      0|            p = p->fts_link;
 6250|      0|        }
 6251|      0|while_break:
 6252|      0|        p = head;
 6253|      0|        while (1) {
 6254|       |
 6255|      0|            if (!(p->fts_level >= 0L)) {
 6256|      0|                goto while_break___1;
 6257|      0|            }
 6258|      0|            while (1) {
 6259|       |
 6260|      0|                if ((unsigned long)p->fts_accpath != (unsigned long)(p->fts_name)) {
 6261|      0|                    p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
 6262|      0|                }
 6263|      0|                p->fts_path = addr;
 6264|      0|                goto while_break___2;
 6265|      0|            }
 6266|      0|while_break___2:
 6267|      0|            ;
 6268|      0|            if (p->fts_link) {
 6269|      0|                p = p->fts_link;
 6270|      0|            }
 6271|      0|            else {
 6272|      0|                p = p->fts_parent;
 6273|      0|            }
 6274|      0|        }
 6275|      0|while_break___1:
 6276|      0|        ;
 6277|      0|        return;
 6278|      0|    }
 6279|      0|}
 6280|       |static size_t fts_maxarglen(char *const *argv)
 6281|      1|{
 6282|      1|    size_t len;
 6283|      1|    size_t max;
 6284|       |
 6285|      1|    {
 6286|      1|        max = (size_t)0;
 6287|      2|        while (1) {
 6288|       |
 6289|      2|            if (!*argv) {
 6290|      1|                goto while_break;
 6291|      1|            }
 6292|      1|            len = strlen((char const *)*argv);
 6293|      1|            if (len > max) {
 6294|      1|                max = len;
 6295|      1|            }
 6296|      1|            argv++;
 6297|      1|        }
 6298|      1|while_break:
 6299|      1|        ;
 6300|      1|        return (max + 1UL);
 6301|      1|    }
 6302|      1|}
 6303|       |static int fts_safe_changedir(FTS *sp, FTSENT *p, int fd, char const *dir)
 6304|      5|{
 6305|      5|    int ret;
 6306|      5|    _Bool is_dotdot;
 6307|      5|    int tmp;
 6308|      5|    int tmp___0;
 6309|      5|    int newfd;
 6310|      5|    int parent_fd;
 6311|      5|    _Bool tmp___1;
 6312|      5|    struct stat sb;
 6313|      5|    int tmp___2;
 6314|      5|    int *tmp___3;
 6315|      5|    int tmp___4;
 6316|      5|    int oerrno;
 6317|      5|    int *tmp___5;
 6318|      5|    int *tmp___6;
 6319|       |
 6320|      5|    {
 6321|      5|        if (dir) {
 6322|      2|            tmp = strcmp(dir, "..");
 6323|      2|            if (tmp == 0) {
 6324|      2|                tmp___0 = 1;
 6325|      2|            }
 6326|      0|            else {
 6327|      0|                tmp___0 = 0;
 6328|      0|            }
 6329|      2|        }
 6330|      3|        else {
 6331|      3|            tmp___0 = 0;
 6332|      3|        }
 6333|      5|        is_dotdot = (_Bool)tmp___0;
 6334|      5|        if (sp->fts_options & 4) {
 6335|      0|            if (sp->fts_options & 512) {
 6336|      0|                if (0 <= fd) {
 6337|      0|                    close(fd);
 6338|      0|                }
 6339|      0|            }
 6340|      0|            return (0);
 6341|      0|        }
 6342|      5|        if (fd < 0) {
 6343|      2|            if (is_dotdot) {
 6344|      2|                if (sp->fts_options & 512) {
 6345|      2|                    tmp___1 = i_ring_empty((I_ring const *)(&sp->fts_fd_ring));
 6346|      2|                    if (!tmp___1) {
 6347|      2|                        parent_fd = i_ring_pop(&sp->fts_fd_ring);
 6348|      2|                        is_dotdot = (_Bool)1;
 6349|      2|                        if (0 <= parent_fd) {
 6350|      2|                            fd = parent_fd;
 6351|      2|                            dir = (char const *)((void *)0);
 6352|      2|                        }
 6353|      2|                    }
 6354|      2|                }
 6355|      2|            }
 6356|      2|        }
 6357|      5|        newfd = fd;
 6358|      5|        if (fd < 0) {
 6359|      0|            newfd = diropen((FTS const *)sp, dir);
 6360|      0|            if (newfd < 0) {
 6361|      0|                return (-1);
 6362|      0|            }
 6363|      0|        }
 6364|      5|        if (sp->fts_options & 2) {
 6365|      0|            goto _L;
 6366|      0|        }
 6367|      5|        else {
 6368|      5|            if (dir) {
 6369|      0|                tmp___4 = strcmp(dir, "..");
 6370|      0|                if (tmp___4 == 0) {
 6371|      0|_L:
 6372|      0|                    tmp___2 = fstat(newfd, &sb);
 6373|      0|                    if (tmp___2) {
 6374|      0|                        ret = -1;
 6375|      0|                        goto bail;
 6376|      0|                    }
 6377|      0|                    if (p->fts_statp[0].st_dev != sb.st_dev) {
 6378|      0|                        tmp___3 = __errno_location();
 6379|      0|                        *tmp___3 = 2;
 6380|      0|                        ret = -1;
 6381|      0|                        goto bail;
 6382|      0|                    }
 6383|      0|                    else {
 6384|      0|                        if (p->fts_statp[0].st_ino != sb.st_ino) {
 6385|      0|                            tmp___3 = __errno_location();
 6386|      0|                            *tmp___3 = 2;
 6387|      0|                            ret = -1;
 6388|      0|                            goto bail;
 6389|      0|                        }
 6390|      0|                    }
 6391|      0|                }
 6392|      0|            }
 6393|      5|        }
 6394|      5|        if (sp->fts_options & 512) {
 6395|      5|            cwd_advance_fd(sp, newfd, (_Bool)(!is_dotdot));
 6396|      5|            return (0);
 6397|      5|        }
 6398|      0|        ret = fchdir(newfd);
 6399|      0|bail:
 6400|      0|        if (fd < 0) {
 6401|      0|            tmp___5 = __errno_location();
 6402|      0|            oerrno = *tmp___5;
 6403|      0|            close(newfd);
 6404|      0|            tmp___6 = __errno_location();
 6405|      0|            *tmp___6 = oerrno;
 6406|      0|        }
 6407|      0|        return (ret);
 6408|      0|    }
 6409|      0|}
 6410|       |#pragma weak pthread_key_create
 6411|       |#pragma weak pthread_getspecific
 6412|       |#pragma weak pthread_setspecific
 6413|       |#pragma weak pthread_key_delete
 6414|       |#pragma weak pthread_self
 6415|       |#pragma weak pthread_cancel
 6416|       |#pragma weak pthread_mutex_init
 6417|       |#pragma weak pthread_mutex_lock
 6418|       |#pragma weak pthread_mutex_unlock
 6419|       |#pragma weak pthread_mutex_destroy
 6420|       |#pragma weak pthread_rwlock_init
 6421|       |#pragma weak pthread_rwlock_rdlock
 6422|       |#pragma weak pthread_rwlock_wrlock
 6423|       |#pragma weak pthread_rwlock_unlock
 6424|       |#pragma weak pthread_rwlock_destroy
 6425|       |#pragma weak pthread_once
 6426|       |#pragma weak pthread_cond_init
 6427|       |#pragma weak pthread_cond_wait
 6428|       |#pragma weak pthread_cond_signal
 6429|       |#pragma weak pthread_cond_broadcast
 6430|       |#pragma weak pthread_cond_destroy
 6431|       |#pragma weak pthread_mutexattr_init
 6432|       |#pragma weak pthread_mutexattr_settype
 6433|       |#pragma weak pthread_mutexattr_destroy
 6434|       |#pragma weak pthread_self
 6435|       |#pragma weak pthread_cancel
 6436|       |char const *Version = "8.2";
 6437|       |extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2),
 6438|       |                                        __leaf__)) fchownat)(
 6439|       |                                                int __fd, char const *__file, __uid_t __owner, __gid_t __group, int __flag);
 6440|       |__inline static int chownat(int fd, char const *file, uid_t owner,
 6441|       |                            gid_t group)
 6442|      0|{
 6443|      0|    int tmp;
 6444|       |
 6445|      0|    {
 6446|      0|        tmp = fchownat(fd, file, owner, group, 0);
 6447|      0|        return (tmp);
 6448|      0|    }
 6449|      0|}
 6450|       |__inline static int lchownat(int fd, char const *file, uid_t owner,
 6451|       |                             gid_t group)
 6452|      7|{
 6453|      7|    int tmp;
 6454|       |
 6455|      7|    {
 6456|      7|        tmp = fchownat(fd, file, owner, group, 256);
 6457|      7|        return (tmp);
 6458|      7|    }
 6459|      7|}
 6460|       |extern void chopt_init(struct Chown_option *chopt);
 6461|       |extern void chopt_free(struct Chown_option *chopt __attribute__((__unused__)));
 6462|       |extern char *gid_to_name(gid_t gid);
 6463|       |extern char *uid_to_name(uid_t uid);
 6464|       |extern _Bool chown_files(char **files, int bit_flags, uid_t uid, gid_t gid,
 6465|       |                         uid_t required_uid, gid_t required_gid,
 6466|       |                         struct Chown_option const *chopt);
 6467|       |__inline static void ignore_ptr(void *p)
 6468|      0|{
 6469|       |
 6470|      0|    {
 6471|      0|        return;
 6472|      0|    }
 6473|      0|}
 6474|       |extern void chopt_init(struct Chown_option *chopt)
 6475|      1|{
 6476|       |
 6477|      1|    {
 6478|      1|        chopt->verbosity = (enum Verbosity)2;
 6479|      1|        chopt->root_dev_ino = (struct dev_ino *)((void *)0);
 6480|      1|        chopt->affect_symlink_referent = (_Bool)1;
 6481|      1|        chopt->recurse = (_Bool)0;
 6482|      1|        chopt->force_silent = (_Bool)0;
 6483|      1|        chopt->user_name = (char *)((void *)0);
 6484|      1|        chopt->group_name = (char *)((void *)0);
 6485|      1|        return;
 6486|      1|    }
 6487|      1|}
 6488|       |extern void chopt_free(struct Chown_option *chopt __attribute__((__unused__)))
 6489|      1|{
 6490|       |
 6491|      1|    {
 6492|      1|        return;
 6493|      1|    }
 6494|      1|}
 6495|       |extern char *gid_to_name(gid_t gid)
 6496|      0|{
 6497|      0|    char
 6498|      0|    buf___1[((((sizeof(intmax_t) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL) +
 6499|      0|                                 1UL];
 6500|      0|    struct group *grp;
 6501|      0|    struct group *tmp;
 6502|      0|    char *tmp___1;
 6503|      0|    char *tmp___2;
 6504|      0|    char *tmp___3;
 6505|       |
 6506|      0|    {
 6507|      0|        tmp = getgrgid(gid);
 6508|      0|        grp = tmp;
 6509|      0|        if (grp) {
 6510|      0|            tmp___2 = grp->gr_name;
 6511|      0|        }
 6512|      0|        else {
 6513|      0|            tmp___1 = umaxtostr((uintmax_t)gid, buf___1);
 6514|      0|            tmp___2 = tmp___1;
 6515|      0|        }
 6516|      0|        tmp___3 = xstrdup((char const *)tmp___2);
 6517|      0|        return (tmp___3);
 6518|      0|    }
 6519|      0|}
 6520|       |extern char *uid_to_name(uid_t uid)
 6521|      0|{
 6522|      0|    char
 6523|      0|    buf___1[((((sizeof(intmax_t) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL) +
 6524|      0|                                 1UL];
 6525|      0|    struct passwd *pwd;
 6526|      0|    struct passwd *tmp;
 6527|      0|    char *tmp___1;
 6528|      0|    char *tmp___2;
 6529|      0|    char *tmp___3;
 6530|       |
 6531|      0|    {
 6532|      0|        tmp = getpwuid(uid);
 6533|      0|        pwd = tmp;
 6534|      0|        if (pwd) {
 6535|      0|            tmp___2 = pwd->pw_name;
 6536|      0|        }
 6537|      0|        else {
 6538|      0|            tmp___1 = umaxtostr((uintmax_t)uid, buf___1);
 6539|      0|            tmp___2 = tmp___1;
 6540|      0|        }
 6541|      0|        tmp___3 = xstrdup((char const *)tmp___2);
 6542|      0|        return (tmp___3);
 6543|      0|    }
 6544|      0|}
 6545|       |static void describe_change(char const *file, enum Change_status changed,
 6546|       |                            char const *user, char const *group)
 6547|      0|{
 6548|      0|    char const *fmt;
 6549|      0|    char const *spec;
 6550|      0|    char *spec_allocated;
 6551|      0|    char const *tmp;
 6552|      0|    char *tmp___0;
 6553|      0|    size_t tmp___1;
 6554|      0|    size_t tmp___2;
 6555|      0|    char *tmp___3;
 6556|      0|    char *tmp___4;
 6557|      0|    char *tmp___5;
 6558|      0|    char *tmp___6;
 6559|      0|    char *tmp___7;
 6560|      0|    char *tmp___8;
 6561|      0|    char *tmp___9;
 6562|      0|    char *tmp___10;
 6563|      0|    char *tmp___11;
 6564|      0|    char *tmp___12;
 6565|      0|    char *tmp___13;
 6566|      0|    char *tmp___14;
 6567|      0|    char *tmp___15;
 6568|      0|    char *tmp___16;
 6569|      0|    char const *tmp___17;
 6570|       |
 6571|      0|    {
 6572|      0|        spec_allocated = (char *)((void *)0);
 6573|      0|        if ((unsigned int)changed == 1U) {
 6574|      0|            tmp = quote(file);
 6575|      0|            tmp___0 =
 6576|      0|                gettext("neither symbolic link %s nor referent has been changed\n");
 6577|      0|            printf((char const *)tmp___0, tmp);
 6578|      0|            return;
 6579|      0|        }
 6580|      0|        if (user) {
 6581|      0|            if (group) {
 6582|      0|                tmp___1 = strlen(user);
 6583|      0|                tmp___2 = strlen(group);
 6584|      0|                spec_allocated = (char *)xmalloc(((tmp___1 + 1UL) + tmp___2) + 1UL);
 6585|      0|                tmp___3 = stpcpy(spec_allocated, user);
 6586|      0|                tmp___4 = stpcpy(tmp___3, ":");
 6587|      0|                stpcpy(tmp___4, group);
 6588|      0|                spec = (char const *)spec_allocated;
 6589|      0|            }
 6590|      0|            else {
 6591|      0|                spec = user;
 6592|      0|            }
 6593|      0|        }
 6594|      0|        else {
 6595|      0|            spec = group;
 6596|      0|        }
 6597|      0|        if ((unsigned int)changed == 2U) {
 6598|      0|            goto case_2;
 6599|      0|        }
 6600|      0|        if ((unsigned int)changed == 3U) {
 6601|      0|            goto case_3;
 6602|      0|        }
 6603|      0|        if ((unsigned int)changed == 4U) {
 6604|      0|            goto case_4;
 6605|      0|        }
 6606|      0|        goto switch_default;
 6607|      0|case_2:
 6608|      0|        if (user) {
 6609|      0|            tmp___5 = gettext("changed ownership of %s to %s\n");
 6610|      0|            fmt = (char const *)tmp___5;
 6611|      0|        }
 6612|      0|        else {
 6613|      0|            if (group) {
 6614|      0|                tmp___6 = gettext("changed group of %s to %s\n");
 6615|      0|                tmp___8 = tmp___6;
 6616|      0|            }
 6617|      0|            else {
 6618|      0|                tmp___7 = gettext("no change to ownership of %s\n");
 6619|      0|                tmp___8 = tmp___7;
 6620|      0|            }
 6621|      0|            fmt = (char const *)tmp___8;
 6622|      0|        }
 6623|      0|        goto switch_break;
 6624|      0|case_3:
 6625|      0|        if (user) {
 6626|      0|            tmp___9 = gettext("failed to change ownership of %s to %s\n");
 6627|      0|            fmt = (char const *)tmp___9;
 6628|      0|        }
 6629|      0|        else {
 6630|      0|            if (group) {
 6631|      0|                tmp___10 = gettext("failed to change group of %s to %s\n");
 6632|      0|                tmp___12 = tmp___10;
 6633|      0|            }
 6634|      0|            else {
 6635|      0|                tmp___11 = gettext("failed to change ownership of %s\n");
 6636|      0|                tmp___12 = tmp___11;
 6637|      0|            }
 6638|      0|            fmt = (char const *)tmp___12;
 6639|      0|        }
 6640|      0|        goto switch_break;
 6641|      0|case_4:
 6642|      0|        if (user) {
 6643|      0|            tmp___13 = gettext("ownership of %s retained as %s\n");
 6644|      0|            fmt = (char const *)tmp___13;
 6645|      0|        }
 6646|      0|        else {
 6647|      0|            if (group) {
 6648|      0|                tmp___14 = gettext("group of %s retained as %s\n");
 6649|      0|                tmp___16 = tmp___14;
 6650|      0|            }
 6651|      0|            else {
 6652|      0|                tmp___15 = gettext("ownership of %s retained\n");
 6653|      0|                tmp___16 = tmp___15;
 6654|      0|            }
 6655|      0|            fmt = (char const *)tmp___16;
 6656|      0|        }
 6657|      0|        goto switch_break;
 6658|      0|switch_default:
 6659|      0|        abort();
 6660|      0|switch_break:
 6661|      0|        tmp___17 = quote(file);
 6662|      0|        printf(fmt, tmp___17, spec);
 6663|      0|        free((void *)spec_allocated);
 6664|      0|        return;
 6665|      0|    }
 6666|      0|}
 6667|       |static enum RCH_status restricted_chown(int cwd_fd, char const *file,
 6668|       |                                        struct stat const *orig_st, uid_t uid,
 6669|       |                                        gid_t gid, uid_t required_uid,
 6670|       |                                        gid_t required_gid)
 6671|      0|{
 6672|      0|    enum RCH_status status;
 6673|      0|    struct stat st;
 6674|      0|    int open_flags;
 6675|      0|    int fd;
 6676|      0|    int tmp___0;
 6677|      0|    int *tmp___1;
 6678|      0|    int *tmp___2;
 6679|      0|    int tmp___4;
 6680|      0|    int tmp___5;
 6681|      0|    int tmp___6;
 6682|      0|    int saved_errno;
 6683|      0|    int *tmp___7;
 6684|      0|    int *tmp___8;
 6685|       |
 6686|      0|    {
 6687|      0|        status = (enum RCH_status)2;
 6688|      0|        open_flags = 2304;
 6689|      0|        if (required_uid == 4294967295U) {
 6690|      0|            if (required_gid == 4294967295U) {
 6691|      0|                return ((enum RCH_status)5);
 6692|      0|            }
 6693|      0|        }
 6694|      0|        if (!((orig_st->st_mode & 61440U) == 32768U)) {
 6695|      0|            if ((orig_st->st_mode & 61440U) == 16384U) {
 6696|      0|                open_flags |= 65536;
 6697|      0|            }
 6698|      0|            else {
 6699|      0|                return ((enum RCH_status)5);
 6700|      0|            }
 6701|      0|        }
 6702|      0|        fd = openat(cwd_fd, file, open_flags);
 6703|      0|        if (!(0 <= fd)) {
 6704|      0|            tmp___2 = __errno_location();
 6705|      0|            if (*tmp___2 == 13) {
 6706|      0|                if ((orig_st->st_mode & 61440U) == 32768U) {
 6707|      0|                    fd = openat(cwd_fd, file, 1 | open_flags);
 6708|      0|                    if (!(0 <= fd)) {
 6709|      0|                        goto _L___0;
 6710|      0|                    }
 6711|      0|                }
 6712|      0|                else {
 6713|      0|                    goto _L___0;
 6714|      0|                }
 6715|      0|            }
 6716|      0|            else {
 6717|      0|_L___0:
 6718|      0|                tmp___1 = __errno_location();
 6719|      0|                if (*tmp___1 == 13) {
 6720|      0|                    tmp___0 = 5;
 6721|      0|                }
 6722|      0|                else {
 6723|      0|                    tmp___0 = 6;
 6724|      0|                }
 6725|      0|                return ((enum RCH_status)tmp___0);
 6726|      0|            }
 6727|      0|        }
 6728|      0|        tmp___6 = fstat(fd, &st);
 6729|      0|        if (tmp___6 != 0) {
 6730|      0|            status = (enum RCH_status)6;
 6731|      0|        }
 6732|      0|        else {
 6733|      0|            if (orig_st->st_ino == (__ino_t const)st.st_ino) {
 6734|      0|                if (orig_st->st_dev == (__dev_t const)st.st_dev) {
 6735|      0|                    if (required_uid == 4294967295U) {
 6736|      0|                        goto _L___2;
 6737|      0|                    }
 6738|      0|                    else {
 6739|      0|                        if (required_uid == st.st_uid) {
 6740|      0|_L___2:
 6741|      0|                            if (required_gid == 4294967295U) {
 6742|      0|                                goto _L___1;
 6743|      0|                            }
 6744|      0|                            else {
 6745|      0|                                if (required_gid == st.st_gid) {
 6746|      0|_L___1:
 6747|      0|                                    tmp___5 = fchown(fd, uid, gid);
 6748|      0|                                    if (tmp___5 == 0) {
 6749|      0|                                        tmp___4 = close(fd);
 6750|      0|                                        if (tmp___4 == 0) {
 6751|      0|                                            status = (enum RCH_status)2;
 6752|      0|                                        }
 6753|      0|                                        else {
 6754|      0|                                            status = (enum RCH_status)6;
 6755|      0|                                        }
 6756|      0|                                        return (status);
 6757|      0|                                    }
 6758|      0|                                    else {
 6759|      0|                                        status = (enum RCH_status)6;
 6760|      0|                                    }
 6761|      0|                                }
 6762|      0|                            }
 6763|      0|                        }
 6764|      0|                    }
 6765|      0|                }
 6766|      0|                else {
 6767|      0|                    status = (enum RCH_status)4;
 6768|      0|                }
 6769|      0|            }
 6770|      0|            else {
 6771|      0|                status = (enum RCH_status)4;
 6772|      0|            }
 6773|      0|        }
 6774|      0|        tmp___7 = __errno_location();
 6775|      0|        saved_errno = *tmp___7;
 6776|      0|        close(fd);
 6777|      0|        tmp___8 = __errno_location();
 6778|      0|        *tmp___8 = saved_errno;
 6779|      0|        return (status);
 6780|      0|    }
 6781|      0|}
 6782|       |static _Bool change_file_owner(FTS *fts, FTSENT *ent, uid_t uid, gid_t gid,
 6783|       |                               uid_t required_uid, gid_t required_gid,
 6784|       |                               struct Chown_option const *chopt)
 6785|     10|{
 6786|     10|    char const *file_full_name;
 6787|     10|    char const *file;
 6788|     10|    struct stat const *file_stats;
 6789|     10|    struct stat stat_buf;
 6790|     10|    _Bool ok;
 6791|     10|    _Bool do_chown;
 6792|     10|    _Bool symlink_changed;
 6793|     10|    char const *tmp;
 6794|     10|    char *tmp___0;
 6795|     10|    char const *tmp___1;
 6796|     10|    char const *tmp___2;
 6797|     10|    char *tmp___3;
 6798|     10|    int tmp___4;
 6799|     10|    char *tmp___5;
 6800|     10|    FTSENT *tmp___6;
 6801|     10|    char const *tmp___7;
 6802|     10|    char *tmp___8;
 6803|     10|    char const *tmp___9;
 6804|     10|    char *tmp___10;
 6805|     10|    char const *tmp___11;
 6806|     10|    char *tmp___12;
 6807|     10|    char const *tmp___13;
 6808|     10|    char *tmp___14;
 6809|     10|    _Bool tmp___15;
 6810|     10|    char const *tmp___16;
 6811|     10|    char *tmp___17;
 6812|     10|    int *tmp___18;
 6813|     10|    int tmp___19;
 6814|     10|    int tmp___20;
 6815|     10|    char const *tmp___21;
 6816|     10|    char *tmp___22;
 6817|     10|    char const *tmp___23;
 6818|     10|    char const *tmp___24;
 6819|     10|    char *tmp___25;
 6820|     10|    int tmp___26;
 6821|     10|    char *tmp___27;
 6822|     10|    int tmp___28;
 6823|     10|    int *tmp___29;
 6824|     10|    enum RCH_status err;
 6825|     10|    enum RCH_status tmp___30;
 6826|     10|    int tmp___31;
 6827|     10|    char const *tmp___32;
 6828|     10|    char *tmp___33;
 6829|     10|    char *tmp___34;
 6830|     10|    char *tmp___35;
 6831|     10|    int *tmp___36;
 6832|     10|    _Bool changed;
 6833|     10|    int tmp___37;
 6834|     10|    enum Change_status ch_status;
 6835|     10|    int tmp___38;
 6836|     10|    int tmp___39;
 6837|     10|    int tmp___40;
 6838|       |
 6839|     10|    {
 6840|     10|        file_full_name = (char const *)ent->fts_path;
 6841|     10|        file = (char const *)ent->fts_accpath;
 6842|     10|        ok = (_Bool)1;
 6843|     10|        symlink_changed = (_Bool)1;
 6844|     10|        if ((int)ent->fts_info == 1) {
 6845|      3|            goto case_1;
 6846|      3|        }
 6847|      7|        if ((int)ent->fts_info == 6) {
 6848|      3|            goto case_6;
 6849|      3|        }
 6850|      4|        if ((int)ent->fts_info == 10) {
 6851|      0|            goto case_10;
 6852|      0|        }
 6853|      4|        if ((int)ent->fts_info == 7) {
 6854|      0|            goto case_7;
 6855|      0|        }
 6856|      4|        if ((int)ent->fts_info == 4) {
 6857|      0|            goto case_4;
 6858|      0|        }
 6859|      4|        if ((int)ent->fts_info == 2) {
 6860|      0|            goto case_2;
 6861|      0|        }
 6862|      4|        goto switch_default;
 6863|      4|case_1:
 6864|      3|        if (chopt->recurse) {
 6865|      3|            if (chopt->root_dev_ino) {
 6866|      0|                if (ent->fts_statp[0].st_ino == (chopt->root_dev_ino)->st_ino) {
 6867|      0|                    if (ent->fts_statp[0].st_dev == (chopt->root_dev_ino)->st_dev) {
 6868|      0|                        while (1) {
 6869|      0|                            tmp___4 = strcmp(file_full_name, "/");
 6870|      0|                            if (tmp___4 == 0) {
 6871|      0|                                tmp = quote(file_full_name);
 6872|      0|                                tmp___0 =
 6873|      0|                                    gettext("it is dangerous to operate recursively on %s");
 6874|      0|                                error(0, 0, (char const *)tmp___0, tmp);
 6875|      0|                            }
 6876|      0|                            else {
 6877|      0|                                tmp___1 = quote_n(1, "/");
 6878|      0|                                tmp___2 = quote_n(0, file_full_name);
 6879|      0|                                tmp___3 = gettext("it is dangerous to operate recursively on "
 6880|      0|                                                  "%s (same as %s)");
 6881|      0|                                error(0, 0, (char const *)tmp___3, tmp___2, tmp___1);
 6882|      0|                            }
 6883|      0|                            tmp___5 =
 6884|      0|                                gettext("use --no-preserve-root to override this failsafe");
 6885|      0|                            error(0, 0, (char const *)tmp___5);
 6886|      0|                            goto while_break;
 6887|      0|                        }
 6888|      0|while_break:
 6889|      0|                        fts_set(fts, ent, 4);
 6890|      0|                        tmp___6 = fts_read(fts);
 6891|      0|                        ignore_ptr((void *)tmp___6);
 6892|      0|                        return ((_Bool)0);
 6893|      0|                    }
 6894|      0|                }
 6895|      0|            }
 6896|      3|            return ((_Bool)1);
 6897|      3|        }
 6898|      0|        goto switch_break;
 6899|      3|case_6:
 6900|      3|        if (!chopt->recurse) {
 6901|      0|            return ((_Bool)1);
 6902|      0|        }
 6903|      3|        goto switch_break;
 6904|      3|case_10:
 6905|      0|        if (ent->fts_level == 0L) {
 6906|      0|            if (ent->fts_number == 0L) {
 6907|      0|                ent->fts_number = 1L;
 6908|      0|                fts_set(fts, ent, 1);
 6909|      0|                return ((_Bool)1);
 6910|      0|            }
 6911|      0|        }
 6912|      0|        if (!chopt->force_silent) {
 6913|      0|            tmp___7 = quote(file_full_name);
 6914|      0|            tmp___8 = gettext("cannot access %s");
 6915|      0|            error(0, ent->fts_errno, (char const *)tmp___8, tmp___7);
 6916|      0|        }
 6917|      0|        ok = (_Bool)0;
 6918|      0|        goto switch_break;
 6919|      0|case_7:
 6920|      0|        if (!chopt->force_silent) {
 6921|      0|            tmp___9 = quote(file_full_name);
 6922|      0|            tmp___10 = gettext("%s");
 6923|      0|            error(0, ent->fts_errno, (char const *)tmp___10, tmp___9);
 6924|      0|        }
 6925|      0|        ok = (_Bool)0;
 6926|      0|        goto switch_break;
 6927|      0|case_4:
 6928|      0|        if (!chopt->force_silent) {
 6929|      0|            tmp___11 = quote(file_full_name);
 6930|      0|            tmp___12 = gettext("cannot read directory %s");
 6931|      0|            error(0, ent->fts_errno, (char const *)tmp___12, tmp___11);
 6932|      0|        }
 6933|      0|        ok = (_Bool)0;
 6934|      0|        goto switch_break;
 6935|      0|case_2:
 6936|      0|        tmp___15 = cycle_warning_required((FTS const *)fts, (FTSENT const *)ent);
 6937|      0|        if (tmp___15) {
 6938|      0|            while (1) {
 6939|      0|                tmp___13 = quote(file_full_name);
 6940|      0|                tmp___14 = gettext(
 6941|      0|                               "WARNING: Circular directory structure.\nThis almost certainly "
 6942|      0|                               "means that you have a corrupted file system.\nNOTIFY YOUR SYSTEM "
 6943|      0|                               "MANAGER.\nThe following directory is part of the cycle:\n  %s\n");
 6944|      0|                error(0, 0, (char const *)tmp___14, tmp___13);
 6945|      0|                goto while_break___0;
 6946|      0|            }
 6947|      0|while_break___0:
 6948|      0|            ;
 6949|      0|            return ((_Bool)0);
 6950|      0|        }
 6951|      0|        goto switch_break;
 6952|      4|switch_default:
 6953|      4|        goto switch_break;
 6954|      7|switch_break:
 6955|      7|        ;
 6956|      7|        if (!ok) {
 6957|      0|            do_chown = (_Bool)0;
 6958|      0|            file_stats = (struct stat const *)((void *)0);
 6959|      0|        }
 6960|      7|        else {
 6961|      7|            if (required_uid == 4294967295U) {
 6962|      7|                if (required_gid == 4294967295U) {
 6963|      7|                    if ((unsigned int const)chopt->verbosity == 2U) {
 6964|      7|                        if (!chopt->root_dev_ino) {
 6965|      7|                            if (!chopt->affect_symlink_referent) {
 6966|      7|                                do_chown = (_Bool)1;
 6967|      7|                                file_stats = (struct stat const *)(ent->fts_statp);
 6968|      7|                            }
 6969|      0|                            else {
 6970|      0|                                goto _L___3;
 6971|      0|                            }
 6972|      7|                        }
 6973|      0|                        else {
 6974|      0|                            goto _L___3;
 6975|      0|                        }
 6976|      7|                    }
 6977|      0|                    else {
 6978|      0|                        goto _L___3;
 6979|      0|                    }
 6980|      7|                }
 6981|      0|                else {
 6982|      0|                    goto _L___3;
 6983|      0|                }
 6984|      7|            }
 6985|      0|            else {
 6986|      0|_L___3:
 6987|      0|                file_stats = (struct stat const *)(ent->fts_statp);
 6988|      0|                if (chopt->affect_symlink_referent) {
 6989|      0|                    if ((file_stats->st_mode & 61440U) == 40960U) {
 6990|      0|                        tmp___19 = fstatat(fts->fts_cwd_fd, file, &stat_buf, 0);
 6991|      0|                        if (tmp___19 != 0) {
 6992|      0|                            if (!chopt->force_silent) {
 6993|      0|                                tmp___16 = quote(file_full_name);
 6994|      0|                                tmp___17 = gettext("cannot dereference %s");
 6995|      0|                                tmp___18 = __errno_location();
 6996|      0|                                error(0, *tmp___18, (char const *)tmp___17, tmp___16);
 6997|      0|                            }
 6998|      0|                            ok = (_Bool)0;
 6999|      0|                        }
 7000|      0|                        file_stats = (struct stat const *)(&stat_buf);
 7001|      0|                    }
 7002|      0|                }
 7003|      0|                if (ok) {
 7004|      0|                    if (required_uid == 4294967295U) {
 7005|      0|                        goto _L;
 7006|      0|                    }
 7007|      0|                    else {
 7008|      0|                        if (required_uid == (uid_t)file_stats->st_uid) {
 7009|      0|_L:
 7010|      0|                            if (required_gid == 4294967295U) {
 7011|      0|                                tmp___20 = 1;
 7012|      0|                            }
 7013|      0|                            else {
 7014|      0|                                if (required_gid == (gid_t)file_stats->st_gid) {
 7015|      0|                                    tmp___20 = 1;
 7016|      0|                                }
 7017|      0|                                else {
 7018|      0|                                    tmp___20 = 0;
 7019|      0|                                }
 7020|      0|                            }
 7021|      0|                        }
 7022|      0|                        else {
 7023|      0|                            tmp___20 = 0;
 7024|      0|                        }
 7025|      0|                    }
 7026|      0|                }
 7027|      0|                else {
 7028|      0|                    tmp___20 = 0;
 7029|      0|                }
 7030|      0|                do_chown = (_Bool)tmp___20;
 7031|      0|            }
 7032|      7|        }
 7033|      7|        if (ok) {
 7034|      7|            if ((int)ent->fts_info == 1) {
 7035|      0|                goto _L___4;
 7036|      0|            }
 7037|      7|            else {
 7038|      7|                if ((int)ent->fts_info == 2) {
 7039|      0|                    goto _L___4;
 7040|      0|                }
 7041|      7|                else {
 7042|      7|                    if ((int)ent->fts_info == 6) {
 7043|      3|                        goto _L___4;
 7044|      3|                    }
 7045|      4|                    else {
 7046|      4|                        if ((int)ent->fts_info == 4) {
 7047|      3|_L___4:
 7048|      3|                            if (chopt->root_dev_ino) {
 7049|      0|                                if (file_stats->st_ino ==
 7050|      0|                                        (__ino_t const)(chopt->root_dev_ino)->st_ino) {
 7051|      0|                                    if (file_stats->st_dev ==
 7052|      0|                                            (__dev_t const)(chopt->root_dev_ino)->st_dev) {
 7053|      0|                                        while (1) {
 7054|      0|                                            tmp___26 = strcmp(file_full_name, "/");
 7055|      0|                                            if (tmp___26 == 0) {
 7056|      0|                                                tmp___21 = quote(file_full_name);
 7057|      0|                                                tmp___22 = gettext(
 7058|      0|                                                               "it is dangerous to operate recursively on %s");
 7059|      0|                                                error(0, 0, (char const *)tmp___22, tmp___21);
 7060|      0|                                            }
 7061|      0|                                            else {
 7062|      0|                                                tmp___23 = quote_n(1, "/");
 7063|      0|                                                tmp___24 = quote_n(0, file_full_name);
 7064|      0|                                                tmp___25 = gettext("it is dangerous to operate "
 7065|      0|                                                                   "recursively on %s (same as %s)");
 7066|      0|                                                error(0, 0, (char const *)tmp___25, tmp___24, tmp___23);
 7067|      0|                                            }
 7068|      0|                                            tmp___27 = gettext(
 7069|      0|                                                           "use --no-preserve-root to override this failsafe");
 7070|      0|                                            error(0, 0, (char const *)tmp___27);
 7071|      0|                                            goto while_break___1;
 7072|      0|                                        }
 7073|      0|while_break___1:
 7074|      0|                                        ;
 7075|      0|                                        return ((_Bool)0);
 7076|      0|                                    }
 7077|      0|                                }
 7078|      0|                            }
 7079|      3|                        }
 7080|      4|                    }
 7081|      7|                }
 7082|      7|            }
 7083|      7|        }
 7084|      7|        if (do_chown) {
 7085|      7|            if (!chopt->affect_symlink_referent) {
 7086|      7|                tmp___28 = lchownat(fts->fts_cwd_fd, file, uid, gid);
 7087|      7|                ok = (_Bool)(tmp___28 == 0);
 7088|      7|                if (!ok) {
 7089|      0|                    tmp___29 = __errno_location();
 7090|      0|                    if (*tmp___29 == 95) {
 7091|      0|                        ok = (_Bool)1;
 7092|      0|                        symlink_changed = (_Bool)0;
 7093|      0|                    }
 7094|      0|                }
 7095|      7|            }
 7096|      0|            else {
 7097|      0|                tmp___30 = restricted_chown(fts->fts_cwd_fd, file, file_stats, uid, gid,
 7098|      0|                                            required_uid, required_gid);
 7099|      0|                err = tmp___30;
 7100|      0|                if ((unsigned int)err == 2U) {
 7101|      0|                    goto case_2___0;
 7102|      0|                }
 7103|      0|                if ((unsigned int)err == 5U) {
 7104|      0|                    goto case_5;
 7105|      0|                }
 7106|      0|                if ((unsigned int)err == 6U) {
 7107|      0|                    goto case_6___0;
 7108|      0|                }
 7109|      0|                if ((unsigned int)err == 4U) {
 7110|      0|                    goto case_4___0;
 7111|      0|                }
 7112|      0|                if ((unsigned int)err == 3U) {
 7113|      0|                    goto case_4___0;
 7114|      0|                }
 7115|      0|                goto switch_default___0;
 7116|      0|case_2___0:
 7117|      0|                goto switch_break___0;
 7118|      0|case_5:
 7119|      0|                tmp___31 = chownat(fts->fts_cwd_fd, file, uid, gid);
 7120|      0|                ok = (_Bool)(tmp___31 == 0);
 7121|      0|                goto switch_break___0;
 7122|      0|case_6___0:
 7123|      0|                ok = (_Bool)0;
 7124|      0|                goto switch_break___0;
 7125|      0|case_4___0:
 7126|      0|                do_chown = (_Bool)0;
 7127|      0|                ok = (_Bool)0;
 7128|      0|                goto switch_break___0;
 7129|      0|switch_default___0:
 7130|      0|                abort();
 7131|      0|switch_break___0:
 7132|      0|                ;
 7133|      0|            }
 7134|      7|            if (do_chown) {
 7135|      7|                if (!ok) {
 7136|      0|                    if (!chopt->force_silent) {
 7137|      0|                        tmp___32 = quote(file_full_name);
 7138|      0|                        if (uid != 4294967295U) {
 7139|      0|                            tmp___33 = gettext("changing ownership of %s");
 7140|      0|                            tmp___35 = tmp___33;
 7141|      0|                        }
 7142|      0|                        else {
 7143|      0|                            tmp___34 = gettext("changing group of %s");
 7144|      0|                            tmp___35 = tmp___34;
 7145|      0|                        }
 7146|      0|                        tmp___36 = __errno_location();
 7147|      0|                        error(0, *tmp___36, (char const *)tmp___35, tmp___32);
 7148|      0|                    }
 7149|      0|                }
 7150|      7|            }
 7151|      7|        }
 7152|      7|        if ((unsigned int const)chopt->verbosity != 2U) {
 7153|      0|            if (do_chown) {
 7154|      0|                if (ok) {
 7155|      0|                    if (symlink_changed) {
 7156|      0|                        if (uid == 4294967295U) {
 7157|      0|                            goto _L___5;
 7158|      0|                        }
 7159|      0|                        else {
 7160|      0|                            if (uid == (uid_t)file_stats->st_uid) {
 7161|      0|_L___5:
 7162|      0|                                if (gid == 4294967295U) {
 7163|      0|                                    tmp___37 = 0;
 7164|      0|                                }
 7165|      0|                                else {
 7166|      0|                                    if (gid == (gid_t)file_stats->st_gid) {
 7167|      0|                                        tmp___37 = 0;
 7168|      0|                                    }
 7169|      0|                                    else {
 7170|      0|                                        tmp___37 = 1;
 7171|      0|                                    }
 7172|      0|                                }
 7173|      0|                            }
 7174|      0|                            else {
 7175|      0|                                tmp___37 = 1;
 7176|      0|                            }
 7177|      0|                        }
 7178|      0|                    }
 7179|      0|                    else {
 7180|      0|                        tmp___37 = 0;
 7181|      0|                    }
 7182|      0|                }
 7183|      0|                else {
 7184|      0|                    tmp___37 = 0;
 7185|      0|                }
 7186|      0|            }
 7187|      0|            else {
 7188|      0|                tmp___37 = 0;
 7189|      0|            }
 7190|      0|            changed = (_Bool)tmp___37;
 7191|      0|            if (changed) {
 7192|      0|                goto _L___6;
 7193|      0|            }
 7194|      0|            else {
 7195|      0|                if ((unsigned int const)chopt->verbosity == 0U) {
 7196|      0|_L___6:
 7197|      0|                    if (!ok) {
 7198|      0|                        tmp___40 = 3;
 7199|      0|                    }
 7200|      0|                    else {
 7201|      0|                        if (!symlink_changed) {
 7202|      0|                            tmp___39 = 1;
 7203|      0|                        }
 7204|      0|                        else {
 7205|      0|                            if (!changed) {
 7206|      0|                                tmp___38 = 4;
 7207|      0|                            }
 7208|      0|                            else {
 7209|      0|                                tmp___38 = 2;
 7210|      0|                            }
 7211|      0|                            tmp___39 = tmp___38;
 7212|      0|                        }
 7213|      0|                        tmp___40 = tmp___39;
 7214|      0|                    }
 7215|      0|                    ch_status = (enum Change_status)tmp___40;
 7216|      0|                    describe_change(file_full_name, ch_status,
 7217|      0|                                    (char const *)chopt->user_name,
 7218|      0|                                    (char const *)chopt->group_name);
 7219|      0|                }
 7220|      0|            }
 7221|      0|        }
 7222|      7|        if (!chopt->recurse) {
 7223|      0|            fts_set(fts, ent, 4);
 7224|      0|        }
 7225|      7|        return (ok);
 7226|      7|    }
 7227|      7|}
 7228|       |extern _Bool chown_files(char **files, int bit_flags, uid_t uid, gid_t gid,
 7229|       |                         uid_t required_uid, gid_t required_gid,
 7230|       |                         struct Chown_option const *chopt)
 7231|      1|{
 7232|      1|    _Bool ok;
 7233|      1|    int stat_flags;
 7234|      1|    int tmp;
 7235|      1|    FTS *fts;
 7236|      1|    FTS *tmp___0;
 7237|      1|    FTSENT *ent;
 7238|      1|    char *tmp___1;
 7239|      1|    int *tmp___2;
 7240|      1|    int *tmp___3;
 7241|      1|    _Bool tmp___4;
 7242|      1|    char *tmp___5;
 7243|      1|    int *tmp___6;
 7244|      1|    int tmp___7;
 7245|       |
 7246|      1|    {
 7247|      1|        ok = (_Bool)1;
 7248|      1|        if (required_uid != 4294967295U) {
 7249|      0|            tmp = 0;
 7250|      0|        }
 7251|      1|        else {
 7252|      1|            if (required_gid != 4294967295U) {
 7253|      0|                tmp = 0;
 7254|      0|            }
 7255|      1|            else {
 7256|      1|                if (chopt->affect_symlink_referent) {
 7257|      0|                    tmp = 0;
 7258|      0|                }
 7259|      1|                else {
 7260|      1|                    if ((unsigned int const)chopt->verbosity != 2U) {
 7261|      0|                        tmp = 0;
 7262|      0|                    }
 7263|      1|                    else {
 7264|      1|                        tmp = 8;
 7265|      1|                    }
 7266|      1|                }
 7267|      1|            }
 7268|      1|        }
 7269|      1|        stat_flags = tmp;
 7270|      1|        tmp___0 = xfts_open((char *const *)files, bit_flags | stat_flags,
 7271|      1|                            (int (*)(FTSENT const **, FTSENT const **))((void *)0));
 7272|      1|        fts = tmp___0;
 7273|     11|        while (1) {
 7274|     11|            ent = fts_read(fts);
 7275|     11|            if ((unsigned long)ent == (unsigned long)((void *)0)) {
 7276|      1|                tmp___3 = __errno_location();
 7277|      1|                if (*tmp___3 != 0) {
 7278|      0|                    if (!chopt->force_silent) {
 7279|      0|                        tmp___1 = gettext("fts_read failed");
 7280|      0|                        tmp___2 = __errno_location();
 7281|      0|                        error(0, *tmp___2, (char const *)tmp___1);
 7282|      0|                    }
 7283|      0|                    ok = (_Bool)0;
 7284|      0|                }
 7285|      1|                goto while_break;
 7286|      1|            }
 7287|     10|            tmp___4 = change_file_owner(fts, ent, uid, gid, required_uid,
 7288|     10|                                        required_gid, chopt);
 7289|     10|            ok = (_Bool)((int)ok & (int)tmp___4);
 7290|     10|        }
 7291|      1|while_break:
 7292|      1|        tmp___7 = fts_close(fts);
 7293|      1|        if (tmp___7 != 0) {
 7294|      0|            tmp___5 = gettext("fts_close failed");
 7295|      0|            tmp___6 = __errno_location();
 7296|      0|            error(0, *tmp___6, (char const *)tmp___5);
 7297|      0|            ok = (_Bool)0;
 7298|      0|        }
 7299|      1|        return (ok);
 7300|      1|    }
 7301|      1|}
 7302|       |extern char *optarg;
 7303|       |extern __attribute__((__nothrow__)) int(
 7304|       |    __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void));
 7305|       |extern __attribute__((__nothrow__)) char *(
 7306|       |    __attribute__((__leaf__)) textdomain)(char const *__domainname);
 7307|       |extern __attribute__((__nothrow__)) char *(__attribute__((
 7308|       |            __leaf__)) bindtextdomain)(char const *__domainname, char const *__dirname);
 7309|       |__inline static void emit_ancillary_info(void)
 7310|      0|{
 7311|      0|    char *tmp;
 7312|      0|    char *tmp___0;
 7313|      0|    char *tmp___1;
 7314|      0|    char *tmp___2;
 7315|      0|    char const *lc_messages;
 7316|      0|    char const *tmp___3;
 7317|      0|    char *tmp___4;
 7318|      0|    char *tmp___5;
 7319|      0|    int tmp___6;
 7320|      0|    char *tmp___7;
 7321|      0|    char *tmp___8;
 7322|       |
 7323|      0|    {
 7324|      0|        tmp = last_component(program_name);
 7325|      0|        tmp___0 = gettext("\nReport %s bugs to %s\n");
 7326|      0|        printf((char const *)tmp___0, tmp, "bug-coreutils@gnu.org");
 7327|      0|        tmp___1 = gettext("%s home page: <http://www.gnu.org/software/%s/>\n");
 7328|      0|        printf((char const *)tmp___1, "GNU coreutils", "coreutils");
 7329|      0|        tmp___2 = gettext(
 7330|      0|                      "General help using GNU software: <http://www.gnu.org/gethelp/>\n");
 7331|      0|        fputs_unlocked((char const *)tmp___2, stdout);
 7332|      0|        tmp___3 = (char const *)setlocale(5, (char const *)((void *)0));
 7333|      0|        lc_messages = tmp___3;
 7334|      0|        if (lc_messages) {
 7335|      0|            tmp___6 = strncmp(lc_messages, "en_", (size_t)3);
 7336|      0|            if (tmp___6) {
 7337|      0|                tmp___4 = last_component(program_name);
 7338|      0|                tmp___5 = gettext("Report %s translation bugs to "
 7339|      0|                                  "<http://translationproject.org/team/>\n");
 7340|      0|                printf((char const *)tmp___5, tmp___4);
 7341|      0|            }
 7342|      0|        }
 7343|      0|        tmp___7 = last_component(program_name);
 7344|      0|        tmp___8 = gettext(
 7345|      0|                      "For complete documentation, run: info coreutils \'%s invocation\'\n");
 7346|      0|        printf((char const *)tmp___8, tmp___7);
 7347|      0|        return;
 7348|      0|    }
 7349|      0|}
 7350|       |__inline static char *bad_cast(char const *s)
 7351|      0|{
 7352|       |
 7353|      0|    {
 7354|      0|        return ((char *)s);
 7355|      0|    }
 7356|      0|}
 7357|       |static char *reference_file;
 7358|       |static struct option const long_options___1[14] = {
 7359|       |    {"recursive", 0, (int *)((void *)0), 'R'},
 7360|       |    {"changes", 0, (int *)((void *)0), 'c'},
 7361|       |    {"dereference", 0, (int *)((void *)0), 128},
 7362|       |    {"from", 1, (int *)((void *)0), 129},
 7363|       |    {"no-dereference", 0, (int *)((void *)0), 'h'},
 7364|       |    {"no-preserve-root", 0, (int *)((void *)0), 130},
 7365|       |    {"preserve-root", 0, (int *)((void *)0), 131},
 7366|       |    {"quiet", 0, (int *)((void *)0), 'f'},
 7367|       |    {"silent", 0, (int *)((void *)0), 'f'},
 7368|       |    {"reference", 1, (int *)((void *)0), 132},
 7369|       |    {"verbose", 0, (int *)((void *)0), 'v'},
 7370|       |    {"help", 0, (int *)((void *)0), -130},
 7371|       |    {"version", 0, (int *)((void *)0), -131},
 7372|       |    {(char const *)((void *)0), 0, (int *)((void *)0), 0}
 7373|       |};
 7374|       |__attribute__((__noreturn__)) void usage(int status);
 7375|       |void usage(int status)
 7376|      0|{
 7377|      0|    char *tmp;
 7378|      0|    char *tmp___0;
 7379|      0|    char *tmp___1;
 7380|      0|    char *tmp___2;
 7381|      0|    char *tmp___3;
 7382|      0|    char *tmp___4;
 7383|      0|    char *tmp___5;
 7384|      0|    char *tmp___6;
 7385|      0|    char *tmp___7;
 7386|      0|    char *tmp___8;
 7387|      0|    char *tmp___9;
 7388|      0|    char *tmp___10;
 7389|       |
 7390|      0|    {
 7391|      0|        if (status != 0) {
 7392|      0|            tmp = gettext("Try `%s --help\' for more information.\n");
 7393|      0|            fprintf(stderr, (char const *)tmp, program_name);
 7394|      0|        }
 7395|      0|        else {
 7396|      0|            tmp___0 = gettext("Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n  "
 7397|      0|                              "or:  %s [OPTION]... --reference=RFILE FILE...\n");
 7398|      0|            printf((char const *)tmp___0, program_name, program_name);
 7399|      0|            tmp___1 = gettext(
 7400|      0|                          "Change the owner and/or group of each FILE to OWNER and/or "
 7401|      0|                          "GROUP.\nWith --reference, change the owner and group of each FILE "
 7402|      0|                          "to those of RFILE.\n\n  -c, --changes          like verbose but "
 7403|      0|                          "report only when a change is made\n      --dereference      affect "
 7404|      0|                          "the referent of each symbolic link (this is\n                       "
 7405|      0|                          "  the default), rather than the symbolic link itself\n");
 7406|      0|            fputs_unlocked((char const *)tmp___1, stdout);
 7407|      0|            tmp___2 = gettext("  -h, --no-dereference   affect each symbolic link "
 7408|      0|                              "instead of any referenced\n                         "
 7409|      0|                              "file (useful only on systems that can change the\n    "
 7410|      0|                              "                     ownership of a symlink)\n");
 7411|      0|            fputs_unlocked((char const *)tmp___2, stdout);
 7412|      0|            tmp___3 =
 7413|      0|                gettext("      --from=CURRENT_OWNER:CURRENT_GROUP\n                  "
 7414|      0|                        "       change the owner and/or group of each file only if\n "
 7415|      0|                        "                        its current owner and/or group "
 7416|      0|                        "match those specified\n                         here.  "
 7417|      0|                        "Either may be omitted, in which case a match\n              "
 7418|      0|                        "           is not required for the omitted attribute.\n");
 7419|      0|            fputs_unlocked((char const *)tmp___3, stdout);
 7420|      0|            tmp___4 = gettext("      --no-preserve-root  do not treat `/\' specially "
 7421|      0|                              "(the default)\n      --preserve-root    fail to "
 7422|      0|                              "operate recursively on `/\'\n");
 7423|      0|            fputs_unlocked((char const *)tmp___4, stdout);
 7424|      0|            tmp___5 = gettext(
 7425|      0|                          "  -f, --silent, --quiet  suppress most error messages\n      "
 7426|      0|                          "--reference=RFILE  use RFILE\'s owner and group rather than\n       "
 7427|      0|                          "                  specifying OWNER:GROUP values\n  -R, --recursive  "
 7428|      0|                          "      operate on files and directories recursively\n  -v, --verbose "
 7429|      0|                          "         output a diagnostic for every file processed\n\n");
 7430|      0|            fputs_unlocked((char const *)tmp___5, stdout);
 7431|      0|            tmp___6 = gettext(
 7432|      0|                          "The following options modify how a hierarchy is traversed when the "
 7433|      0|                          "-R\noption is also specified.  If more than one is specified, only "
 7434|      0|                          "the final\none takes effect.\n\n  -H                     if a "
 7435|      0|                          "command line argument is a symbolic link\n                         "
 7436|      0|                          "to a directory, traverse it\n  -L                     traverse "
 7437|      0|                          "every symbolic link to a directory\n                         "
 7438|      0|                          "encountered\n  -P                     do not traverse any symbolic "
 7439|      0|                          "links (default)\n\n");
 7440|      0|            fputs_unlocked((char const *)tmp___6, stdout);
 7441|      0|            tmp___7 = gettext("      --help     display this help and exit\n");
 7442|      0|            fputs_unlocked((char const *)tmp___7, stdout);
 7443|      0|            tmp___8 =
 7444|      0|                gettext("      --version  output version information and exit\n");
 7445|      0|            fputs_unlocked((char const *)tmp___8, stdout);
 7446|      0|            tmp___9 = gettext("\nOwner is unchanged if missing.  Group is unchanged "
 7447|      0|                              "if missing, but changed\nto login group if implied by "
 7448|      0|                              "a `:\' following a symbolic OWNER.\nOWNER and GROUP "
 7449|      0|                              "may be numeric as well as symbolic.\n");
 7450|      0|            fputs_unlocked((char const *)tmp___9, stdout);
 7451|      0|            tmp___10 =
 7452|      0|                gettext("\nExamples:\n  %s root /u        Change the owner of /u to "
 7453|      0|                        "\"root\".\n  %s root:staff /u  Likewise, but also change "
 7454|      0|                        "its group to \"staff\".\n  %s -hR root /u    Change the "
 7455|      0|                        "owner of /u and subfiles to \"root\".\n");
 7456|      0|            printf((char const *)tmp___10, program_name, program_name, program_name);
 7457|      0|            emit_ancillary_info();
 7458|      0|        }
 7459|      0|        exit(status);
 7460|      0|    }
 7461|      0|}
 7462|       |static struct dev_ino dev_ino_buf;
 7463|       |int main(int argc, char **argv)
 7464|      1|{
 7465|      1|    _Bool preserve_root;
 7466|      1|    uid_t uid;
 7467|      1|    gid_t gid;
 7468|      1|    uid_t required_uid;
 7469|      1|    gid_t required_gid;
 7470|      1|    int bit_flags;
 7471|      1|    int dereference;
 7472|      1|    struct Chown_option chopt;
 7473|      1|    _Bool ok;
 7474|      1|    int optc;
 7475|      1|    char *u_dummy;
 7476|      1|    char *g_dummy;
 7477|      1|    char const *e;
 7478|      1|    char const *tmp;
 7479|      1|    char const *tmp___0;
 7480|      1|    char *tmp___1;
 7481|      1|    char *tmp___2;
 7482|      1|    char const *tmp___3;
 7483|      1|    char *tmp___4;
 7484|      1|    int tmp___5;
 7485|      1|    struct stat ref_stats;
 7486|      1|    char const *tmp___6;
 7487|      1|    char *tmp___7;
 7488|      1|    int *tmp___8;
 7489|      1|    int tmp___9;
 7490|      1|    char const *e___0;
 7491|      1|    char const *tmp___10;
 7492|      1|    char const *tmp___11;
 7493|      1|    char const *tmp___12;
 7494|      1|    char *tmp___13;
 7495|      1|    int *tmp___14;
 7496|      1|    int tmp___15;
 7497|       |
 7498|      1|    {
 7499|      1|        preserve_root = (_Bool)0;
 7500|      1|        uid = (uid_t)-1;
 7501|      1|        gid = (gid_t)-1;
 7502|      1|        required_uid = (uid_t)-1;
 7503|      1|        required_gid = (gid_t)-1;
 7504|      1|        bit_flags = 16;
 7505|      1|        dereference = -1;
 7506|      1|        set_program_name((char const *)*(argv + 0));
 7507|      1|        setlocale(6, "");
 7508|      1|        bindtextdomain("coreutils", "/usr/local/share/locale");
 7509|      1|        textdomain("coreutils");
 7510|      1|        atexit(&close_stdout);
 7511|      1|        chopt_init(&chopt);
 7512|      2|        while (1) {
 7513|      2|            optc = getopt_long(argc, (char *const *)argv, "HLPRcfhv",
 7514|      2|                               long_options___1, (int *)((void *)0));
 7515|      2|            if (!(optc != -1)) {
 7516|      1|                goto while_break;
 7517|      1|            }
 7518|      1|            if (optc == 72) {
 7519|      0|                goto case_72;
 7520|      0|            }
 7521|      1|            if (optc == 76) {
 7522|      0|                goto case_76;
 7523|      0|            }
 7524|      1|            if (optc == 80) {
 7525|      0|                goto case_80;
 7526|      0|            }
 7527|      1|            if (optc == 104) {
 7528|      0|                goto case_104;
 7529|      0|            }
 7530|      1|            if (optc == 128) {
 7531|      0|                goto case_128;
 7532|      0|            }
 7533|      1|            if (optc == 130) {
 7534|      0|                goto case_130;
 7535|      0|            }
 7536|      1|            if (optc == 131) {
 7537|      0|                goto case_131;
 7538|      0|            }
 7539|      1|            if (optc == 132) {
 7540|      0|                goto case_132;
 7541|      0|            }
 7542|      1|            if (optc == 129) {
 7543|      0|                goto case_129;
 7544|      0|            }
 7545|      1|            if (optc == 82) {
 7546|      1|                goto case_82;
 7547|      1|            }
 7548|      0|            if (optc == 99) {
 7549|      0|                goto case_99;
 7550|      0|            }
 7551|      0|            if (optc == 102) {
 7552|      0|                goto case_102;
 7553|      0|            }
 7554|      0|            if (optc == 118) {
 7555|      0|                goto case_118;
 7556|      0|            }
 7557|      0|            if (optc == -130) {
 7558|      0|                goto case_neg_130;
 7559|      0|            }
 7560|      0|            if (optc == -131) {
 7561|      0|                goto case_neg_131;
 7562|      0|            }
 7563|      0|            goto switch_default;
 7564|      0|case_72:
 7565|      0|            bit_flags = 17;
 7566|      0|            goto switch_break;
 7567|      0|case_76:
 7568|      0|            bit_flags = 2;
 7569|      0|            goto switch_break;
 7570|      0|case_80:
 7571|      0|            bit_flags = 16;
 7572|      0|            goto switch_break;
 7573|      0|case_104:
 7574|      0|            dereference = 0;
 7575|      0|            goto switch_break;
 7576|      0|case_128:
 7577|      0|            dereference = 1;
 7578|      0|            goto switch_break;
 7579|      0|case_130:
 7580|      0|            preserve_root = (_Bool)0;
 7581|      0|            goto switch_break;
 7582|      0|case_131:
 7583|      0|            preserve_root = (_Bool)1;
 7584|      0|            goto switch_break;
 7585|      0|case_132:
 7586|      0|            reference_file = optarg;
 7587|      0|            goto switch_break;
 7588|      0|case_129:
 7589|      0|            tmp = parse_user_spec((char const *)optarg, &required_uid, &required_gid,
 7590|      0|                                  &u_dummy, &g_dummy);
 7591|      0|            e = tmp;
 7592|      0|            if (e) {
 7593|      0|                tmp___0 = quote((char const *)optarg);
 7594|      0|                error(1, 0, "%s: %s", e, tmp___0);
 7595|      0|            }
 7596|      0|            goto switch_break;
 7597|      1|case_82:
 7598|      1|            chopt.recurse = (_Bool)1;
 7599|      1|            goto switch_break;
 7600|      0|case_99:
 7601|      0|            chopt.verbosity = (enum Verbosity)1;
 7602|      0|            goto switch_break;
 7603|      0|case_102:
 7604|      0|            chopt.force_silent = (_Bool)1;
 7605|      0|            goto switch_break;
 7606|      0|case_118:
 7607|      0|            chopt.verbosity = (enum Verbosity)0;
 7608|      0|            goto switch_break;
 7609|      0|case_neg_130:
 7610|      0|            usage(0);
 7611|      0|            goto switch_break;
 7612|      0|case_neg_131:
 7613|      0|            version_etc(stdout, "chown", "GNU coreutils", Version, "David MacKenzie",
 7614|      0|                        "Jim Meyering", (char *)((void *)0));
 7615|      0|            exit(0);
 7616|      0|            goto switch_break;
 7617|      0|switch_default:
 7618|      0|            usage(1);
 7619|      1|switch_break:
 7620|      1|            ;
 7621|      1|        }
 7622|      1|while_break:
 7623|      1|        ;
 7624|      1|        if (chopt.recurse) {
 7625|      1|            if (bit_flags == 16) {
 7626|      1|                if (dereference == 1) {
 7627|      0|                    tmp___1 = gettext("-R --dereference requires either -H or -L");
 7628|      0|                    error(1, 0, (char const *)tmp___1);
 7629|      0|                }
 7630|      1|                dereference = 0;
 7631|      1|            }
 7632|      1|        }
 7633|      0|        else {
 7634|      0|            bit_flags = 16;
 7635|      0|        }
 7636|      1|        chopt.affect_symlink_referent = (_Bool)(dereference != 0);
 7637|      1|        if (reference_file) {
 7638|      0|            tmp___5 = 1;
 7639|      0|        }
 7640|      1|        else {
 7641|      1|            tmp___5 = 2;
 7642|      1|        }
 7643|      1|        if (argc - optind < tmp___5) {
 7644|      0|            if (argc <= optind) {
 7645|      0|                tmp___2 = gettext("missing operand");
 7646|      0|                error(0, 0, (char const *)tmp___2);
 7647|      0|            }
 7648|      0|            else {
 7649|      0|                tmp___3 = quote((char const *)*(argv + (argc - 1)));
 7650|      0|                tmp___4 = gettext("missing operand after %s");
 7651|      0|                error(0, 0, (char const *)tmp___4, tmp___3);
 7652|      0|            }
 7653|      0|            usage(1);
 7654|      0|        }
 7655|      1|        if (reference_file) {
 7656|      0|            tmp___9 = stat((char const *)reference_file, &ref_stats);
 7657|      0|            if (tmp___9) {
 7658|      0|                tmp___6 = quote((char const *)reference_file);
 7659|      0|                tmp___7 = gettext("failed to get attributes of %s");
 7660|      0|                tmp___8 = __errno_location();
 7661|      0|                error(1, *tmp___8, (char const *)tmp___7, tmp___6);
 7662|      0|            }
 7663|      0|            uid = ref_stats.st_uid;
 7664|      0|            gid = ref_stats.st_gid;
 7665|      0|            chopt.user_name = uid_to_name(ref_stats.st_uid);
 7666|      0|            chopt.group_name = gid_to_name(ref_stats.st_gid);
 7667|      0|        }
 7668|      1|        else {
 7669|      1|            tmp___10 = parse_user_spec((char const *)*(argv + optind), &uid, &gid,
 7670|      1|                                       &chopt.user_name, &chopt.group_name);
 7671|      1|            e___0 = tmp___10;
 7672|      1|            if (e___0) {
 7673|      0|                tmp___11 = quote((char const *)*(argv + optind));
 7674|      0|                error(1, 0, "%s: %s", e___0, tmp___11);
 7675|      0|            }
 7676|      1|            if (!chopt.user_name) {
 7677|      0|                if (chopt.group_name) {
 7678|      0|                    chopt.user_name = bad_cast("");
 7679|      0|                }
 7680|      0|            }
 7681|      1|            optind++;
 7682|      1|        }
 7683|      1|        if (chopt.recurse) {
 7684|      1|            if (preserve_root) {
 7685|      0|                chopt.root_dev_ino = get_root_dev_ino(&dev_ino_buf);
 7686|      0|                if ((unsigned long)chopt.root_dev_ino == (unsigned long)((void *)0)) {
 7687|      0|                    tmp___12 = quote("/");
 7688|      0|                    tmp___13 = gettext("failed to get attributes of %s");
 7689|      0|                    tmp___14 = __errno_location();
 7690|      0|                    error(1, *tmp___14, (char const *)tmp___13, tmp___12);
 7691|      0|                }
 7692|      0|            }
 7693|      1|        }
 7694|      1|        bit_flags |= 1024;
 7695|      1|        ok = chown_files(argv + optind, bit_flags, uid, gid, required_uid,
 7696|      1|                         required_gid, (struct Chown_option const *)(&chopt));
 7697|      1|        chopt_free(&chopt);
 7698|      1|        if (ok) {
 7699|      1|            tmp___15 = 0;
 7700|      1|        }
 7701|      0|        else {
 7702|      0|            tmp___15 = 1;
 7703|      0|        }
 7704|      1|        exit(tmp___15);
 7705|      1|    }
 7706|      1|}


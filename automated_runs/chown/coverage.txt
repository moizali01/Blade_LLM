    1|       |typedef unsigned long size_t;
    2|       |typedef long __off_t;
    3|       |typedef long __off64_t;
    4|       |struct _IO_FILE;
    5|       |struct _IO_FILE;
    6|       |struct _IO_FILE;
    7|       |typedef struct _IO_FILE FILE;
    8|       |typedef void _IO_lock_t;
    9|       |struct _IO_marker {
   10|       |  struct _IO_marker *_next;
   11|       |  struct _IO_FILE *_sbuf;
   12|       |  int _pos;
   13|       |};
   14|       |struct _IO_FILE {
   15|       |  int _flags;
   16|       |  char *_IO_read_ptr;
   17|       |  char *_IO_read_end;
   18|       |  char *_IO_read_base;
   19|       |  char *_IO_write_base;
   20|       |  char *_IO_write_ptr;
   21|       |  char *_IO_write_end;
   22|       |  char *_IO_buf_base;
   23|       |  char *_IO_buf_end;
   24|       |  char *_IO_save_base;
   25|       |  char *_IO_backup_base;
   26|       |  char *_IO_save_end;
   27|       |  struct _IO_marker *_markers;
   28|       |  struct _IO_FILE *_chain;
   29|       |  int _fileno;
   30|       |  int _flags2;
   31|       |  __off_t _old_offset;
   32|       |  unsigned short _cur_column;
   33|       |  signed char _vtable_offset;
   34|       |  char _shortbuf[1];
   35|       |  _IO_lock_t *_lock;
   36|       |  __off64_t _offset;
   37|       |  void *__pad1;
   38|       |  void *__pad2;
   39|       |  void *__pad3;
   40|       |  void *__pad4;
   41|       |  size_t __pad5;
   42|       |  int _mode;
   43|       |  char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
   44|       |};
   45|       |typedef long __time_t;
   46|       |typedef unsigned long __dev_t;
   47|       |typedef unsigned int __uid_t;
   48|       |typedef unsigned int __gid_t;
   49|       |typedef unsigned long __ino_t;
   50|       |typedef unsigned int __mode_t;
   51|       |typedef unsigned long __nlink_t;
   52|       |typedef long __blksize_t;
   53|       |typedef long __blkcnt_t;
   54|       |typedef long __syscall_slong_t;
   55|       |typedef __mode_t mode_t;
   56|       |struct timespec {
   57|       |  __time_t tv_sec;
   58|       |  __syscall_slong_t tv_nsec;
   59|       |};
   60|       |struct stat {
   61|       |  __dev_t st_dev;
   62|       |  __ino_t st_ino;
   63|       |  __nlink_t st_nlink;
   64|       |  __mode_t st_mode;
   65|       |  __uid_t st_uid;
   66|       |  __gid_t st_gid;
   67|       |  int __pad0;
   68|       |  __dev_t st_rdev;
   69|       |  __off_t st_size;
   70|       |  __blksize_t st_blksize;
   71|       |  __blkcnt_t st_blocks;
   72|       |  struct timespec st_atim;
   73|       |  struct timespec st_mtim;
   74|       |  struct timespec st_ctim;
   75|       |  __syscall_slong_t __glibc_reserved[3];
   76|       |};
   77|       |typedef __ino_t ino_t;
   78|       |typedef __dev_t dev_t;
   79|       |struct hash_table;
   80|       |struct hash_table;
   81|       |struct hash_table;
   82|       |typedef struct hash_table Hash_table;
   83|       |struct F_triple {
   84|       |  char *name;
   85|       |  ino_t st_ino;
   86|       |  dev_t st_dev;
   87|       |};
   88|       |struct __dirstream;
   89|       |struct __dirstream;
   90|       |struct __dirstream;
   91|       |typedef struct __dirstream DIR;
   92|       |typedef int wchar_t;
   93|       |union __anonunion___value_4 {
   94|       |  unsigned int __wch;
   95|       |  char __wchb[4];
   96|       |};
   97|       |struct __anonstruct___mbstate_t_3 {
   98|       |  int __count;
   99|       |  union __anonunion___value_4 __value;
  100|       |};
  101|       |typedef struct __anonstruct___mbstate_t_3 __mbstate_t;
  102|       |typedef unsigned int wint_t;
  103|       |struct hash_tuning {
  104|       |  float shrink_threshold;
  105|       |  float shrink_factor;
  106|       |  float growth_threshold;
  107|       |  float growth_factor;
  108|       |  _Bool is_n_buckets;
  109|       |};
  110|       |typedef struct hash_tuning Hash_tuning;
  111|       |typedef __mbstate_t mbstate_t;
  112|       |struct mbchar {
  113|       |  char const *ptr;
  114|       |  size_t bytes;
  115|       |  _Bool wc_valid;
  116|       |  wchar_t wc;
  117|       |  char buf[24];
  118|       |};
  119|       |struct mbuiter_multi {
  120|       |  _Bool in_shift;
  121|       |  mbstate_t state;
  122|       |  _Bool next_done;
  123|       |  struct mbchar cur;
  124|       |};
  125|       |typedef struct mbuiter_multi mbui_iterator_t;
  126|       |typedef __gid_t gid_t;
  127|       |typedef __uid_t uid_t;
  128|       |typedef unsigned long uintmax_t;
  129|       |struct dev_ino {
  130|       |  ino_t st_ino;
  131|       |  dev_t st_dev;
  132|       |};
  133|       |struct cycle_check_state {
  134|       |  struct dev_ino dev_ino;
  135|       |  uintmax_t chdir_counter;
  136|       |  int magic;
  137|       |};
  138|       |typedef long ptrdiff_t;
  139|       |struct dirent {
  140|       |  __ino_t d_ino;
  141|       |  __off_t d_off;
  142|       |  unsigned short d_reclen;
  143|       |  unsigned char d_type;
  144|       |  char d_name[256];
  145|       |};
  146|       |typedef __builtin_va_list __gnuc_va_list;
  147|       |typedef __gnuc_va_list va_list;
  148|       |enum quoting_style {
  149|       |  literal_quoting_style = 0,
  150|       |  shell_quoting_style = 1,
  151|       |  shell_always_quoting_style = 2,
  152|       |  c_quoting_style = 3,
  153|       |  c_maybe_quoting_style = 4,
  154|       |  escape_quoting_style = 5,
  155|       |  locale_quoting_style = 6,
  156|       |  clocale_quoting_style = 7,
  157|       |  custom_quoting_style = 8
  158|       |};
  159|       |enum strtol_error {
  160|       |  LONGINT_OK = 0,
  161|       |  LONGINT_OVERFLOW = 1,
  162|       |  LONGINT_INVALID_SUFFIX_CHAR = 2,
  163|       |  LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
  164|       |  LONGINT_INVALID = 4
  165|       |};
  166|       |typedef enum strtol_error strtol_error;
  167|       |struct option {
  168|       |  char const *name;
  169|       |  int has_arg;
  170|       |  int *flag;
  171|       |  int val;
  172|       |};
  173|       |typedef long intmax_t;
  174|       |typedef __nlink_t nlink_t;
  175|       |struct I_ring {
  176|       |  int ir_data[4];
  177|       |  int ir_default_val;
  178|       |  unsigned int ir_front;
  179|       |  unsigned int ir_back;
  180|       |  _Bool ir_empty;
  181|       |};
  182|       |typedef struct I_ring I_ring;
  183|       |struct _ftsent;
  184|       |struct _ftsent;
  185|       |struct _ftsent;
  186|       |union __anonunion_fts_cycle_29 {
  187|       |  struct hash_table *ht;
  188|       |  struct cycle_check_state *state;
  189|       |};
  190|       |struct __anonstruct_FTS_28 {
  191|       |  struct _ftsent *fts_cur;
  192|       |  struct _ftsent *fts_child;
  193|       |  struct _ftsent **fts_array;
  194|       |  dev_t fts_dev;
  195|       |  char *fts_path;
  196|       |  int fts_rfd;
  197|       |  int fts_cwd_fd;
  198|       |  size_t fts_pathlen;
  199|       |  size_t fts_nitems;
  200|       |  int (*fts_compar)(struct _ftsent const **, struct _ftsent const **);
  201|       |  int fts_options;
  202|       |  struct hash_table *fts_leaf_optimization_works_ht;
  203|       |  union __anonunion_fts_cycle_29 fts_cycle;
  204|       |  I_ring fts_fd_ring;
  205|       |};
  206|       |typedef struct __anonstruct_FTS_28 FTS;
  207|       |struct _ftsent {
  208|       |  struct _ftsent *fts_cycle;
  209|       |  struct _ftsent *fts_parent;
  210|       |  struct _ftsent *fts_link;
  211|       |  long fts_number;
  212|       |  void *fts_pointer;
  213|       |  char *fts_accpath;
  214|       |  char *fts_path;
  215|       |  int fts_errno;
  216|       |  int fts_symfd;
  217|       |  size_t fts_pathlen;
  218|       |  FTS *fts_fts;
  219|       |  ptrdiff_t fts_level;
  220|       |  size_t fts_namelen;
  221|       |  nlink_t fts_n_dirs_remaining;
  222|       |  unsigned short fts_info;
  223|       |  unsigned short fts_flags;
  224|       |  unsigned short fts_instr;
  225|       |  struct stat fts_statp[1];
  226|       |  char fts_name[1];
  227|       |};
  228|       |typedef struct _ftsent FTSENT;
  229|       |struct passwd {
  230|       |  char *pw_name;
  231|       |  char *pw_passwd;
  232|       |  __uid_t pw_uid;
  233|       |  __gid_t pw_gid;
  234|       |  char *pw_gecos;
  235|       |  char *pw_dir;
  236|       |  char *pw_shell;
  237|       |};
  238|       |struct group {
  239|       |  char *gr_name;
  240|       |  char *gr_passwd;
  241|       |  __gid_t gr_gid;
  242|       |  char **gr_mem;
  243|       |};
  244|       |typedef unsigned long reg_syntax_t;
  245|       |struct quoting_options;
  246|       |struct quoting_options;
  247|       |struct quoting_options;
  248|       |struct quoting_options {
  249|       |  enum quoting_style style;
  250|       |  int flags;
  251|       |  unsigned int quote_these_too[255UL / (sizeof(int) * 8UL) + 1UL];
  252|       |  char const *left_quote;
  253|       |  char const *right_quote;
  254|       |};
  255|       |struct slotvec {
  256|       |  size_t size;
  257|       |  char *val;
  258|       |};
  259|       |struct hash_entry {
  260|       |  void *data;
  261|       |  struct hash_entry *next;
  262|       |};
  263|       |struct hash_table {
  264|       |  struct hash_entry *bucket;
  265|       |  struct hash_entry const *bucket_limit;
  266|       |  size_t n_buckets;
  267|       |  size_t n_buckets_used;
  268|       |  size_t n_entries;
  269|       |  Hash_tuning const *tuning;
  270|       |  size_t (*hasher)(void const *, size_t);
  271|       |  _Bool (*comparator)(void const *, void const *);
  272|       |  void (*data_freer)(void *);
  273|       |  struct hash_entry *free_entry_list;
  274|       |};
  275|       |struct __anonstruct___fsid_t_1 {
  276|       |  int __val[2];
  277|       |};
  278|       |typedef struct __anonstruct___fsid_t_1 __fsid_t;
  279|       |typedef unsigned long __fsblkcnt_t;
  280|       |typedef unsigned long __fsfilcnt_t;
  281|       |typedef long __fsword_t;
  282|       |struct Active_dir {
  283|       |  dev_t dev;
  284|       |  ino_t ino;
  285|       |  FTSENT *fts_ent;
  286|       |};
  287|       |struct statfs {
  288|       |  __fsword_t f_type;
  289|       |  __fsword_t f_bsize;
  290|       |  __fsblkcnt_t f_blocks;
  291|       |  __fsblkcnt_t f_bfree;
  292|       |  __fsblkcnt_t f_bavail;
  293|       |  __fsfilcnt_t f_files;
  294|       |  __fsfilcnt_t f_ffree;
  295|       |  __fsid_t f_fsid;
  296|       |  __fsword_t f_namelen;
  297|       |  __fsword_t f_frsize;
  298|       |  __fsword_t f_flags;
  299|       |  __fsword_t f_spare[4];
  300|       |};
  301|       |struct LCO_ent {
  302|       |  dev_t st_dev;
  303|       |  _Bool opt_ok;
  304|       |};
  305|       |enum Change_status {
  306|       |  CH_NOT_APPLIED = 1,
  307|       |  CH_SUCCEEDED = 2,
  308|       |  CH_FAILED = 3,
  309|       |  CH_NO_CHANGE_REQUESTED = 4
  310|       |};
  311|       |enum Verbosity { V_high = 0, V_changes_only = 1, V_off = 2 };
  312|       |struct Chown_option {
  313|       |  enum Verbosity verbosity;
  314|       |  _Bool recurse;
  315|       |  struct dev_ino *root_dev_ino;
  316|       |  _Bool affect_symlink_referent;
  317|       |  _Bool force_silent;
  318|       |  char *user_name;
  319|       |  char *group_name;
  320|       |};
  321|       |enum RCH_status {
  322|       |  RC_ok = 2,
  323|       |  RC_excluded = 3,
  324|       |  RC_inode_changed = 4,
  325|       |  RC_do_ordinary_chown = 5,
  326|       |  RC_error = 6
  327|       |};
  328|       |extern __attribute__((__nothrow__)) int *(
  329|       |    __attribute__((__leaf__)) __errno_location)(void)__attribute__((__const__));
  330|       |extern int close(int __fd);
  331|       |extern int(__attribute__((__nonnull__(1))) open)(char const *__file,
  332|       |                                                 int __oflag, ...);
  333|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) tolower)(
  334|       |    int __c);
  335|       |extern __attribute__((__nothrow__))
  336|       |size_t(__attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s)
  337|       |    __attribute__((__pure__));
  338|       |extern int fclose(FILE *__stream);
  339|       |int dup_safer(int fd);
  340|       |extern __attribute__((__nothrow__)) int(__attribute__((
  341|       |    __nonnull__(1, 2), __leaf__)) strcmp)(char const *__s1, char const *__s2)
  342|       |    __attribute__((__pure__));
  343|       |extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2),
  344|       |                                                       __leaf__)) strncmp)(
  345|       |    char const *__s1, char const *__s2, size_t __n) __attribute__((__pure__));
  346|       |__attribute__((__noreturn__)) void xalloc_die(void);
  347|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__)) malloc)(
  348|       |    size_t __size) __attribute__((__malloc__));
  349|       |char *last_component(char const *name);
  350|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) gettext)(
  351|       |    char const *__msgid) __attribute__((__format_arg__(1)));
  352|       |void *hash_lookup(Hash_table const *table___0, void const *entry);
  353|       |void *(__attribute__((__warn_unused_result__)) hash_insert)(
  354|       |    Hash_table *table___0, void const *entry);
  355|       |void triple_free(void *x);
  356|       |void *xmalloc(size_t n) __attribute__((__malloc__));
  357|       |char *xstrdup(char const *string) __attribute__((__malloc__));
  358|       |extern DIR *fdopendir(int __fd);
  359|       |DIR *rpl_fdopendir(int fd);
  360|       |extern __attribute__((__nothrow__)) int(__attribute__((
  361|       |    __nonnull__(2), __leaf__)) fstat)(int __fd, struct stat *__buf);
  362|      2|DIR *rpl_fdopendir(int fd) {
  363|      2|  struct stat st;
  364|      2|  int tmp;
  365|      2|  int *tmp___0;
  366|      2|  DIR *tmp___1;
  367|       |
  368|      2|  {
  369|      2|    tmp = fstat(fd, &st);
  370|      2|    if (tmp) {
  371|      0|      return ((DIR *)((void *)0));
  372|      0|    }
  373|      2|    if (!((st.st_mode & 61440U) == 16384U)) {
  374|      0|      tmp___0 = __errno_location();
  375|      0|      *tmp___0 = 20;
  376|      0|      return ((DIR *)((void *)0));
  377|      0|    }
  378|      2|    tmp___1 = fdopendir(fd);
  379|      2|    return (tmp___1);
  380|      2|  }
  381|      2|}
  382|       |int fd_safer(int fd);
  383|      2|int fd_safer(int fd) {
  384|      2|  int f;
  385|      2|  int tmp;
  386|      2|  int e;
  387|      2|  int *tmp___0;
  388|      2|  int *tmp___1;
  389|       |
  390|      2|  {
  391|      2|    if (0 <= fd) {
  392|      2|      if (fd <= 2) {
  393|      0|        tmp = dup_safer(fd);
  394|      0|        f = tmp;
  395|      0|        tmp___0 = __errno_location();
  396|      0|        e = *tmp___0;
  397|      0|        close(fd);
  398|      0|        tmp___1 = __errno_location();
  399|      0|        *tmp___1 = e;
  400|      0|        fd = f;
  401|      0|      }
  402|      2|    }
  403|      2|    return (fd);
  404|      2|  }
  405|      2|}
  406|       |int volatile exit_failure;
  407|       |int volatile exit_failure = (int volatile)1;
  408|       |extern __attribute__((__nothrow__)) unsigned short const **(
  409|       |    __attribute__((__leaf__)) __ctype_b_loc)(void)__attribute__((__const__));
  410|       |extern __attribute__((__nothrow__)) int(
  411|       |    __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream);
  412|       |extern __attribute__((__nothrow__))
  413|       |size_t(__attribute__((__leaf__)) __ctype_get_mb_cur_max)(void);
  414|       |extern __attribute__((__nothrow__)) void(__attribute__((__leaf__)) free)(
  415|       |    void *__ptr);
  416|       |extern
  417|       |    __attribute__((__nothrow__,
  418|       |                   __noreturn__)) void(__attribute__((__leaf__)) abort)(void);
  419|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  420|       |    __nonnull__(1), __leaf__)) memset)(void *__s, int __c, size_t __n);
  421|       |extern __attribute__((__nothrow__)) char *(
  422|       |    __attribute__((__nonnull__(1), __leaf__)) strchr)(char const *__s, int __c)
  423|       |    __attribute__((__pure__));
  424|       |extern __attribute__((__nothrow__)) char *(
  425|       |    __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const *__s, int __c)
  426|       |    __attribute__((__pure__));
  427|       |int mbscasecmp(char const *s1, char const *s2);
  428|       |extern __attribute__((__nothrow__))
  429|       |wint_t(__attribute__((__leaf__)) towlower)(wint_t __wc);
  430|       |size_t hash_string(char const *string, size_t n_buckets);
  431|       |Hash_table *(__attribute__((__warn_unused_result__)) hash_initialize)(
  432|       |    size_t candidate, Hash_tuning const *tuning,
  433|       |    size_t (*hasher)(void const *, size_t),
  434|       |    _Bool (*comparator)(void const *, void const *),
  435|       |    void (*data_freer)(void *));
  436|       |void hash_free(Hash_table *table___0);
  437|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((
  438|       |    __leaf__)) __assert_fail)(char const *__assertion, char const *__file,
  439|       |                              unsigned int __line, char const *__function);
  440|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) mbsinit)(
  441|       |    mbstate_t const *__ps) __attribute__((__pure__));
  442|       |extern __attribute__((__nothrow__)) size_t(__attribute__((__leaf__)) mbrtowc)(
  443|       |    wchar_t *__restrict __pwc, char const *__restrict __s, size_t __n,
  444|       |    mbstate_t *__restrict __p);
  445|       |unsigned int const is_basic_table[8];
  446|      0|__inline static _Bool is_basic(char c) {
  447|       |
  448|      0|  {
  449|      0|    return ((_Bool)((is_basic_table[(int)((unsigned char)c) >> 5] >>
  450|      0|                     ((int)((unsigned char)c) & 31)) &
  451|      0|                    1U));
  452|      0|  }
  453|      0|}
  454|       |size_t strnlen1(char const *string, size_t maxlen);
  455|      0|__inline static void mbuiter_multi_next(struct mbuiter_multi *iter) {
  456|      0|  int tmp;
  457|      0|  size_t tmp___0;
  458|      0|  size_t tmp___1;
  459|      0|  int tmp___2;
  460|      0|  _Bool tmp___3;
  461|       |
  462|      0|  {
  463|      0|    if (iter->next_done) {
  464|      0|      return;
  465|      0|    }
  466|      0|    if (iter->in_shift) {
  467|      0|      goto with_shift;
  468|      0|    }
  469|      0|    tmp___3 = is_basic((char)*(iter->cur.ptr));
  470|      0|    if (tmp___3) {
  471|      0|      iter->cur.bytes = (size_t)1;
  472|      0|      iter->cur.wc = (wchar_t) * (iter->cur.ptr);
  473|      0|      iter->cur.wc_valid = (_Bool)1;
  474|      0|    } else {
  475|      0|      tmp = mbsinit((mbstate_t const *)(&iter->state));
  476|      0|      if (!tmp) {
  477|      0|        __assert_fail("mbsinit (&iter->state)",
  478|      0|                      "/home/khheo/project/program-reduce/benchmark/"
  479|      0|                      "coreutils-8.2/lib/mbuiter.h",
  480|      0|                      142U, "mbuiter_multi_next");
  481|      0|      }
  482|      0|      iter->in_shift = (_Bool)1;
  483|      0|    with_shift:
  484|      0|      tmp___0 = __ctype_get_mb_cur_max();
  485|      0|      tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
  486|      0|      iter->cur.bytes =
  487|      0|          mbrtowc(&iter->cur.wc, iter->cur.ptr, tmp___1, &iter->state);
  488|      0|      if (iter->cur.bytes == 0xffffffffffffffffUL) {
  489|      0|        iter->cur.bytes = (size_t)1;
  490|      0|        iter->cur.wc_valid = (_Bool)0;
  491|      0|      } else {
  492|      0|        if (iter->cur.bytes == 0xfffffffffffffffeUL) {
  493|      0|          iter->cur.bytes = strlen(iter->cur.ptr);
  494|      0|          iter->cur.wc_valid = (_Bool)0;
  495|      0|        } else {
  496|      0|          if (iter->cur.bytes == 0UL) {
  497|      0|            iter->cur.bytes = (size_t)1;
  498|      0|            if (!((int const) * (iter->cur.ptr) == 0)) {
  499|      0|              __assert_fail("*iter->cur.ptr == \'\\0\'",
  500|      0|                            "/home/khheo/project/program-reduce/benchmark/"
  501|      0|                            "coreutils-8.2/lib/mbuiter.h",
  502|      0|                            170U, "mbuiter_multi_next");
  503|      0|            }
  504|      0|            if (!(iter->cur.wc == 0)) {
  505|      0|              __assert_fail("iter->cur.wc == 0",
  506|      0|                            "/home/khheo/project/program-reduce/benchmark/"
  507|      0|                            "coreutils-8.2/lib/mbuiter.h",
  508|      0|                            171U, "mbuiter_multi_next");
  509|      0|            }
  510|      0|          }
  511|      0|          iter->cur.wc_valid = (_Bool)1;
  512|      0|          tmp___2 = mbsinit((mbstate_t const *)(&iter->state));
  513|      0|          if (tmp___2) {
  514|      0|            iter->in_shift = (_Bool)0;
  515|      0|          }
  516|      0|        }
  517|      0|      }
  518|      0|    }
  519|      0|    iter->next_done = (_Bool)1;
  520|      0|    return;
  521|      0|  }
  522|      0|}
  523|       |void *xrealloc(void *p, size_t n);
  524|       |extern int fcntl(int __fd, int __cmd, ...);
  525|      2|int dup_safer(int fd) {
  526|      2|  int tmp;
  527|       |
  528|      2|  {
  529|      2|    tmp = fcntl(fd, 0, 3);
  530|      2|    return (tmp);
  531|      2|  }
  532|      2|}
  533|       |extern __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1, 2),
  534|       |                                                          __leaf__)) memcpy)(
  535|       |    void *__restrict __dest, void const *__restrict __src, size_t __n);
  536|       |extern __attribute__((__nothrow__)) int(__attribute__((
  537|       |    __nonnull__(1, 2), __leaf__)) stat)(char const *__restrict __file,
  538|       |                                        struct stat *__restrict __buf);
  539|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) fchown)(
  540|       |    int __fd, __uid_t __owner, __gid_t __group);
  541|       |char const diacrit_base[256];
  542|       |char const diacrit_diac[256];
  543|       |char const diacrit_base[256] = {
  544|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  545|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  546|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  547|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  548|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  549|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  550|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  551|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  552|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  553|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  554|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  555|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  556|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  557|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  558|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  559|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  560|       |    (char const)0,   (char const)'A', (char const)'B', (char const)'C',
  561|       |    (char const)'D', (char const)'E', (char const)'F', (char const)'G',
  562|       |    (char const)'H', (char const)'I', (char const)'J', (char const)'K',
  563|       |    (char const)'L', (char const)'M', (char const)'N', (char const)'O',
  564|       |    (char const)'P', (char const)'Q', (char const)'R', (char const)'S',
  565|       |    (char const)'T', (char const)'U', (char const)'V', (char const)'W',
  566|       |    (char const)'X', (char const)'Y', (char const)'Z', (char const)0,
  567|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  568|       |    (char const)0,   (char const)'a', (char const)'b', (char const)'c',
  569|       |    (char const)'d', (char const)'e', (char const)'f', (char const)'g',
  570|       |    (char const)'h', (char const)'i', (char const)'j', (char const)'k',
  571|       |    (char const)'l', (char const)'m', (char const)'n', (char const)'o',
  572|       |    (char const)'p', (char const)'q', (char const)'r', (char const)'s',
  573|       |    (char const)'t', (char const)'u', (char const)'v', (char const)'w',
  574|       |    (char const)'x', (char const)'y', (char const)'z', (char const)0,
  575|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  576|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  577|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  578|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  579|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  580|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  581|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  582|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  583|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  584|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  585|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  586|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  587|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  588|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  589|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  590|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  591|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  592|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'A',
  593|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'C',
  594|       |    (char const)'E', (char const)'E', (char const)'E', (char const)'E',
  595|       |    (char const)'I', (char const)'I', (char const)'I', (char const)'I',
  596|       |    (char const)0,   (char const)'N', (char const)'O', (char const)'O',
  597|       |    (char const)'O', (char const)'O', (char const)'O', (char const)0,
  598|       |    (char const)'O', (char const)'U', (char const)'U', (char const)'U',
  599|       |    (char const)'U', (char const)'Y', (char const)0,   (char const)0,
  600|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'a',
  601|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'c',
  602|       |    (char const)'e', (char const)'e', (char const)'e', (char const)'e',
  603|       |    (char const)'i', (char const)'i', (char const)'i', (char const)'i',
  604|       |    (char const)0,   (char const)'n', (char const)'o', (char const)'o',
  605|       |    (char const)'o', (char const)'o', (char const)'o', (char const)0,
  606|       |    (char const)'o', (char const)'u', (char const)'u', (char const)'u',
  607|       |    (char const)'u', (char const)'y', (char const)0,   (char const)'y'};
  608|       |char const diacrit_diac[256] = {
  609|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  610|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  611|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  612|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  613|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  614|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  615|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  616|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  617|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  618|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  619|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  620|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  621|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  622|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  623|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  624|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  625|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  626|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  627|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)4,
  628|       |    (char const)0, (char const)3, (char const)0, (char const)0, (char const)0,
  629|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  630|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  631|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  632|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  633|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  634|       |    (char const)0, (char const)6, (char const)0, (char const)0, (char const)0,
  635|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  636|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  637|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  638|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  639|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  640|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  641|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  642|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  643|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  644|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  645|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  646|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  647|       |    (char const)0, (char const)0, (char const)3, (char const)2, (char const)4,
  648|       |    (char const)6, (char const)5, (char const)8, (char const)1, (char const)7,
  649|       |    (char const)3, (char const)2, (char const)4, (char const)5, (char const)3,
  650|       |    (char const)2, (char const)4, (char const)5, (char const)0, (char const)6,
  651|       |    (char const)3, (char const)2, (char const)4, (char const)6, (char const)5,
  652|       |    (char const)0, (char const)9, (char const)3, (char const)2, (char const)4,
  653|       |    (char const)5, (char const)2, (char const)0, (char const)0, (char const)3,
  654|       |    (char const)2, (char const)4, (char const)6, (char const)5, (char const)8,
  655|       |    (char const)1, (char const)7, (char const)3, (char const)2, (char const)4,
  656|       |    (char const)5, (char const)3, (char const)2, (char const)4, (char const)5,
  657|       |    (char const)0, (char const)6, (char const)3, (char const)2, (char const)4,
  658|       |    (char const)6, (char const)5, (char const)0, (char const)9, (char const)3,
  659|       |    (char const)2, (char const)4, (char const)5, (char const)2, (char const)0,
  660|       |    (char const)0};
  661|       |void cycle_check_init(struct cycle_check_state *state);
  662|       |_Bool cycle_check(struct cycle_check_state *state, struct stat const *sb);
  663|      2|__inline static _Bool is_zero_or_power_of_two(uintmax_t i) {
  664|       |
  665|      2|  { return ((_Bool)((i & (i - 1UL)) == 0UL)); }
  666|      2|}
  667|      4|void cycle_check_init(struct cycle_check_state *state) {
  668|       |
  669|      4|  {
  670|      4|    state->chdir_counter = (uintmax_t)0;
  671|      4|    state->magic = 9827862;
  672|      4|    return;
  673|      4|  }
  674|      4|}
  675|      2|_Bool cycle_check(struct cycle_check_state *state, struct stat const *sb) {
  676|      2|  _Bool tmp;
  677|       |
  678|      2|  {
  679|      2|    if (!(state->magic == 9827862)) {
  680|      0|      __assert_fail("state->magic == 9827862",
  681|      0|                    "/home/khheo/project/program-reduce/benchmark/"
  682|      0|                    "coreutils-8.2/lib/cycle-check.c",
  683|      0|                    60U, "cycle_check");
  684|      0|    }
  685|      2|    if (state->chdir_counter) {
  686|      0|      if (sb->st_ino == (__ino_t const)state->dev_ino.st_ino) {
  687|      0|        if (sb->st_dev == (__dev_t const)state->dev_ino.st_dev) {
  688|      0|          return ((_Bool)1);
  689|      0|        }
  690|      0|      }
  691|      0|    }
  692|      2|    (state->chdir_counter)++;
  693|      2|    tmp = is_zero_or_power_of_two(state->chdir_counter);
  694|      2|    if (tmp) {
  695|      2|      if (state->chdir_counter == 0UL) {
  696|      0|        return ((_Bool)1);
  697|      0|      }
  698|      2|      state->dev_ino.st_dev = (dev_t)sb->st_dev;
  699|      2|      state->dev_ino.st_ino = (ino_t)sb->st_ino;
  700|      2|    }
  701|      2|    return ((_Bool)0);
  702|      2|  }
  703|      2|}
  704|       |extern void error(int __status, int __errnum, char const *__format, ...);
  705|       |char const *quote(char const *name);
  706|       |void close_stdout(void);
  707|       |extern struct _IO_FILE *stdout;
  708|       |extern struct _IO_FILE *stderr;
  709|       |extern __attribute__((__noreturn__)) void _exit(int __status);
  710|       |int close_stream(FILE *stream);
  711|       |char *quotearg_colon(char const *arg);
  712|       |static char const *file_name;
  713|       |static _Bool ignore_EPIPE;
  714|      2|void close_stdout(void) {
  715|      2|  char const *write_error;
  716|      2|  char const *tmp;
  717|      2|  char *tmp___0;
  718|      2|  int *tmp___1;
  719|      2|  int *tmp___2;
  720|      2|  int tmp___3;
  721|      2|  int *tmp___4;
  722|      2|  int tmp___5;
  723|       |
  724|      2|  {
  725|      2|    tmp___3 = close_stream(stdout);
  726|      2|    if (tmp___3 != 0) {
  727|      0|      if (ignore_EPIPE) {
  728|      0|        tmp___4 = __errno_location();
  729|      0|        if (!(*tmp___4 == 32)) {
  730|      0|          goto _L;
  731|      0|        }
  732|      0|      } else {
  733|      0|      _L:
  734|      0|        tmp = (char const *)gettext("write error");
  735|      0|        write_error = tmp;
  736|      0|        if (file_name) {
  737|      0|          tmp___0 = quotearg_colon(file_name);
  738|      0|          tmp___1 = __errno_location();
  739|      0|          error(0, *tmp___1, "%s: %s", tmp___0, write_error);
  740|      0|        } else {
  741|      0|          tmp___2 = __errno_location();
  742|      0|          error(0, *tmp___2, "%s", write_error);
  743|      0|        }
  744|      0|        _exit((int)exit_failure);
  745|      0|      }
  746|      0|    }
  747|      2|    tmp___5 = close_stream(stderr);
  748|      2|    if (tmp___5 != 0) {
  749|      0|      _exit((int)exit_failure);
  750|      0|    }
  751|      2|    return;
  752|      2|  }
  753|      2|}
  754|       |extern __attribute__((__nothrow__))
  755|       |size_t(__attribute__((__leaf__)) __fpending)(FILE *__fp);
  756|      4|int close_stream(FILE *stream) {
  757|      4|  _Bool some_pending;
  758|      4|  size_t tmp;
  759|      4|  _Bool prev_fail;
  760|      4|  int tmp___0;
  761|      4|  _Bool fclose_fail;
  762|      4|  int tmp___1;
  763|      4|  int *tmp___2;
  764|      4|  int *tmp___3;
  765|       |
  766|      4|  {
  767|      4|    tmp = __fpending(stream);
  768|      4|    some_pending = (_Bool)(tmp != 0UL);
  769|      4|    tmp___0 = ferror_unlocked(stream);
  770|      4|    prev_fail = (_Bool)(tmp___0 != 0);
  771|      4|    tmp___1 = fclose(stream);
  772|      4|    fclose_fail = (_Bool)(tmp___1 != 0);
  773|      4|    if (prev_fail) {
  774|      0|      goto _L___0;
  775|      4|    } else {
  776|      4|      if (fclose_fail) {
  777|      0|        if (some_pending) {
  778|      0|          goto _L___0;
  779|      0|        } else {
  780|      0|          tmp___3 = __errno_location();
  781|      0|          if (*tmp___3 != 9) {
  782|      0|          _L___0:
  783|      0|            if (!fclose_fail) {
  784|      0|              tmp___2 = __errno_location();
  785|      0|              *tmp___2 = 0;
  786|      0|            }
  787|      0|            return (-1);
  788|      0|          }
  789|      0|        }
  790|      0|      }
  791|      4|    }
  792|      4|    return (0);
  793|      4|  }
  794|      4|}
  795|       |int set_cloexec_flag(int desc, _Bool value);
  796|      4|int set_cloexec_flag(int desc, _Bool value) {
  797|      4|  int flags;
  798|      4|  int tmp;
  799|      4|  int newflags;
  800|      4|  int tmp___0;
  801|      4|  int tmp___1;
  802|       |
  803|      4|  {
  804|      4|    tmp = fcntl(desc, 1, 0);
  805|      4|    flags = tmp;
  806|      4|    if (0 <= flags) {
  807|      4|      if (value) {
  808|      4|        tmp___0 = flags | 1;
  809|      4|      } else {
  810|      0|        tmp___0 = flags & -2;
  811|      0|      }
  812|      4|      newflags = tmp___0;
  813|      4|      if (flags == newflags) {
  814|      0|        return (0);
  815|      4|      } else {
  816|      4|        tmp___1 = fcntl(desc, 2, newflags);
  817|      4|        if (tmp___1 != -1) {
  818|      4|          return (0);
  819|      4|        }
  820|      4|      }
  821|      4|    }
  822|      0|    return (-1);
  823|      4|  }
  824|      4|}
  825|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) fchdir)(
  826|       |    int __fd);
  827|       |extern int(__attribute__((__nonnull__(2))) openat)(int __fd, char const *__file,
  828|       |                                                   int __oflag, ...);
  829|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  830|       |    __nonnull__(1), __leaf__)) memchr)(void const *__s, int __c, size_t __n)
  831|       |    __attribute__((__pure__));
  832|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  833|       |    __nonnull__(1, 2), __leaf__)) memmove)(void *__dest, void const *__src,
  834|       |                                           size_t __n);
  835|       |extern __attribute__((__nothrow__)) int(__attribute__((
  836|       |    __nonnull__(1, 2), __leaf__)) lstat)(char const *__restrict __file,
  837|       |                                         struct stat *__restrict __buf);
  838|       |size_t triple_hash(void const *x, size_t table_size);
  839|       |_Bool triple_compare_ino_str(void const *x, void const *y);
  840|      0|char *last_component(char const *name) {
  841|      0|  char const *base;
  842|      0|  char const *p;
  843|      0|  _Bool saw_slash;
  844|       |
  845|      0|  {
  846|      0|    base = name + 0;
  847|      0|    saw_slash = (_Bool)0;
  848|      0|    while (1) {
  849|       |
  850|      0|      if (!((int const) * base == 47)) {
  851|      0|        goto while_break;
  852|      0|      }
  853|      0|      base++;
  854|      0|    }
  855|      0|  while_break:
  856|      0|    p = base;
  857|      0|    while (1) {
  858|       |
  859|      0|      if (!*p) {
  860|      0|        goto while_break___0;
  861|      0|      }
  862|      0|      if ((int const) * p == 47) {
  863|      0|        saw_slash = (_Bool)1;
  864|      0|      } else {
  865|      0|        if (saw_slash) {
  866|      0|          base = p;
  867|      0|          saw_slash = (_Bool)0;
  868|      0|        }
  869|      0|      }
  870|      0|      p++;
  871|      0|    }
  872|      0|  while_break___0:;
  873|      0|    return ((char *)base);
  874|      0|  }
  875|      0|}
  876|       |char const *simple_backup_suffix;
  877|       |void (*argmatch_die)(void);
  878|       |extern __attribute__((__nothrow__)) int(__attribute__((
  879|       |    __nonnull__(1, 2), __leaf__)) memcmp)(void const *__s1, void const *__s2,
  880|       |                                          size_t __n) __attribute__((__pure__));
  881|       |extern int(__attribute__((__nonnull__(1))) closedir)(DIR *__dirp);
  882|       |extern struct dirent *(__attribute__((__nonnull__(1))) readdir)(DIR *__dirp);
  883|       |DIR *opendir_safer(char const *name);
  884|       |char const *simple_backup_suffix = "~";
  885|       |extern int fprintf(FILE *__restrict __stream, char const *__restrict __format,
  886|       |                   ...);
  887|       |char *quotearg_n_style(int n, enum quoting_style s, char const *arg);
  888|       |char const *quote_n(int n, char const *name);
  889|       |__attribute__((__noreturn__)) void usage(int status);
  890|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  891|       |    __warn_unused_result__, __leaf__)) realloc)(void *__ptr, size_t __size);
  892|       |__inline static void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__));
  893|       |__inline static void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__));
  894|      0|__inline static void *xnmalloc(size_t n, size_t s) {
  895|      0|  int tmp;
  896|      0|  void *tmp___0;
  897|      0|
  898|      0|  {
  899|      0|    if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
  900|      0|      tmp = -1;
  901|      0|    } else {
  902|      0|      tmp = -2;
  903|      0|    }
  904|      0|    if ((size_t)tmp / s < n) {
  905|      0|      xalloc_die();
  906|      0|    }
  907|      0|    tmp___0 = xmalloc(n * s);
  908|      0|    return (tmp___0);
  909|      0|  }
  910|      0|}
  911|       |strtol_error xstrtoul(char const *s, char **ptr, int strtol_base,
  912|       |                      unsigned long *val, char const *valid_suffixes);
  913|       |extern __attribute__((__nothrow__)) unsigned long(__attribute__((
  914|       |    __nonnull__(1), __leaf__)) strtoul)(char const *__restrict __nptr,
  915|       |                                        char **__restrict __endptr, int __base);
  916|      0|static strtol_error bkm_scale___0(unsigned long *x, int scale_factor) {
  917|       |
  918|      0|  {
  919|      0|    if (0xffffffffffffffffUL / (unsigned long)scale_factor < *x) {
  920|      0|      *x = 0xffffffffffffffffUL;
  921|      0|      return ((strtol_error)1);
  922|      0|    }
  923|      0|    *x *= (unsigned long)scale_factor;
  924|      0|    return ((strtol_error)0);
  925|      0|  }
  926|      0|}
  927|       |static strtol_error bkm_scale_by_power___0(unsigned long *x, int base,
  928|      0|                                           int power) {
  929|      0|  strtol_error err;
  930|      0|  strtol_error tmp;
  931|      0|  int tmp___0;
  932|       |
  933|      0|  {
  934|      0|    err = (strtol_error)0;
  935|      0|    while (1) {
  936|      0|      tmp___0 = power;
  937|      0|      power--;
  938|      0|      if (!tmp___0) {
  939|      0|        goto while_break;
  940|      0|      }
  941|      0|      tmp = bkm_scale___0(x, base);
  942|      0|      err = (strtol_error)((unsigned int)err | (unsigned int)tmp);
  943|      0|    }
  944|      0|  while_break:;
  945|      0|    return (err);
  946|      0|  }
  947|      0|}
  948|       |strtol_error xstrtoul(char const *s, char **ptr, int strtol_base,
  949|      0|                      unsigned long *val, char const *valid_suffixes) {
  950|      0|  char *t_ptr;
  951|      0|  char **p;
  952|      0|  unsigned long tmp;
  953|      0|  strtol_error err;
  954|      0|  char const *q;
  955|      0|  unsigned char ch;
  956|      0|  unsigned short const **tmp___0;
  957|      0|  int *tmp___1;
  958|      0|  char *tmp___2;
  959|      0|  int *tmp___3;
  960|      0|  int *tmp___4;
  961|      0|  int base;
  962|      0|  int suffixes;
  963|      0|  strtol_error overflow;
  964|      0|  char *tmp___5;
  965|      0|  char *tmp___6;
  966|       |
  967|      0|  {
  968|      0|    err = (strtol_error)0;
  969|      0|    if (0 <= strtol_base) {
  970|      0|      if (!(strtol_base <= 36)) {
  971|      0|        __assert_fail("0 <= strtol_base && strtol_base <= 36",
  972|      0|                      "/home/khheo/project/program-reduce/benchmark/"
  973|      0|                      "coreutils-8.2/lib/xstrtol.c",
  974|      0|                      83U, "xstrtoul");
  975|      0|      }
  976|      0|    } else {
  977|      0|      __assert_fail("0 <= strtol_base && strtol_base <= 36",
  978|      0|                    "/home/khheo/project/program-reduce/benchmark/"
  979|      0|                    "coreutils-8.2/lib/xstrtol.c",
  980|      0|                    83U, "xstrtoul");
  981|      0|    }
  982|      0|    if (ptr) {
  983|      0|      p = ptr;
  984|      0|    } else {
  985|      0|      p = &t_ptr;
  986|      0|    }
  987|      0|    q = s;
  988|      0|    ch = (unsigned char)*q;
  989|      0|    while (1) {
  990|      0|      tmp___0 = __ctype_b_loc();
  991|      0|      if (!((int const) * (*tmp___0 + (int)ch) & 8192)) {
  992|      0|        goto while_break;
  993|      0|      }
  994|      0|      q++;
  995|      0|      ch = (unsigned char)*q;
  996|      0|    }
  997|      0|  while_break:;
  998|      0|    if ((int)ch == 45) {
  999|      0|      return ((strtol_error)4);
 1000|      0|    }
 1001|      0|    tmp___1 = __errno_location();
 1002|      0|    *tmp___1 = 0;
 1003|      0|    tmp = strtoul(s, p, strtol_base);
 1004|      0|    if ((unsigned long)*p == (unsigned long)s) {
 1005|      0|      if (valid_suffixes) {
 1006|      0|        if (*(*p)) {
 1007|      0|          tmp___2 = strchr(valid_suffixes, (int)*(*p));
 1008|      0|          if (tmp___2) {
 1009|      0|            tmp = 1UL;
 1010|      0|          } else {
 1011|      0|            return ((strtol_error)4);
 1012|      0|          }
 1013|      0|        } else {
 1014|      0|          return ((strtol_error)4);
 1015|      0|        }
 1016|      0|      } else {
 1017|      0|        return ((strtol_error)4);
 1018|      0|      }
 1019|      0|    } else {
 1020|      0|      tmp___4 = __errno_location();
 1021|      0|      if (*tmp___4 != 0) {
 1022|      0|        tmp___3 = __errno_location();
 1023|      0|        if (*tmp___3 != 34) {
 1024|      0|          return ((strtol_error)4);
 1025|      0|        }
 1026|      0|        err = (strtol_error)1;
 1027|      0|      }
 1028|      0|    }
 1029|      0|    if (!valid_suffixes) {
 1030|      0|      *val = tmp;
 1031|      0|      return (err);
 1032|      0|    }
 1033|      0|    if ((int)*(*p) != 0) {
 1034|      0|      base = 1024;
 1035|      0|      suffixes = 1;
 1036|      0|      tmp___5 = strchr(valid_suffixes, (int)*(*p));
 1037|      0|      if (!tmp___5) {
 1038|      0|        *val = tmp;
 1039|      0|        return ((strtol_error)((unsigned int)err | 2U));
 1040|      0|      }
 1041|      0|      tmp___6 = strchr(valid_suffixes, '0');
 1042|      0|      if (tmp___6) {
 1043|      0|        if ((int)*(*(p + 0) + 1) == 105) {
 1044|      0|          goto case_105;
 1045|      0|        }
 1046|      0|        if ((int)*(*(p + 0) + 1) == 66) {
 1047|      0|          goto case_66;
 1048|      0|        }
 1049|      0|        if ((int)*(*(p + 0) + 1) == 68) {
 1050|      0|          goto case_66;
 1051|      0|        }
 1052|      0|        goto switch_break;
 1053|      0|      case_105:
 1054|      0|        if ((int)*(*(p + 0) + 2) == 66) {
 1055|      0|          suffixes += 2;
 1056|      0|        }
 1057|      0|        goto switch_break;
 1058|      0|      case_66:
 1059|      0|        base = 1000;
 1060|      0|        suffixes++;
 1061|      0|        goto switch_break;
 1062|      0|      switch_break:;
 1063|      0|      }
 1064|      0|      if ((int)*(*p) == 98) {
 1065|      0|        goto case_98;
 1066|      0|      }
 1067|      0|      if ((int)*(*p) == 66) {
 1068|      0|        goto case_66___0;
 1069|      0|      }
 1070|      0|      if ((int)*(*p) == 99) {
 1071|      0|        goto case_99;
 1072|      0|      }
 1073|      0|      if ((int)*(*p) == 69) {
 1074|      0|        goto case_69;
 1075|      0|      }
 1076|      0|      if ((int)*(*p) == 71) {
 1077|      0|        goto case_71;
 1078|      0|      }
 1079|      0|      if ((int)*(*p) == 103) {
 1080|      0|        goto case_71;
 1081|      0|      }
 1082|      0|      if ((int)*(*p) == 107) {
 1083|      0|        goto case_107;
 1084|      0|      }
 1085|      0|      if ((int)*(*p) == 75) {
 1086|      0|        goto case_107;
 1087|      0|      }
 1088|      0|      if ((int)*(*p) == 77) {
 1089|      0|        goto case_77;
 1090|      0|      }
 1091|      0|      if ((int)*(*p) == 109) {
 1092|      0|        goto case_77;
 1093|      0|      }
 1094|      0|      if ((int)*(*p) == 80) {
 1095|      0|        goto case_80;
 1096|      0|      }
 1097|      0|      if ((int)*(*p) == 84) {
 1098|      0|        goto case_84;
 1099|      0|      }
 1100|      0|      if ((int)*(*p) == 116) {
 1101|      0|        goto case_84;
 1102|      0|      }
 1103|      0|      if ((int)*(*p) == 119) {
 1104|      0|        goto case_119;
 1105|      0|      }
 1106|      0|      if ((int)*(*p) == 89) {
 1107|      0|        goto case_89;
 1108|      0|      }
 1109|      0|      if ((int)*(*p) == 90) {
 1110|      0|        goto case_90;
 1111|      0|      }
 1112|      0|      goto switch_default;
 1113|      0|    case_98:
 1114|      0|      overflow = bkm_scale___0(&tmp, 512);
 1115|      0|      goto switch_break___0;
 1116|      0|    case_66___0:
 1117|      0|      overflow = bkm_scale___0(&tmp, 1024);
 1118|      0|      goto switch_break___0;
 1119|      0|    case_99:
 1120|      0|      overflow = (strtol_error)0;
 1121|      0|      goto switch_break___0;
 1122|      0|    case_69:
 1123|      0|      overflow = bkm_scale_by_power___0(&tmp, base, 6);
 1124|      0|      goto switch_break___0;
 1125|      0|    case_71:
 1126|      0|      overflow = bkm_scale_by_power___0(&tmp, base, 3);
 1127|      0|      goto switch_break___0;
 1128|      0|    case_107:
 1129|      0|      overflow = bkm_scale_by_power___0(&tmp, base, 1);
 1130|      0|      goto switch_break___0;
 1131|      0|    case_77:
 1132|      0|      overflow = bkm_scale_by_power___0(&tmp, base, 2);
 1133|      0|      goto switch_break___0;
 1134|      0|    case_80:
 1135|      0|      overflow = bkm_scale_by_power___0(&tmp, base, 5);
 1136|      0|      goto switch_break___0;
 1137|      0|    case_84:
 1138|      0|      overflow = bkm_scale_by_power___0(&tmp, base, 4);
 1139|      0|      goto switch_break___0;
 1140|      0|    case_119:
 1141|      0|      overflow = bkm_scale___0(&tmp, 2);
 1142|      0|      goto switch_break___0;
 1143|      0|    case_89:
 1144|      0|      overflow = bkm_scale_by_power___0(&tmp, base, 8);
 1145|      0|      goto switch_break___0;
 1146|      0|    case_90:
 1147|      0|      overflow = bkm_scale_by_power___0(&tmp, base, 7);
 1148|      0|      goto switch_break___0;
 1149|      0|    switch_default:
 1150|      0|      *val = tmp;
 1151|      0|      return ((strtol_error)((unsigned int)err | 2U));
 1152|      0|    switch_break___0:
 1153|      0|      err = (strtol_error)((unsigned int)err | (unsigned int)overflow);
 1154|      0|      *p += suffixes;
 1155|      0|      if (*(*p)) {
 1156|      0|        err = (strtol_error)((unsigned int)err | 2U);
 1157|      0|      }
 1158|      0|    }
 1159|      0|    *val = tmp;
 1160|      0|    return (err);
 1161|      0|  }
 1162|      0|}
 1163|       |void *xmemdup(void const *p, size_t s) __attribute__((__malloc__));
 1164|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__)) calloc)(
 1165|       |    size_t __nmemb, size_t __size) __attribute__((__malloc__));
 1166|       |void *xmalloc(size_t n) __attribute__((__malloc__));
 1167|      2|void *xmalloc(size_t n) {
 1168|      2|  void *p;
 1169|      2|  void *tmp;
 1170|       |
 1171|      2|  {
 1172|      2|    tmp = malloc(n);
 1173|      2|    p = tmp;
 1174|      2|    if (!p) {
 1175|      0|      if (n != 0UL) {
 1176|      0|        xalloc_die();
 1177|      0|      }
 1178|      0|    }
 1179|      2|    return (p);
 1180|      2|  }
 1181|      2|}
 1182|      0|void *xrealloc(void *p, size_t n) {
 1183|       |
 1184|      0|  {
 1185|      0|    p = realloc(p, n);
 1186|      0|    if (!p) {
 1187|      0|      if (n != 0UL) {
 1188|      0|        xalloc_die();
 1189|      0|      }
 1190|      0|    }
 1191|      0|    return (p);
 1192|      0|  }
 1193|      0|}
 1194|       |void *xmemdup(void const *p, size_t s) __attribute__((__malloc__));
 1195|      2|void *xmemdup(void const *p, size_t s) {
 1196|      2|  void *tmp;
 1197|      2|  void *tmp___0;
 1198|       |
 1199|      2|  {
 1200|      2|    tmp = xmalloc(s);
 1201|      2|    tmp___0 = memcpy(tmp, p, s);
 1202|      2|    return (tmp___0);
 1203|      2|  }
 1204|      2|}
 1205|       |char *xstrdup(char const *string) __attribute__((__malloc__));
 1206|      2|char *xstrdup(char const *string) {
 1207|      2|  size_t tmp;
 1208|      2|  char *tmp___0;
 1209|       |
 1210|      2|  {
 1211|      2|    tmp = strlen(string);
 1212|      2|    tmp___0 = (char *)xmemdup((void const *)string, tmp + 1UL);
 1213|      2|    return (tmp___0);
 1214|      2|  }
 1215|      2|}
 1216|       |__attribute__((__nothrow__))
 1217|       |FTS *(__attribute__((__warn_unused_result__, __leaf__)) fts_open)(
 1218|       |    char *const *argv, int options,
 1219|       |    int (*compar)(FTSENT const **, FTSENT const **));
 1220|       |FTS *xfts_open(char *const *argv, int options,
 1221|       |               int (*compar)(FTSENT const **, FTSENT const **));
 1222|       |_Bool cycle_warning_required(FTS const *fts, FTSENT const *ent);
 1223|       |FTS *xfts_open(char *const *argv, int options,
 1224|      2|               int (*compar)(FTSENT const **, FTSENT const **)) {
 1225|      2|  FTS *fts;
 1226|      2|  FTS *tmp;
 1227|      2|  int *tmp___0;
 1228|       |
 1229|      2|  {
 1230|      2|    tmp = fts_open(argv, options | 512, compar);
 1231|      2|    fts = tmp;
 1232|      2|    if ((unsigned long)fts == (unsigned long)((void *)0)) {
 1233|      0|      tmp___0 = __errno_location();
 1234|      0|      if (!(*tmp___0 != 22)) {
 1235|      0|        __assert_fail("(*__errno_location ()) != 22",
 1236|      0|                      "/home/khheo/project/program-reduce/benchmark/"
 1237|      0|                      "coreutils-8.2/lib/xfts.c",
 1238|      0|                      41U, "xfts_open");
 1239|      0|      }
 1240|      0|      xalloc_die();
 1241|      0|    }
 1242|      2|    return (fts);
 1243|      2|  }
 1244|      2|}
 1245|      0|_Bool cycle_warning_required(FTS const *fts, FTSENT const *ent) {
 1246|      0|  int tmp;
 1247|       |
 1248|      0|  {
 1249|      0|    if (fts->fts_options & 16) {
 1250|      0|      if (!(fts->fts_options & 1)) {
 1251|      0|        tmp = 1;
 1252|      0|      } else {
 1253|      0|        goto _L;
 1254|      0|      }
 1255|      0|    } else {
 1256|      0|    _L:
 1257|      0|      if (fts->fts_options & 16) {
 1258|      0|        if (fts->fts_options & 1) {
 1259|      0|          if (ent->fts_level != 0L) {
 1260|      0|            tmp = 1;
 1261|      0|          } else {
 1262|      0|            tmp = 0;
 1263|      0|          }
 1264|      0|        } else {
 1265|      0|          tmp = 0;
 1266|      0|        }
 1267|      0|      } else {
 1268|      0|        tmp = 0;
 1269|      0|      }
 1270|      0|    }
 1271|      0|    return ((_Bool)tmp);
 1272|      0|  }
 1273|      0|}
 1274|       |__attribute__((__noreturn__)) void xalloc_die(void);
 1275|      0|void xalloc_die(void) {
 1276|      0|  char *tmp;
 1277|       |
 1278|      0|  {
 1279|      0|    tmp = gettext("memory exhausted");
 1280|      0|    error((int)exit_failure, 0, "%s", tmp);
 1281|      0|    abort();
 1282|      0|  }
 1283|      0|}
 1284|       |extern int printf(char const *__restrict __format, ...);
 1285|       |extern int fputs_unlocked(char const *__restrict __s,
 1286|       |                          FILE *__restrict __stream);
 1287|       |char const version_etc_copyright[47];
 1288|       |void version_etc_arn(FILE *stream, char const *command_name,
 1289|       |                     char const *package, char const *version,
 1290|       |                     char const *const *authors, size_t n_authors);
 1291|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 1292|       |                    char const *version, va_list authors);
 1293|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1294|       |                 char const *version, ...) __attribute__((__sentinel__));
 1295|       |void version_etc_arn(FILE *stream, char const *command_name,
 1296|       |                     char const *package, char const *version,
 1297|      0|                     char const *const *authors, size_t n_authors) {
 1298|      0|  char *tmp;
 1299|      0|  char *tmp___0;
 1300|      0|  char *tmp___1;
 1301|      0|  char *tmp___2;
 1302|      0|  char *tmp___3;
 1303|      0|  char *tmp___4;
 1304|      0|  char *tmp___5;
 1305|      0|  char *tmp___6;
 1306|      0|  char *tmp___7;
 1307|      0|  char *tmp___8;
 1308|      0|  char *tmp___9;
 1309|      0|  char *tmp___10;
 1310|       |
 1311|      0|  {
 1312|      0|    if (command_name) {
 1313|      0|      fprintf(stream, "%s (%s) %s\n", command_name, package, version);
 1314|      0|    } else {
 1315|      0|      fprintf(stream, "%s %s\n", package, version);
 1316|      0|    }
 1317|      0|    tmp = gettext("(C)");
 1318|      0|    fprintf(stream, version_etc_copyright, tmp, 2009);
 1319|      0|    tmp___0 =
 1320|      0|        gettext("\nLicense GPLv3+: GNU GPL version 3 or later "
 1321|      0|                "<http://gnu.org/licenses/gpl.html>.\nThis is free software: "
 1322|      0|                "you are free to change and redistribute it.\nThere is NO "
 1323|      0|                "WARRANTY, to the extent permitted by law.\n\n");
 1324|      0|    fputs_unlocked((char const *)tmp___0, stream);
 1325|      0|    if (n_authors == 0UL) {
 1326|      0|      goto case_0;
 1327|      0|    }
 1328|      0|    if (n_authors == 1UL) {
 1329|      0|      goto case_1;
 1330|      0|    }
 1331|      0|    if (n_authors == 2UL) {
 1332|      0|      goto case_2;
 1333|      0|    }
 1334|      0|    if (n_authors == 3UL) {
 1335|      0|      goto case_3;
 1336|      0|    }
 1337|      0|    if (n_authors == 4UL) {
 1338|      0|      goto case_4;
 1339|      0|    }
 1340|      0|    if (n_authors == 5UL) {
 1341|      0|      goto case_5;
 1342|      0|    }
 1343|      0|    if (n_authors == 6UL) {
 1344|      0|      goto case_6;
 1345|      0|    }
 1346|      0|    if (n_authors == 7UL) {
 1347|      0|      goto case_7;
 1348|      0|    }
 1349|      0|    if (n_authors == 8UL) {
 1350|      0|      goto case_8;
 1351|      0|    }
 1352|      0|    if (n_authors == 9UL) {
 1353|      0|      goto case_9;
 1354|      0|    }
 1355|      0|    goto switch_default;
 1356|      0|  case_0:
 1357|      0|    abort();
 1358|      0|  case_1:
 1359|      0|    tmp___1 = gettext("Written by %s.\n");
 1360|      0|    fprintf(stream, (char const *)tmp___1, *(authors + 0));
 1361|      0|    goto switch_break;
 1362|      0|  case_2:
 1363|      0|    tmp___2 = gettext("Written by %s and %s.\n");
 1364|      0|    fprintf(stream, (char const *)tmp___2, *(authors + 0), *(authors + 1));
 1365|      0|    goto switch_break;
 1366|      0|  case_3:
 1367|      0|    tmp___3 = gettext("Written by %s, %s, and %s.\n");
 1368|      0|    fprintf(stream, (char const *)tmp___3, *(authors + 0), *(authors + 1),
 1369|      0|            *(authors + 2));
 1370|      0|    goto switch_break;
 1371|      0|  case_4:
 1372|      0|    tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
 1373|      0|    fprintf(stream, (char const *)tmp___4, *(authors + 0), *(authors + 1),
 1374|      0|            *(authors + 2), *(authors + 3));
 1375|      0|    goto switch_break;
 1376|      0|  case_5:
 1377|      0|    tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
 1378|      0|    fprintf(stream, (char const *)tmp___5, *(authors + 0), *(authors + 1),
 1379|      0|            *(authors + 2), *(authors + 3), *(authors + 4));
 1380|      0|    goto switch_break;
 1381|      0|  case_6:
 1382|      0|    tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
 1383|      0|    fprintf(stream, (char const *)tmp___6, *(authors + 0), *(authors + 1),
 1384|      0|            *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5));
 1385|      0|    goto switch_break;
 1386|      0|  case_7:
 1387|      0|    tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
 1388|      0|    fprintf(stream, (char const *)tmp___7, *(authors + 0), *(authors + 1),
 1389|      0|            *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1390|      0|            *(authors + 6));
 1391|      0|    goto switch_break;
 1392|      0|  case_8:
 1393|      0|    tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
 1394|      0|    fprintf(stream, (char const *)tmp___8, *(authors + 0), *(authors + 1),
 1395|      0|            *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1396|      0|            *(authors + 6), *(authors + 7));
 1397|      0|    goto switch_break;
 1398|      0|  case_9:
 1399|      0|    tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
 1400|      0|    fprintf(stream, (char const *)tmp___9, *(authors + 0), *(authors + 1),
 1401|      0|            *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1402|      0|            *(authors + 6), *(authors + 7), *(authors + 8));
 1403|      0|    goto switch_break;
 1404|      0|  switch_default:
 1405|      0|    tmp___10 = gettext(
 1406|      0|        "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
 1407|      0|    fprintf(stream, (char const *)tmp___10, *(authors + 0), *(authors + 1),
 1408|      0|            *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1409|      0|            *(authors + 6), *(authors + 7), *(authors + 8));
 1410|      0|    goto switch_break;
 1411|      0|  switch_break:;
 1412|      0|    return;
 1413|      0|  }
 1414|      0|}
 1415|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 1416|      0|                    char const *version, va_list authors) {
 1417|      0|  size_t n_authors;
 1418|      0|  char const *authtab[10];
 1419|      0|  char const *tmp;
 1420|       |
 1421|      0|  {
 1422|      0|    n_authors = (size_t)0;
 1423|      0|    while (1) {
 1424|       |
 1425|      0|      if (n_authors < 10UL) {
 1426|      0|        tmp = __builtin_va_arg(authors, char const *);
 1427|      0|        authtab[n_authors] = tmp;
 1428|      0|        if (!((unsigned long)tmp != (unsigned long)((void *)0))) {
 1429|      0|          goto while_break;
 1430|      0|        }
 1431|      0|      } else {
 1432|      0|        goto while_break;
 1433|      0|      }
 1434|      0|      n_authors++;
 1435|      0|    }
 1436|      0|  while_break:
 1437|      0|    version_etc_arn(stream, command_name, package, version,
 1438|      0|                    (char const *const *)(authtab), n_authors);
 1439|      0|    return;
 1440|      0|  }
 1441|      0|}
 1442|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1443|       |                 char const *version, ...) __attribute__((__sentinel__));
 1444|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1445|      0|                 char const *version, ...) {
 1446|      0|  va_list authors;
 1447|       |
 1448|      0|  {
 1449|      0|    __builtin_va_start(authors, version);
 1450|      0|    version_etc_va(stream, command_name, package, version, authors);
 1451|      0|    __builtin_va_end(authors);
 1452|      0|    return;
 1453|      0|  }
 1454|      0|}
 1455|       |char const version_etc_copyright[47] = {
 1456|       |    (char const)'C', (char const)'o', (char const)'p',   (char const)'y',
 1457|       |    (char const)'r', (char const)'i', (char const)'g',   (char const)'h',
 1458|       |    (char const)'t', (char const)' ', (char const)'%',   (char const)'s',
 1459|       |    (char const)' ', (char const)'%', (char const)'d',   (char const)' ',
 1460|       |    (char const)'F', (char const)'r', (char const)'e',   (char const)'e',
 1461|       |    (char const)' ', (char const)'S', (char const)'o',   (char const)'f',
 1462|       |    (char const)'t', (char const)'w', (char const)'a',   (char const)'r',
 1463|       |    (char const)'e', (char const)' ', (char const)'F',   (char const)'o',
 1464|       |    (char const)'u', (char const)'n', (char const)'d',   (char const)'a',
 1465|       |    (char const)'t', (char const)'i', (char const)'o',   (char const)'n',
 1466|       |    (char const)',', (char const)' ', (char const)'I',   (char const)'n',
 1467|       |    (char const)'c', (char const)'.', (char const)'\000'};
 1468|       |char const *parse_user_spec(char const *spec, uid_t *uid, gid_t *gid,
 1469|       |                            char **username, char **groupname);
 1470|       |extern void endpwent(void);
 1471|       |extern struct passwd *getpwnam(char const *__name);
 1472|       |extern void endgrent(void);
 1473|       |extern struct group *getgrgid(__gid_t __gid);
 1474|       |extern struct group *getgrnam(char const *__name);
 1475|       |char *(__attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i,
 1476|       |                                                          char *buf___1);
 1477|       |static char const *parse_with_separator(char const *spec, char const *separator,
 1478|       |                                        uid_t *uid, gid_t *gid, char **username,
 1479|       |                                        char **groupname);
 1480|       |static char const *E_invalid_user = "invalid user";
 1481|       |static char const *E_invalid_group = "invalid group";
 1482|       |static char const *E_bad_spec = "invalid spec";
 1483|       |static char const *parse_with_separator(char const *spec, char const *separator,
 1484|       |                                        uid_t *uid, gid_t *gid, char **username,
 1485|      2|                                        char **groupname) {
 1486|      2|  char const *error_msg;
 1487|      2|  struct passwd *pwd;
 1488|      2|  struct group *grp;
 1489|      2|  char *u;
 1490|      2|  char const *g;
 1491|      2|  char *gname;
 1492|      2|  uid_t unum;
 1493|      2|  gid_t gnum;
 1494|      2|  char *tmp;
 1495|      2|  size_t ulen;
 1496|      2|  struct passwd *tmp___0;
 1497|      2|  _Bool use_login_group;
 1498|      2|  int tmp___1;
 1499|      2|  unsigned long tmp___2;
 1500|      2|  strtol_error tmp___3;
 1501|      2|  char buf___1[(((sizeof(uintmax_t) * 8UL) * 146UL) / 485UL + 1UL) + 1UL];
 1502|      2|  char *tmp___4;
 1503|      2|  char *tmp___5;
 1504|      2|  struct group *tmp___6;
 1505|      2|  unsigned long tmp___7;
 1506|      2|  strtol_error tmp___8;
 1507|      2|  char const *tmp___9;
 1508|       |
 1509|      2|  {
 1510|      2|    gname = (char *)((void *)0);
 1511|      2|    unum = *uid;
 1512|      2|    gnum = *gid;
 1513|      2|    error_msg = (char const *)((void *)0);
 1514|      2|    tmp = (char *)((void *)0);
 1515|      2|    *groupname = tmp;
 1516|      2|    *username = tmp;
 1517|      2|    u = (char *)((void *)0);
 1518|      2|    if ((unsigned long)separator == (unsigned long)((void *)0)) {
 1519|      1|      if (*spec) {
 1520|      1|        u = xstrdup(spec);
 1521|      1|      }
 1522|      1|    } else {
 1523|      1|      ulen = (size_t)(separator - spec);
 1524|      1|      if (ulen != 0UL) {
 1525|      0|        u = (char *)xmemdup((void const *)spec, ulen + 1UL);
 1526|      0|        *(u + ulen) = (char)'\000';
 1527|      0|      }
 1528|      1|    }
 1529|      2|    if ((unsigned long)separator == (unsigned long)((void *)0)) {
 1530|      1|      g = (char const *)((void *)0);
 1531|      1|    } else {
 1532|      1|      if ((int const) * (separator + 1) == 0) {
 1533|      0|        g = (char const *)((void *)0);
 1534|      1|      } else {
 1535|      1|        g = separator + 1;
 1536|      1|      }
 1537|      1|    }
 1538|      2|    if ((unsigned long)u != (unsigned long)((void *)0)) {
 1539|      1|      if ((int)*u == 43) {
 1540|      0|        pwd = (struct passwd *)((void *)0);
 1541|      1|      } else {
 1542|      1|        tmp___0 = getpwnam((char const *)u);
 1543|      1|        pwd = tmp___0;
 1544|      1|      }
 1545|      1|      if ((unsigned long)pwd == (unsigned long)((void *)0)) {
 1546|      0|        if ((unsigned long)separator != (unsigned long)((void *)0)) {
 1547|      0|          if ((unsigned long)g == (unsigned long)((void *)0)) {
 1548|      0|            tmp___1 = 1;
 1549|      0|          } else {
 1550|      0|            tmp___1 = 0;
 1551|      0|          }
 1552|      0|        } else {
 1553|      0|          tmp___1 = 0;
 1554|      0|        }
 1555|      0|        use_login_group = (_Bool)tmp___1;
 1556|      0|        if (use_login_group) {
 1557|      0|          error_msg = E_bad_spec;
 1558|      0|        } else {
 1559|      0|          tmp___3 =
 1560|      0|              xstrtoul((char const *)u, (char **)((void *)0), 10, &tmp___2, "");
 1561|      0|          if ((unsigned int)tmp___3 == 0U) {
 1562|      0|            if (tmp___2 <= 4294967295UL) {
 1563|      0|              if ((uid_t)tmp___2 != 4294967295U) {
 1564|      0|                unum = (uid_t)tmp___2;
 1565|      0|              } else {
 1566|      0|                error_msg = E_invalid_user;
 1567|      0|              }
 1568|      0|            } else {
 1569|      0|              error_msg = E_invalid_user;
 1570|      0|            }
 1571|      0|          } else {
 1572|      0|            error_msg = E_invalid_user;
 1573|      0|          }
 1574|      0|        }
 1575|      1|      } else {
 1576|      1|        unum = pwd->pw_uid;
 1577|      1|        if ((unsigned long)g == (unsigned long)((void *)0)) {
 1578|      1|          if ((unsigned long)separator != (unsigned long)((void *)0)) {
 1579|      0|            gnum = pwd->pw_gid;
 1580|      0|            grp = getgrgid(gnum);
 1581|      0|            if (grp) {
 1582|      0|              tmp___5 = grp->gr_name;
 1583|      0|            } else {
 1584|      0|              tmp___4 = umaxtostr((uintmax_t)gnum, buf___1);
 1585|      0|              tmp___5 = tmp___4;
 1586|      0|            }
 1587|      0|            gname = xstrdup((char const *)tmp___5);
 1588|      0|            endgrent();
 1589|      0|          }
 1590|      1|        }
 1591|      1|      }
 1592|      1|      endpwent();
 1593|      1|    }
 1594|      2|    if ((unsigned long)g != (unsigned long)((void *)0)) {
 1595|      1|      if ((unsigned long)error_msg == (unsigned long)((void *)0)) {
 1596|      1|        if ((int const) * g == 43) {
 1597|      0|          grp = (struct group *)((void *)0);
 1598|      1|        } else {
 1599|      1|          tmp___6 = getgrnam(g);
 1600|      1|          grp = tmp___6;
 1601|      1|        }
 1602|      1|        if ((unsigned long)grp == (unsigned long)((void *)0)) {
 1603|      0|          tmp___8 = xstrtoul(g, (char **)((void *)0), 10, &tmp___7, "");
 1604|      0|          if ((unsigned int)tmp___8 == 0U) {
 1605|      0|            if (tmp___7 <= 4294967295UL) {
 1606|      0|              if ((gid_t)tmp___7 != 4294967295U) {
 1607|      0|                gnum = (gid_t)tmp___7;
 1608|      0|              } else {
 1609|      0|                error_msg = E_invalid_group;
 1610|      0|              }
 1611|      0|            } else {
 1612|      0|              error_msg = E_invalid_group;
 1613|      0|            }
 1614|      0|          } else {
 1615|      0|            error_msg = E_invalid_group;
 1616|      0|          }
 1617|      1|        } else {
 1618|      1|          gnum = grp->gr_gid;
 1619|      1|        }
 1620|      1|        endgrent();
 1621|      1|        gname = xstrdup(g);
 1622|      1|      }
 1623|      1|    }
 1624|      2|    if ((unsigned long)error_msg == (unsigned long)((void *)0)) {
 1625|      2|      *uid = unum;
 1626|      2|      *gid = gnum;
 1627|      2|      *username = u;
 1628|      2|      *groupname = gname;
 1629|      2|      u = (char *)((void *)0);
 1630|      2|    } else {
 1631|      0|      free((void *)gname);
 1632|      0|    }
 1633|      2|    free((void *)u);
 1634|      2|    tmp___9 = (char const *)gettext(error_msg);
 1635|      2|    return (tmp___9);
 1636|      2|  }
 1637|      2|}
 1638|       |char const *parse_user_spec(char const *spec, uid_t *uid, gid_t *gid,
 1639|      2|                            char **username, char **groupname) {
 1640|      2|  char const *colon;
 1641|      2|  char const *tmp;
 1642|      2|  char const *error_msg;
 1643|      2|  char const *tmp___0;
 1644|      2|  char const *dot;
 1645|      2|  char const *tmp___1;
 1646|      2|  char const *tmp___2;
 1647|       |
 1648|      2|  {
 1649|      2|    tmp = (char const *)strchr(spec, ':');
 1650|      2|    colon = tmp;
 1651|      2|    tmp___0 = parse_with_separator(spec, colon, uid, gid, username, groupname);
 1652|      2|    error_msg = tmp___0;
 1653|      2|    if (!colon) {
 1654|      1|      if (error_msg) {
 1655|      0|        tmp___1 = (char const *)strchr(spec, '.');
 1656|      0|        dot = tmp___1;
 1657|      0|        if (dot) {
 1658|      0|          tmp___2 =
 1659|      0|              parse_with_separator(spec, dot, uid, gid, username, groupname);
 1660|      0|          if (!tmp___2) {
 1661|      0|            error_msg = (char const *)((void *)0);
 1662|      0|          }
 1663|      0|        }
 1664|      0|      }
 1665|      1|    }
 1666|      2|    return (error_msg);
 1667|      2|  }
 1668|      2|}
 1669|       |char *(__attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i,
 1670|      0|                                                          char *buf___1) {
 1671|      0|  char *p;
 1672|       |
 1673|      0|  {
 1674|      0|    p = buf___1 + (((sizeof(uintmax_t) * 8UL) * 146UL) / 485UL + 1UL);
 1675|      0|    *p = (char)0;
 1676|      0|    while (1) {
 1677|      0|      p--;
 1678|      0|      *p = (char)(48UL + i % 10UL);
 1679|      0|      i /= 10UL;
 1680|      0|      if (!(i != 0UL)) {
 1681|      0|        goto while_break;
 1682|      0|      }
 1683|      0|    }
 1684|      0|  while_break:;
 1685|      0|    return (p);
 1686|      0|  }
 1687|      0|}
 1688|       |#pragma weak pthread_key_create
 1689|       |#pragma weak pthread_getspecific
 1690|       |#pragma weak pthread_setspecific
 1691|       |#pragma weak pthread_key_delete
 1692|       |#pragma weak pthread_self
 1693|       |#pragma weak pthread_cancel
 1694|      0|size_t strnlen1(char const *string, size_t maxlen) {
 1695|      0|  char const *end;
 1696|      0|  char const *tmp;
 1697|       |
 1698|      0|  {
 1699|      0|    tmp = (char const *)memchr((void const *)string, '\000', maxlen);
 1700|      0|    end = tmp;
 1701|      0|    if ((unsigned long)end != (unsigned long)((void *)0)) {
 1702|      0|      return ((size_t)((end - string) + 1L));
 1703|      0|    } else {
 1704|      0|      return (maxlen);
 1705|      0|    }
 1706|      0|  }
 1707|      0|}
 1708|       |int open_safer(char const *file, int flags, ...);
 1709|       |struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i);
 1710|      0|struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i) {
 1711|      0|  struct stat statbuf;
 1712|      0|  int tmp;
 1713|       |
 1714|      0|  {
 1715|      0|    tmp = lstat("/", &statbuf);
 1716|      0|    if (tmp) {
 1717|      0|      return ((struct dev_ino *)((void *)0));
 1718|      0|    }
 1719|      0|    root_d_i->st_ino = statbuf.st_ino;
 1720|      0|    root_d_i->st_dev = statbuf.st_dev;
 1721|      0|    return (root_d_i);
 1722|      0|  }
 1723|      0|}
 1724|       |reg_syntax_t rpl_re_syntax_options;
 1725|       |char const *const quoting_style_args[9];
 1726|       |enum quoting_style const quoting_style_vals[8];
 1727|       |int set_char_quoting(struct quoting_options *o, char c, int i);
 1728|       |char *quotearg_char(char const *arg, char ch);
 1729|       |char *quotearg_char_mem(char const *arg, size_t argsize, char ch);
 1730|       |__inline static char *xcharalloc(size_t n) __attribute__((__malloc__));
 1731|       |__inline static char *xcharalloc(size_t n) __attribute__((__malloc__));
 1732|      0|__inline static char *xcharalloc(size_t n) {
 1733|      0|  void *tmp;
 1734|      0|  void *tmp___0;
 1735|      0|  void *tmp___1;
 1736|       |
 1737|      0|  {
 1738|      0|    if (sizeof(char) == 1UL) {
 1739|      0|      tmp = xmalloc(n);
 1740|      0|      tmp___1 = tmp;
 1741|      0|    } else {
 1742|      0|      tmp___0 = xnmalloc(n, sizeof(char));
 1743|      0|      tmp___1 = tmp___0;
 1744|      0|    }
 1745|      0|    return ((char *)tmp___1);
 1746|      0|  }
 1747|      0|}
 1748|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) iswprint)(
 1749|       |    wint_t __wc);
 1750|       |char const *const quoting_style_args[9] = {
 1751|       |    "literal", "shell",   "shell-always", "c", "c-maybe", "escape",
 1752|       |    "locale",  "clocale", (char const *)0};
 1753|       |enum quoting_style const quoting_style_vals[8] = {
 1754|       |    (enum quoting_style const)0, (enum quoting_style const)1,
 1755|       |    (enum quoting_style const)2, (enum quoting_style const)3,
 1756|       |    (enum quoting_style const)4, (enum quoting_style const)5,
 1757|       |    (enum quoting_style const)6, (enum quoting_style const)7};
 1758|       |static struct quoting_options default_quoting_options;
 1759|      0|int set_char_quoting(struct quoting_options *o, char c, int i) {
 1760|      0|  unsigned char uc;
 1761|      0|  unsigned int *p;
 1762|      0|  struct quoting_options *tmp;
 1763|      0|  int shift;
 1764|      0|  int r;
 1765|       |
 1766|      0|  {
 1767|      0|    uc = (unsigned char)c;
 1768|      0|    if (o) {
 1769|      0|      tmp = o;
 1770|      0|    } else {
 1771|      0|      tmp = &default_quoting_options;
 1772|      0|    }
 1773|      0|    p = tmp->quote_these_too + (unsigned long)uc / (sizeof(int) * 8UL);
 1774|      0|    shift = (int)((unsigned long)uc % (sizeof(int) * 8UL));
 1775|      0|    r = (int)((*p >> shift) & 1U);
 1776|      0|    *p ^= (unsigned int)(((i & 1) ^ r) << shift);
 1777|      0|    return (r);
 1778|      0|  }
 1779|      0|}
 1780|       |static struct quoting_options
 1781|      0|quoting_options_from_style(enum quoting_style style) {
 1782|      0|  struct quoting_options o;
 1783|       |
 1784|      0|  {
 1785|      0|    o.style = style;
 1786|      0|    o.flags = 0;
 1787|      0|    memset((void *)(o.quote_these_too), 0, sizeof(o.quote_these_too));
 1788|      0|    return (o);
 1789|      0|  }
 1790|      0|}
 1791|      0|static char const *gettext_quote(char const *msgid, enum quoting_style s) {
 1792|      0|  char const *translation;
 1793|      0|  char const *tmp;
 1794|       |
 1795|      0|  {
 1796|      0|    tmp = (char const *)gettext(msgid);
 1797|      0|    translation = tmp;
 1798|      0|    if ((unsigned long)translation == (unsigned long)msgid) {
 1799|      0|      if ((unsigned int)s == 7U) {
 1800|      0|        translation = "\"";
 1801|      0|      }
 1802|      0|    }
 1803|      0|    return (translation);
 1804|      0|  }
 1805|      0|}
 1806|       |static size_t
 1807|       |quotearg_buffer_restyled(char *buffer, size_t buffersize, char const *arg,
 1808|       |                         size_t argsize, enum quoting_style quoting_style,
 1809|       |                         int flags, unsigned int const *quote_these_too,
 1810|      0|                         char const *left_quote, char const *right_quote) {
 1811|      0|  size_t i;
 1812|      0|  size_t len;
 1813|      0|  char const *quote_string;
 1814|      0|  size_t quote_string_len;
 1815|      0|  _Bool backslash_escapes;
 1816|      0|  _Bool unibyte_locale;
 1817|      0|  size_t tmp;
 1818|      0|  _Bool elide_outer_quotes;
 1819|      0|  unsigned char c;
 1820|      0|  unsigned char esc;
 1821|      0|  _Bool is_right_quote;
 1822|      0|  int tmp___0;
 1823|      0|  int tmp___1;
 1824|      0|  size_t m;
 1825|      0|  _Bool printable;
 1826|      0|  unsigned short const **tmp___2;
 1827|      0|  mbstate_t mbstate;
 1828|      0|  wchar_t w;
 1829|      0|  size_t bytes;
 1830|      0|  size_t tmp___3;
 1831|      0|  size_t j;
 1832|      0|  int tmp___4;
 1833|      0|  int tmp___5;
 1834|      0|  size_t ilim;
 1835|      0|  int tmp___6;
 1836|      0|  size_t tmp___7;
 1837|       |
 1838|      0|  {
 1839|      0|    len = (size_t)0;
 1840|      0|    quote_string = (char const *)0;
 1841|      0|    quote_string_len = (size_t)0;
 1842|      0|    backslash_escapes = (_Bool)0;
 1843|      0|    tmp = __ctype_get_mb_cur_max();
 1844|      0|    unibyte_locale = (_Bool)(tmp == 1UL);
 1845|      0|    elide_outer_quotes = (_Bool)((flags & 2) != 0);
 1846|      0|    if ((unsigned int)quoting_style == 4U) {
 1847|      0|      goto case_4;
 1848|      0|    }
 1849|      0|    if ((unsigned int)quoting_style == 3U) {
 1850|      0|      goto case_3;
 1851|      0|    }
 1852|      0|    if ((unsigned int)quoting_style == 5U) {
 1853|      0|      goto case_5;
 1854|      0|    }
 1855|      0|    if ((unsigned int)quoting_style == 6U) {
 1856|      0|      goto case_6;
 1857|      0|    }
 1858|      0|    if ((unsigned int)quoting_style == 7U) {
 1859|      0|      goto case_6;
 1860|      0|    }
 1861|      0|    if ((unsigned int)quoting_style == 8U) {
 1862|      0|      goto case_6;
 1863|      0|    }
 1864|      0|    if ((unsigned int)quoting_style == 1U) {
 1865|      0|      goto case_1;
 1866|      0|    }
 1867|      0|    if ((unsigned int)quoting_style == 2U) {
 1868|      0|      goto case_2;
 1869|      0|    }
 1870|      0|    if ((unsigned int)quoting_style == 0U) {
 1871|      0|      goto case_0;
 1872|      0|    }
 1873|      0|    goto switch_default;
 1874|      0|  case_4:
 1875|      0|    quoting_style = (enum quoting_style)3;
 1876|      0|    elide_outer_quotes = (_Bool)1;
 1877|      0|  case_3:
 1878|      0|    if (!elide_outer_quotes) {
 1879|      0|      while (1) {
 1880|       |
 1881|      0|        if (len < buffersize) {
 1882|      0|          *(buffer + len) = (char)'\"';
 1883|      0|        }
 1884|      0|        len++;
 1885|      0|        goto while_break;
 1886|      0|      }
 1887|      0|    while_break:;
 1888|      0|    }
 1889|      0|    backslash_escapes = (_Bool)1;
 1890|      0|    quote_string = "\"";
 1891|      0|    quote_string_len = (size_t)1;
 1892|      0|    goto switch_break;
 1893|      0|  case_5:
 1894|      0|    backslash_escapes = (_Bool)1;
 1895|      0|    elide_outer_quotes = (_Bool)0;
 1896|      0|    goto switch_break;
 1897|      0|  case_6:
 1898|      0|    if ((unsigned int)quoting_style != 8U) {
 1899|      0|      left_quote = gettext_quote("`", quoting_style);
 1900|      0|      right_quote = gettext_quote("\'", quoting_style);
 1901|      0|    }
 1902|      0|    if (!elide_outer_quotes) {
 1903|      0|      quote_string = left_quote;
 1904|      0|      while (1) {
 1905|       |
 1906|      0|        if (!*quote_string) {
 1907|      0|          goto while_break___0;
 1908|      0|        }
 1909|      0|        while (1) {
 1910|       |
 1911|      0|          if (len < buffersize) {
 1912|      0|            *(buffer + len) = (char)*quote_string;
 1913|      0|          }
 1914|      0|          len++;
 1915|      0|          goto while_break___1;
 1916|      0|        }
 1917|      0|      while_break___1:
 1918|      0|        quote_string++;
 1919|      0|      }
 1920|      0|    while_break___0:;
 1921|      0|    }
 1922|      0|    backslash_escapes = (_Bool)1;
 1923|      0|    quote_string = right_quote;
 1924|      0|    quote_string_len = strlen(quote_string);
 1925|      0|    goto switch_break;
 1926|      0|  case_1:
 1927|      0|    quoting_style = (enum quoting_style)2;
 1928|      0|    elide_outer_quotes = (_Bool)1;
 1929|      0|  case_2:
 1930|      0|    if (!elide_outer_quotes) {
 1931|      0|      while (1) {
 1932|       |
 1933|      0|        if (len < buffersize) {
 1934|      0|          *(buffer + len) = (char)'\'';
 1935|      0|        }
 1936|      0|        len++;
 1937|      0|        goto while_break___2;
 1938|      0|      }
 1939|      0|    while_break___2:;
 1940|      0|    }
 1941|      0|    quote_string = "\'";
 1942|      0|    quote_string_len = (size_t)1;
 1943|      0|    goto switch_break;
 1944|      0|  case_0:
 1945|      0|    elide_outer_quotes = (_Bool)0;
 1946|      0|    goto switch_break;
 1947|      0|  switch_default:
 1948|      0|    abort();
 1949|      0|  switch_break:
 1950|      0|    i = (size_t)0;
 1951|      0|    while (1) {
 1952|       |
 1953|      0|      if (argsize == 0xffffffffffffffffUL) {
 1954|      0|        tmp___6 = (int const) * (arg + i) == 0;
 1955|      0|      } else {
 1956|      0|        tmp___6 = i == argsize;
 1957|      0|      }
 1958|      0|      if (tmp___6) {
 1959|      0|        goto while_break___3;
 1960|      0|      }
 1961|      0|      is_right_quote = (_Bool)0;
 1962|      0|      if (backslash_escapes) {
 1963|      0|        if (quote_string_len) {
 1964|      0|          if (i + quote_string_len <= argsize) {
 1965|      0|            tmp___0 = memcmp((void const *)(arg + i),
 1966|      0|                             (void const *)quote_string, quote_string_len);
 1967|      0|            if (tmp___0 == 0) {
 1968|      0|              if (elide_outer_quotes) {
 1969|      0|                goto force_outer_quoting_style;
 1970|      0|              }
 1971|      0|              is_right_quote = (_Bool)1;
 1972|      0|            }
 1973|      0|          }
 1974|      0|        }
 1975|      0|      }
 1976|      0|      c = (unsigned char)*(arg + i);
 1977|      0|      if ((int)c == 0) {
 1978|      0|        goto case_0___0;
 1979|      0|      }
 1980|      0|      if ((int)c == 63) {
 1981|      0|        goto case_63;
 1982|      0|      }
 1983|      0|      if ((int)c == 7) {
 1984|      0|        goto case_7___0;
 1985|      0|      }
 1986|      0|      if ((int)c == 8) {
 1987|      0|        goto case_8___0;
 1988|      0|      }
 1989|      0|      if ((int)c == 12) {
 1990|      0|        goto case_12;
 1991|      0|      }
 1992|      0|      if ((int)c == 10) {
 1993|      0|        goto case_10;
 1994|      0|      }
 1995|      0|      if ((int)c == 13) {
 1996|      0|        goto case_13;
 1997|      0|      }
 1998|      0|      if ((int)c == 9) {
 1999|      0|        goto case_9;
 2000|      0|      }
 2001|      0|      if ((int)c == 11) {
 2002|      0|        goto case_11;
 2003|      0|      }
 2004|      0|      if ((int)c == 92) {
 2005|      0|        goto case_92;
 2006|      0|      }
 2007|      0|      if ((int)c == 123) {
 2008|      0|        goto case_123;
 2009|      0|      }
 2010|      0|      if ((int)c == 125) {
 2011|      0|        goto case_123;
 2012|      0|      }
 2013|      0|      if ((int)c == 35) {
 2014|      0|        goto case_35;
 2015|      0|      }
 2016|      0|      if ((int)c == 126) {
 2017|      0|        goto case_35;
 2018|      0|      }
 2019|      0|      if ((int)c == 32) {
 2020|      0|        goto case_32;
 2021|      0|      }
 2022|      0|      if ((int)c == 33) {
 2023|      0|        goto case_32;
 2024|      0|      }
 2025|      0|      if ((int)c == 34) {
 2026|      0|        goto case_32;
 2027|      0|      }
 2028|      0|      if ((int)c == 36) {
 2029|      0|        goto case_32;
 2030|      0|      }
 2031|      0|      if ((int)c == 38) {
 2032|      0|        goto case_32;
 2033|      0|      }
 2034|      0|      if ((int)c == 40) {
 2035|      0|        goto case_32;
 2036|      0|      }
 2037|      0|      if ((int)c == 41) {
 2038|      0|        goto case_32;
 2039|      0|      }
 2040|      0|      if ((int)c == 42) {
 2041|      0|        goto case_32;
 2042|      0|      }
 2043|      0|      if ((int)c == 59) {
 2044|      0|        goto case_32;
 2045|      0|      }
 2046|      0|      if ((int)c == 60) {
 2047|      0|        goto case_32;
 2048|      0|      }
 2049|      0|      if ((int)c == 61) {
 2050|      0|        goto case_32;
 2051|      0|      }
 2052|      0|      if ((int)c == 62) {
 2053|      0|        goto case_32;
 2054|      0|      }
 2055|      0|      if ((int)c == 91) {
 2056|      0|        goto case_32;
 2057|      0|      }
 2058|      0|      if ((int)c == 94) {
 2059|      0|        goto case_32;
 2060|      0|      }
 2061|      0|      if ((int)c == 96) {
 2062|      0|        goto case_32;
 2063|      0|      }
 2064|      0|      if ((int)c == 124) {
 2065|      0|        goto case_32;
 2066|      0|      }
 2067|      0|      if ((int)c == 39) {
 2068|      0|        goto case_39___0;
 2069|      0|      }
 2070|      0|      if ((int)c == 37) {
 2071|      0|        goto case_37;
 2072|      0|      }
 2073|      0|      if ((int)c == 43) {
 2074|      0|        goto case_37;
 2075|      0|      }
 2076|      0|      if ((int)c == 44) {
 2077|      0|        goto case_37;
 2078|      0|      }
 2079|      0|      if ((int)c == 45) {
 2080|      0|        goto case_37;
 2081|      0|      }
 2082|      0|      if ((int)c == 46) {
 2083|      0|        goto case_37;
 2084|      0|      }
 2085|      0|      if ((int)c == 47) {
 2086|      0|        goto case_37;
 2087|      0|      }
 2088|      0|      if ((int)c == 48) {
 2089|      0|        goto case_37;
 2090|      0|      }
 2091|      0|      if ((int)c == 49) {
 2092|      0|        goto case_37;
 2093|      0|      }
 2094|      0|      if ((int)c == 50) {
 2095|      0|        goto case_37;
 2096|      0|      }
 2097|      0|      if ((int)c == 51) {
 2098|      0|        goto case_37;
 2099|      0|      }
 2100|      0|      if ((int)c == 52) {
 2101|      0|        goto case_37;
 2102|      0|      }
 2103|      0|      if ((int)c == 53) {
 2104|      0|        goto case_37;
 2105|      0|      }
 2106|      0|      if ((int)c == 54) {
 2107|      0|        goto case_37;
 2108|      0|      }
 2109|      0|      if ((int)c == 55) {
 2110|      0|        goto case_37;
 2111|      0|      }
 2112|      0|      if ((int)c == 56) {
 2113|      0|        goto case_37;
 2114|      0|      }
 2115|      0|      if ((int)c == 57) {
 2116|      0|        goto case_37;
 2117|      0|      }
 2118|      0|      if ((int)c == 58) {
 2119|      0|        goto case_37;
 2120|      0|      }
 2121|      0|      if ((int)c == 65) {
 2122|      0|        goto case_37;
 2123|      0|      }
 2124|      0|      if ((int)c == 66) {
 2125|      0|        goto case_37;
 2126|      0|      }
 2127|      0|      if ((int)c == 67) {
 2128|      0|        goto case_37;
 2129|      0|      }
 2130|      0|      if ((int)c == 68) {
 2131|      0|        goto case_37;
 2132|      0|      }
 2133|      0|      if ((int)c == 69) {
 2134|      0|        goto case_37;
 2135|      0|      }
 2136|      0|      if ((int)c == 70) {
 2137|      0|        goto case_37;
 2138|      0|      }
 2139|      0|      if ((int)c == 71) {
 2140|      0|        goto case_37;
 2141|      0|      }
 2142|      0|      if ((int)c == 72) {
 2143|      0|        goto case_37;
 2144|      0|      }
 2145|      0|      if ((int)c == 73) {
 2146|      0|        goto case_37;
 2147|      0|      }
 2148|      0|      if ((int)c == 74) {
 2149|      0|        goto case_37;
 2150|      0|      }
 2151|      0|      if ((int)c == 75) {
 2152|      0|        goto case_37;
 2153|      0|      }
 2154|      0|      if ((int)c == 76) {
 2155|      0|        goto case_37;
 2156|      0|      }
 2157|      0|      if ((int)c == 77) {
 2158|      0|        goto case_37;
 2159|      0|      }
 2160|      0|      if ((int)c == 78) {
 2161|      0|        goto case_37;
 2162|      0|      }
 2163|      0|      if ((int)c == 79) {
 2164|      0|        goto case_37;
 2165|      0|      }
 2166|      0|      if ((int)c == 80) {
 2167|      0|        goto case_37;
 2168|      0|      }
 2169|      0|      if ((int)c == 81) {
 2170|      0|        goto case_37;
 2171|      0|      }
 2172|      0|      if ((int)c == 82) {
 2173|      0|        goto case_37;
 2174|      0|      }
 2175|      0|      if ((int)c == 83) {
 2176|      0|        goto case_37;
 2177|      0|      }
 2178|      0|      if ((int)c == 84) {
 2179|      0|        goto case_37;
 2180|      0|      }
 2181|      0|      if ((int)c == 85) {
 2182|      0|        goto case_37;
 2183|      0|      }
 2184|      0|      if ((int)c == 86) {
 2185|      0|        goto case_37;
 2186|      0|      }
 2187|      0|      if ((int)c == 87) {
 2188|      0|        goto case_37;
 2189|      0|      }
 2190|      0|      if ((int)c == 88) {
 2191|      0|        goto case_37;
 2192|      0|      }
 2193|      0|      if ((int)c == 89) {
 2194|      0|        goto case_37;
 2195|      0|      }
 2196|      0|      if ((int)c == 90) {
 2197|      0|        goto case_37;
 2198|      0|      }
 2199|      0|      if ((int)c == 93) {
 2200|      0|        goto case_37;
 2201|      0|      }
 2202|      0|      if ((int)c == 95) {
 2203|      0|        goto case_37;
 2204|      0|      }
 2205|      0|      if ((int)c == 97) {
 2206|      0|        goto case_37;
 2207|      0|      }
 2208|      0|      if ((int)c == 98) {
 2209|      0|        goto case_37;
 2210|      0|      }
 2211|      0|      if ((int)c == 99) {
 2212|      0|        goto case_37;
 2213|      0|      }
 2214|      0|      if ((int)c == 100) {
 2215|      0|        goto case_37;
 2216|      0|      }
 2217|      0|      if ((int)c == 101) {
 2218|      0|        goto case_37;
 2219|      0|      }
 2220|      0|      if ((int)c == 102) {
 2221|      0|        goto case_37;
 2222|      0|      }
 2223|      0|      if ((int)c == 103) {
 2224|      0|        goto case_37;
 2225|      0|      }
 2226|      0|      if ((int)c == 104) {
 2227|      0|        goto case_37;
 2228|      0|      }
 2229|      0|      if ((int)c == 105) {
 2230|      0|        goto case_37;
 2231|      0|      }
 2232|      0|      if ((int)c == 106) {
 2233|      0|        goto case_37;
 2234|      0|      }
 2235|      0|      if ((int)c == 107) {
 2236|      0|        goto case_37;
 2237|      0|      }
 2238|      0|      if ((int)c == 108) {
 2239|      0|        goto case_37;
 2240|      0|      }
 2241|      0|      if ((int)c == 109) {
 2242|      0|        goto case_37;
 2243|      0|      }
 2244|      0|      if ((int)c == 110) {
 2245|      0|        goto case_37;
 2246|      0|      }
 2247|      0|      if ((int)c == 111) {
 2248|      0|        goto case_37;
 2249|      0|      }
 2250|      0|      if ((int)c == 112) {
 2251|      0|        goto case_37;
 2252|      0|      }
 2253|      0|      if ((int)c == 113) {
 2254|      0|        goto case_37;
 2255|      0|      }
 2256|      0|      if ((int)c == 114) {
 2257|      0|        goto case_37;
 2258|      0|      }
 2259|      0|      if ((int)c == 115) {
 2260|      0|        goto case_37;
 2261|      0|      }
 2262|      0|      if ((int)c == 116) {
 2263|      0|        goto case_37;
 2264|      0|      }
 2265|      0|      if ((int)c == 117) {
 2266|      0|        goto case_37;
 2267|      0|      }
 2268|      0|      if ((int)c == 118) {
 2269|      0|        goto case_37;
 2270|      0|      }
 2271|      0|      if ((int)c == 119) {
 2272|      0|        goto case_37;
 2273|      0|      }
 2274|      0|      if ((int)c == 120) {
 2275|      0|        goto case_37;
 2276|      0|      }
 2277|      0|      if ((int)c == 121) {
 2278|      0|        goto case_37;
 2279|      0|      }
 2280|      0|      if ((int)c == 122) {
 2281|      0|        goto case_37;
 2282|      0|      }
 2283|      0|      goto switch_default___2;
 2284|      0|    case_0___0:
 2285|      0|      if (backslash_escapes) {
 2286|      0|        if (elide_outer_quotes) {
 2287|      0|          goto force_outer_quoting_style;
 2288|      0|        }
 2289|      0|        while (1) {
 2290|       |
 2291|      0|          if (len < buffersize) {
 2292|      0|            *(buffer + len) = (char)'\\';
 2293|      0|          }
 2294|      0|          len++;
 2295|      0|          goto while_break___4;
 2296|      0|        }
 2297|      0|      while_break___4:;
 2298|      0|        if (i + 1UL < argsize) {
 2299|      0|          if (48 <= (int)*(arg + (i + 1UL))) {
 2300|      0|            if ((int const) * (arg + (i + 1UL)) <= 57) {
 2301|      0|              while (1) {
 2302|       |
 2303|      0|                if (len < buffersize) {
 2304|      0|                  *(buffer + len) = (char)'0';
 2305|      0|                }
 2306|      0|                len++;
 2307|      0|                goto while_break___5;
 2308|      0|              }
 2309|      0|            while_break___5:;
 2310|      0|              while (1) {
 2311|       |
 2312|      0|                if (len < buffersize) {
 2313|      0|                  *(buffer + len) = (char)'0';
 2314|      0|                }
 2315|      0|                len++;
 2316|      0|                goto while_break___6;
 2317|      0|              }
 2318|      0|            while_break___6:;
 2319|      0|            }
 2320|      0|          }
 2321|      0|        }
 2322|      0|        c = (unsigned char)'0';
 2323|      0|      } else {
 2324|      0|        if (flags & 1) {
 2325|      0|          goto __Cont;
 2326|      0|        }
 2327|      0|      }
 2328|      0|      goto switch_break___0;
 2329|      0|    case_63:
 2330|      0|      if ((unsigned int)quoting_style == 2U) {
 2331|      0|        goto case_2___0;
 2332|      0|      }
 2333|      0|      if ((unsigned int)quoting_style == 3U) {
 2334|      0|        goto case_3___0;
 2335|      0|      }
 2336|      0|      goto switch_default___1;
 2337|      0|    case_2___0:
 2338|      0|      if (elide_outer_quotes) {
 2339|      0|        goto force_outer_quoting_style;
 2340|      0|      }
 2341|      0|      goto switch_break___1;
 2342|      0|    case_3___0:
 2343|      0|      if (flags & 4) {
 2344|      0|        if (i + 2UL < argsize) {
 2345|      0|          if ((int const) * (arg + (i + 1UL)) == 63) {
 2346|      0|            if ((int const) * (arg + (i + 2UL)) == 33) {
 2347|      0|              goto case_33;
 2348|      0|            }
 2349|      0|            if ((int const) * (arg + (i + 2UL)) == 39) {
 2350|      0|              goto case_33;
 2351|      0|            }
 2352|      0|            if ((int const) * (arg + (i + 2UL)) == 40) {
 2353|      0|              goto case_33;
 2354|      0|            }
 2355|      0|            if ((int const) * (arg + (i + 2UL)) == 41) {
 2356|      0|              goto case_33;
 2357|      0|            }
 2358|      0|            if ((int const) * (arg + (i + 2UL)) == 45) {
 2359|      0|              goto case_33;
 2360|      0|            }
 2361|      0|            if ((int const) * (arg + (i + 2UL)) == 47) {
 2362|      0|              goto case_33;
 2363|      0|            }
 2364|      0|            if ((int const) * (arg + (i + 2UL)) == 60) {
 2365|      0|              goto case_33;
 2366|      0|            }
 2367|      0|            if ((int const) * (arg + (i + 2UL)) == 61) {
 2368|      0|              goto case_33;
 2369|      0|            }
 2370|      0|            if ((int const) * (arg + (i + 2UL)) == 62) {
 2371|      0|              goto case_33;
 2372|      0|            }
 2373|      0|            goto switch_default___0;
 2374|      0|          case_33:
 2375|      0|            if (elide_outer_quotes) {
 2376|      0|              goto force_outer_quoting_style;
 2377|      0|            }
 2378|      0|            c = (unsigned char)*(arg + (i + 2UL));
 2379|      0|            i += 2UL;
 2380|      0|            while (1) {
 2381|       |
 2382|      0|              if (len < buffersize) {
 2383|      0|                *(buffer + len) = (char)'?';
 2384|      0|              }
 2385|      0|              len++;
 2386|      0|              goto while_break___7;
 2387|      0|            }
 2388|      0|          while_break___7:;
 2389|      0|            while (1) {
 2390|       |
 2391|      0|              if (len < buffersize) {
 2392|      0|                *(buffer + len) = (char)'\"';
 2393|      0|              }
 2394|      0|              len++;
 2395|      0|              goto while_break___8;
 2396|      0|            }
 2397|      0|          while_break___8:;
 2398|      0|            while (1) {
 2399|       |
 2400|      0|              if (len < buffersize) {
 2401|      0|                *(buffer + len) = (char)'\"';
 2402|      0|              }
 2403|      0|              len++;
 2404|      0|              goto while_break___9;
 2405|      0|            }
 2406|      0|          while_break___9:;
 2407|      0|            while (1) {
 2408|       |
 2409|      0|              if (len < buffersize) {
 2410|      0|                *(buffer + len) = (char)'?';
 2411|      0|              }
 2412|      0|              len++;
 2413|      0|              goto while_break___10;
 2414|      0|            }
 2415|      0|          while_break___10:;
 2416|      0|            goto switch_break___2;
 2417|      0|          switch_default___0:
 2418|      0|            goto switch_break___2;
 2419|      0|          switch_break___2:;
 2420|      0|          }
 2421|      0|        }
 2422|      0|      }
 2423|      0|      goto switch_break___1;
 2424|      0|    switch_default___1:
 2425|      0|      goto switch_break___1;
 2426|      0|    switch_break___1:;
 2427|      0|      goto switch_break___0;
 2428|      0|    case_7___0:
 2429|      0|      esc = (unsigned char)'a';
 2430|      0|      goto c_escape;
 2431|      0|    case_8___0:
 2432|      0|      esc = (unsigned char)'b';
 2433|      0|      goto c_escape;
 2434|      0|    case_12:
 2435|      0|      esc = (unsigned char)'f';
 2436|      0|      goto c_escape;
 2437|      0|    case_10:
 2438|      0|      esc = (unsigned char)'n';
 2439|      0|      goto c_and_shell_escape;
 2440|      0|    case_13:
 2441|      0|      esc = (unsigned char)'r';
 2442|      0|      goto c_and_shell_escape;
 2443|      0|    case_9:
 2444|      0|      esc = (unsigned char)'t';
 2445|      0|      goto c_and_shell_escape;
 2446|      0|    case_11:
 2447|      0|      esc = (unsigned char)'v';
 2448|      0|      goto c_escape;
 2449|      0|    case_92:
 2450|      0|      esc = c;
 2451|      0|      if (backslash_escapes) {
 2452|      0|        if (elide_outer_quotes) {
 2453|      0|          if (quote_string_len) {
 2454|      0|            goto store_c;
 2455|      0|          }
 2456|      0|        }
 2457|      0|      }
 2458|      0|    c_and_shell_escape:
 2459|      0|      if ((unsigned int)quoting_style == 2U) {
 2460|      0|        if (elide_outer_quotes) {
 2461|      0|          goto force_outer_quoting_style;
 2462|      0|        }
 2463|      0|      }
 2464|      0|    c_escape:
 2465|      0|      if (backslash_escapes) {
 2466|      0|        c = esc;
 2467|      0|        goto store_escape;
 2468|      0|      }
 2469|      0|      goto switch_break___0;
 2470|      0|    case_123:
 2471|      0|      if (argsize == 0xffffffffffffffffUL) {
 2472|      0|        tmp___1 = (int const) * (arg + 1) == 0;
 2473|      0|      } else {
 2474|      0|        tmp___1 = argsize == 1UL;
 2475|      0|      }
 2476|      0|      if (!tmp___1) {
 2477|      0|        goto switch_break___0;
 2478|      0|      }
 2479|      0|    case_35:
 2480|      0|      if (i != 0UL) {
 2481|      0|        goto switch_break___0;
 2482|      0|      }
 2483|      0|    case_32:
 2484|      0|      if ((unsigned int)quoting_style == 2U) {
 2485|      0|        if (elide_outer_quotes) {
 2486|      0|          goto force_outer_quoting_style;
 2487|      0|        }
 2488|      0|      }
 2489|      0|      goto switch_break___0;
 2490|      0|    case_39___0:
 2491|      0|      if ((unsigned int)quoting_style == 2U) {
 2492|      0|        if (elide_outer_quotes) {
 2493|      0|          goto force_outer_quoting_style;
 2494|      0|        }
 2495|      0|        while (1) {
 2496|       |
 2497|      0|          if (len < buffersize) {
 2498|      0|            *(buffer + len) = (char)'\'';
 2499|      0|          }
 2500|      0|          len++;
 2501|      0|          goto while_break___11;
 2502|      0|        }
 2503|      0|      while_break___11:;
 2504|      0|        while (1) {
 2505|       |
 2506|      0|          if (len < buffersize) {
 2507|      0|            *(buffer + len) = (char)'\\';
 2508|      0|          }
 2509|      0|          len++;
 2510|      0|          goto while_break___12;
 2511|      0|        }
 2512|      0|      while_break___12:;
 2513|      0|        while (1) {
 2514|       |
 2515|      0|          if (len < buffersize) {
 2516|      0|            *(buffer + len) = (char)'\'';
 2517|      0|          }
 2518|      0|          len++;
 2519|      0|          goto while_break___13;
 2520|      0|        }
 2521|      0|      while_break___13:;
 2522|      0|      }
 2523|      0|      goto switch_break___0;
 2524|      0|    case_37:
 2525|      0|      goto switch_break___0;
 2526|      0|    switch_default___2:
 2527|      0|      if (unibyte_locale) {
 2528|      0|        m = (size_t)1;
 2529|      0|        tmp___2 = __ctype_b_loc();
 2530|      0|        printable = (_Bool)(((int const) * (*tmp___2 + (int)c) & 16384) != 0);
 2531|      0|      } else {
 2532|      0|        memset((void *)(&mbstate), 0, sizeof(mbstate));
 2533|      0|        m = (size_t)0;
 2534|      0|        printable = (_Bool)1;
 2535|      0|        if (argsize == 0xffffffffffffffffUL) {
 2536|      0|          argsize = strlen(arg);
 2537|      0|        }
 2538|      0|        while (1) {
 2539|      0|          tmp___3 = mbrtowc(&w, arg + (i + m), argsize - (i + m), &mbstate);
 2540|      0|          bytes = tmp___3;
 2541|      0|          if (bytes == 0UL) {
 2542|      0|            goto while_break___14;
 2543|      0|          } else {
 2544|      0|            if (bytes == 0xffffffffffffffffUL) {
 2545|      0|              printable = (_Bool)0;
 2546|      0|              goto while_break___14;
 2547|      0|            } else {
 2548|      0|              if (bytes == 0xfffffffffffffffeUL) {
 2549|      0|                printable = (_Bool)0;
 2550|      0|                while (1) {
 2551|       |
 2552|      0|                  if (i + m < argsize) {
 2553|      0|                    if (!*(arg + (i + m))) {
 2554|      0|                      goto while_break___15;
 2555|      0|                    }
 2556|      0|                  } else {
 2557|      0|                    goto while_break___15;
 2558|      0|                  }
 2559|      0|                  m++;
 2560|      0|                }
 2561|      0|              while_break___15:;
 2562|      0|                goto while_break___14;
 2563|      0|              } else {
 2564|      0|                if (elide_outer_quotes) {
 2565|      0|                  if ((unsigned int)quoting_style == 2U) {
 2566|      0|                    j = (size_t)1;
 2567|      0|                    while (1) {
 2568|       |
 2569|      0|                      if (!(j < bytes)) {
 2570|      0|                        goto while_break___16;
 2571|      0|                      }
 2572|      0|                      if ((int const) * (arg + ((i + m) + j)) == 91) {
 2573|      0|                        goto case_91___0;
 2574|      0|                      }
 2575|      0|                      if ((int const) * (arg + ((i + m) + j)) == 92) {
 2576|      0|                        goto case_91___0;
 2577|      0|                      }
 2578|      0|                      if ((int const) * (arg + ((i + m) + j)) == 94) {
 2579|      0|                        goto case_91___0;
 2580|      0|                      }
 2581|      0|                      if ((int const) * (arg + ((i + m) + j)) == 96) {
 2582|      0|                        goto case_91___0;
 2583|      0|                      }
 2584|      0|                      if ((int const) * (arg + ((i + m) + j)) == 124) {
 2585|      0|                        goto case_91___0;
 2586|      0|                      }
 2587|      0|                      goto switch_default___3;
 2588|      0|                    case_91___0:
 2589|      0|                      goto force_outer_quoting_style;
 2590|      0|                    switch_default___3:
 2591|      0|                      goto switch_break___3;
 2592|      0|                    switch_break___3:
 2593|      0|                      j++;
 2594|      0|                    }
 2595|      0|                  while_break___16:;
 2596|      0|                  }
 2597|      0|                }
 2598|      0|                tmp___4 = iswprint((wint_t)w);
 2599|      0|                if (!tmp___4) {
 2600|      0|                  printable = (_Bool)0;
 2601|      0|                }
 2602|      0|                m += bytes;
 2603|      0|              }
 2604|      0|            }
 2605|      0|          }
 2606|      0|          tmp___5 = mbsinit((mbstate_t const *)(&mbstate));
 2607|      0|          if (tmp___5) {
 2608|      0|            goto while_break___14;
 2609|      0|          }
 2610|      0|        }
 2611|      0|      while_break___14:;
 2612|      0|      }
 2613|      0|      if (1UL < m) {
 2614|      0|        goto _L___0;
 2615|      0|      } else {
 2616|      0|        if (backslash_escapes) {
 2617|      0|          if (!printable) {
 2618|      0|          _L___0:
 2619|      0|            ilim = i + m;
 2620|      0|            while (1) {
 2621|       |
 2622|      0|              if (backslash_escapes) {
 2623|      0|                if (!printable) {
 2624|      0|                  if (elide_outer_quotes) {
 2625|      0|                    goto force_outer_quoting_style;
 2626|      0|                  }
 2627|      0|                  while (1) {
 2628|       |
 2629|      0|                    if (len < buffersize) {
 2630|      0|                      *(buffer + len) = (char)'\\';
 2631|      0|                    }
 2632|      0|                    len++;
 2633|      0|                    goto while_break___18;
 2634|      0|                  }
 2635|      0|                while_break___18:;
 2636|      0|                  while (1) {
 2637|       |
 2638|      0|                    if (len < buffersize) {
 2639|      0|                      *(buffer + len) = (char)(48 + ((int)c >> 6));
 2640|      0|                    }
 2641|      0|                    len++;
 2642|      0|                    goto while_break___19;
 2643|      0|                  }
 2644|      0|                while_break___19:;
 2645|      0|                  while (1) {
 2646|       |
 2647|      0|                    if (len < buffersize) {
 2648|      0|                      *(buffer + len) = (char)(48 + (((int)c >> 3) & 7));
 2649|      0|                    }
 2650|      0|                    len++;
 2651|      0|                    goto while_break___20;
 2652|      0|                  }
 2653|      0|                while_break___20:
 2654|      0|                  c = (unsigned char)(48 + ((int)c & 7));
 2655|      0|                } else {
 2656|      0|                  goto _L;
 2657|      0|                }
 2658|      0|              } else {
 2659|      0|              _L:
 2660|      0|                if (is_right_quote) {
 2661|      0|                  while (1) {
 2662|       |
 2663|      0|                    if (len < buffersize) {
 2664|      0|                      *(buffer + len) = (char)'\\';
 2665|      0|                    }
 2666|      0|                    len++;
 2667|      0|                    goto while_break___21;
 2668|      0|                  }
 2669|      0|                while_break___21:
 2670|      0|                  is_right_quote = (_Bool)0;
 2671|      0|                }
 2672|      0|              }
 2673|      0|              if (ilim <= i + 1UL) {
 2674|      0|                goto while_break___17;
 2675|      0|              }
 2676|      0|              while (1) {
 2677|       |
 2678|      0|                if (len < buffersize) {
 2679|      0|                  *(buffer + len) = (char)c;
 2680|      0|                }
 2681|      0|                len++;
 2682|      0|                goto while_break___22;
 2683|      0|              }
 2684|      0|            while_break___22:
 2685|      0|              i++;
 2686|      0|              c = (unsigned char)*(arg + i);
 2687|      0|            }
 2688|      0|          while_break___17:;
 2689|      0|            goto store_c;
 2690|      0|          }
 2691|      0|        }
 2692|      0|      }
 2693|      0|    switch_break___0:;
 2694|      0|      if (backslash_escapes) {
 2695|      0|        goto _L___3;
 2696|      0|      } else {
 2697|      0|        if (elide_outer_quotes) {
 2698|      0|        _L___3:
 2699|      0|          if (quote_these_too) {
 2700|      0|            if (!(*(quote_these_too + (unsigned long)c / (sizeof(int) * 8UL)) &
 2701|      0|                  (unsigned int const)(1 << (unsigned long)c %
 2702|      0|                                                (sizeof(int) * 8UL)))) {
 2703|      0|              goto _L___2;
 2704|      0|            }
 2705|      0|          } else {
 2706|      0|            goto _L___2;
 2707|      0|          }
 2708|      0|        } else {
 2709|      0|        _L___2:
 2710|      0|          if (!is_right_quote) {
 2711|      0|            goto store_c;
 2712|      0|          }
 2713|      0|        }
 2714|      0|      }
 2715|      0|    store_escape:
 2716|      0|      if (elide_outer_quotes) {
 2717|      0|        goto force_outer_quoting_style;
 2718|      0|      }
 2719|      0|      while (1) {
 2720|       |
 2721|      0|        if (len < buffersize) {
 2722|      0|          *(buffer + len) = (char)'\\';
 2723|      0|        }
 2724|      0|        len++;
 2725|      0|        goto while_break___23;
 2726|      0|      }
 2727|      0|    while_break___23:;
 2728|      0|    store_c:
 2729|      0|      while (1) {
 2730|       |
 2731|      0|        if (len < buffersize) {
 2732|      0|          *(buffer + len) = (char)c;
 2733|      0|        }
 2734|      0|        len++;
 2735|      0|        goto while_break___24;
 2736|      0|      }
 2737|      0|    while_break___24:;
 2738|      0|    __Cont:
 2739|      0|      i++;
 2740|      0|    }
 2741|      0|  while_break___3:;
 2742|      0|    if (len == 0UL) {
 2743|      0|      if ((unsigned int)quoting_style == 2U) {
 2744|      0|        if (elide_outer_quotes) {
 2745|      0|          goto force_outer_quoting_style;
 2746|      0|        }
 2747|      0|      }
 2748|      0|    }
 2749|      0|    if (quote_string) {
 2750|      0|      if (!elide_outer_quotes) {
 2751|      0|        while (1) {
 2752|       |
 2753|      0|          if (!*quote_string) {
 2754|      0|            goto while_break___25;
 2755|      0|          }
 2756|      0|          while (1) {
 2757|       |
 2758|      0|            if (len < buffersize) {
 2759|      0|              *(buffer + len) = (char)*quote_string;
 2760|      0|            }
 2761|      0|            len++;
 2762|      0|            goto while_break___26;
 2763|      0|          }
 2764|      0|        while_break___26:
 2765|      0|          quote_string++;
 2766|      0|        }
 2767|      0|      while_break___25:;
 2768|      0|      }
 2769|      0|    }
 2770|      0|    if (len < buffersize) {
 2771|      0|      *(buffer + len) = (char)'\000';
 2772|      0|    }
 2773|      0|    return (len);
 2774|      0|  force_outer_quoting_style:
 2775|      0|    tmp___7 = quotearg_buffer_restyled(
 2776|      0|        buffer, buffersize, arg, argsize, quoting_style, flags & -3,
 2777|      0|        (unsigned int const *)((void *)0), left_quote, right_quote);
 2778|      0|    return (tmp___7);
 2779|      0|  }
 2780|      0|}
 2781|       |static char slot0[256];
 2782|       |static unsigned int nslots = 1U;
 2783|       |static struct slotvec slotvec0 = {sizeof(slot0), slot0};
 2784|       |static struct slotvec *slotvec = &slotvec0;
 2785|       |static char *quotearg_n_options(int n, char const *arg, size_t argsize,
 2786|      0|                                struct quoting_options const *options) {
 2787|      0|  int e;
 2788|      0|  int *tmp;
 2789|      0|  unsigned int n0;
 2790|      0|  struct slotvec *sv;
 2791|      0|  size_t n1;
 2792|      0|  _Bool preallocated;
 2793|      0|  int tmp___0;
 2794|      0|  struct slotvec *tmp___1;
 2795|      0|  size_t size;
 2796|      0|  char *val;
 2797|      0|  int flags;
 2798|      0|  size_t qsize;
 2799|      0|  size_t tmp___2;
 2800|      0|  int *tmp___3;
 2801|       |
 2802|      0|  {
 2803|      0|    tmp = __errno_location();
 2804|      0|    e = *tmp;
 2805|      0|    n0 = (unsigned int)n;
 2806|      0|    sv = slotvec;
 2807|      0|    if (n < 0) {
 2808|      0|      abort();
 2809|      0|    }
 2810|      0|    if (nslots <= n0) {
 2811|      0|      n1 = (size_t)(n0 + 1U);
 2812|      0|      preallocated = (_Bool)((unsigned long)sv == (unsigned long)(&slotvec0));
 2813|      0|      if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 2814|      0|        tmp___0 = -1;
 2815|      0|      } else {
 2816|      0|        tmp___0 = -2;
 2817|      0|      }
 2818|      0|      if ((size_t)tmp___0 / sizeof(*sv) < n1) {
 2819|      0|        xalloc_die();
 2820|      0|      }
 2821|      0|      if (preallocated) {
 2822|      0|        tmp___1 = (struct slotvec *)((void *)0);
 2823|      0|      } else {
 2824|      0|        tmp___1 = sv;
 2825|      0|      }
 2826|      0|      sv = (struct slotvec *)xrealloc((void *)tmp___1, n1 * sizeof(*sv));
 2827|      0|      slotvec = sv;
 2828|      0|      if (preallocated) {
 2829|      0|        *sv = slotvec0;
 2830|      0|      }
 2831|      0|      memset((void *)(sv + nslots), 0, (n1 - (size_t)nslots) * sizeof(*sv));
 2832|      0|      nslots = (unsigned int)n1;
 2833|      0|    }
 2834|      0|    size = (sv + n)->size;
 2835|      0|    val = (sv + n)->val;
 2836|      0|    flags = (int)(options->flags | 1);
 2837|      0|    tmp___2 = quotearg_buffer_restyled(
 2838|      0|        val, size, arg, argsize, (enum quoting_style)options->style, flags,
 2839|      0|        (unsigned int const *)(options->quote_these_too),
 2840|      0|        (char const *)options->left_quote, (char const *)options->right_quote);
 2841|      0|    qsize = tmp___2;
 2842|      0|    if (size <= qsize) {
 2843|      0|      size = qsize + 1UL;
 2844|      0|      (sv + n)->size = size;
 2845|      0|      if ((unsigned long)val != (unsigned long)(slot0)) {
 2846|      0|        free((void *)val);
 2847|      0|      }
 2848|      0|      val = xcharalloc(size);
 2849|      0|      (sv + n)->val = val;
 2850|      0|      quotearg_buffer_restyled(val, size, arg, argsize,
 2851|      0|                               (enum quoting_style)options->style, flags,
 2852|      0|                               (unsigned int const *)(options->quote_these_too),
 2853|      0|                               (char const *)options->left_quote,
 2854|      0|                               (char const *)options->right_quote);
 2855|      0|    }
 2856|      0|    tmp___3 = __errno_location();
 2857|      0|    *tmp___3 = e;
 2858|      0|    return (val);
 2859|      0|  }
 2860|      0|}
 2861|      0|char *quotearg_n_style(int n, enum quoting_style s, char const *arg) {
 2862|      0|  struct quoting_options o;
 2863|      0|  struct quoting_options tmp;
 2864|      0|  char *tmp___0;
 2865|       |
 2866|      0|  {
 2867|      0|    tmp = quoting_options_from_style(s);
 2868|      0|    o = tmp;
 2869|      0|    tmp___0 = quotearg_n_options(n, arg, (size_t)-1,
 2870|      0|                                 (struct quoting_options const *)(&o));
 2871|      0|    return (tmp___0);
 2872|      0|  }
 2873|      0|}
 2874|      0|char *quotearg_char_mem(char const *arg, size_t argsize, char ch) {
 2875|      0|  struct quoting_options options;
 2876|      0|  char *tmp;
 2877|       |
 2878|      0|  {
 2879|      0|    options = default_quoting_options;
 2880|      0|    set_char_quoting(&options, ch, 1);
 2881|      0|    tmp = quotearg_n_options(0, arg, argsize,
 2882|      0|                             (struct quoting_options const *)(&options));
 2883|      0|    return (tmp);
 2884|      0|  }
 2885|      0|}
 2886|      0|char *quotearg_char(char const *arg, char ch) {
 2887|      0|  char *tmp;
 2888|       |
 2889|      0|  {
 2890|      0|    tmp = quotearg_char_mem(arg, (size_t)-1, ch);
 2891|      0|    return (tmp);
 2892|      0|  }
 2893|      0|}
 2894|      0|char *quotearg_colon(char const *arg) {
 2895|      0|  char *tmp;
 2896|       |
 2897|      0|  {
 2898|      0|    tmp = quotearg_char(arg, (char)':');
 2899|      0|    return (tmp);
 2900|      0|  }
 2901|      0|}
 2902|      0|char const *quote_n(int n, char const *name) {
 2903|      0|  char const *tmp;
 2904|       |
 2905|      0|  {
 2906|      0|    tmp = (char const *)quotearg_n_style(n, (enum quoting_style)6, name);
 2907|      0|    return (tmp);
 2908|      0|  }
 2909|      0|}
 2910|      0|char const *quote(char const *name) {
 2911|      0|  char const *tmp;
 2912|       |
 2913|      0|  {
 2914|      0|    tmp = quote_n(0, name);
 2915|      0|    return (tmp);
 2916|      0|  }
 2917|      0|}
 2918|       |char const *program_name;
 2919|       |void set_program_name(char const *argv0);
 2920|       |extern char *program_invocation_name;
 2921|       |extern char *program_invocation_short_name;
 2922|       |extern int fputs(char const *__restrict __s, FILE *__restrict __stream);
 2923|       |char const *program_name = (char const *)((void *)0);
 2924|      2|void set_program_name(char const *argv0) {
 2925|      2|  char const *slash;
 2926|      2|  char const *base;
 2927|      2|  int tmp;
 2928|      2|  int tmp___0;
 2929|       |
 2930|      2|  {
 2931|      2|    if ((unsigned long)argv0 == (unsigned long)((void *)0)) {
 2932|      0|      fputs("A NULL argv[0] was passed through an exec system call.\n", stderr);
 2933|      0|      abort();
 2934|      0|    }
 2935|      2|    slash = (char const *)strrchr(argv0, '/');
 2936|      2|    if ((unsigned long)slash != (unsigned long)((void *)0)) {
 2937|      2|      base = slash + 1;
 2938|      2|    } else {
 2939|      0|      base = argv0;
 2940|      0|    }
 2941|      2|    if (base - argv0 >= 7L) {
 2942|      0|      tmp___0 = strncmp(base - 7, "/.libs/", (size_t)7);
 2943|      0|      if (tmp___0 == 0) {
 2944|      0|        argv0 = base;
 2945|      0|        tmp = strncmp(base, "lt-", (size_t)3);
 2946|      0|        if (tmp == 0) {
 2947|      0|          argv0 = base + 3;
 2948|      0|          program_invocation_short_name = (char *)argv0;
 2949|      0|        }
 2950|      0|      }
 2951|      0|    }
 2952|      2|    program_name = argv0;
 2953|      2|    program_invocation_name = (char *)argv0;
 2954|      2|    return;
 2955|      2|  }
 2956|      2|}
 2957|       |extern __attribute__((__nothrow__)) char *(__attribute__((
 2958|       |    __nonnull__(1, 2), __leaf__)) stpcpy)(char *__restrict __dest,
 2959|       |                                          char const *__restrict __src);
 2960|       |extern DIR *(__attribute__((__nonnull__(1))) opendir)(char const *__name);
 2961|       |extern __attribute__((__nothrow__)) int(
 2962|       |    __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp);
 2963|      0|DIR *opendir_safer(char const *name) {
 2964|      0|  DIR *dp;
 2965|      0|  DIR *tmp;
 2966|      0|  int fd;
 2967|      0|  int tmp___0;
 2968|      0|  DIR *newdp;
 2969|      0|  int e;
 2970|      0|  int f;
 2971|      0|  int tmp___1;
 2972|      0|  int *tmp___2;
 2973|      0|  int *tmp___3;
 2974|       |
 2975|      0|  {
 2976|      0|    tmp = opendir(name);
 2977|      0|    dp = tmp;
 2978|      0|    if (dp) {
 2979|      0|      tmp___0 = dirfd(dp);
 2980|      0|      fd = tmp___0;
 2981|      0|      if (0 <= fd) {
 2982|      0|        if (fd <= 2) {
 2983|      0|          tmp___1 = dup_safer(fd);
 2984|      0|          f = tmp___1;
 2985|      0|          newdp = rpl_fdopendir(f);
 2986|      0|          tmp___2 = __errno_location();
 2987|      0|          e = *tmp___2;
 2988|      0|          if (!newdp) {
 2989|      0|            close(f);
 2990|      0|          }
 2991|      0|          closedir(dp);
 2992|      0|          tmp___3 = __errno_location();
 2993|      0|          *tmp___3 = e;
 2994|      0|          dp = newdp;
 2995|      0|        }
 2996|      0|      }
 2997|      0|    }
 2998|      0|    return (dp);
 2999|      0|  }
 3000|      0|}
 3001|       |int openat_safer(int fd, char const *file, int flags, ...);
 3002|      2|int openat_safer(int fd, char const *file, int flags, ...) {
 3003|      2|  mode_t mode;
 3004|      2|  va_list ap;
 3005|      2|  int tmp;
 3006|      2|  int tmp___0;
 3007|       |
 3008|      2|  {
 3009|      2|    mode = (mode_t)0;
 3010|      2|    if (flags & 64) {
 3011|      0|      __builtin_va_start(ap, flags);
 3012|      0|      mode = __builtin_va_arg(ap, mode_t);
 3013|      0|      __builtin_va_end(ap);
 3014|      0|    }
 3015|      2|    tmp = openat(fd, file, flags, mode);
 3016|      2|    tmp___0 = fd_safer(tmp);
 3017|      2|    return (tmp___0);
 3018|      2|  }
 3019|      2|}
 3020|      0|int open_safer(char const *file, int flags, ...) {
 3021|      0|  mode_t mode;
 3022|      0|  va_list ap;
 3023|      0|  int tmp;
 3024|      0|  int tmp___0;
 3025|       |
 3026|      0|  {
 3027|      0|    mode = (mode_t)0;
 3028|      0|    if (flags & 64) {
 3029|      0|      __builtin_va_start(ap, flags);
 3030|      0|      mode = __builtin_va_arg(ap, mode_t);
 3031|      0|      __builtin_va_end(ap);
 3032|      0|    }
 3033|      0|    tmp = open(file, flags, mode);
 3034|      0|    tmp___0 = fd_safer(tmp);
 3035|      0|    return (tmp___0);
 3036|      0|  }
 3037|      0|}
 3038|      0|int mbscasecmp(char const *s1, char const *s2) {
 3039|      0|  mbui_iterator_t iter1;
 3040|      0|  mbui_iterator_t iter2;
 3041|      0|  int cmp;
 3042|      0|  wint_t tmp;
 3043|      0|  wint_t tmp___0;
 3044|      0|  int tmp___1;
 3045|      0|  int tmp___2;
 3046|      0|  int tmp___4;
 3047|      0|  int tmp___5;
 3048|      0|  int tmp___7;
 3049|      0|  int tmp___8;
 3050|      0|  int tmp___9;
 3051|      0|  int tmp___10;
 3052|      0|  int tmp___11;
 3053|      0|  int tmp___12;
 3054|      0|  int tmp___13;
 3055|      0|  int tmp___14;
 3056|      0|  int tmp___15;
 3057|      0|  int tmp___16;
 3058|      0|  unsigned char const *p1;
 3059|      0|  unsigned char const *p2;
 3060|      0|  unsigned char c1;
 3061|      0|  unsigned char c2;
 3062|      0|  int tmp___18;
 3063|      0|  unsigned short const **tmp___19;
 3064|      0|  int tmp___21;
 3065|      0|  unsigned short const **tmp___22;
 3066|      0|  size_t tmp___25;
 3067|       |
 3068|      0|  {
 3069|      0|    if ((unsigned long)s1 == (unsigned long)s2) {
 3070|      0|      return (0);
 3071|      0|    }
 3072|      0|    tmp___25 = __ctype_get_mb_cur_max();
 3073|      0|    if (tmp___25 > 1UL) {
 3074|      0|      iter1.cur.ptr = s1;
 3075|      0|      iter1.in_shift = (_Bool)0;
 3076|      0|      memset((void *)(&iter1.state), '\000', sizeof(mbstate_t));
 3077|      0|      iter1.next_done = (_Bool)0;
 3078|      0|      iter2.cur.ptr = s2;
 3079|      0|      iter2.in_shift = (_Bool)0;
 3080|      0|      memset((void *)(&iter2.state), '\000', sizeof(mbstate_t));
 3081|      0|      iter2.next_done = (_Bool)0;
 3082|      0|      while (1) {
 3083|      0|        mbuiter_multi_next(&iter1);
 3084|      0|        if (iter1.cur.wc_valid) {
 3085|      0|          if (iter1.cur.wc == 0) {
 3086|      0|            tmp___13 = 0;
 3087|      0|          } else {
 3088|      0|            tmp___13 = 1;
 3089|      0|          }
 3090|      0|        } else {
 3091|      0|          tmp___13 = 1;
 3092|      0|        }
 3093|      0|        if (tmp___13) {
 3094|      0|          mbuiter_multi_next(&iter2);
 3095|      0|          if (iter2.cur.wc_valid) {
 3096|      0|            if (iter2.cur.wc == 0) {
 3097|      0|              tmp___14 = 0;
 3098|      0|            } else {
 3099|      0|              tmp___14 = 1;
 3100|      0|            }
 3101|      0|          } else {
 3102|      0|            tmp___14 = 1;
 3103|      0|          }
 3104|      0|          if (!tmp___14) {
 3105|      0|            goto while_break;
 3106|      0|          }
 3107|      0|        } else {
 3108|      0|          goto while_break;
 3109|      0|        }
 3110|      0|        if (iter1.cur.wc_valid) {
 3111|      0|          if (iter2.cur.wc_valid) {
 3112|      0|            tmp = towlower((wint_t)iter1.cur.wc);
 3113|      0|            tmp___0 = towlower((wint_t)iter2.cur.wc);
 3114|      0|            tmp___1 = (int)tmp - (int)tmp___0;
 3115|      0|          } else {
 3116|      0|            tmp___1 = -1;
 3117|      0|          }
 3118|      0|          tmp___12 = tmp___1;
 3119|      0|        } else {
 3120|      0|          if (iter2.cur.wc_valid) {
 3121|      0|            tmp___11 = 1;
 3122|      0|          } else {
 3123|      0|            if (iter1.cur.bytes == iter2.cur.bytes) {
 3124|      0|              tmp___2 = memcmp((void const *)iter1.cur.ptr,
 3125|      0|                               (void const *)iter2.cur.ptr, iter1.cur.bytes);
 3126|      0|              tmp___10 = tmp___2;
 3127|      0|            } else {
 3128|      0|              if (iter1.cur.bytes < iter2.cur.bytes) {
 3129|      0|                tmp___5 = memcmp((void const *)iter1.cur.ptr,
 3130|      0|                                 (void const *)iter2.cur.ptr, iter1.cur.bytes);
 3131|      0|                if (tmp___5 > 0) {
 3132|      0|                  tmp___4 = 1;
 3133|      0|                } else {
 3134|      0|                  tmp___4 = -1;
 3135|      0|                }
 3136|      0|                tmp___9 = tmp___4;
 3137|      0|              } else {
 3138|      0|                tmp___8 = memcmp((void const *)iter1.cur.ptr,
 3139|      0|                                 (void const *)iter2.cur.ptr, iter2.cur.bytes);
 3140|      0|                if (tmp___8 >= 0) {
 3141|      0|                  tmp___7 = 1;
 3142|      0|                } else {
 3143|      0|                  tmp___7 = -1;
 3144|      0|                }
 3145|      0|                tmp___9 = tmp___7;
 3146|      0|              }
 3147|      0|              tmp___10 = tmp___9;
 3148|      0|            }
 3149|      0|            tmp___11 = tmp___10;
 3150|      0|          }
 3151|      0|          tmp___12 = tmp___11;
 3152|      0|        }
 3153|      0|        cmp = tmp___12;
 3154|      0|        if (cmp != 0) {
 3155|      0|          return (cmp);
 3156|      0|        }
 3157|      0|        iter1.cur.ptr += iter1.cur.bytes;
 3158|      0|        iter1.next_done = (_Bool)0;
 3159|      0|        iter2.cur.ptr += iter2.cur.bytes;
 3160|      0|        iter2.next_done = (_Bool)0;
 3161|      0|      }
 3162|      0|    while_break:
 3163|      0|      mbuiter_multi_next(&iter1);
 3164|      0|      if (iter1.cur.wc_valid) {
 3165|      0|        if (iter1.cur.wc == 0) {
 3166|      0|          tmp___15 = 0;
 3167|      0|        } else {
 3168|      0|          tmp___15 = 1;
 3169|      0|        }
 3170|      0|      } else {
 3171|      0|        tmp___15 = 1;
 3172|      0|      }
 3173|      0|      if (tmp___15) {
 3174|      0|        return (1);
 3175|      0|      }
 3176|      0|      mbuiter_multi_next(&iter2);
 3177|      0|      if (iter2.cur.wc_valid) {
 3178|      0|        if (iter2.cur.wc == 0) {
 3179|      0|          tmp___16 = 0;
 3180|      0|        } else {
 3181|      0|          tmp___16 = 1;
 3182|      0|        }
 3183|      0|      } else {
 3184|      0|        tmp___16 = 1;
 3185|      0|      }
 3186|      0|      if (tmp___16) {
 3187|      0|        return (-1);
 3188|      0|      }
 3189|      0|      return (0);
 3190|      0|    } else {
 3191|      0|      p1 = (unsigned char const *)s1;
 3192|      0|      p2 = (unsigned char const *)s2;
 3193|      0|      while (1) {
 3194|      0|        tmp___19 = __ctype_b_loc();
 3195|      0|        if ((int const) * (*tmp___19 + (int)*p1) & 256) {
 3196|      0|          tmp___18 = tolower((int)*p1);
 3197|      0|          c1 = (unsigned char)tmp___18;
 3198|      0|        } else {
 3199|      0|          c1 = (unsigned char)*p1;
 3200|      0|        }
 3201|      0|        tmp___22 = __ctype_b_loc();
 3202|      0|        if ((int const) * (*tmp___22 + (int)*p2) & 256) {
 3203|      0|          tmp___21 = tolower((int)*p2);
 3204|      0|          c2 = (unsigned char)tmp___21;
 3205|      0|        } else {
 3206|      0|          c2 = (unsigned char)*p2;
 3207|      0|        }
 3208|      0|        if ((int)c1 == 0) {
 3209|      0|          goto while_break___0;
 3210|      0|        }
 3211|      0|        p1++;
 3212|      0|        p2++;
 3213|      0|        if (!((int)c1 == (int)c2)) {
 3214|      0|          goto while_break___0;
 3215|      0|        }
 3216|      0|      }
 3217|      0|    while_break___0:;
 3218|      0|      return ((int)c1 - (int)c2);
 3219|      0|    }
 3220|      0|  }
 3221|      0|}
 3222|       |unsigned int const is_basic_table[8] = {
 3223|       |    (unsigned int const)6656, (unsigned int const)4294967279U,
 3224|       |    (unsigned int const)4294967294U, (unsigned int const)2147483646};
 3225|       |extern __attribute__((__nothrow__, __noreturn__)) void(
 3226|       |    __attribute__((__leaf__)) exit)(int __status);
 3227|       |extern int optind;
 3228|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) getopt_long)(
 3229|       |    int ___argc, char *const *___argv, char const *__shortopts,
 3230|       |    struct option const *__longopts, int *__longind);
 3231|       |#pragma weak pthread_mutex_init
 3232|       |#pragma weak pthread_mutex_lock
 3233|       |#pragma weak pthread_mutex_unlock
 3234|       |#pragma weak pthread_mutex_destroy
 3235|       |#pragma weak pthread_rwlock_init
 3236|       |#pragma weak pthread_rwlock_rdlock
 3237|       |#pragma weak pthread_rwlock_wrlock
 3238|       |#pragma weak pthread_rwlock_unlock
 3239|       |#pragma weak pthread_rwlock_destroy
 3240|       |#pragma weak pthread_once
 3241|       |#pragma weak pthread_cond_init
 3242|       |#pragma weak pthread_cond_wait
 3243|       |#pragma weak pthread_cond_signal
 3244|       |#pragma weak pthread_cond_broadcast
 3245|       |#pragma weak pthread_cond_destroy
 3246|       |#pragma weak pthread_mutexattr_init
 3247|       |#pragma weak pthread_mutexattr_settype
 3248|       |#pragma weak pthread_mutexattr_destroy
 3249|       |#pragma weak pthread_self
 3250|       |#pragma weak pthread_cancel
 3251|       |extern struct passwd *getpwuid(__uid_t __uid);
 3252|       |void i_ring_init(I_ring *ir, int default_val);
 3253|       |int i_ring_push(I_ring *ir, int val);
 3254|       |int i_ring_pop(I_ring *ir);
 3255|       |_Bool i_ring_empty(I_ring const *ir);
 3256|      2|void i_ring_init(I_ring *ir, int default_val) {
 3257|      2|  int i;
 3258|       |
 3259|      2|  {
 3260|      2|    ir->ir_empty = (_Bool)1;
 3261|      2|    ir->ir_front = 0U;
 3262|      2|    ir->ir_back = 0U;
 3263|      2|    i = 0;
 3264|     10|    while (1) {
 3265|       |
 3266|     10|      if (!(i < 4)) {
 3267|      2|        goto while_break;
 3268|      2|      }
 3269|      8|      ir->ir_data[i] = default_val;
 3270|      8|      i++;
 3271|      8|    }
 3272|      2|  while_break:
 3273|      2|    ir->ir_default_val = default_val;
 3274|      2|    return;
 3275|      2|  }
 3276|      2|}
 3277|     18|_Bool i_ring_empty(I_ring const *ir) {
 3278|       |
 3279|     18|  { return ((_Bool)ir->ir_empty); }
 3280|     18|}
 3281|      6|int i_ring_push(I_ring *ir, int val) {
 3282|      6|  unsigned int dest_idx;
 3283|      6|  int old_val;
 3284|       |
 3285|      6|  {
 3286|      6|    dest_idx = (ir->ir_front + (unsigned int)(!ir->ir_empty)) % 4U;
 3287|      6|    old_val = ir->ir_data[dest_idx];
 3288|      6|    ir->ir_data[dest_idx] = val;
 3289|      6|    ir->ir_front = dest_idx;
 3290|      6|    if (dest_idx == ir->ir_back) {
 3291|      4|      ir->ir_back = (ir->ir_back + (unsigned int)(!ir->ir_empty)) % 4U;
 3292|      4|    }
 3293|      6|    ir->ir_empty = (_Bool)0;
 3294|      6|    return (old_val);
 3295|      6|  }
 3296|      6|}
 3297|      6|int i_ring_pop(I_ring *ir) {
 3298|      6|  int top_val;
 3299|      6|  _Bool tmp;
 3300|       |
 3301|      6|  {
 3302|      6|    tmp = i_ring_empty((I_ring const *)ir);
 3303|      6|    if (tmp) {
 3304|      0|      abort();
 3305|      0|    }
 3306|      6|    top_val = ir->ir_data[ir->ir_front];
 3307|      6|    ir->ir_data[ir->ir_front] = ir->ir_default_val;
 3308|      6|    if (ir->ir_front == ir->ir_back) {
 3309|      4|      ir->ir_empty = (_Bool)1;
 3310|      4|    } else {
 3311|      2|      ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
 3312|      2|    }
 3313|      6|    return (top_val);
 3314|      6|  }
 3315|      6|}
 3316|       |_Bool(__attribute__((__warn_unused_result__)) hash_rehash)(
 3317|       |    Hash_table *table___0, size_t candidate);
 3318|       |void *hash_delete(Hash_table *table___0, void const *entry);
 3319|      0|__inline static size_t rotr_sz(size_t x, int n) {
 3320|       |
 3321|      0|  {
 3322|      0|    return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long)n))) &
 3323|      0|            0xffffffffffffffffUL);
 3324|      0|  }
 3325|      0|}
 3326|       |static struct hash_tuning const default_tuning = {
 3327|       |    (float)0.0, (float)1.0, (float)0.8, (float)1.414, (_Bool)0};
 3328|      0|void *hash_lookup(Hash_table const *table___0, void const *entry) {
 3329|      0|  struct hash_entry const *bucket;
 3330|      0|  size_t tmp;
 3331|      0|  struct hash_entry const *cursor;
 3332|      0|  _Bool tmp___0;
 3333|       |
 3334|      0|  {
 3335|      0|    tmp = (*(table___0->hasher))(entry, (size_t)table___0->n_buckets);
 3336|      0|    bucket = (struct hash_entry const *)(table___0->bucket + tmp);
 3337|      0|    if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3338|      0|      abort();
 3339|      0|    }
 3340|      0|    if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
 3341|      0|      return ((void *)0);
 3342|      0|    }
 3343|      0|    cursor = bucket;
 3344|      0|    while (1) {
 3345|       |
 3346|      0|      if (!cursor) {
 3347|      0|        goto while_break;
 3348|      0|      }
 3349|      0|      if ((unsigned long)entry == (unsigned long)cursor->data) {
 3350|      0|        return ((void *)cursor->data);
 3351|      0|      } else {
 3352|      0|        tmp___0 = (*(table___0->comparator))(entry, (void const *)cursor->data);
 3353|      0|        if (tmp___0) {
 3354|      0|          return ((void *)cursor->data);
 3355|      0|        }
 3356|      0|      }
 3357|      0|      cursor = (struct hash_entry const *)cursor->next;
 3358|      0|    }
 3359|      0|  while_break:;
 3360|      0|    return ((void *)0);
 3361|      0|  }
 3362|      0|}
 3363|      0|size_t hash_string(char const *string, size_t n_buckets) {
 3364|      0|  size_t value;
 3365|      0|  unsigned char ch;
 3366|       |
 3367|      0|  {
 3368|      0|    value = (size_t)0;
 3369|      0|    while (1) {
 3370|      0|      ch = (unsigned char)*string;
 3371|      0|      if (!ch) {
 3372|      0|        goto while_break;
 3373|      0|      }
 3374|      0|      value = (value * 31UL + (size_t)ch) % n_buckets;
 3375|      0|      string++;
 3376|      0|    }
 3377|      0|  while_break:;
 3378|      0|    return (value);
 3379|      0|  }
 3380|      0|}
 3381|      0|static _Bool is_prime(size_t candidate) {
 3382|      0|  size_t divisor;
 3383|      0|  size_t square;
 3384|      0|  int tmp;
 3385|       |
 3386|      0|  {
 3387|      0|    divisor = (size_t)3;
 3388|      0|    square = divisor * divisor;
 3389|      0|    while (1) {
 3390|       |
 3391|      0|      if (square < candidate) {
 3392|      0|        if (!(candidate % divisor)) {
 3393|      0|          goto while_break;
 3394|      0|        }
 3395|      0|      } else {
 3396|      0|        goto while_break;
 3397|      0|      }
 3398|      0|      divisor++;
 3399|      0|      square += 4UL * divisor;
 3400|      0|      divisor++;
 3401|      0|    }
 3402|      0|  while_break:;
 3403|      0|    if (candidate % divisor) {
 3404|      0|      tmp = 1;
 3405|      0|    } else {
 3406|      0|      tmp = 0;
 3407|      0|    }
 3408|      0|    return ((_Bool)tmp);
 3409|      0|  }
 3410|      0|}
 3411|      0|static size_t next_prime(size_t candidate) {
 3412|      0|  _Bool tmp;
 3413|       |
 3414|      0|  {
 3415|      0|    if (candidate < 10UL) {
 3416|      0|      candidate = (size_t)10;
 3417|      0|    }
 3418|      0|    candidate |= 1UL;
 3419|      0|    while (1) {
 3420|       |
 3421|      0|      if (0xffffffffffffffffUL != candidate) {
 3422|      0|        tmp = is_prime(candidate);
 3423|      0|        if (tmp) {
 3424|      0|          goto while_break;
 3425|      0|        }
 3426|      0|      } else {
 3427|      0|        goto while_break;
 3428|      0|      }
 3429|      0|      candidate += 2UL;
 3430|      0|    }
 3431|      0|  while_break:;
 3432|      0|    return (candidate);
 3433|      0|  }
 3434|      0|}
 3435|      0|static size_t raw_hasher(void const *data, size_t n) {
 3436|      0|  size_t val;
 3437|      0|  size_t tmp;
 3438|       |
 3439|      0|  {
 3440|      0|    tmp = rotr_sz((size_t)data, 3);
 3441|      0|    val = tmp;
 3442|      0|    return (val % n);
 3443|      0|  }
 3444|      0|}
 3445|      0|static _Bool raw_comparator(void const *a, void const *b) {
 3446|       |
 3447|      0|  { return ((_Bool)((unsigned long)a == (unsigned long)b)); }
 3448|      0|}
 3449|      0|static _Bool check_tuning(Hash_table *table___0) {
 3450|      0|  Hash_tuning const *tuning;
 3451|      0|  float epsilon;
 3452|       |
 3453|      0|  {
 3454|      0|    tuning = table___0->tuning;
 3455|      0|    if ((unsigned long)tuning == (unsigned long)(&default_tuning)) {
 3456|      0|      return ((_Bool)1);
 3457|      0|    }
 3458|      0|    epsilon = 0.1f;
 3459|      0|    if (epsilon < (float)tuning->growth_threshold) {
 3460|      0|      if (tuning->growth_threshold < (float const)((float)1 - epsilon)) {
 3461|      0|        if ((float)1 + epsilon < (float)tuning->growth_factor) {
 3462|      0|          if ((float const)0 <= tuning->shrink_threshold) {
 3463|      0|            if (tuning->shrink_threshold + (float const)epsilon <
 3464|      0|                tuning->shrink_factor) {
 3465|      0|              if (tuning->shrink_factor <= (float const)1) {
 3466|      0|                if (tuning->shrink_threshold + (float const)epsilon <
 3467|      0|                    tuning->growth_threshold) {
 3468|      0|                  return ((_Bool)1);
 3469|      0|                }
 3470|      0|              }
 3471|      0|            }
 3472|      0|          }
 3473|      0|        }
 3474|      0|      }
 3475|      0|    }
 3476|      0|    table___0->tuning = &default_tuning;
 3477|      0|    return ((_Bool)0);
 3478|      0|  }
 3479|      0|}
 3480|      0|static size_t compute_bucket_size(size_t candidate, Hash_tuning const *tuning) {
 3481|      0|  float new_candidate;
 3482|      0|  int tmp;
 3483|       |
 3484|      0|  {
 3485|      0|    if (!tuning->is_n_buckets) {
 3486|      0|      new_candidate =
 3487|      0|          (float)((float const)candidate / tuning->growth_threshold);
 3488|      0|      if ((float)0xffffffffffffffffUL <= new_candidate) {
 3489|      0|        return ((size_t)0);
 3490|      0|      }
 3491|      0|      candidate = (size_t)new_candidate;
 3492|      0|    }
 3493|      0|    candidate = next_prime(candidate);
 3494|      0|    if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 3495|      0|      tmp = -1;
 3496|      0|    } else {
 3497|      0|      tmp = -2;
 3498|      0|    }
 3499|      0|    if ((size_t)tmp / sizeof(struct hash_entry *) < candidate) {
 3500|      0|      return ((size_t)0);
 3501|      0|    }
 3502|      0|    return (candidate);
 3503|      0|  }
 3504|      0|}
 3505|       |Hash_table *(__attribute__((__warn_unused_result__)) hash_initialize)(
 3506|       |    size_t candidate, Hash_tuning const *tuning,
 3507|       |    size_t (*hasher)(void const *, size_t),
 3508|       |    _Bool (*comparator)(void const *, void const *),
 3509|      0|    void (*data_freer)(void *)) {
 3510|      0|  Hash_table *table___0;
 3511|      0|  _Bool tmp;
 3512|       |
 3513|      0|  {
 3514|      0|    if ((unsigned long)hasher == (unsigned long)((void *)0)) {
 3515|      0|      hasher = &raw_hasher;
 3516|      0|    }
 3517|      0|    if ((unsigned long)comparator == (unsigned long)((void *)0)) {
 3518|      0|      comparator = &raw_comparator;
 3519|      0|    }
 3520|      0|    table___0 = (Hash_table *)malloc(sizeof(*table___0));
 3521|      0|    if ((unsigned long)table___0 == (unsigned long)((void *)0)) {
 3522|      0|      return ((Hash_table *)((void *)0));
 3523|      0|    }
 3524|      0|    if (!tuning) {
 3525|      0|      tuning = &default_tuning;
 3526|      0|    }
 3527|      0|    table___0->tuning = tuning;
 3528|      0|    tmp = check_tuning(table___0);
 3529|      0|    if (!tmp) {
 3530|      0|      goto fail;
 3531|      0|    }
 3532|      0|    table___0->n_buckets = compute_bucket_size(candidate, tuning);
 3533|      0|    if (!table___0->n_buckets) {
 3534|      0|      goto fail;
 3535|      0|    }
 3536|      0|    table___0->bucket = (struct hash_entry *)calloc(
 3537|      0|        table___0->n_buckets, sizeof(*(table___0->bucket)));
 3538|      0|    if ((unsigned long)table___0->bucket == (unsigned long)((void *)0)) {
 3539|      0|      goto fail;
 3540|      0|    }
 3541|      0|    table___0->bucket_limit =
 3542|      0|        (struct hash_entry const *)(table___0->bucket + table___0->n_buckets);
 3543|      0|    table___0->n_buckets_used = (size_t)0;
 3544|      0|    table___0->n_entries = (size_t)0;
 3545|      0|    table___0->hasher = hasher;
 3546|      0|    table___0->comparator = comparator;
 3547|      0|    table___0->data_freer = data_freer;
 3548|      0|    table___0->free_entry_list = (struct hash_entry *)((void *)0);
 3549|      0|    return (table___0);
 3550|      0|  fail:
 3551|      0|    free((void *)table___0);
 3552|      0|    return ((Hash_table *)((void *)0));
 3553|      0|  }
 3554|      0|}
 3555|      0|void hash_free(Hash_table *table___0) {
 3556|      0|  struct hash_entry *bucket;
 3557|      0|  struct hash_entry *cursor;
 3558|      0|  struct hash_entry *next;
 3559|       |
 3560|      0|  {
 3561|      0|    if (table___0->data_freer) {
 3562|      0|      if (table___0->n_entries) {
 3563|      0|        bucket = table___0->bucket;
 3564|      0|        while (1) {
 3565|       |
 3566|      0|          if (!((unsigned long)bucket <
 3567|      0|                (unsigned long)table___0->bucket_limit)) {
 3568|      0|            goto while_break;
 3569|      0|          }
 3570|      0|          if (bucket->data) {
 3571|      0|            cursor = bucket;
 3572|      0|            while (1) {
 3573|       |
 3574|      0|              if (!cursor) {
 3575|      0|                goto while_break___0;
 3576|      0|              }
 3577|      0|              (*(table___0->data_freer))(cursor->data);
 3578|      0|              cursor = cursor->next;
 3579|      0|            }
 3580|      0|          while_break___0:;
 3581|      0|          }
 3582|      0|          bucket++;
 3583|      0|        }
 3584|      0|      while_break:;
 3585|      0|      }
 3586|      0|    }
 3587|      0|    bucket = table___0->bucket;
 3588|      0|    while (1) {
 3589|       |
 3590|      0|      if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3591|      0|        goto while_break___1;
 3592|      0|      }
 3593|      0|      cursor = bucket->next;
 3594|      0|      while (1) {
 3595|       |
 3596|      0|        if (!cursor) {
 3597|      0|          goto while_break___2;
 3598|      0|        }
 3599|      0|        next = cursor->next;
 3600|      0|        free((void *)cursor);
 3601|      0|        cursor = next;
 3602|      0|      }
 3603|      0|    while_break___2:
 3604|      0|      bucket++;
 3605|      0|    }
 3606|      0|  while_break___1:
 3607|      0|    cursor = table___0->free_entry_list;
 3608|      0|    while (1) {
 3609|       |
 3610|      0|      if (!cursor) {
 3611|      0|        goto while_break___3;
 3612|      0|      }
 3613|      0|      next = cursor->next;
 3614|      0|      free((void *)cursor);
 3615|      0|      cursor = next;
 3616|      0|    }
 3617|      0|  while_break___3:
 3618|      0|    free((void *)table___0->bucket);
 3619|      0|    free((void *)table___0);
 3620|      0|    return;
 3621|      0|  }
 3622|      0|}
 3623|      0|static struct hash_entry *allocate_entry(Hash_table *table___0) {
 3624|      0|  struct hash_entry *new;
 3625|       |
 3626|      0|  {
 3627|      0|    if (table___0->free_entry_list) {
 3628|      0|      new = table___0->free_entry_list;
 3629|      0|      table___0->free_entry_list = new->next;
 3630|      0|    } else {
 3631|      0|      new = (struct hash_entry *)malloc(sizeof(*new));
 3632|      0|    }
 3633|      0|    return (new);
 3634|      0|  }
 3635|      0|}
 3636|      0|static void free_entry(Hash_table *table___0, struct hash_entry *entry) {
 3637|       |
 3638|      0|  {
 3639|      0|    entry->data = (void *)0;
 3640|      0|    entry->next = table___0->free_entry_list;
 3641|      0|    table___0->free_entry_list = entry;
 3642|      0|    return;
 3643|      0|  }
 3644|      0|}
 3645|       |static void *hash_find_entry(Hash_table *table___0, void const *entry,
 3646|      0|                             struct hash_entry **bucket_head, _Bool delete) {
 3647|      0|  struct hash_entry *bucket;
 3648|      0|  size_t tmp;
 3649|      0|  struct hash_entry *cursor;
 3650|      0|  void *data;
 3651|      0|  struct hash_entry *next;
 3652|      0|  _Bool tmp___0;
 3653|      0|  void *data___0;
 3654|      0|  struct hash_entry *next___0;
 3655|      0|  _Bool tmp___1;
 3656|       |
 3657|      0|  {
 3658|      0|    tmp = (*(table___0->hasher))(entry, table___0->n_buckets);
 3659|      0|    bucket = table___0->bucket + tmp;
 3660|      0|    if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3661|      0|      abort();
 3662|      0|    }
 3663|      0|    *bucket_head = bucket;
 3664|      0|    if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
 3665|      0|      return ((void *)0);
 3666|      0|    }
 3667|      0|    if ((unsigned long)entry == (unsigned long)bucket->data) {
 3668|      0|      goto _L;
 3669|      0|    } else {
 3670|      0|      tmp___0 = (*(table___0->comparator))(entry, (void const *)bucket->data);
 3671|      0|      if (tmp___0) {
 3672|      0|      _L:
 3673|      0|        data = bucket->data;
 3674|      0|        if (delete) {
 3675|      0|          if (bucket->next) {
 3676|      0|            next = bucket->next;
 3677|      0|            *bucket = *next;
 3678|      0|            free_entry(table___0, next);
 3679|      0|          } else {
 3680|      0|            bucket->data = (void *)0;
 3681|      0|          }
 3682|      0|        }
 3683|      0|        return (data);
 3684|      0|      }
 3685|      0|    }
 3686|      0|    cursor = bucket;
 3687|      0|    while (1) {
 3688|       |
 3689|      0|      if (!cursor->next) {
 3690|      0|        goto while_break;
 3691|      0|      }
 3692|      0|      if ((unsigned long)entry == (unsigned long)(cursor->next)->data) {
 3693|      0|        goto _L___0;
 3694|      0|      } else {
 3695|      0|        tmp___1 = (*(table___0->comparator))(
 3696|      0|            entry, (void const *)(cursor->next)->data);
 3697|      0|        if (tmp___1) {
 3698|      0|        _L___0:
 3699|      0|          data___0 = (cursor->next)->data;
 3700|      0|          if (delete) {
 3701|      0|            next___0 = cursor->next;
 3702|      0|            cursor->next = next___0->next;
 3703|      0|            free_entry(table___0, next___0);
 3704|      0|          }
 3705|      0|          return (data___0);
 3706|      0|        }
 3707|      0|      }
 3708|      0|      cursor = cursor->next;
 3709|      0|    }
 3710|      0|  while_break:;
 3711|      0|    return ((void *)0);
 3712|      0|  }
 3713|      0|}
 3714|      0|static _Bool transfer_entries(Hash_table *dst, Hash_table *src, _Bool safe) {
 3715|      0|  struct hash_entry *bucket;
 3716|      0|  struct hash_entry *cursor;
 3717|      0|  struct hash_entry *next;
 3718|      0|  void *data;
 3719|      0|  struct hash_entry *new_bucket;
 3720|      0|  size_t tmp;
 3721|      0|  size_t tmp___0;
 3722|      0|  struct hash_entry *new_entry;
 3723|      0|  struct hash_entry *tmp___1;
 3724|       |
 3725|      0|  {
 3726|      0|    bucket = src->bucket;
 3727|      0|    while (1) {
 3728|       |
 3729|      0|      if (!((unsigned long)bucket < (unsigned long)src->bucket_limit)) {
 3730|      0|        goto while_break;
 3731|      0|      }
 3732|      0|      if (bucket->data) {
 3733|      0|        cursor = bucket->next;
 3734|      0|        while (1) {
 3735|       |
 3736|      0|          if (!cursor) {
 3737|      0|            goto while_break___0;
 3738|      0|          }
 3739|      0|          data = cursor->data;
 3740|      0|          tmp = (*(dst->hasher))((void const *)data, dst->n_buckets);
 3741|      0|          new_bucket = dst->bucket + tmp;
 3742|      0|          if (!((unsigned long)new_bucket < (unsigned long)dst->bucket_limit)) {
 3743|      0|            abort();
 3744|      0|          }
 3745|      0|          next = cursor->next;
 3746|      0|          if (new_bucket->data) {
 3747|      0|            cursor->next = new_bucket->next;
 3748|      0|            new_bucket->next = cursor;
 3749|      0|          } else {
 3750|      0|            new_bucket->data = data;
 3751|      0|            (dst->n_buckets_used)++;
 3752|      0|            free_entry(dst, cursor);
 3753|      0|          }
 3754|      0|          cursor = next;
 3755|      0|        }
 3756|      0|      while_break___0:
 3757|      0|        data = bucket->data;
 3758|      0|        bucket->next = (struct hash_entry *)((void *)0);
 3759|      0|        if (safe) {
 3760|      0|          goto __Cont;
 3761|      0|        }
 3762|      0|        tmp___0 = (*(dst->hasher))((void const *)data, dst->n_buckets);
 3763|      0|        new_bucket = dst->bucket + tmp___0;
 3764|      0|        if (!((unsigned long)new_bucket < (unsigned long)dst->bucket_limit)) {
 3765|      0|          abort();
 3766|      0|        }
 3767|      0|        if (new_bucket->data) {
 3768|      0|          tmp___1 = allocate_entry(dst);
 3769|      0|          new_entry = tmp___1;
 3770|      0|          if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 3771|      0|            return ((_Bool)0);
 3772|      0|          }
 3773|      0|          new_entry->data = data;
 3774|      0|          new_entry->next = new_bucket->next;
 3775|      0|          new_bucket->next = new_entry;
 3776|      0|        } else {
 3777|      0|          new_bucket->data = data;
 3778|      0|          (dst->n_buckets_used)++;
 3779|      0|        }
 3780|      0|        bucket->data = (void *)0;
 3781|      0|        (src->n_buckets_used)--;
 3782|      0|      }
 3783|      0|    __Cont:
 3784|      0|      bucket++;
 3785|      0|    }
 3786|      0|  while_break:;
 3787|      0|    return ((_Bool)1);
 3788|      0|  }
 3789|      0|}
 3790|       |_Bool(__attribute__((__warn_unused_result__)) hash_rehash)(
 3791|      0|    Hash_table *table___0, size_t candidate) {
 3792|      0|  Hash_table storage;
 3793|      0|  Hash_table *new_table;
 3794|      0|  size_t new_size;
 3795|      0|  size_t tmp;
 3796|      0|  _Bool tmp___0;
 3797|      0|  _Bool tmp___1;
 3798|      0|  _Bool tmp___2;
 3799|       |
 3800|      0|  {
 3801|      0|    tmp = compute_bucket_size(candidate, table___0->tuning);
 3802|      0|    new_size = tmp;
 3803|      0|    if (!new_size) {
 3804|      0|      return ((_Bool)0);
 3805|      0|    }
 3806|      0|    if (new_size == table___0->n_buckets) {
 3807|      0|      return ((_Bool)1);
 3808|      0|    }
 3809|      0|    new_table = &storage;
 3810|      0|    new_table->bucket =
 3811|      0|        (struct hash_entry *)calloc(new_size, sizeof(*(new_table->bucket)));
 3812|      0|    if ((unsigned long)new_table->bucket == (unsigned long)((void *)0)) {
 3813|      0|      return ((_Bool)0);
 3814|      0|    }
 3815|      0|    new_table->n_buckets = new_size;
 3816|      0|    new_table->bucket_limit =
 3817|      0|        (struct hash_entry const *)(new_table->bucket + new_size);
 3818|      0|    new_table->n_buckets_used = (size_t)0;
 3819|      0|    new_table->n_entries = (size_t)0;
 3820|      0|    new_table->tuning = table___0->tuning;
 3821|      0|    new_table->hasher = table___0->hasher;
 3822|      0|    new_table->comparator = table___0->comparator;
 3823|      0|    new_table->data_freer = table___0->data_freer;
 3824|      0|    new_table->free_entry_list = table___0->free_entry_list;
 3825|      0|    tmp___0 = transfer_entries(new_table, table___0, (_Bool)0);
 3826|      0|    if (tmp___0) {
 3827|      0|      free((void *)table___0->bucket);
 3828|      0|      table___0->bucket = new_table->bucket;
 3829|      0|      table___0->bucket_limit = new_table->bucket_limit;
 3830|      0|      table___0->n_buckets = new_table->n_buckets;
 3831|      0|      table___0->n_buckets_used = new_table->n_buckets_used;
 3832|      0|      table___0->free_entry_list = new_table->free_entry_list;
 3833|      0|      return ((_Bool)1);
 3834|      0|    }
 3835|      0|    table___0->free_entry_list = new_table->free_entry_list;
 3836|      0|    tmp___1 = transfer_entries(table___0, new_table, (_Bool)1);
 3837|      0|    if (tmp___1) {
 3838|      0|      tmp___2 = transfer_entries(table___0, new_table, (_Bool)0);
 3839|      0|      if (!tmp___2) {
 3840|      0|        abort();
 3841|      0|      }
 3842|      0|    } else {
 3843|      0|      abort();
 3844|      0|    }
 3845|      0|    free((void *)new_table->bucket);
 3846|      0|    return ((_Bool)0);
 3847|      0|  }
 3848|      0|}
 3849|       |void *(__attribute__((__warn_unused_result__)) hash_insert)(
 3850|      0|    Hash_table *table___0, void const *entry) {
 3851|      0|  void *data;
 3852|      0|  struct hash_entry *bucket;
 3853|      0|  Hash_tuning const *tuning;
 3854|      0|  float candidate;
 3855|      0|  float tmp;
 3856|      0|  _Bool tmp___0;
 3857|      0|  void *tmp___1;
 3858|      0|  struct hash_entry *new_entry;
 3859|      0|  struct hash_entry *tmp___2;
 3860|       |
 3861|      0|  {
 3862|      0|    if (!entry) {
 3863|      0|      abort();
 3864|      0|    }
 3865|      0|    data = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 3866|      0|    if ((unsigned long)data != (unsigned long)((void *)0)) {
 3867|      0|      return (data);
 3868|      0|    }
 3869|      0|    if ((float const)table___0->n_buckets_used >
 3870|      0|        (table___0->tuning)->growth_threshold *
 3871|      0|            (float const)table___0->n_buckets) {
 3872|      0|      check_tuning(table___0);
 3873|      0|      if ((float const)table___0->n_buckets_used >
 3874|      0|          (table___0->tuning)->growth_threshold *
 3875|      0|              (float const)table___0->n_buckets) {
 3876|      0|        tuning = table___0->tuning;
 3877|      0|        if (tuning->is_n_buckets) {
 3878|      0|          tmp = (float)((float const)table___0->n_buckets *
 3879|      0|                        tuning->growth_factor);
 3880|      0|        } else {
 3881|      0|          tmp = (float)(((float const)table___0->n_buckets *
 3882|      0|                         tuning->growth_factor) *
 3883|      0|                        tuning->growth_threshold);
 3884|      0|        }
 3885|      0|        candidate = tmp;
 3886|      0|        if ((float)0xffffffffffffffffUL <= candidate) {
 3887|      0|          return ((void *)0);
 3888|      0|        }
 3889|      0|        tmp___0 = hash_rehash(table___0, (size_t)candidate);
 3890|      0|        if (!tmp___0) {
 3891|      0|          return ((void *)0);
 3892|      0|        }
 3893|      0|        tmp___1 = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 3894|      0|        if ((unsigned long)tmp___1 != (unsigned long)((void *)0)) {
 3895|      0|          abort();
 3896|      0|        }
 3897|      0|      }
 3898|      0|    }
 3899|      0|    if (bucket->data) {
 3900|      0|      tmp___2 = allocate_entry(table___0);
 3901|      0|      new_entry = tmp___2;
 3902|      0|      if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 3903|      0|        return ((void *)0);
 3904|      0|      }
 3905|      0|      new_entry->data = (void *)entry;
 3906|      0|      new_entry->next = bucket->next;
 3907|      0|      bucket->next = new_entry;
 3908|      0|      (table___0->n_entries)++;
 3909|      0|      return ((void *)entry);
 3910|      0|    }
 3911|      0|    bucket->data = (void *)entry;
 3912|      0|    (table___0->n_entries)++;
 3913|      0|    (table___0->n_buckets_used)++;
 3914|      0|    return ((void *)entry);
 3915|      0|  }
 3916|      0|}
 3917|      0|void *hash_delete(Hash_table *table___0, void const *entry) {
 3918|      0|  void *data;
 3919|      0|  struct hash_entry *bucket;
 3920|      0|  Hash_tuning const *tuning;
 3921|      0|  size_t candidate;
 3922|      0|  float tmp;
 3923|      0|  struct hash_entry *cursor;
 3924|      0|  struct hash_entry *next;
 3925|      0|  _Bool tmp___0;
 3926|       |
 3927|      0|  {
 3928|      0|    data = hash_find_entry(table___0, entry, &bucket, (_Bool)1);
 3929|      0|    if (!data) {
 3930|      0|      return ((void *)0);
 3931|      0|    }
 3932|      0|    (table___0->n_entries)--;
 3933|      0|    if (!bucket->data) {
 3934|      0|      (table___0->n_buckets_used)--;
 3935|      0|      if ((float const)table___0->n_buckets_used <
 3936|      0|          (table___0->tuning)->shrink_threshold *
 3937|      0|              (float const)table___0->n_buckets) {
 3938|      0|        check_tuning(table___0);
 3939|      0|        if ((float const)table___0->n_buckets_used <
 3940|      0|            (table___0->tuning)->shrink_threshold *
 3941|      0|                (float const)table___0->n_buckets) {
 3942|      0|          tuning = table___0->tuning;
 3943|      0|          if (tuning->is_n_buckets) {
 3944|      0|            tmp = (float)((float const)table___0->n_buckets *
 3945|      0|                          tuning->shrink_factor);
 3946|      0|          } else {
 3947|      0|            tmp = (float)(((float const)table___0->n_buckets *
 3948|      0|                           tuning->shrink_factor) *
 3949|      0|                          tuning->growth_threshold);
 3950|      0|          }
 3951|      0|          candidate = (size_t)tmp;
 3952|      0|          tmp___0 = hash_rehash(table___0, candidate);
 3953|      0|          if (!tmp___0) {
 3954|      0|            cursor = table___0->free_entry_list;
 3955|      0|            while (1) {
 3956|       |
 3957|      0|              if (!cursor) {
 3958|      0|                goto while_break;
 3959|      0|              }
 3960|      0|              next = cursor->next;
 3961|      0|              free((void *)cursor);
 3962|      0|              cursor = next;
 3963|      0|            }
 3964|      0|          while_break:;
 3965|      0|            table___0->free_entry_list = (struct hash_entry *)((void *)0);
 3966|      0|          }
 3967|      0|        }
 3968|      0|      }
 3969|      0|    }
 3970|      0|    return (data);
 3971|      0|  }
 3972|      0|}
 3973|       |size_t hash_pjw(void const *x, size_t tablesize);
 3974|      0|size_t triple_hash(void const *x, size_t table_size) {
 3975|      0|  struct F_triple const *p;
 3976|      0|  size_t tmp;
 3977|      0|  size_t tmp___0;
 3978|       |
 3979|      0|  {
 3980|      0|    p = (struct F_triple const *)x;
 3981|      0|    tmp___0 = hash_pjw((void const *)p->name, table_size);
 3982|      0|    tmp = tmp___0;
 3983|      0|    return ((tmp ^ (unsigned long)p->st_ino) % table_size);
 3984|      0|  }
 3985|      0|}
 3986|      0|_Bool triple_compare_ino_str(void const *x, void const *y) {
 3987|      0|  struct F_triple const *a;
 3988|      0|  struct F_triple const *b;
 3989|      0|  int tmp___0;
 3990|      0|  int tmp___1;
 3991|       |
 3992|      0|  {
 3993|      0|    a = (struct F_triple const *)x;
 3994|      0|    b = (struct F_triple const *)y;
 3995|      0|    if (a->st_ino == b->st_ino) {
 3996|      0|      if (a->st_dev == b->st_dev) {
 3997|      0|        tmp___1 = strcmp((char const *)a->name, (char const *)b->name);
 3998|      0|        if (tmp___1 == 0) {
 3999|      0|          tmp___0 = 1;
 4000|      0|        } else {
 4001|      0|          tmp___0 = 0;
 4002|      0|        }
 4003|      0|      } else {
 4004|      0|        tmp___0 = 0;
 4005|      0|      }
 4006|      0|    } else {
 4007|      0|      tmp___0 = 0;
 4008|      0|    }
 4009|      0|    return ((_Bool)tmp___0);
 4010|      0|  }
 4011|      0|}
 4012|      0|void triple_free(void *x) {
 4013|      0|  struct F_triple *a;
 4014|       |
 4015|      0|  {
 4016|      0|    a = (struct F_triple *)x;
 4017|      0|    free((void *)a->name);
 4018|      0|    free((void *)a);
 4019|      0|    return;
 4020|      0|  }
 4021|      0|}
 4022|      0|size_t hash_pjw(void const *x, size_t tablesize) {
 4023|      0|  char const *s;
 4024|      0|  size_t h;
 4025|       |
 4026|      0|  {
 4027|      0|    h = (size_t)0;
 4028|      0|    s = (char const *)x;
 4029|      0|    while (1) {
 4030|       |
 4031|      0|      if (!*s) {
 4032|      0|        goto while_break;
 4033|      0|      }
 4034|      0|      h = (unsigned long)*s + ((h << 9) | (h >> (sizeof(size_t) * 8UL - 9UL)));
 4035|      0|      s++;
 4036|      0|    }
 4037|      0|  while_break:;
 4038|      0|    return (h % tablesize);
 4039|      0|  }
 4040|      0|}
 4041|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) setlocale)(
 4042|       |    int __category, char const *__locale);
 4043|       |extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2, 3),
 4044|       |                                                       __leaf__)) fstatat)(
 4045|       |    int __fd, char const *__restrict __file, struct stat *__restrict __buf,
 4046|       |    int __flag);
 4047|       |__attribute__((__nothrow__)) int(__attribute__((__warn_unused_result__,
 4048|       |                                                __leaf__)) fts_close)(FTS *sp);
 4049|       |__attribute__((__nothrow__))
 4050|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp);
 4051|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__)) fts_set)(
 4052|       |    FTS *sp __attribute__((__unused__)), FTSENT *p, int instr);
 4053|       |extern void(__attribute__((__nonnull__(1, 4))) qsort)(
 4054|       |    void *__base, size_t __nmemb, size_t __size,
 4055|       |    int (*__compar)(void const *, void const *));
 4056|       |static FTSENT *fts_alloc(FTS *sp, char const *name, size_t namelen);
 4057|       |static FTSENT *fts_build(FTS *sp, int type);
 4058|       |static void fts_lfree(FTSENT *head);
 4059|       |static void fts_load(FTS *sp, FTSENT *p);
 4060|       |static size_t fts_maxarglen(char *const *argv);
 4061|       |static void fts_padjust(FTS *sp, FTSENT *head);
 4062|       |static _Bool fts_palloc(FTS *sp, size_t more);
 4063|       |static FTSENT *fts_sort(FTS *sp, FTSENT *head, size_t nitems);
 4064|       |static unsigned short fts_stat(FTS *sp, FTSENT *p, _Bool follow);
 4065|       |static int fts_safe_changedir(FTS *sp, FTSENT *p, int fd, char const *dir);
 4066|      0|static _Bool AD_compare(void const *x, void const *y) {
 4067|      0|  struct Active_dir const *ax;
 4068|      0|  struct Active_dir const *ay;
 4069|      0|  int tmp;
 4070|       |
 4071|      0|  {
 4072|      0|    ax = (struct Active_dir const *)x;
 4073|      0|    ay = (struct Active_dir const *)y;
 4074|      0|    if (ax->ino == ay->ino) {
 4075|      0|      if (ax->dev == ay->dev) {
 4076|      0|        tmp = 1;
 4077|      0|      } else {
 4078|      0|        tmp = 0;
 4079|      0|      }
 4080|      0|    } else {
 4081|      0|      tmp = 0;
 4082|      0|    }
 4083|      0|    return ((_Bool)tmp);
 4084|      0|  }
 4085|      0|}
 4086|      0|static size_t AD_hash(void const *x, size_t table_size) {
 4087|      0|  struct Active_dir const *ax;
 4088|       |
 4089|      0|  {
 4090|      0|    ax = (struct Active_dir const *)x;
 4091|      0|    return ((uintmax_t)ax->ino % table_size);
 4092|      0|  }
 4093|      0|}
 4094|      4|static _Bool setup_dir(FTS *fts) {
 4095|       |
 4096|      4|  {
 4097|      4|    if (fts->fts_options & 258) {
 4098|      0|      fts->fts_cycle.ht =
 4099|      0|          hash_initialize((size_t)31, (Hash_tuning const *)((void *)0),
 4100|      0|                          &AD_hash, &AD_compare, (void (*)(void *))(&free));
 4101|      0|      if (!fts->fts_cycle.ht) {
 4102|      0|        return ((_Bool)0);
 4103|      0|      }
 4104|      4|    } else {
 4105|      4|      fts->fts_cycle.state =
 4106|      4|          (struct cycle_check_state *)malloc(sizeof(*(fts->fts_cycle.state)));
 4107|      4|      if (!fts->fts_cycle.state) {
 4108|      0|        return ((_Bool)0);
 4109|      0|      }
 4110|      4|      cycle_check_init(fts->fts_cycle.state);
 4111|      4|    }
 4112|      4|    return ((_Bool)1);
 4113|      4|  }
 4114|      4|}
 4115|      2|static _Bool enter_dir(FTS *fts, FTSENT *ent) {
 4116|      2|  struct stat const *st;
 4117|      2|  struct Active_dir *ad;
 4118|      2|  struct Active_dir *tmp;
 4119|      2|  struct Active_dir *ad_from_table;
 4120|      2|  _Bool tmp___0;
 4121|       |
 4122|      2|  {
 4123|      2|    if (fts->fts_options & 258) {
 4124|      0|      st = (struct stat const *)(ent->fts_statp);
 4125|      0|      tmp = (struct Active_dir *)malloc(sizeof(*ad));
 4126|      0|      ad = tmp;
 4127|      0|      if (!ad) {
 4128|      0|        return ((_Bool)0);
 4129|      0|      }
 4130|      0|      ad->dev = (dev_t)st->st_dev;
 4131|      0|      ad->ino = (ino_t)st->st_ino;
 4132|      0|      ad->fts_ent = ent;
 4133|      0|      ad_from_table =
 4134|      0|          (struct Active_dir *)hash_insert(fts->fts_cycle.ht, (void const *)ad);
 4135|      0|      if ((unsigned long)ad_from_table != (unsigned long)ad) {
 4136|      0|        free((void *)ad);
 4137|      0|        if (!ad_from_table) {
 4138|      0|          return ((_Bool)0);
 4139|      0|        }
 4140|      0|        ent->fts_cycle = ad_from_table->fts_ent;
 4141|      0|        ent->fts_info = (unsigned short)2;
 4142|      0|      }
 4143|      2|    } else {
 4144|      2|      tmp___0 = cycle_check(fts->fts_cycle.state,
 4145|      2|                            (struct stat const *)(ent->fts_statp));
 4146|      2|      if (tmp___0) {
 4147|      0|        ent->fts_cycle = ent;
 4148|      0|        ent->fts_info = (unsigned short)2;
 4149|      0|      }
 4150|      2|    }
 4151|      2|    return ((_Bool)1);
 4152|      2|  }
 4153|      2|}
 4154|      2|static void leave_dir(FTS *fts, FTSENT *ent) {
 4155|      2|  struct stat const *st;
 4156|      2|  struct Active_dir obj;
 4157|      2|  void *found;
 4158|      2|  FTSENT *parent;
 4159|       |
 4160|      2|  {
 4161|      2|    st = (struct stat const *)(ent->fts_statp);
 4162|      2|    if (fts->fts_options & 258) {
 4163|      0|      obj.dev = (dev_t)st->st_dev;
 4164|      0|      obj.ino = (ino_t)st->st_ino;
 4165|      0|      found = hash_delete(fts->fts_cycle.ht, (void const *)(&obj));
 4166|      0|      if (!found) {
 4167|      0|        abort();
 4168|      0|      }
 4169|      0|      free(found);
 4170|      2|    } else {
 4171|      2|      parent = ent->fts_parent;
 4172|      2|      if ((unsigned long)parent != (unsigned long)((void *)0)) {
 4173|      2|        if (0L <= parent->fts_level) {
 4174|      0|          while (1) {
 4175|       |
 4176|      0|            if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
 4177|      0|              abort();
 4178|      0|            }
 4179|      0|            if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t)st->st_ino) {
 4180|      0|              if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t)st->st_dev) {
 4181|      0|                (fts->fts_cycle.state)->dev_ino.st_dev =
 4182|      0|                    parent->fts_statp[0].st_dev;
 4183|      0|                (fts->fts_cycle.state)->dev_ino.st_ino =
 4184|      0|                    parent->fts_statp[0].st_ino;
 4185|      0|              }
 4186|      0|            }
 4187|      0|            goto while_break;
 4188|      0|          }
 4189|      0|        while_break:;
 4190|      0|        }
 4191|      2|      }
 4192|      2|    }
 4193|      2|    return;
 4194|      2|  }
 4195|      2|}
 4196|      4|static void free_dir(FTS *sp) {
 4197|       |
 4198|      4|  {
 4199|      4|    if (sp->fts_options & 258) {
 4200|      0|      if (sp->fts_cycle.ht) {
 4201|      0|        hash_free(sp->fts_cycle.ht);
 4202|      0|      }
 4203|      4|    } else {
 4204|      4|      free((void *)sp->fts_cycle.state);
 4205|      4|    }
 4206|      4|    return;
 4207|      4|  }
 4208|      4|}
 4209|      6|static void fd_ring_clear(I_ring *fd_ring) {
 4210|      6|  int fd;
 4211|      6|  int tmp;
 4212|      6|  _Bool tmp___0;
 4213|       |
 4214|      6|  {
 4215|     12|    while (1) {
 4216|     12|      tmp___0 = i_ring_empty((I_ring const *)fd_ring);
 4217|     12|      if (tmp___0) {
 4218|      6|        goto while_break;
 4219|      6|      }
 4220|      6|      tmp = i_ring_pop(fd_ring);
 4221|      6|      fd = tmp;
 4222|      6|      if (0 <= fd) {
 4223|      2|        close(fd);
 4224|      2|      }
 4225|      6|    }
 4226|      6|  while_break:;
 4227|      6|    return;
 4228|      6|  }
 4229|      6|}
 4230|      2|static void fts_set_stat_required(FTSENT *p, _Bool required) {
 4231|       |
 4232|      2|  {
 4233|      2|    while (1) {
 4234|       |
 4235|      2|      if (!((int)p->fts_info == 11)) {
 4236|      0|        abort();
 4237|      0|      }
 4238|      2|      goto while_break;
 4239|      2|    }
 4240|      2|  while_break:;
 4241|      2|    if (required) {
 4242|      0|      p->fts_statp[0].st_size = (__off_t)2;
 4243|      2|    } else {
 4244|      2|      p->fts_statp[0].st_size = (__off_t)1;
 4245|      2|    }
 4246|      2|    return;
 4247|      2|  }
 4248|      2|}
 4249|      2|__inline static DIR *opendirat(int fd, char const *dir) {
 4250|      2|  int new_fd;
 4251|      2|  int tmp;
 4252|      2|  DIR *dirp;
 4253|      2|  int saved_errno;
 4254|      2|  int *tmp___0;
 4255|      2|  int *tmp___1;
 4256|       |
 4257|      2|  {
 4258|      2|    tmp = openat_safer(fd, dir, 67840);
 4259|      2|    new_fd = tmp;
 4260|      2|    if (new_fd < 0) {
 4261|      0|      return ((DIR *)((void *)0));
 4262|      0|    }
 4263|      2|    set_cloexec_flag(new_fd, (_Bool)1);
 4264|      2|    dirp = rpl_fdopendir(new_fd);
 4265|      2|    if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 4266|      0|      tmp___0 = __errno_location();
 4267|      0|      saved_errno = *tmp___0;
 4268|      0|      close(new_fd);
 4269|      0|      tmp___1 = __errno_location();
 4270|      0|      *tmp___1 = saved_errno;
 4271|      0|    }
 4272|      2|    return (dirp);
 4273|      2|  }
 4274|      2|}
 4275|      6|static void cwd_advance_fd(FTS *sp, int fd, _Bool chdir_down_one) {
 4276|      6|  int old;
 4277|      6|  int prev_fd_in_slot;
 4278|      6|  int tmp;
 4279|       |
 4280|      6|  {
 4281|      6|    old = sp->fts_cwd_fd;
 4282|      6|    while (1) {
 4283|       |
 4284|      6|      if (!(old != fd)) {
 4285|      2|        if (!(old == -100)) {
 4286|      0|          abort();
 4287|      0|        }
 4288|      2|      }
 4289|      6|      goto while_break;
 4290|      6|    }
 4291|      6|  while_break:;
 4292|      6|    if (chdir_down_one) {
 4293|      6|      tmp = i_ring_push(&sp->fts_fd_ring, old);
 4294|      6|      prev_fd_in_slot = tmp;
 4295|      6|      if (0 <= prev_fd_in_slot) {
 4296|      0|        close(prev_fd_in_slot);
 4297|      0|      }
 4298|      6|    } else {
 4299|      0|      if (!(sp->fts_options & 4)) {
 4300|      0|        if (0 <= old) {
 4301|      0|          close(old);
 4302|      0|        }
 4303|      0|      }
 4304|      0|    }
 4305|      6|    sp->fts_cwd_fd = fd;
 4306|      6|    return;
 4307|      6|  }
 4308|      6|}
 4309|      0|__inline static int diropen(FTS const *sp, char const *dir) {
 4310|      0|  int open_flags;
 4311|      0|  int tmp;
 4312|      0|  int fd;
 4313|      0|  int tmp___0;
 4314|      0|  int tmp___1;
 4315|      0|  int tmp___2;
 4316|       |
 4317|      0|  {
 4318|      0|    if (sp->fts_options & 16) {
 4319|      0|      tmp = 131072;
 4320|      0|    } else {
 4321|      0|      tmp = 0;
 4322|      0|    }
 4323|      0|    open_flags = 67840 | tmp;
 4324|      0|    if (sp->fts_options & 512) {
 4325|      0|      tmp___0 = openat_safer((int)sp->fts_cwd_fd, dir, open_flags);
 4326|      0|      tmp___2 = tmp___0;
 4327|      0|    } else {
 4328|      0|      tmp___1 = open_safer(dir, open_flags);
 4329|      0|      tmp___2 = tmp___1;
 4330|      0|    }
 4331|      0|    fd = tmp___2;
 4332|      0|    if (0 <= fd) {
 4333|      0|      set_cloexec_flag(fd, (_Bool)1);
 4334|      0|    }
 4335|      0|    return (fd);
 4336|      0|  }
 4337|      0|}
 4338|       |__attribute__((__nothrow__))
 4339|       |FTS *(__attribute__((__warn_unused_result__, __leaf__)) fts_open)(
 4340|       |    char *const *argv, int options,
 4341|       |    int (*compar)(FTSENT const **, FTSENT const **));
 4342|       |FTS *(__attribute__((__warn_unused_result__, __leaf__)) fts_open)(
 4343|       |    char *const *argv, int options,
 4344|      2|    int (*compar)(FTSENT const **, FTSENT const **)) {
 4345|      2|  FTS *sp;
 4346|      2|  FTSENT *p;
 4347|      2|  FTSENT *root;
 4348|      2|  size_t nitems;
 4349|      2|  FTSENT *parent;
 4350|      2|  FTSENT *tmp;
 4351|      2|  _Bool defer_stat;
 4352|      2|  int *tmp___0;
 4353|      2|  int *tmp___1;
 4354|      2|  int *tmp___2;
 4355|      2|  size_t maxarglen;
 4356|      2|  size_t tmp___4;
 4357|      2|  size_t tmp___5;
 4358|      2|  _Bool tmp___6;
 4359|      2|  int tmp___7;
 4360|      2|  size_t len;
 4361|      2|  size_t tmp___8;
 4362|      2|  struct _ftsent *tmp___9;
 4363|      2|  _Bool tmp___10;
 4364|      2|  int tmp___11;
 4365|       |
 4366|      2|  {
 4367|      2|    parent = (FTSENT *)((void *)0);
 4368|      2|    tmp = (FTSENT *)((void *)0);
 4369|      2|    if (options & -2048) {
 4370|      0|      tmp___0 = __errno_location();
 4371|      0|      *tmp___0 = 22;
 4372|      0|      return ((FTS *)((void *)0));
 4373|      0|    }
 4374|      2|    if (options & 4) {
 4375|      0|      if (options & 512) {
 4376|      0|        tmp___1 = __errno_location();
 4377|      0|        *tmp___1 = 22;
 4378|      0|        return ((FTS *)((void *)0));
 4379|      0|      }
 4380|      0|    }
 4381|      2|    if (!(options & 18)) {
 4382|      0|      tmp___2 = __errno_location();
 4383|      0|      *tmp___2 = 22;
 4384|      0|      return ((FTS *)((void *)0));
 4385|      0|    }
 4386|      2|    sp = (FTS *)malloc(sizeof(FTS));
 4387|      2|    if ((unsigned long)sp == (unsigned long)((void *)0)) {
 4388|      0|      return ((FTS *)((void *)0));
 4389|      0|    }
 4390|      2|    memset((void *)sp, 0, sizeof(FTS));
 4391|      2|    sp->fts_compar = compar;
 4392|      2|    sp->fts_options = options;
 4393|      2|    if (sp->fts_options & 2) {
 4394|      0|      sp->fts_options |= 4;
 4395|      0|      sp->fts_options &= -513;
 4396|      0|    }
 4397|      2|    sp->fts_cwd_fd = -100;
 4398|      2|    tmp___4 = fts_maxarglen(argv);
 4399|      2|    maxarglen = tmp___4;
 4400|      2|    if (maxarglen > 4096UL) {
 4401|      0|      tmp___5 = maxarglen;
 4402|      2|    } else {
 4403|      2|      tmp___5 = (size_t)4096;
 4404|      2|    }
 4405|      2|    tmp___6 = fts_palloc(sp, tmp___5);
 4406|      2|    if (!tmp___6) {
 4407|      0|      goto mem1;
 4408|      0|    }
 4409|      2|    if ((unsigned long)*argv != (unsigned long)((void *)0)) {
 4410|      2|      parent = fts_alloc(sp, "", (size_t)0);
 4411|      2|      if ((unsigned long)parent == (unsigned long)((void *)0)) {
 4412|      0|        goto mem2;
 4413|      0|      }
 4414|      2|      parent->fts_level = (ptrdiff_t)-1;
 4415|      2|    }
 4416|      2|    if ((unsigned long)compar == (unsigned long)((void *)0)) {
 4417|      2|      tmp___7 = 1;
 4418|      2|    } else {
 4419|      0|      if (sp->fts_options & 1024) {
 4420|      0|        tmp___7 = 1;
 4421|      0|      } else {
 4422|      0|        tmp___7 = 0;
 4423|      0|      }
 4424|      0|    }
 4425|      2|    defer_stat = (_Bool)tmp___7;
 4426|      2|    root = (FTSENT *)((void *)0);
 4427|      2|    nitems = (size_t)0;
 4428|      4|    while (1) {
 4429|       |
 4430|      4|      if (!((unsigned long)*argv != (unsigned long)((void *)0))) {
 4431|      2|        goto while_break;
 4432|      2|      }
 4433|      2|      tmp___8 = strlen((char const *)*argv);
 4434|      2|      len = tmp___8;
 4435|      2|      p = fts_alloc(sp, (char const *)*argv, len);
 4436|      2|      if ((unsigned long)p == (unsigned long)((void *)0)) {
 4437|      0|        goto mem3;
 4438|      0|      }
 4439|      2|      p->fts_level = (ptrdiff_t)0;
 4440|      2|      p->fts_parent = parent;
 4441|      2|      p->fts_accpath = p->fts_name;
 4442|      2|      if (defer_stat) {
 4443|      2|        if ((unsigned long)root != (unsigned long)((void *)0)) {
 4444|      0|          p->fts_info = (unsigned short)11;
 4445|      0|          fts_set_stat_required(p, (_Bool)1);
 4446|      2|        } else {
 4447|      2|          p->fts_info = fts_stat(sp, p, (_Bool)0);
 4448|      2|        }
 4449|      2|      } else {
 4450|      0|        p->fts_info = fts_stat(sp, p, (_Bool)0);
 4451|      0|      }
 4452|      2|      if (compar) {
 4453|      0|        p->fts_link = root;
 4454|      0|        root = p;
 4455|      2|      } else {
 4456|      2|        p->fts_link = (struct _ftsent *)((void *)0);
 4457|      2|        if ((unsigned long)root == (unsigned long)((void *)0)) {
 4458|      2|          root = p;
 4459|      2|          tmp = root;
 4460|      2|        } else {
 4461|      0|          tmp->fts_link = p;
 4462|      0|          tmp = p;
 4463|      0|        }
 4464|      2|      }
 4465|      2|      argv++;
 4466|      2|      nitems++;
 4467|      2|    }
 4468|      2|  while_break:;
 4469|      2|    if (compar) {
 4470|      0|      if (nitems > 1UL) {
 4471|      0|        root = fts_sort(sp, root, nitems);
 4472|      0|      }
 4473|      0|    }
 4474|      2|    tmp___9 = fts_alloc(sp, "", (size_t)0);
 4475|      2|    sp->fts_cur = tmp___9;
 4476|      2|    if ((unsigned long)tmp___9 == (unsigned long)((void *)0)) {
 4477|      0|      goto mem3;
 4478|      0|    }
 4479|      2|    (sp->fts_cur)->fts_link = root;
 4480|      2|    (sp->fts_cur)->fts_info = (unsigned short)9;
 4481|      2|    tmp___10 = setup_dir(sp);
 4482|      2|    if (!tmp___10) {
 4483|      0|      goto mem3;
 4484|      0|    }
 4485|      2|    if (!(sp->fts_options & 4)) {
 4486|      2|      if (!(sp->fts_options & 512)) {
 4487|      0|        tmp___11 = diropen((FTS const *)sp, ".");
 4488|      0|        sp->fts_rfd = tmp___11;
 4489|      0|        if (tmp___11 < 0) {
 4490|      0|          sp->fts_options |= 4;
 4491|      0|        }
 4492|      0|      }
 4493|      2|    }
 4494|      2|    i_ring_init(&sp->fts_fd_ring, -1);
 4495|      2|    return (sp);
 4496|      0|  mem3:
 4497|      0|    fts_lfree(root);
 4498|      0|    free((void *)parent);
 4499|      0|  mem2:
 4500|      0|    free((void *)sp->fts_path);
 4501|      0|  mem1:
 4502|      0|    free((void *)sp);
 4503|      0|    return ((FTS *)((void *)0));
 4504|      0|  }
 4505|      0|}
 4506|      2|static void fts_load(FTS *sp, FTSENT *p) {
 4507|      2|  size_t len;
 4508|      2|  char *cp;
 4509|      2|  size_t tmp;
 4510|      2|  char *tmp___0;
 4511|       |
 4512|      2|  {
 4513|      2|    tmp = p->fts_namelen;
 4514|      2|    p->fts_pathlen = tmp;
 4515|      2|    len = tmp;
 4516|      2|    memmove((void *)sp->fts_path, (void const *)(p->fts_name), len + 1UL);
 4517|      2|    cp = strrchr((char const *)(p->fts_name), '/');
 4518|      2|    if (cp) {
 4519|      2|      if ((unsigned long)cp != (unsigned long)(p->fts_name)) {
 4520|      2|        cp++;
 4521|      2|        len = strlen((char const *)cp);
 4522|      2|        memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
 4523|      2|        p->fts_namelen = len;
 4524|      2|      } else {
 4525|      0|        if (*(cp + 1)) {
 4526|      0|          cp++;
 4527|      0|          len = strlen((char const *)cp);
 4528|      0|          memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
 4529|      0|          p->fts_namelen = len;
 4530|      0|        }
 4531|      0|      }
 4532|      2|    }
 4533|      2|    tmp___0 = sp->fts_path;
 4534|      2|    p->fts_path = tmp___0;
 4535|      2|    p->fts_accpath = tmp___0;
 4536|      2|    return;
 4537|      2|  }
 4538|      2|}
 4539|       |__attribute__((__nothrow__)) int(__attribute__((__warn_unused_result__,
 4540|       |                                                __leaf__)) fts_close)(FTS *sp);
 4541|      2|int(__attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp) {
 4542|      2|  FTSENT *freep;
 4543|      2|  FTSENT *p;
 4544|      2|  int saved_errno;
 4545|      2|  int *tmp;
 4546|      2|  int tmp___0;
 4547|      2|  int *tmp___1;
 4548|      2|  int tmp___2;
 4549|      2|  int *tmp___3;
 4550|      2|  int tmp___4;
 4551|      2|  int *tmp___5;
 4552|       |
 4553|      2|  {
 4554|      2|    saved_errno = 0;
 4555|      2|    if (sp->fts_cur) {
 4556|      0|      p = sp->fts_cur;
 4557|      0|      while (1) {
 4558|       |
 4559|      0|        if (!(p->fts_level >= 0L)) {
 4560|      0|          goto while_break;
 4561|      0|        }
 4562|      0|        freep = p;
 4563|      0|        if ((unsigned long)p->fts_link != (unsigned long)((void *)0)) {
 4564|      0|          p = p->fts_link;
 4565|      0|        } else {
 4566|      0|          p = p->fts_parent;
 4567|      0|        }
 4568|      0|        free((void *)freep);
 4569|      0|      }
 4570|      0|    while_break:
 4571|      0|      free((void *)p);
 4572|      0|    }
 4573|      2|    if (sp->fts_child) {
 4574|      0|      fts_lfree(sp->fts_child);
 4575|      0|    }
 4576|      2|    free((void *)sp->fts_array);
 4577|      2|    free((void *)sp->fts_path);
 4578|      2|    if (sp->fts_options & 512) {
 4579|      2|      if (0 <= sp->fts_cwd_fd) {
 4580|      0|        tmp___0 = close(sp->fts_cwd_fd);
 4581|      0|        if (tmp___0) {
 4582|      0|          tmp = __errno_location();
 4583|      0|          saved_errno = *tmp;
 4584|      0|        }
 4585|      0|      }
 4586|      2|    } else {
 4587|      0|      if (!(sp->fts_options & 4)) {
 4588|      0|        tmp___2 = fchdir(sp->fts_rfd);
 4589|      0|        if (tmp___2) {
 4590|      0|          tmp___1 = __errno_location();
 4591|      0|          saved_errno = *tmp___1;
 4592|      0|        }
 4593|      0|        tmp___4 = close(sp->fts_rfd);
 4594|      0|        if (tmp___4) {
 4595|      0|          if (saved_errno == 0) {
 4596|      0|            tmp___3 = __errno_location();
 4597|      0|            saved_errno = *tmp___3;
 4598|      0|          }
 4599|      0|        }
 4600|      0|      }
 4601|      0|    }
 4602|      2|    fd_ring_clear(&sp->fts_fd_ring);
 4603|      2|    if (sp->fts_leaf_optimization_works_ht) {
 4604|      0|      hash_free(sp->fts_leaf_optimization_works_ht);
 4605|      0|    }
 4606|      2|    free_dir(sp);
 4607|      2|    free((void *)sp);
 4608|      2|    if (saved_errno) {
 4609|      0|      tmp___5 = __errno_location();
 4610|      0|      *tmp___5 = saved_errno;
 4611|      0|      return (-1);
 4612|      0|    }
 4613|      2|    return (0);
 4614|      2|  }
 4615|      2|}
 4616|       |extern __attribute__((__nothrow__)) int(__attribute__((
 4617|       |    __nonnull__(2), __leaf__)) fstatfs)(int __fildes, struct statfs *__buf);
 4618|      0|static _Bool dirent_inode_sort_may_be_useful(int dir_fd) {
 4619|      0|  struct statfs fs_buf;
 4620|      0|  int tmp;
 4621|       |
 4622|      0|  {
 4623|      0|    tmp = fstatfs(dir_fd, &fs_buf);
 4624|      0|    if (tmp != 0) {
 4625|      0|      return ((_Bool)1);
 4626|      0|    }
 4627|      0|    if (fs_buf.f_type == 16914836L) {
 4628|      0|      goto case_16914836;
 4629|      0|    }
 4630|      0|    if (fs_buf.f_type == 26985L) {
 4631|      0|      goto case_16914836;
 4632|      0|    }
 4633|      0|    goto switch_default;
 4634|      0|  case_16914836:
 4635|      0|    return ((_Bool)0);
 4636|      0|  switch_default:
 4637|      0|    return ((_Bool)1);
 4638|       |
 4639|      0|    return ((_Bool)0);
 4640|      0|  }
 4641|      0|}
 4642|      0|static _Bool leaf_optimization_applies(int dir_fd) {
 4643|      0|  struct statfs fs_buf;
 4644|      0|  int tmp;
 4645|       |
 4646|      0|  {
 4647|      0|    tmp = fstatfs(dir_fd, &fs_buf);
 4648|      0|    if (tmp != 0) {
 4649|      0|      return ((_Bool)0);
 4650|      0|    }
 4651|      0|    if (fs_buf.f_type == 1382369651L) {
 4652|      0|      goto case_1382369651;
 4653|      0|    }
 4654|      0|    goto switch_default;
 4655|      0|  case_1382369651:
 4656|      0|    return ((_Bool)1);
 4657|      0|  switch_default:
 4658|      0|    return ((_Bool)0);
 4659|       |
 4660|      0|    return ((_Bool)0);
 4661|      0|  }
 4662|      0|}
 4663|      0|static size_t LCO_hash(void const *x, size_t table_size) {
 4664|      0|  struct LCO_ent const *ax;
 4665|       |
 4666|      0|  {
 4667|      0|    ax = (struct LCO_ent const *)x;
 4668|      0|    return ((uintmax_t)ax->st_dev % table_size);
 4669|      0|  }
 4670|      0|}
 4671|      0|static _Bool LCO_compare(void const *x, void const *y) {
 4672|      0|  struct LCO_ent const *ax;
 4673|      0|  struct LCO_ent const *ay;
 4674|       |
 4675|      0|  {
 4676|      0|    ax = (struct LCO_ent const *)x;
 4677|      0|    ay = (struct LCO_ent const *)y;
 4678|      0|    return ((_Bool)(ax->st_dev == ay->st_dev));
 4679|      0|  }
 4680|      0|}
 4681|      0|static _Bool link_count_optimize_ok(FTSENT const *p) {
 4682|      0|  FTS *sp;
 4683|      0|  Hash_table *h;
 4684|      0|  struct LCO_ent tmp;
 4685|      0|  struct LCO_ent *ent;
 4686|      0|  _Bool opt_ok;
 4687|      0|  struct LCO_ent *t2;
 4688|      0|  struct hash_table *tmp___0;
 4689|       |
 4690|      0|  {
 4691|      0|    sp = (FTS *)p->fts_fts;
 4692|      0|    h = sp->fts_leaf_optimization_works_ht;
 4693|      0|    if (!(sp->fts_options & 512)) {
 4694|      0|      return ((_Bool)0);
 4695|      0|    }
 4696|      0|    if ((unsigned long)h == (unsigned long)((void *)0)) {
 4697|      0|      tmp___0 =
 4698|      0|          hash_initialize((size_t)13, (Hash_tuning const *)((void *)0),
 4699|      0|                          &LCO_hash, &LCO_compare, (void (*)(void *))(&free));
 4700|      0|      sp->fts_leaf_optimization_works_ht = tmp___0;
 4701|      0|      h = tmp___0;
 4702|      0|      if ((unsigned long)h == (unsigned long)((void *)0)) {
 4703|      0|        return ((_Bool)0);
 4704|      0|      }
 4705|      0|    }
 4706|      0|    tmp.st_dev = (dev_t)p->fts_statp[0].st_dev;
 4707|      0|    ent = (struct LCO_ent *)hash_lookup((Hash_table const *)h,
 4708|      0|                                        (void const *)(&tmp));
 4709|      0|    if (ent) {
 4710|      0|      return (ent->opt_ok);
 4711|      0|    }
 4712|      0|    t2 = (struct LCO_ent *)malloc(sizeof(*t2));
 4713|      0|    if ((unsigned long)t2 == (unsigned long)((void *)0)) {
 4714|      0|      return ((_Bool)0);
 4715|      0|    }
 4716|      0|    opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
 4717|      0|    t2->opt_ok = opt_ok;
 4718|      0|    t2->st_dev = (dev_t)p->fts_statp[0].st_dev;
 4719|      0|    ent = (struct LCO_ent *)hash_insert(h, (void const *)t2);
 4720|      0|    if ((unsigned long)ent == (unsigned long)((void *)0)) {
 4721|      0|      free((void *)t2);
 4722|      0|      return ((_Bool)0);
 4723|      0|    }
 4724|      0|    while (1) {
 4725|       |
 4726|      0|      if (!((unsigned long)ent == (unsigned long)t2)) {
 4727|      0|        abort();
 4728|      0|      }
 4729|      0|      goto while_break;
 4730|      0|    }
 4731|      0|  while_break:;
 4732|      0|    return (opt_ok);
 4733|      0|  }
 4734|      0|}
 4735|       |__attribute__((__nothrow__))
 4736|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp);
 4737|      8|FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp) {
 4738|      8|  FTSENT *p;
 4739|      8|  FTSENT *tmp;
 4740|      8|  unsigned short instr;
 4741|      8|  char *t;
 4742|      8|  int *tmp___0;
 4743|      8|  int tmp___1;
 4744|      8|  int *tmp___2;
 4745|      8|  int tmp___3;
 4746|      8|  struct _ftsent *tmp___4;
 4747|      8|  int tmp___5;
 4748|      8|  int tmp___6;
 4749|      8|  int tmp___7;
 4750|      8|  int tmp___8;
 4751|      8|  int tmp___9;
 4752|      8|  int *tmp___10;
 4753|      8|  int tmp___11;
 4754|      8|  size_t tmp___12;
 4755|      8|  char *tmp___13;
 4756|      8|  FTSENT *parent;
 4757|      8|  _Bool tmp___14;
 4758|      8|  int *tmp___15;
 4759|      8|  _Bool tmp___16;
 4760|      8|  int *tmp___17;
 4761|      8|  struct _ftsent *tmp___18;
 4762|      8|  int *tmp___19;
 4763|      8|  int tmp___20;
 4764|      8|  int tmp___21;
 4765|      8|  int tmp___22;
 4766|      8|  int tmp___23;
 4767|      8|  int tmp___24;
 4768|      8|  int saved_errno;
 4769|      8|  int *tmp___25;
 4770|      8|  int *tmp___26;
 4771|      8|  int *tmp___27;
 4772|      8|  int tmp___28;
 4773|      8|  int tmp___29;
 4774|      8|  int *tmp___30;
 4775|      8|  int tmp___31;
 4776|      8|  FTSENT *tmp___32;
 4777|       |
 4778|      8|  {
 4779|      8|    if ((unsigned long)sp->fts_cur == (unsigned long)((void *)0)) {
 4780|      0|      return ((FTSENT *)((void *)0));
 4781|      8|    } else {
 4782|      8|      if (sp->fts_options & 8192) {
 4783|      0|        return ((FTSENT *)((void *)0));
 4784|      0|      }
 4785|      8|    }
 4786|      8|    p = sp->fts_cur;
 4787|      8|    instr = p->fts_instr;
 4788|      8|    p->fts_instr = (unsigned short)3;
 4789|      8|    if ((int)instr == 1) {
 4790|      0|      p->fts_info = fts_stat(sp, p, (_Bool)0);
 4791|      0|      return (p);
 4792|      0|    }
 4793|      8|    if ((int)instr == 2) {
 4794|      0|      if ((int)p->fts_info == 12) {
 4795|      0|        goto _L;
 4796|      0|      } else {
 4797|      0|        if ((int)p->fts_info == 13) {
 4798|      0|        _L:
 4799|      0|          p->fts_info = fts_stat(sp, p, (_Bool)1);
 4800|      0|          if ((int)p->fts_info == 1) {
 4801|      0|            if (!(sp->fts_options & 4)) {
 4802|      0|              tmp___1 = diropen((FTS const *)sp, ".");
 4803|      0|              p->fts_symfd = tmp___1;
 4804|      0|              if (tmp___1 < 0) {
 4805|      0|                tmp___0 = __errno_location();
 4806|      0|                p->fts_errno = *tmp___0;
 4807|      0|                p->fts_info = (unsigned short)7;
 4808|      0|              } else {
 4809|      0|                p->fts_flags = (unsigned short)((int)p->fts_flags | 2);
 4810|      0|              }
 4811|      0|            }
 4812|      0|          }
 4813|      0|          goto check_for_dir;
 4814|      0|        }
 4815|      0|      }
 4816|      0|    }
 4817|      8|    if ((int)p->fts_info == 1) {
 4818|      2|      if ((int)instr == 4) {
 4819|      0|        goto _L___0;
 4820|      2|      } else {
 4821|      2|        if (sp->fts_options & 64) {
 4822|      0|          if (p->fts_statp[0].st_dev != sp->fts_dev) {
 4823|      0|          _L___0:
 4824|      0|            if ((int)p->fts_flags & 2) {
 4825|      0|              close(p->fts_symfd);
 4826|      0|            }
 4827|      0|            if (sp->fts_child) {
 4828|      0|              fts_lfree(sp->fts_child);
 4829|      0|              sp->fts_child = (struct _ftsent *)((void *)0);
 4830|      0|            }
 4831|      0|            p->fts_info = (unsigned short)6;
 4832|      0|            while (1) {
 4833|      0|              leave_dir(sp, p);
 4834|      0|              goto while_break;
 4835|      0|            }
 4836|      0|          while_break:;
 4837|      0|            return (p);
 4838|      0|          }
 4839|      0|        }
 4840|      2|      }
 4841|      2|      if ((unsigned long)sp->fts_child != (unsigned long)((void *)0)) {
 4842|      0|        if (sp->fts_options & 4096) {
 4843|      0|          sp->fts_options &= -4097;
 4844|      0|          fts_lfree(sp->fts_child);
 4845|      0|          sp->fts_child = (struct _ftsent *)((void *)0);
 4846|      0|        }
 4847|      0|      }
 4848|      2|      if ((unsigned long)sp->fts_child != (unsigned long)((void *)0)) {
 4849|      0|        tmp___3 = fts_safe_changedir(sp, p, -1, (char const *)p->fts_accpath);
 4850|      0|        if (tmp___3) {
 4851|      0|          tmp___2 = __errno_location();
 4852|      0|          p->fts_errno = *tmp___2;
 4853|      0|          p->fts_flags = (unsigned short)((int)p->fts_flags | 1);
 4854|      0|          p = sp->fts_child;
 4855|      0|          while (1) {
 4856|       |
 4857|      0|            if (!((unsigned long)p != (unsigned long)((void *)0))) {
 4858|      0|              goto while_break___0;
 4859|      0|            }
 4860|      0|            p->fts_accpath = (p->fts_parent)->fts_accpath;
 4861|      0|            p = p->fts_link;
 4862|      0|          }
 4863|      0|        while_break___0:;
 4864|      0|        }
 4865|      2|      } else {
 4866|      2|        tmp___4 = fts_build(sp, 3);
 4867|      2|        sp->fts_child = tmp___4;
 4868|      2|        if ((unsigned long)tmp___4 == (unsigned long)((void *)0)) {
 4869|      0|          if (sp->fts_options & 8192) {
 4870|      0|            return ((FTSENT *)((void *)0));
 4871|      0|          }
 4872|      0|          if (p->fts_errno) {
 4873|      0|            if ((int)p->fts_info != 4) {
 4874|      0|              p->fts_info = (unsigned short)7;
 4875|      0|            }
 4876|      0|          }
 4877|      0|          while (1) {
 4878|      0|            leave_dir(sp, p);
 4879|      0|            goto while_break___1;
 4880|      0|          }
 4881|      0|        while_break___1:;
 4882|      0|          return (p);
 4883|      0|        }
 4884|      2|      }
 4885|      2|      p = sp->fts_child;
 4886|      2|      sp->fts_child = (struct _ftsent *)((void *)0);
 4887|      2|      goto name;
 4888|      2|    }
 4889|      6|  next:
 4890|      6|    tmp = p;
 4891|      6|    p = p->fts_link;
 4892|      6|    if ((unsigned long)p != (unsigned long)((void *)0)) {
 4893|      2|      sp->fts_cur = p;
 4894|      2|      free((void *)tmp);
 4895|      2|      if (p->fts_level == 0L) {
 4896|      2|        fd_ring_clear(&sp->fts_fd_ring);
 4897|      2|        if (!(sp->fts_options & 4)) {
 4898|      2|          if (sp->fts_options & 512) {
 4899|      2|            if (sp->fts_options & 512) {
 4900|      2|              tmp___5 = -100;
 4901|      2|            } else {
 4902|      0|              tmp___5 = sp->fts_rfd;
 4903|      0|            }
 4904|      2|            cwd_advance_fd(sp, tmp___5, (_Bool)1);
 4905|      2|            tmp___8 = 0;
 4906|      2|          } else {
 4907|      0|            if (sp->fts_options & 512) {
 4908|      0|              tmp___6 = -100;
 4909|      0|            } else {
 4910|      0|              tmp___6 = sp->fts_rfd;
 4911|      0|            }
 4912|      0|            tmp___7 = fchdir(tmp___6);
 4913|      0|            tmp___8 = tmp___7;
 4914|      0|          }
 4915|      2|          if (tmp___8) {
 4916|      0|            tmp___9 = 1;
 4917|      2|          } else {
 4918|      2|            tmp___9 = 0;
 4919|      2|          }
 4920|      2|        } else {
 4921|      0|          tmp___9 = 0;
 4922|      0|        }
 4923|      2|        if (tmp___9) {
 4924|      0|          sp->fts_options |= 8192;
 4925|      0|          return ((FTSENT *)((void *)0));
 4926|      0|        }
 4927|      2|        free_dir(sp);
 4928|      2|        fts_load(sp, p);
 4929|      2|        setup_dir(sp);
 4930|      2|        goto check_for_dir;
 4931|      2|      }
 4932|      0|      if ((int)p->fts_instr == 4) {
 4933|      0|        goto next;
 4934|      0|      }
 4935|      0|      if ((int)p->fts_instr == 2) {
 4936|      0|        p->fts_info = fts_stat(sp, p, (_Bool)1);
 4937|      0|        if ((int)p->fts_info == 1) {
 4938|      0|          if (!(sp->fts_options & 4)) {
 4939|      0|            tmp___11 = diropen((FTS const *)sp, ".");
 4940|      0|            p->fts_symfd = tmp___11;
 4941|      0|            if (tmp___11 < 0) {
 4942|      0|              tmp___10 = __errno_location();
 4943|      0|              p->fts_errno = *tmp___10;
 4944|      0|              p->fts_info = (unsigned short)7;
 4945|      0|            } else {
 4946|      0|              p->fts_flags = (unsigned short)((int)p->fts_flags | 2);
 4947|      0|            }
 4948|      0|          }
 4949|      0|        }
 4950|      0|        p->fts_instr = (unsigned short)3;
 4951|      0|      }
 4952|      2|    name:
 4953|      2|      if ((int)*((p->fts_parent)->fts_path +
 4954|      2|                 ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
 4955|      0|        tmp___12 = (p->fts_parent)->fts_pathlen - 1UL;
 4956|      2|      } else {
 4957|      2|        tmp___12 = (p->fts_parent)->fts_pathlen;
 4958|      2|      }
 4959|      2|      t = sp->fts_path + tmp___12;
 4960|      2|      tmp___13 = t;
 4961|      2|      t++;
 4962|      2|      *tmp___13 = (char)'/';
 4963|      2|      memmove((void *)t, (void const *)(p->fts_name), p->fts_namelen + 1UL);
 4964|      4|    check_for_dir:
 4965|      4|      sp->fts_cur = p;
 4966|      4|      if ((int)p->fts_info == 11) {
 4967|      2|        if (p->fts_statp[0].st_size == 2L) {
 4968|      0|          parent = p->fts_parent;
 4969|      0|          if (0L < p->fts_level) {
 4970|      0|            if (parent->fts_n_dirs_remaining == 0UL) {
 4971|      0|              if (sp->fts_options & 8) {
 4972|      0|                if (sp->fts_options & 16) {
 4973|      0|                  tmp___14 = link_count_optimize_ok((FTSENT const *)parent);
 4974|      0|                  if (!tmp___14) {
 4975|      0|                    goto _L___4;
 4976|      0|                  }
 4977|      0|                } else {
 4978|      0|                  goto _L___4;
 4979|      0|                }
 4980|      0|              } else {
 4981|      0|                goto _L___4;
 4982|      0|              }
 4983|      0|            } else {
 4984|      0|              goto _L___4;
 4985|      0|            }
 4986|      0|          } else {
 4987|      0|          _L___4:
 4988|      0|            p->fts_info = fts_stat(sp, p, (_Bool)0);
 4989|      0|            if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
 4990|      0|              if (p->fts_level != 0L) {
 4991|      0|                if (parent->fts_n_dirs_remaining) {
 4992|      0|                  (parent->fts_n_dirs_remaining)--;
 4993|      0|                }
 4994|      0|              }
 4995|      0|            }
 4996|      0|          }
 4997|      2|        } else {
 4998|      2|          while (1) {
 4999|       |
 5000|      2|            if (!(p->fts_statp[0].st_size == 1L)) {
 5001|      0|              abort();
 5002|      0|            }
 5003|      2|            goto while_break___2;
 5004|      2|          }
 5005|      2|        while_break___2:;
 5006|      2|        }
 5007|      2|      }
 5008|      4|      if ((int)p->fts_info == 1) {
 5009|      2|        if (p->fts_level == 0L) {
 5010|      2|          sp->fts_dev = p->fts_statp[0].st_dev;
 5011|      2|        }
 5012|      2|        tmp___16 = enter_dir(sp, p);
 5013|      2|        if (!tmp___16) {
 5014|      0|          tmp___15 = __errno_location();
 5015|      0|          *tmp___15 = 12;
 5016|      0|          return ((FTSENT *)((void *)0));
 5017|      0|        }
 5018|      2|      }
 5019|      4|      return (p);
 5020|      4|    }
 5021|      4|    p = tmp->fts_parent;
 5022|      4|    sp->fts_cur = p;
 5023|      4|    free((void *)tmp);
 5024|      4|    if (p->fts_level == -1L) {
 5025|      2|      free((void *)p);
 5026|      2|      tmp___17 = __errno_location();
 5027|      2|      *tmp___17 = 0;
 5028|      2|      tmp___18 = (struct _ftsent *)((void *)0);
 5029|      2|      sp->fts_cur = tmp___18;
 5030|      2|      return (tmp___18);
 5031|      2|    }
 5032|      2|    while (1) {
 5033|       |
 5034|      2|      if (!((int)p->fts_info != 11)) {
 5035|      0|        abort();
 5036|      0|      }
 5037|      2|      goto while_break___3;
 5038|      2|    }
 5039|      2|  while_break___3:
 5040|      2|    *(sp->fts_path + p->fts_pathlen) = (char)'\000';
 5041|      2|    if (p->fts_level == 0L) {
 5042|      2|      fd_ring_clear(&sp->fts_fd_ring);
 5043|      2|      if (!(sp->fts_options & 4)) {
 5044|      2|        if (sp->fts_options & 512) {
 5045|      2|          if (sp->fts_options & 512) {
 5046|      2|            tmp___20 = -100;
 5047|      2|          } else {
 5048|      0|            tmp___20 = sp->fts_rfd;
 5049|      0|          }
 5050|      2|          cwd_advance_fd(sp, tmp___20, (_Bool)1);
 5051|      2|          tmp___23 = 0;
 5052|      2|        } else {
 5053|      0|          if (sp->fts_options & 512) {
 5054|      0|            tmp___21 = -100;
 5055|      0|          } else {
 5056|      0|            tmp___21 = sp->fts_rfd;
 5057|      0|          }
 5058|      0|          tmp___22 = fchdir(tmp___21);
 5059|      0|          tmp___23 = tmp___22;
 5060|      0|        }
 5061|      2|        if (tmp___23) {
 5062|      0|          tmp___24 = 1;
 5063|      2|        } else {
 5064|      2|          tmp___24 = 0;
 5065|      2|        }
 5066|      2|      } else {
 5067|      0|        tmp___24 = 0;
 5068|      0|      }
 5069|      2|      if (tmp___24) {
 5070|      0|        tmp___19 = __errno_location();
 5071|      0|        p->fts_errno = *tmp___19;
 5072|      0|        sp->fts_options |= 8192;
 5073|      0|      }
 5074|      2|    } else {
 5075|      0|      if ((int)p->fts_flags & 2) {
 5076|      0|        if (!(sp->fts_options & 4)) {
 5077|      0|          if (sp->fts_options & 512) {
 5078|      0|            cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
 5079|      0|            tmp___29 = 0;
 5080|      0|          } else {
 5081|      0|            tmp___28 = fchdir(p->fts_symfd);
 5082|      0|            tmp___29 = tmp___28;
 5083|      0|          }
 5084|      0|          if (tmp___29) {
 5085|      0|            tmp___25 = __errno_location();
 5086|      0|            saved_errno = *tmp___25;
 5087|      0|            close(p->fts_symfd);
 5088|      0|            tmp___26 = __errno_location();
 5089|      0|            *tmp___26 = saved_errno;
 5090|      0|            tmp___27 = __errno_location();
 5091|      0|            p->fts_errno = *tmp___27;
 5092|      0|            sp->fts_options |= 8192;
 5093|      0|          }
 5094|      0|        }
 5095|      0|        close(p->fts_symfd);
 5096|      0|      } else {
 5097|      0|        if (!((int)p->fts_flags & 1)) {
 5098|      0|          tmp___31 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
 5099|      0|          if (tmp___31) {
 5100|      0|            tmp___30 = __errno_location();
 5101|      0|            p->fts_errno = *tmp___30;
 5102|      0|            sp->fts_options |= 8192;
 5103|      0|          }
 5104|      0|        }
 5105|      0|      }
 5106|      0|    }
 5107|      2|    if (p->fts_errno) {
 5108|      0|      p->fts_info = (unsigned short)7;
 5109|      2|    } else {
 5110|      2|      p->fts_info = (unsigned short)6;
 5111|      2|    }
 5112|      2|    if (p->fts_errno == 0) {
 5113|      2|      while (1) {
 5114|      2|        leave_dir(sp, p);
 5115|      2|        goto while_break___4;
 5116|      2|      }
 5117|      2|    while_break___4:;
 5118|      2|    }
 5119|      2|    if (sp->fts_options & 8192) {
 5120|      0|      tmp___32 = (FTSENT *)((void *)0);
 5121|      2|    } else {
 5122|      2|      tmp___32 = p;
 5123|      2|    }
 5124|      2|    return (tmp___32);
 5125|      2|  }
 5126|      2|}
 5127|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__)) fts_set)(
 5128|       |    FTS *sp __attribute__((__unused__)), FTSENT *p, int instr);
 5129|       |int(__attribute__((__leaf__)) fts_set)(FTS *sp __attribute__((__unused__)),
 5130|      0|                                       FTSENT *p, int instr) {
 5131|      0|  int *tmp;
 5132|       |
 5133|      0|  {
 5134|      0|    if (instr != 0) {
 5135|      0|      if (instr != 1) {
 5136|      0|        if (instr != 2) {
 5137|      0|          if (instr != 3) {
 5138|      0|            if (instr != 4) {
 5139|      0|              tmp = __errno_location();
 5140|      0|              *tmp = 22;
 5141|      0|              return (1);
 5142|      0|            }
 5143|      0|          }
 5144|      0|        }
 5145|      0|      }
 5146|      0|    }
 5147|      0|    p->fts_instr = (unsigned short)instr;
 5148|      0|    return (0);
 5149|      0|  }
 5150|      0|}
 5151|      0|static int fts_compare_ino(struct _ftsent const **a, struct _ftsent const **b) {
 5152|      0|  int tmp;
 5153|      0|  int tmp___0;
 5154|       |
 5155|      0|  {
 5156|      0|    if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
 5157|      0|      tmp___0 = -1;
 5158|      0|    } else {
 5159|      0|      if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
 5160|      0|        tmp = 1;
 5161|      0|      } else {
 5162|      0|        tmp = 0;
 5163|      0|      }
 5164|      0|      tmp___0 = tmp;
 5165|      0|    }
 5166|      0|    return (tmp___0);
 5167|      0|  }
 5168|      0|}
 5169|      2|static void set_stat_type(struct stat *st, unsigned int dtype) {
 5170|      2|  mode_t type;
 5171|       |
 5172|      2|  {
 5173|      2|    if (dtype == 6U) {
 5174|      0|      goto case_6;
 5175|      0|    }
 5176|      2|    if (dtype == 2U) {
 5177|      0|      goto case_2;
 5178|      0|    }
 5179|      2|    if (dtype == 4U) {
 5180|      0|      goto case_4;
 5181|      0|    }
 5182|      2|    if (dtype == 1U) {
 5183|      0|      goto case_1;
 5184|      0|    }
 5185|      2|    if (dtype == 10U) {
 5186|      0|      goto case_10;
 5187|      0|    }
 5188|      2|    if (dtype == 8U) {
 5189|      2|      goto case_8;
 5190|      2|    }
 5191|      0|    if (dtype == 12U) {
 5192|      0|      goto case_12;
 5193|      0|    }
 5194|      0|    goto switch_default;
 5195|      0|  case_6:
 5196|      0|    type = (mode_t)24576;
 5197|      0|    goto switch_break;
 5198|      0|  case_2:
 5199|      0|    type = (mode_t)8192;
 5200|      0|    goto switch_break;
 5201|      0|  case_4:
 5202|      0|    type = (mode_t)16384;
 5203|      0|    goto switch_break;
 5204|      0|  case_1:
 5205|      0|    type = (mode_t)4096;
 5206|      0|    goto switch_break;
 5207|      0|  case_10:
 5208|      0|    type = (mode_t)40960;
 5209|      0|    goto switch_break;
 5210|      2|  case_8:
 5211|      2|    type = (mode_t)32768;
 5212|      2|    goto switch_break;
 5213|      0|  case_12:
 5214|      0|    type = (mode_t)49152;
 5215|      0|    goto switch_break;
 5216|      0|  switch_default:
 5217|      0|    type = (mode_t)0;
 5218|      2|  switch_break:
 5219|      2|    st->st_mode = type;
 5220|      2|    return;
 5221|      0|  }
 5222|      0|}
 5223|      2|static FTSENT *fts_build(FTS *sp, int type) {
 5224|      2|  struct dirent *dp;
 5225|      2|  FTSENT *p;
 5226|      2|  FTSENT *head;
 5227|      2|  size_t nitems;
 5228|      2|  FTSENT *cur;
 5229|      2|  FTSENT *tail;
 5230|      2|  DIR *dirp;
 5231|      2|  void *oldaddr;
 5232|      2|  int saved_errno;
 5233|      2|  _Bool descend;
 5234|      2|  _Bool doadjust;
 5235|      2|  ptrdiff_t level;
 5236|      2|  nlink_t nlinks;
 5237|      2|  _Bool nostat;
 5238|      2|  size_t len;
 5239|      2|  size_t maxlen;
 5240|      2|  size_t new_len;
 5241|      2|  char *cp;
 5242|      2|  int *tmp;
 5243|      2|  DIR *tmp___0;
 5244|      2|  DIR *tmp___1;
 5245|      2|  int *tmp___2;
 5246|      2|  _Bool tmp___3;
 5247|      2|  int tmp___4;
 5248|      2|  int dir_fd;
 5249|      2|  int tmp___5;
 5250|      2|  int *tmp___6;
 5251|      2|  int tmp___7;
 5252|      2|  char *tmp___8;
 5253|      2|  _Bool is_dir;
 5254|      2|  size_t tmp___9;
 5255|      2|  int *tmp___10;
 5256|      2|  int *tmp___11;
 5257|      2|  size_t tmp___12;
 5258|      2|  _Bool tmp___13;
 5259|      2|  size_t tmp___14;
 5260|      2|  size_t tmp___15;
 5261|      2|  int *tmp___16;
 5262|      2|  _Bool skip_stat;
 5263|      2|  int tmp___17;
 5264|      2|  int tmp___18;
 5265|      2|  int tmp___19;
 5266|      2|  int tmp___20;
 5267|      2|  int tmp___21;
 5268|      2|  int tmp___22;
 5269|      2|  int tmp___23;
 5270|      2|  int tmp___24;
 5271|      2|  int tmp___25;
 5272|      2|  int tmp___26;
 5273|      2|  _Bool tmp___27;
 5274|       |
 5275|      2|  {
 5276|      2|    cur = sp->fts_cur;
 5277|      2|    if (!(sp->fts_options & 4)) {
 5278|      2|      if (sp->fts_options & 512) {
 5279|      2|        tmp___0 = opendirat(sp->fts_cwd_fd, (char const *)cur->fts_accpath);
 5280|      2|        dirp = tmp___0;
 5281|      2|      } else {
 5282|      0|        tmp___1 = opendir_safer((char const *)cur->fts_accpath);
 5283|      0|        dirp = tmp___1;
 5284|      0|      }
 5285|      2|    } else {
 5286|      0|      tmp___1 = opendir_safer((char const *)cur->fts_accpath);
 5287|      0|      dirp = tmp___1;
 5288|      0|    }
 5289|      2|    if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 5290|      0|      if (type == 3) {
 5291|      0|        cur->fts_info = (unsigned short)4;
 5292|      0|        tmp = __errno_location();
 5293|      0|        cur->fts_errno = *tmp;
 5294|      0|      }
 5295|      0|      return ((FTSENT *)((void *)0));
 5296|      0|    }
 5297|      2|    if ((int)cur->fts_info == 11) {
 5298|      0|      cur->fts_info = fts_stat(sp, cur, (_Bool)0);
 5299|      2|    } else {
 5300|      2|      if (sp->fts_options & 256) {
 5301|      0|        while (1) {
 5302|      0|          leave_dir(sp, cur);
 5303|      0|          goto while_break;
 5304|      0|        }
 5305|      0|      while_break:
 5306|      0|        fts_stat(sp, cur, (_Bool)0);
 5307|      0|        tmp___3 = enter_dir(sp, cur);
 5308|      0|        if (!tmp___3) {
 5309|      0|          tmp___2 = __errno_location();
 5310|      0|          *tmp___2 = 12;
 5311|      0|          return ((FTSENT *)((void *)0));
 5312|      0|        }
 5313|      0|      }
 5314|      2|    }
 5315|      2|    if (type == 2) {
 5316|      0|      nlinks = (nlink_t)0;
 5317|      0|      nostat = (_Bool)0;
 5318|      2|    } else {
 5319|      2|      if (sp->fts_options & 8) {
 5320|      2|        if (sp->fts_options & 16) {
 5321|      2|          if (sp->fts_options & 32) {
 5322|      0|            tmp___4 = 0;
 5323|      2|          } else {
 5324|      2|            tmp___4 = 2;
 5325|      2|          }
 5326|      2|          nlinks = cur->fts_statp[0].st_nlink - (__nlink_t)tmp___4;
 5327|      2|          nostat = (_Bool)1;
 5328|      2|        } else {
 5329|      0|          nlinks = (nlink_t)-1;
 5330|      0|          nostat = (_Bool)0;
 5331|      0|        }
 5332|      2|      } else {
 5333|      0|        nlinks = (nlink_t)-1;
 5334|      0|        nostat = (_Bool)0;
 5335|      0|      }
 5336|      2|    }
 5337|      2|    if (nlinks) {
 5338|      0|      goto _L___0;
 5339|      2|    } else {
 5340|      2|      if (type == 3) {
 5341|      2|      _L___0:
 5342|      2|        tmp___5 = dirfd(dirp);
 5343|      2|        dir_fd = tmp___5;
 5344|      2|        if (sp->fts_options & 512) {
 5345|      2|          if (0 <= dir_fd) {
 5346|      2|            dir_fd = dup_safer(dir_fd);
 5347|      2|            set_cloexec_flag(dir_fd, (_Bool)1);
 5348|      2|          }
 5349|      2|        }
 5350|      2|        if (dir_fd < 0) {
 5351|      0|          goto _L;
 5352|      2|        } else {
 5353|      2|          tmp___7 =
 5354|      2|              fts_safe_changedir(sp, cur, dir_fd, (char const *)((void *)0));
 5355|      2|          if (tmp___7) {
 5356|      0|          _L:
 5357|      0|            if (nlinks) {
 5358|      0|              if (type == 3) {
 5359|      0|                tmp___6 = __errno_location();
 5360|      0|                cur->fts_errno = *tmp___6;
 5361|      0|              }
 5362|      0|            }
 5363|      0|            cur->fts_flags = (unsigned short)((int)cur->fts_flags | 1);
 5364|      0|            descend = (_Bool)0;
 5365|      0|            closedir(dirp);
 5366|      0|            if (sp->fts_options & 512) {
 5367|      0|              if (0 <= dir_fd) {
 5368|      0|                close(dir_fd);
 5369|      0|              }
 5370|      0|            }
 5371|      0|            dirp = (DIR *)((void *)0);
 5372|      2|          } else {
 5373|      2|            descend = (_Bool)1;
 5374|      2|          }
 5375|      2|        }
 5376|      2|      } else {
 5377|      0|        descend = (_Bool)0;
 5378|      0|      }
 5379|      2|    }
 5380|      2|    if ((int)*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
 5381|      0|      len = cur->fts_pathlen - 1UL;
 5382|      2|    } else {
 5383|      2|      len = cur->fts_pathlen;
 5384|      2|    }
 5385|      2|    if (sp->fts_options & 4) {
 5386|      0|      cp = sp->fts_path + len;
 5387|      0|      tmp___8 = cp;
 5388|      0|      cp++;
 5389|      0|      *tmp___8 = (char)'/';
 5390|      2|    } else {
 5391|      2|      cp = (char *)((void *)0);
 5392|      2|    }
 5393|      2|    len++;
 5394|      2|    maxlen = sp->fts_pathlen - len;
 5395|      2|    level = cur->fts_level + 1L;
 5396|      2|    doadjust = (_Bool)0;
 5397|      2|    tail = (FTSENT *)((void *)0);
 5398|      2|    head = tail;
 5399|      2|    nitems = (size_t)0;
 5400|      8|    while (1) {
 5401|       |
 5402|      8|      if (dirp) {
 5403|      8|        dp = readdir(dirp);
 5404|      8|        if (!dp) {
 5405|      2|          goto while_break___0;
 5406|      2|        }
 5407|      8|      } else {
 5408|      0|        goto while_break___0;
 5409|      0|      }
 5410|      6|      if (!(sp->fts_options & 32)) {
 5411|      6|        if ((int)dp->d_name[0] == 46) {
 5412|      4|          if (!dp->d_name[1]) {
 5413|      2|            goto __Cont;
 5414|      2|          } else {
 5415|      2|            if ((int)dp->d_name[1] == 46) {
 5416|      2|              if (!dp->d_name[2]) {
 5417|      2|                goto __Cont;
 5418|      2|              }
 5419|      2|            }
 5420|      2|          }
 5421|      4|        }
 5422|      6|      }
 5423|      2|      tmp___9 = strlen((char const *)(dp->d_name));
 5424|      2|      p = fts_alloc(sp, (char const *)(dp->d_name), tmp___9);
 5425|      2|      if ((unsigned long)p == (unsigned long)((void *)0)) {
 5426|      0|        goto mem1;
 5427|      0|      }
 5428|      2|      tmp___14 = strlen((char const *)(dp->d_name));
 5429|      2|      if (tmp___14 >= maxlen) {
 5430|      0|        oldaddr = (void *)sp->fts_path;
 5431|      0|        tmp___12 = strlen((char const *)(dp->d_name));
 5432|      0|        tmp___13 = fts_palloc(sp, (tmp___12 + len) + 1UL);
 5433|      0|        if (!tmp___13) {
 5434|      0|        mem1:
 5435|      0|          tmp___10 = __errno_location();
 5436|      0|          saved_errno = *tmp___10;
 5437|      0|          free((void *)p);
 5438|      0|          fts_lfree(head);
 5439|      0|          closedir(dirp);
 5440|      0|          cur->fts_info = (unsigned short)7;
 5441|      0|          sp->fts_options |= 8192;
 5442|      0|          tmp___11 = __errno_location();
 5443|      0|          *tmp___11 = saved_errno;
 5444|      0|          return ((FTSENT *)((void *)0));
 5445|      0|        }
 5446|      0|        if ((unsigned long)oldaddr != (unsigned long)sp->fts_path) {
 5447|      0|          doadjust = (_Bool)1;
 5448|      0|          if (sp->fts_options & 4) {
 5449|      0|            cp = sp->fts_path + len;
 5450|      0|          }
 5451|      0|        }
 5452|      0|        maxlen = sp->fts_pathlen - len;
 5453|      0|      }
 5454|      2|      tmp___15 = strlen((char const *)(dp->d_name));
 5455|      2|      new_len = len + tmp___15;
 5456|      2|      if (new_len < len) {
 5457|      0|        free((void *)p);
 5458|      0|        fts_lfree(head);
 5459|      0|        closedir(dirp);
 5460|      0|        cur->fts_info = (unsigned short)7;
 5461|      0|        sp->fts_options |= 8192;
 5462|      0|        tmp___16 = __errno_location();
 5463|      0|        *tmp___16 = 36;
 5464|      0|        return ((FTSENT *)((void *)0));
 5465|      0|      }
 5466|      2|      p->fts_level = level;
 5467|      2|      p->fts_parent = sp->fts_cur;
 5468|      2|      p->fts_pathlen = new_len;
 5469|      2|      p->fts_statp[0].st_ino = dp->d_ino;
 5470|      2|      if (sp->fts_options & 4) {
 5471|      0|        p->fts_accpath = p->fts_path;
 5472|      0|        memmove((void *)cp, (void const *)(p->fts_name), p->fts_namelen + 1UL);
 5473|      2|      } else {
 5474|      2|        p->fts_accpath = p->fts_name;
 5475|      2|      }
 5476|      2|      if ((unsigned long)sp->fts_compar == (unsigned long)((void *)0) ||
 5477|      2|          sp->fts_options & 1024) {
 5478|      2|        if (sp->fts_options & 16) {
 5479|      2|          if (sp->fts_options & 8) {
 5480|      2|            if ((int)dp->d_type != 0) {
 5481|      2|              if (!((int)dp->d_type == 4)) {
 5482|      2|                tmp___17 = 1;
 5483|      2|              } else {
 5484|      0|                tmp___17 = 0;
 5485|      0|              }
 5486|      2|            } else {
 5487|      0|              tmp___17 = 0;
 5488|      0|            }
 5489|      2|          } else {
 5490|      0|            tmp___17 = 0;
 5491|      0|          }
 5492|      2|        } else {
 5493|      0|          tmp___17 = 0;
 5494|      0|        }
 5495|      2|        skip_stat = (_Bool)tmp___17;
 5496|      2|        p->fts_info = (unsigned short)11;
 5497|      2|        set_stat_type(p->fts_statp, (unsigned int)dp->d_type);
 5498|      2|        fts_set_stat_required(p, (_Bool)(!skip_stat));
 5499|      2|        if (sp->fts_options & 16) {
 5500|      2|          if ((int)dp->d_type == 4) {
 5501|      0|            tmp___18 = 1;
 5502|      2|          } else {
 5503|      2|            tmp___18 = 0;
 5504|      2|          }
 5505|      2|        } else {
 5506|      0|          tmp___18 = 0;
 5507|      0|        }
 5508|      2|        is_dir = (_Bool)tmp___18;
 5509|      2|      } else {
 5510|      0|        p->fts_info = fts_stat(sp, p, (_Bool)0);
 5511|      0|        if ((int)p->fts_info == 1) {
 5512|      0|          tmp___19 = 1;
 5513|      0|        } else {
 5514|      0|          if ((int)p->fts_info == 2) {
 5515|      0|            tmp___19 = 1;
 5516|      0|          } else {
 5517|      0|            if ((int)p->fts_info == 5) {
 5518|      0|              tmp___19 = 1;
 5519|      0|            } else {
 5520|      0|              tmp___19 = 0;
 5521|      0|            }
 5522|      0|          }
 5523|      0|        }
 5524|      0|        is_dir = (_Bool)tmp___19;
 5525|      0|      }
 5526|      2|      if (nlinks > 0UL) {
 5527|      0|        if (is_dir) {
 5528|      0|          nlinks -= (nlink_t)nostat;
 5529|      0|        }
 5530|      0|      }
 5531|      2|      p->fts_link = (struct _ftsent *)((void *)0);
 5532|      2|      if ((unsigned long)head == (unsigned long)((void *)0)) {
 5533|      2|        tail = p;
 5534|      2|        head = tail;
 5535|      2|      } else {
 5536|      0|        tail->fts_link = p;
 5537|      0|        tail = p;
 5538|      0|      }
 5539|      2|      nitems++;
 5540|      6|    __Cont:;
 5541|      6|    }
 5542|      2|  while_break___0:;
 5543|      2|    if (dirp) {
 5544|      2|      closedir(dirp);
 5545|      2|    }
 5546|      2|    if (doadjust) {
 5547|      0|      fts_padjust(sp, head);
 5548|      0|    }
 5549|      2|    if (sp->fts_options & 4) {
 5550|      0|      if (len == sp->fts_pathlen) {
 5551|      0|        cp--;
 5552|      0|      } else {
 5553|      0|        if (nitems == 0UL) {
 5554|      0|          cp--;
 5555|      0|        }
 5556|      0|      }
 5557|      0|      *cp = (char)'\000';
 5558|      0|    }
 5559|      2|    if (descend) {
 5560|      2|      if (type == 1 || !nitems) {
 5561|      0|        if (cur->fts_level == 0L) {
 5562|      0|          fd_ring_clear(&sp->fts_fd_ring);
 5563|      0|          if (!(sp->fts_options & 4)) {
 5564|      0|            if (sp->fts_options & 512) {
 5565|      0|              if (sp->fts_options & 512) {
 5566|      0|                tmp___20 = -100;
 5567|      0|              } else {
 5568|      0|                tmp___20 = sp->fts_rfd;
 5569|      0|              }
 5570|      0|              cwd_advance_fd(sp, tmp___20, (_Bool)1);
 5571|      0|              tmp___23 = 0;
 5572|      0|            } else {
 5573|      0|              if (sp->fts_options & 512) {
 5574|      0|                tmp___21 = -100;
 5575|      0|              } else {
 5576|      0|                tmp___21 = sp->fts_rfd;
 5577|      0|              }
 5578|      0|              tmp___22 = fchdir(tmp___21);
 5579|      0|              tmp___23 = tmp___22;
 5580|      0|            }
 5581|      0|            if (tmp___23) {
 5582|      0|              tmp___24 = 1;
 5583|      0|            } else {
 5584|      0|              tmp___24 = 0;
 5585|      0|            }
 5586|      0|          } else {
 5587|      0|            tmp___24 = 0;
 5588|      0|          }
 5589|      0|          tmp___26 = tmp___24;
 5590|      0|        } else {
 5591|      0|          tmp___25 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
 5592|      0|          tmp___26 = tmp___25;
 5593|      0|        }
 5594|      0|        if (tmp___26) {
 5595|      0|          cur->fts_info = (unsigned short)7;
 5596|      0|          sp->fts_options |= 8192;
 5597|      0|          fts_lfree(head);
 5598|      0|          return ((FTSENT *)((void *)0));
 5599|      0|        }
 5600|      0|      }
 5601|      2|    }
 5602|      2|    if (!nitems) {
 5603|      0|      if (type == 3) {
 5604|      0|        cur->fts_info = (unsigned short)6;
 5605|      0|      }
 5606|      0|      fts_lfree(head);
 5607|      0|      return ((FTSENT *)((void *)0));
 5608|      0|    }
 5609|      2|    if (nitems > 10000UL) {
 5610|      0|      if (!sp->fts_compar) {
 5611|      0|        if (sp->fts_options & 512) {
 5612|      0|          tmp___27 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
 5613|      0|          if (tmp___27) {
 5614|      0|            sp->fts_compar = &fts_compare_ino;
 5615|      0|            head = fts_sort(sp, head, nitems);
 5616|      0|            sp->fts_compar = (int (*)(struct _ftsent const **,
 5617|      0|                                      struct _ftsent const **))((void *)0);
 5618|      0|          }
 5619|      0|        }
 5620|      0|      }
 5621|      0|    }
 5622|      2|    if (sp->fts_compar) {
 5623|      0|      if (nitems > 1UL) {
 5624|      0|        head = fts_sort(sp, head, nitems);
 5625|      0|      }
 5626|      0|    }
 5627|      2|    return (head);
 5628|      2|  }
 5629|      2|}
 5630|      2|static unsigned short fts_stat(FTS *sp, FTSENT *p, _Bool follow) {
 5631|      2|  struct stat *sbp;
 5632|      2|  int saved_errno;
 5633|      2|  int *tmp;
 5634|      2|  int *tmp___0;
 5635|      2|  int *tmp___1;
 5636|      2|  int tmp___2;
 5637|      2|  int tmp___3;
 5638|      2|  int *tmp___4;
 5639|      2|  int tmp___5;
 5640|      2|  int tmp___6;
 5641|      2|  int tmp___7;
 5642|       |
 5643|      2|  {
 5644|      2|    sbp = p->fts_statp;
 5645|      2|    if (p->fts_level == 0L) {
 5646|      2|      if (sp->fts_options & 1) {
 5647|      0|        follow = (_Bool)1;
 5648|      0|      }
 5649|      2|    }
 5650|      2|    if (sp->fts_options & 2) {
 5651|      0|      goto _L;
 5652|      2|    } else {
 5653|      2|      if (follow) {
 5654|      0|      _L:
 5655|      0|        tmp___3 = stat((char const *)p->fts_accpath, sbp);
 5656|      0|        if (tmp___3) {
 5657|      0|          tmp = __errno_location();
 5658|      0|          saved_errno = *tmp;
 5659|      0|          tmp___1 = __errno_location();
 5660|      0|          if (*tmp___1 == 2) {
 5661|      0|            tmp___2 = lstat((char const *)p->fts_accpath, sbp);
 5662|      0|            if (tmp___2 == 0) {
 5663|      0|              tmp___0 = __errno_location();
 5664|      0|              *tmp___0 = 0;
 5665|      0|              return ((unsigned short)13);
 5666|      0|            }
 5667|      0|          }
 5668|      0|          p->fts_errno = saved_errno;
 5669|      0|          goto err;
 5670|      0|        }
 5671|      2|      } else {
 5672|      2|        tmp___5 =
 5673|      2|            fstatat(sp->fts_cwd_fd, (char const *)p->fts_accpath, sbp, 256);
 5674|      2|        if (tmp___5) {
 5675|      0|          tmp___4 = __errno_location();
 5676|      0|          p->fts_errno = *tmp___4;
 5677|      0|        err:
 5678|      0|          memset((void *)sbp, 0, sizeof(struct stat));
 5679|      0|          return ((unsigned short)10);
 5680|      0|        }
 5681|      2|      }
 5682|      2|    }
 5683|      2|    if ((sbp->st_mode & 61440U) == 16384U) {
 5684|      2|      if (sp->fts_options & 32) {
 5685|      0|        tmp___6 = 0;
 5686|      2|      } else {
 5687|      2|        tmp___6 = 2;
 5688|      2|      }
 5689|      2|      p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t)tmp___6;
 5690|      2|      if ((int)p->fts_name[0] == 46) {
 5691|      0|        if (!p->fts_name[1]) {
 5692|      0|          goto _L___0;
 5693|      0|        } else {
 5694|      0|          if ((int)p->fts_name[1] == 46) {
 5695|      0|            if (!p->fts_name[2]) {
 5696|      0|            _L___0:
 5697|      0|              if (p->fts_level == 0L) {
 5698|      0|                tmp___7 = 1;
 5699|      0|              } else {
 5700|      0|                tmp___7 = 5;
 5701|      0|              }
 5702|      0|              return ((unsigned short)tmp___7);
 5703|      0|            }
 5704|      0|          }
 5705|      0|        }
 5706|      0|      }
 5707|      2|      return ((unsigned short)1);
 5708|      2|    }
 5709|      0|    if ((sbp->st_mode & 61440U) == 40960U) {
 5710|      0|      return ((unsigned short)12);
 5711|      0|    }
 5712|      0|    if ((sbp->st_mode & 61440U) == 32768U) {
 5713|      0|      return ((unsigned short)8);
 5714|      0|    }
 5715|      0|    return ((unsigned short)3);
 5716|      0|  }
 5717|      0|}
 5718|      0|static int fts_compar(void const *a, void const *b) {
 5719|      0|  FTSENT const **pa;
 5720|      0|  FTSENT const **pb;
 5721|      0|  int tmp;
 5722|       |
 5723|      0|  {
 5724|      0|    pa = (FTSENT const **)a;
 5725|      0|    pb = (FTSENT const **)b;
 5726|      0|    tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
 5727|      0|    return (tmp);
 5728|      0|  }
 5729|      0|}
 5730|      0|static FTSENT *fts_sort(FTS *sp, FTSENT *head, size_t nitems) {
 5731|      0|  FTSENT **ap;
 5732|      0|  FTSENT *p;
 5733|      0|  FTSENT *dummy = 0;
 5734|      0|  int (*compare)(void const *, void const *);
 5735|      0|  int (*tmp)(void const *, void const *);
 5736|      0|  FTSENT **a;
 5737|      0|  FTSENT **tmp___0;
 5738|       |
 5739|      0|  {
 5740|      0|    if (sizeof(&dummy) == sizeof(void *)) {
 5741|      0|      if ((long)(&dummy) == (long)((void *)(&dummy))) {
 5742|      0|        tmp = (int (*)(void const *, void const *))sp->fts_compar;
 5743|      0|      } else {
 5744|      0|        tmp = &fts_compar;
 5745|      0|      }
 5746|      0|    } else {
 5747|      0|      tmp = &fts_compar;
 5748|      0|    }
 5749|      0|    compare = tmp;
 5750|      0|    if (nitems > sp->fts_nitems) {
 5751|      0|      sp->fts_nitems = nitems + 40UL;
 5752|      0|      if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
 5753|      0|        free((void *)sp->fts_array);
 5754|      0|        sp->fts_array = (struct _ftsent **)((void *)0);
 5755|      0|        sp->fts_nitems = (size_t)0;
 5756|      0|        return (head);
 5757|      0|      } else {
 5758|      0|        a = (FTSENT **)realloc((void *)sp->fts_array,
 5759|      0|                               sp->fts_nitems * sizeof(*a));
 5760|      0|        if (!a) {
 5761|      0|          free((void *)sp->fts_array);
 5762|      0|          sp->fts_array = (struct _ftsent **)((void *)0);
 5763|      0|          sp->fts_nitems = (size_t)0;
 5764|      0|          return (head);
 5765|      0|        }
 5766|      0|      }
 5767|      0|      sp->fts_array = a;
 5768|      0|    }
 5769|      0|    ap = sp->fts_array;
 5770|      0|    p = head;
 5771|      0|    while (1) {
 5772|       |
 5773|      0|      if (!p) {
 5774|      0|        goto while_break;
 5775|      0|      }
 5776|      0|      tmp___0 = ap;
 5777|      0|      ap++;
 5778|      0|      *tmp___0 = p;
 5779|      0|      p = p->fts_link;
 5780|      0|    }
 5781|      0|  while_break:
 5782|      0|    qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
 5783|      0|    ap = sp->fts_array;
 5784|      0|    head = *ap;
 5785|      0|    while (1) {
 5786|      0|      nitems--;
 5787|      0|      if (!nitems) {
 5788|      0|        goto while_break___0;
 5789|      0|      }
 5790|      0|      (*(ap + 0))->fts_link = *(ap + 1);
 5791|      0|      ap++;
 5792|      0|    }
 5793|      0|  while_break___0:
 5794|      0|    (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
 5795|      0|    return (head);
 5796|      0|  }
 5797|      0|}
 5798|      8|static FTSENT *fts_alloc(FTS *sp, char const *name, size_t namelen) {
 5799|      8|  FTSENT *p;
 5800|      8|  size_t len;
 5801|       |
 5802|      8|  {
 5803|      8|    len = sizeof(FTSENT) + namelen;
 5804|      8|    p = (FTSENT *)malloc(len);
 5805|      8|    if ((unsigned long)p == (unsigned long)((void *)0)) {
 5806|      0|      return ((FTSENT *)((void *)0));
 5807|      0|    }
 5808|      8|    memmove((void *)(p->fts_name), (void const *)name, namelen);
 5809|      8|    p->fts_name[namelen] = (char)'\000';
 5810|      8|    p->fts_namelen = namelen;
 5811|      8|    p->fts_fts = sp;
 5812|      8|    p->fts_path = sp->fts_path;
 5813|      8|    p->fts_errno = 0;
 5814|      8|    p->fts_flags = (unsigned short)0;
 5815|      8|    p->fts_instr = (unsigned short)3;
 5816|      8|    p->fts_number = 0L;
 5817|      8|    p->fts_pointer = (void *)0;
 5818|      8|    return (p);
 5819|      8|  }
 5820|      8|}
 5821|      0|static void fts_lfree(FTSENT *head) {
 5822|      0|  FTSENT *p;
 5823|       |
 5824|      0|  {
 5825|      0|    while (1) {
 5826|      0|      p = head;
 5827|      0|      if (!p) {
 5828|      0|        goto while_break;
 5829|      0|      }
 5830|      0|      head = head->fts_link;
 5831|      0|      free((void *)p);
 5832|      0|    }
 5833|      0|  while_break:;
 5834|      0|    return;
 5835|      0|  }
 5836|      0|}
 5837|      2|static _Bool fts_palloc(FTS *sp, size_t more) {
 5838|      2|  char *p;
 5839|      2|  size_t new_len;
 5840|      2|  int *tmp;
 5841|       |
 5842|      2|  {
 5843|      2|    new_len = (sp->fts_pathlen + more) + 256UL;
 5844|      2|    if (new_len < sp->fts_pathlen) {
 5845|      0|      free((void *)sp->fts_path);
 5846|      0|      sp->fts_path = (char *)((void *)0);
 5847|      0|      tmp = __errno_location();
 5848|      0|      *tmp = 36;
 5849|      0|      return ((_Bool)0);
 5850|      0|    }
 5851|      2|    sp->fts_pathlen = new_len;
 5852|      2|    p = (char *)realloc((void *)sp->fts_path, sp->fts_pathlen);
 5853|      2|    if ((unsigned long)p == (unsigned long)((void *)0)) {
 5854|      0|      free((void *)sp->fts_path);
 5855|      0|      sp->fts_path = (char *)((void *)0);
 5856|      0|      return ((_Bool)0);
 5857|      0|    }
 5858|      2|    sp->fts_path = p;
 5859|      2|    return ((_Bool)1);
 5860|      2|  }
 5861|      2|}
 5862|      0|static void fts_padjust(FTS *sp, FTSENT *head) {
 5863|      0|  FTSENT *p;
 5864|      0|  char *addr;
 5865|       |
 5866|      0|  {
 5867|      0|    addr = sp->fts_path;
 5868|      0|    p = sp->fts_child;
 5869|      0|    while (1) {
 5870|       |
 5871|      0|      if (!p) {
 5872|      0|        goto while_break;
 5873|      0|      }
 5874|      0|      while (1) {
 5875|       |
 5876|      0|        if ((unsigned long)p->fts_accpath != (unsigned long)(p->fts_name)) {
 5877|      0|          p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
 5878|      0|        }
 5879|      0|        p->fts_path = addr;
 5880|      0|        goto while_break___0;
 5881|      0|      }
 5882|      0|    while_break___0:
 5883|      0|      p = p->fts_link;
 5884|      0|    }
 5885|      0|  while_break:
 5886|      0|    p = head;
 5887|      0|    while (1) {
 5888|       |
 5889|      0|      if (!(p->fts_level >= 0L)) {
 5890|      0|        goto while_break___1;
 5891|      0|      }
 5892|      0|      while (1) {
 5893|       |
 5894|      0|        if ((unsigned long)p->fts_accpath != (unsigned long)(p->fts_name)) {
 5895|      0|          p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
 5896|      0|        }
 5897|      0|        p->fts_path = addr;
 5898|      0|        goto while_break___2;
 5899|      0|      }
 5900|      0|    while_break___2:;
 5901|      0|      if (p->fts_link) {
 5902|      0|        p = p->fts_link;
 5903|      0|      } else {
 5904|      0|        p = p->fts_parent;
 5905|      0|      }
 5906|      0|    }
 5907|      0|  while_break___1:;
 5908|      0|    return;
 5909|      0|  }
 5910|      0|}
 5911|      2|static size_t fts_maxarglen(char *const *argv) {
 5912|      2|  size_t len;
 5913|      2|  size_t max;
 5914|       |
 5915|      2|  {
 5916|      2|    max = (size_t)0;
 5917|      4|    while (1) {
 5918|       |
 5919|      4|      if (!*argv) {
 5920|      2|        goto while_break;
 5921|      2|      }
 5922|      2|      len = strlen((char const *)*argv);
 5923|      2|      if (len > max) {
 5924|      2|        max = len;
 5925|      2|      }
 5926|      2|      argv++;
 5927|      2|    }
 5928|      2|  while_break:;
 5929|      2|    return (max + 1UL);
 5930|      2|  }
 5931|      2|}
 5932|      2|static int fts_safe_changedir(FTS *sp, FTSENT *p, int fd, char const *dir) {
 5933|      2|  int ret;
 5934|      2|  _Bool is_dotdot;
 5935|      2|  int tmp;
 5936|      2|  int tmp___0;
 5937|      2|  int newfd;
 5938|      2|  int parent_fd;
 5939|      2|  _Bool tmp___1;
 5940|      2|  struct stat sb;
 5941|      2|  int tmp___2;
 5942|      2|  int *tmp___3;
 5943|      2|  int tmp___4;
 5944|      2|  int oerrno;
 5945|      2|  int *tmp___5;
 5946|      2|  int *tmp___6;
 5947|       |
 5948|      2|  {
 5949|      2|    if (dir) {
 5950|      0|      tmp = strcmp(dir, "..");
 5951|      0|      if (tmp == 0) {
 5952|      0|        tmp___0 = 1;
 5953|      0|      } else {
 5954|      0|        tmp___0 = 0;
 5955|      0|      }
 5956|      2|    } else {
 5957|      2|      tmp___0 = 0;
 5958|      2|    }
 5959|      2|    is_dotdot = (_Bool)tmp___0;
 5960|      2|    if (sp->fts_options & 4) {
 5961|      0|      if (sp->fts_options & 512) {
 5962|      0|        if (0 <= fd) {
 5963|      0|          close(fd);
 5964|      0|        }
 5965|      0|      }
 5966|      0|      return (0);
 5967|      0|    }
 5968|      2|    if (fd < 0) {
 5969|      0|      if (is_dotdot) {
 5970|      0|        if (sp->fts_options & 512) {
 5971|      0|          tmp___1 = i_ring_empty((I_ring const *)(&sp->fts_fd_ring));
 5972|      0|          if (!tmp___1) {
 5973|      0|            parent_fd = i_ring_pop(&sp->fts_fd_ring);
 5974|      0|            is_dotdot = (_Bool)1;
 5975|      0|            if (0 <= parent_fd) {
 5976|      0|              fd = parent_fd;
 5977|      0|              dir = (char const *)((void *)0);
 5978|      0|            }
 5979|      0|          }
 5980|      0|        }
 5981|      0|      }
 5982|      0|    }
 5983|      2|    newfd = fd;
 5984|      2|    if (fd < 0) {
 5985|      0|      newfd = diropen((FTS const *)sp, dir);
 5986|      0|      if (newfd < 0) {
 5987|      0|        return (-1);
 5988|      0|      }
 5989|      0|    }
 5990|      2|    if (sp->fts_options & 2) {
 5991|      0|      goto _L;
 5992|      2|    } else {
 5993|      2|      if (dir) {
 5994|      0|        tmp___4 = strcmp(dir, "..");
 5995|      0|        if (tmp___4 == 0) {
 5996|      0|        _L:
 5997|      0|          tmp___2 = fstat(newfd, &sb);
 5998|      0|          if (tmp___2) {
 5999|      0|            ret = -1;
 6000|      0|            goto bail;
 6001|      0|          }
 6002|      0|          if (p->fts_statp[0].st_dev != sb.st_dev) {
 6003|      0|            tmp___3 = __errno_location();
 6004|      0|            *tmp___3 = 2;
 6005|      0|            ret = -1;
 6006|      0|            goto bail;
 6007|      0|          } else {
 6008|      0|            if (p->fts_statp[0].st_ino != sb.st_ino) {
 6009|      0|              tmp___3 = __errno_location();
 6010|      0|              *tmp___3 = 2;
 6011|      0|              ret = -1;
 6012|      0|              goto bail;
 6013|      0|            }
 6014|      0|          }
 6015|      0|        }
 6016|      0|      }
 6017|      2|    }
 6018|      2|    if (sp->fts_options & 512) {
 6019|      2|      cwd_advance_fd(sp, newfd, (_Bool)(!is_dotdot));
 6020|      2|      return (0);
 6021|      2|    }
 6022|      0|    ret = fchdir(newfd);
 6023|      0|  bail:
 6024|      0|    if (fd < 0) {
 6025|      0|      tmp___5 = __errno_location();
 6026|      0|      oerrno = *tmp___5;
 6027|      0|      close(newfd);
 6028|      0|      tmp___6 = __errno_location();
 6029|      0|      *tmp___6 = oerrno;
 6030|      0|    }
 6031|      0|    return (ret);
 6032|      0|  }
 6033|      0|}
 6034|       |#pragma weak pthread_key_create
 6035|       |#pragma weak pthread_getspecific
 6036|       |#pragma weak pthread_setspecific
 6037|       |#pragma weak pthread_key_delete
 6038|       |#pragma weak pthread_self
 6039|       |#pragma weak pthread_cancel
 6040|       |#pragma weak pthread_mutex_init
 6041|       |#pragma weak pthread_mutex_lock
 6042|       |#pragma weak pthread_mutex_unlock
 6043|       |#pragma weak pthread_mutex_destroy
 6044|       |#pragma weak pthread_rwlock_init
 6045|       |#pragma weak pthread_rwlock_rdlock
 6046|       |#pragma weak pthread_rwlock_wrlock
 6047|       |#pragma weak pthread_rwlock_unlock
 6048|       |#pragma weak pthread_rwlock_destroy
 6049|       |#pragma weak pthread_once
 6050|       |#pragma weak pthread_cond_init
 6051|       |#pragma weak pthread_cond_wait
 6052|       |#pragma weak pthread_cond_signal
 6053|       |#pragma weak pthread_cond_broadcast
 6054|       |#pragma weak pthread_cond_destroy
 6055|       |#pragma weak pthread_mutexattr_init
 6056|       |#pragma weak pthread_mutexattr_settype
 6057|       |#pragma weak pthread_mutexattr_destroy
 6058|       |#pragma weak pthread_self
 6059|       |#pragma weak pthread_cancel
 6060|       |char const *Version = "8.2";
 6061|       |extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2),
 6062|       |                                                       __leaf__)) fchownat)(
 6063|       |    int __fd, char const *__file, __uid_t __owner, __gid_t __group, int __flag);
 6064|       |__inline static int chownat(int fd, char const *file, uid_t owner,
 6065|      0|                            gid_t group) {
 6066|      0|  int tmp;
 6067|       |
 6068|      0|  {
 6069|      0|    tmp = fchownat(fd, file, owner, group, 0);
 6070|      0|    return (tmp);
 6071|      0|  }
 6072|      0|}
 6073|       |__inline static int lchownat(int fd, char const *file, uid_t owner,
 6074|      4|                             gid_t group) {
 6075|      4|  int tmp;
 6076|       |
 6077|      4|  {
 6078|      4|    tmp = fchownat(fd, file, owner, group, 256);
 6079|      4|    return (tmp);
 6080|      4|  }
 6081|      4|}
 6082|       |extern void chopt_init(struct Chown_option *chopt);
 6083|       |extern void chopt_free(struct Chown_option *chopt __attribute__((__unused__)));
 6084|       |extern char *gid_to_name(gid_t gid);
 6085|       |extern char *uid_to_name(uid_t uid);
 6086|       |extern _Bool chown_files(char **files, int bit_flags, uid_t uid, gid_t gid,
 6087|       |                         uid_t required_uid, gid_t required_gid,
 6088|       |                         struct Chown_option const *chopt);
 6089|      0|__inline static void ignore_ptr(void *p) {
 6090|       |
 6091|      0|  { return; }
 6092|      0|}
 6093|      2|extern void chopt_init(struct Chown_option *chopt) {
 6094|       |
 6095|      2|  {
 6096|      2|    chopt->verbosity = (enum Verbosity)2;
 6097|      2|    chopt->root_dev_ino = (struct dev_ino *)((void *)0);
 6098|      2|    chopt->affect_symlink_referent = (_Bool)1;
 6099|      2|    chopt->recurse = (_Bool)0;
 6100|      2|    chopt->force_silent = (_Bool)0;
 6101|      2|    chopt->user_name = (char *)((void *)0);
 6102|      2|    chopt->group_name = (char *)((void *)0);
 6103|      2|    return;
 6104|      2|  }
 6105|      2|}
 6106|      2|extern void chopt_free(struct Chown_option *chopt __attribute__((__unused__))) {
 6107|       |
 6108|      2|  {
 6109|      2|    return;
 6110|      2|  }
 6111|      2|}
 6112|      0|extern char *gid_to_name(gid_t gid) {
 6113|      0|  char
 6114|      0|      buf___1[((((sizeof(intmax_t) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL) +
 6115|      0|              1UL];
 6116|      0|  struct group *grp;
 6117|      0|  struct group *tmp;
 6118|      0|  char *tmp___1;
 6119|      0|  char *tmp___2;
 6120|      0|  char *tmp___3;
 6121|       |
 6122|      0|  {
 6123|      0|    tmp = getgrgid(gid);
 6124|      0|    grp = tmp;
 6125|      0|    if (grp) {
 6126|      0|      tmp___2 = grp->gr_name;
 6127|      0|    } else {
 6128|      0|      tmp___1 = umaxtostr((uintmax_t)gid, buf___1);
 6129|      0|      tmp___2 = tmp___1;
 6130|      0|    }
 6131|      0|    tmp___3 = xstrdup((char const *)tmp___2);
 6132|      0|    return (tmp___3);
 6133|      0|  }
 6134|      0|}
 6135|      0|extern char *uid_to_name(uid_t uid) {
 6136|      0|  char
 6137|      0|      buf___1[((((sizeof(intmax_t) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL) +
 6138|      0|              1UL];
 6139|      0|  struct passwd *pwd;
 6140|      0|  struct passwd *tmp;
 6141|      0|  char *tmp___1;
 6142|      0|  char *tmp___2;
 6143|      0|  char *tmp___3;
 6144|       |
 6145|      0|  {
 6146|      0|    tmp = getpwuid(uid);
 6147|      0|    pwd = tmp;
 6148|      0|    if (pwd) {
 6149|      0|      tmp___2 = pwd->pw_name;
 6150|      0|    } else {
 6151|      0|      tmp___1 = umaxtostr((uintmax_t)uid, buf___1);
 6152|      0|      tmp___2 = tmp___1;
 6153|      0|    }
 6154|      0|    tmp___3 = xstrdup((char const *)tmp___2);
 6155|      0|    return (tmp___3);
 6156|      0|  }
 6157|      0|}
 6158|       |static void describe_change(char const *file, enum Change_status changed,
 6159|      0|                            char const *user, char const *group) {
 6160|      0|  char const *fmt;
 6161|      0|  char const *spec;
 6162|      0|  char *spec_allocated;
 6163|      0|  char const *tmp;
 6164|      0|  char *tmp___0;
 6165|      0|  size_t tmp___1;
 6166|      0|  size_t tmp___2;
 6167|      0|  char *tmp___3;
 6168|      0|  char *tmp___4;
 6169|      0|  char *tmp___5;
 6170|      0|  char *tmp___6;
 6171|      0|  char *tmp___7;
 6172|      0|  char *tmp___8;
 6173|      0|  char *tmp___9;
 6174|      0|  char *tmp___10;
 6175|      0|  char *tmp___11;
 6176|      0|  char *tmp___12;
 6177|      0|  char *tmp___13;
 6178|      0|  char *tmp___14;
 6179|      0|  char *tmp___15;
 6180|      0|  char *tmp___16;
 6181|      0|  char const *tmp___17;
 6182|       |
 6183|      0|  {
 6184|      0|    spec_allocated = (char *)((void *)0);
 6185|      0|    if ((unsigned int)changed == 1U) {
 6186|      0|      tmp = quote(file);
 6187|      0|      tmp___0 =
 6188|      0|          gettext("neither symbolic link %s nor referent has been changed\n");
 6189|      0|      printf((char const *)tmp___0, tmp);
 6190|      0|      return;
 6191|      0|    }
 6192|      0|    if (user) {
 6193|      0|      if (group) {
 6194|      0|        tmp___1 = strlen(user);
 6195|      0|        tmp___2 = strlen(group);
 6196|      0|        spec_allocated = (char *)xmalloc(((tmp___1 + 1UL) + tmp___2) + 1UL);
 6197|      0|        tmp___3 = stpcpy(spec_allocated, user);
 6198|      0|        tmp___4 = stpcpy(tmp___3, ":");
 6199|      0|        stpcpy(tmp___4, group);
 6200|      0|        spec = (char const *)spec_allocated;
 6201|      0|      } else {
 6202|      0|        spec = user;
 6203|      0|      }
 6204|      0|    } else {
 6205|      0|      spec = group;
 6206|      0|    }
 6207|      0|    if ((unsigned int)changed == 2U) {
 6208|      0|      goto case_2;
 6209|      0|    }
 6210|      0|    if ((unsigned int)changed == 3U) {
 6211|      0|      goto case_3;
 6212|      0|    }
 6213|      0|    if ((unsigned int)changed == 4U) {
 6214|      0|      goto case_4;
 6215|      0|    }
 6216|      0|    goto switch_default;
 6217|      0|  case_2:
 6218|      0|    if (user) {
 6219|      0|      tmp___5 = gettext("changed ownership of %s to %s\n");
 6220|      0|      fmt = (char const *)tmp___5;
 6221|      0|    } else {
 6222|      0|      if (group) {
 6223|      0|        tmp___6 = gettext("changed group of %s to %s\n");
 6224|      0|        tmp___8 = tmp___6;
 6225|      0|      } else {
 6226|      0|        tmp___7 = gettext("no change to ownership of %s\n");
 6227|      0|        tmp___8 = tmp___7;
 6228|      0|      }
 6229|      0|      fmt = (char const *)tmp___8;
 6230|      0|    }
 6231|      0|    goto switch_break;
 6232|      0|  case_3:
 6233|      0|    if (user) {
 6234|      0|      tmp___9 = gettext("failed to change ownership of %s to %s\n");
 6235|      0|      fmt = (char const *)tmp___9;
 6236|      0|    } else {
 6237|      0|      if (group) {
 6238|      0|        tmp___10 = gettext("failed to change group of %s to %s\n");
 6239|      0|        tmp___12 = tmp___10;
 6240|      0|      } else {
 6241|      0|        tmp___11 = gettext("failed to change ownership of %s\n");
 6242|      0|        tmp___12 = tmp___11;
 6243|      0|      }
 6244|      0|      fmt = (char const *)tmp___12;
 6245|      0|    }
 6246|      0|    goto switch_break;
 6247|      0|  case_4:
 6248|      0|    if (user) {
 6249|      0|      tmp___13 = gettext("ownership of %s retained as %s\n");
 6250|      0|      fmt = (char const *)tmp___13;
 6251|      0|    } else {
 6252|      0|      if (group) {
 6253|      0|        tmp___14 = gettext("group of %s retained as %s\n");
 6254|      0|        tmp___16 = tmp___14;
 6255|      0|      } else {
 6256|      0|        tmp___15 = gettext("ownership of %s retained\n");
 6257|      0|        tmp___16 = tmp___15;
 6258|      0|      }
 6259|      0|      fmt = (char const *)tmp___16;
 6260|      0|    }
 6261|      0|    goto switch_break;
 6262|      0|  switch_default:
 6263|      0|    abort();
 6264|      0|  switch_break:
 6265|      0|    tmp___17 = quote(file);
 6266|      0|    printf(fmt, tmp___17, spec);
 6267|      0|    free((void *)spec_allocated);
 6268|      0|    return;
 6269|      0|  }
 6270|      0|}
 6271|       |static enum RCH_status restricted_chown(int cwd_fd, char const *file,
 6272|       |                                        struct stat const *orig_st, uid_t uid,
 6273|       |                                        gid_t gid, uid_t required_uid,
 6274|      0|                                        gid_t required_gid) {
 6275|      0|  enum RCH_status status;
 6276|      0|  struct stat st;
 6277|      0|  int open_flags;
 6278|      0|  int fd;
 6279|      0|  int tmp___0;
 6280|      0|  int *tmp___1;
 6281|      0|  int *tmp___2;
 6282|      0|  int tmp___4;
 6283|      0|  int tmp___5;
 6284|      0|  int tmp___6;
 6285|      0|  int saved_errno;
 6286|      0|  int *tmp___7;
 6287|      0|  int *tmp___8;
 6288|       |
 6289|      0|  {
 6290|      0|    status = (enum RCH_status)2;
 6291|      0|    open_flags = 2304;
 6292|      0|    if (required_uid == 4294967295U) {
 6293|      0|      if (required_gid == 4294967295U) {
 6294|      0|        return ((enum RCH_status)5);
 6295|      0|      }
 6296|      0|    }
 6297|      0|    if (!((orig_st->st_mode & 61440U) == 32768U)) {
 6298|      0|      if ((orig_st->st_mode & 61440U) == 16384U) {
 6299|      0|        open_flags |= 65536;
 6300|      0|      } else {
 6301|      0|        return ((enum RCH_status)5);
 6302|      0|      }
 6303|      0|    }
 6304|      0|    fd = openat(cwd_fd, file, open_flags);
 6305|      0|    if (!(0 <= fd)) {
 6306|      0|      tmp___2 = __errno_location();
 6307|      0|      if (*tmp___2 == 13) {
 6308|      0|        if ((orig_st->st_mode & 61440U) == 32768U) {
 6309|      0|          fd = openat(cwd_fd, file, 1 | open_flags);
 6310|      0|          if (!(0 <= fd)) {
 6311|      0|            goto _L___0;
 6312|      0|          }
 6313|      0|        } else {
 6314|      0|          goto _L___0;
 6315|      0|        }
 6316|      0|      } else {
 6317|      0|      _L___0:
 6318|      0|        tmp___1 = __errno_location();
 6319|      0|        if (*tmp___1 == 13) {
 6320|      0|          tmp___0 = 5;
 6321|      0|        } else {
 6322|      0|          tmp___0 = 6;
 6323|      0|        }
 6324|      0|        return ((enum RCH_status)tmp___0);
 6325|      0|      }
 6326|      0|    }
 6327|      0|    tmp___6 = fstat(fd, &st);
 6328|      0|    if (tmp___6 != 0) {
 6329|      0|      status = (enum RCH_status)6;
 6330|      0|    } else {
 6331|      0|      if (orig_st->st_ino == (__ino_t const)st.st_ino) {
 6332|      0|        if (orig_st->st_dev == (__dev_t const)st.st_dev) {
 6333|      0|          if (required_uid == 4294967295U) {
 6334|      0|            goto _L___2;
 6335|      0|          } else {
 6336|      0|            if (required_uid == st.st_uid) {
 6337|      0|            _L___2:
 6338|      0|              if (required_gid == 4294967295U) {
 6339|      0|                goto _L___1;
 6340|      0|              } else {
 6341|      0|                if (required_gid == st.st_gid) {
 6342|      0|                _L___1:
 6343|      0|                  tmp___5 = fchown(fd, uid, gid);
 6344|      0|                  if (tmp___5 == 0) {
 6345|      0|                    tmp___4 = close(fd);
 6346|      0|                    if (tmp___4 == 0) {
 6347|      0|                      status = (enum RCH_status)2;
 6348|      0|                    } else {
 6349|      0|                      status = (enum RCH_status)6;
 6350|      0|                    }
 6351|      0|                    return (status);
 6352|      0|                  } else {
 6353|      0|                    status = (enum RCH_status)6;
 6354|      0|                  }
 6355|      0|                }
 6356|      0|              }
 6357|      0|            }
 6358|      0|          }
 6359|      0|        } else {
 6360|      0|          status = (enum RCH_status)4;
 6361|      0|        }
 6362|      0|      } else {
 6363|      0|        status = (enum RCH_status)4;
 6364|      0|      }
 6365|      0|    }
 6366|      0|    tmp___7 = __errno_location();
 6367|      0|    saved_errno = *tmp___7;
 6368|      0|    close(fd);
 6369|      0|    tmp___8 = __errno_location();
 6370|      0|    *tmp___8 = saved_errno;
 6371|      0|    return (status);
 6372|      0|  }
 6373|      0|}
 6374|       |static _Bool change_file_owner(FTS *fts, FTSENT *ent, uid_t uid, gid_t gid,
 6375|       |                               uid_t required_uid, gid_t required_gid,
 6376|      6|                               struct Chown_option const *chopt) {
 6377|      6|  char const *file_full_name;
 6378|      6|  char const *file;
 6379|      6|  struct stat const *file_stats;
 6380|      6|  struct stat stat_buf;
 6381|      6|  _Bool ok;
 6382|      6|  _Bool do_chown;
 6383|      6|  _Bool symlink_changed;
 6384|      6|  char const *tmp;
 6385|      6|  char *tmp___0;
 6386|      6|  char const *tmp___1;
 6387|      6|  char const *tmp___2;
 6388|      6|  char *tmp___3;
 6389|      6|  int tmp___4;
 6390|      6|  char *tmp___5;
 6391|      6|  FTSENT *tmp___6;
 6392|      6|  char const *tmp___7;
 6393|      6|  char *tmp___8;
 6394|      6|  char const *tmp___9;
 6395|      6|  char *tmp___10;
 6396|      6|  char const *tmp___11;
 6397|      6|  char *tmp___12;
 6398|      6|  char const *tmp___13;
 6399|      6|  char *tmp___14;
 6400|      6|  _Bool tmp___15;
 6401|      6|  char const *tmp___16;
 6402|      6|  char *tmp___17;
 6403|      6|  int *tmp___18;
 6404|      6|  int tmp___19;
 6405|      6|  int tmp___20;
 6406|      6|  char const *tmp___21;
 6407|      6|  char *tmp___22;
 6408|      6|  char const *tmp___23;
 6409|      6|  char const *tmp___24;
 6410|      6|  char *tmp___25;
 6411|      6|  int tmp___26;
 6412|      6|  char *tmp___27;
 6413|      6|  int tmp___28;
 6414|      6|  int *tmp___29;
 6415|      6|  enum RCH_status err;
 6416|      6|  enum RCH_status tmp___30;
 6417|      6|  int tmp___31;
 6418|      6|  char const *tmp___32;
 6419|      6|  char *tmp___33;
 6420|      6|  char *tmp___34;
 6421|      6|  char *tmp___35;
 6422|      6|  int *tmp___36;
 6423|      6|  _Bool changed;
 6424|      6|  int tmp___37;
 6425|      6|  enum Change_status ch_status;
 6426|      6|  int tmp___38;
 6427|      6|  int tmp___39;
 6428|      6|  int tmp___40;
 6429|       |
 6430|      6|  {
 6431|      6|    file_full_name = (char const *)ent->fts_path;
 6432|      6|    file = (char const *)ent->fts_accpath;
 6433|      6|    ok = (_Bool)1;
 6434|      6|    symlink_changed = (_Bool)1;
 6435|      6|    if ((int)ent->fts_info == 1) {
 6436|      2|      goto case_1;
 6437|      2|    }
 6438|      4|    if ((int)ent->fts_info == 6) {
 6439|      2|      goto case_6;
 6440|      2|    }
 6441|      2|    if ((int)ent->fts_info == 10) {
 6442|      0|      goto case_10;
 6443|      0|    }
 6444|      2|    if ((int)ent->fts_info == 7) {
 6445|      0|      goto case_7;
 6446|      0|    }
 6447|      2|    if ((int)ent->fts_info == 4) {
 6448|      0|      goto case_4;
 6449|      0|    }
 6450|      2|    if ((int)ent->fts_info == 2) {
 6451|      0|      goto case_2;
 6452|      0|    }
 6453|      2|    goto switch_default;
 6454|      2|  case_1:
 6455|      2|    if (chopt->recurse) {
 6456|      2|      if (chopt->root_dev_ino) {
 6457|      0|        if (ent->fts_statp[0].st_ino == (chopt->root_dev_ino)->st_ino) {
 6458|      0|          if (ent->fts_statp[0].st_dev == (chopt->root_dev_ino)->st_dev) {
 6459|      0|            while (1) {
 6460|      0|              tmp___4 = strcmp(file_full_name, "/");
 6461|      0|              if (tmp___4 == 0) {
 6462|      0|                tmp = quote(file_full_name);
 6463|      0|                tmp___0 =
 6464|      0|                    gettext("it is dangerous to operate recursively on %s");
 6465|      0|                error(0, 0, (char const *)tmp___0, tmp);
 6466|      0|              } else {
 6467|      0|                tmp___1 = quote_n(1, "/");
 6468|      0|                tmp___2 = quote_n(0, file_full_name);
 6469|      0|                tmp___3 = gettext("it is dangerous to operate recursively on "
 6470|      0|                                  "%s (same as %s)");
 6471|      0|                error(0, 0, (char const *)tmp___3, tmp___2, tmp___1);
 6472|      0|              }
 6473|      0|              tmp___5 =
 6474|      0|                  gettext("use --no-preserve-root to override this failsafe");
 6475|      0|              error(0, 0, (char const *)tmp___5);
 6476|      0|              goto while_break;
 6477|      0|            }
 6478|      0|          while_break:
 6479|      0|            fts_set(fts, ent, 4);
 6480|      0|            tmp___6 = fts_read(fts);
 6481|      0|            ignore_ptr((void *)tmp___6);
 6482|      0|            return ((_Bool)0);
 6483|      0|          }
 6484|      0|        }
 6485|      0|      }
 6486|      2|      return ((_Bool)1);
 6487|      2|    }
 6488|      0|    goto switch_break;
 6489|      2|  case_6:
 6490|      2|    if (!chopt->recurse) {
 6491|      0|      return ((_Bool)1);
 6492|      0|    }
 6493|      2|    goto switch_break;
 6494|      2|  case_10:
 6495|      0|    if (ent->fts_level == 0L) {
 6496|      0|      if (ent->fts_number == 0L) {
 6497|      0|        ent->fts_number = 1L;
 6498|      0|        fts_set(fts, ent, 1);
 6499|      0|        return ((_Bool)1);
 6500|      0|      }
 6501|      0|    }
 6502|      0|    if (!chopt->force_silent) {
 6503|      0|      tmp___7 = quote(file_full_name);
 6504|      0|      tmp___8 = gettext("cannot access %s");
 6505|      0|      error(0, ent->fts_errno, (char const *)tmp___8, tmp___7);
 6506|      0|    }
 6507|      0|    ok = (_Bool)0;
 6508|      0|    goto switch_break;
 6509|      0|  case_7:
 6510|      0|    if (!chopt->force_silent) {
 6511|      0|      tmp___9 = quote(file_full_name);
 6512|      0|      tmp___10 = gettext("%s");
 6513|      0|      error(0, ent->fts_errno, (char const *)tmp___10, tmp___9);
 6514|      0|    }
 6515|      0|    ok = (_Bool)0;
 6516|      0|    goto switch_break;
 6517|      0|  case_4:
 6518|      0|    if (!chopt->force_silent) {
 6519|      0|      tmp___11 = quote(file_full_name);
 6520|      0|      tmp___12 = gettext("cannot read directory %s");
 6521|      0|      error(0, ent->fts_errno, (char const *)tmp___12, tmp___11);
 6522|      0|    }
 6523|      0|    ok = (_Bool)0;
 6524|      0|    goto switch_break;
 6525|      0|  case_2:
 6526|      0|    tmp___15 = cycle_warning_required((FTS const *)fts, (FTSENT const *)ent);
 6527|      0|    if (tmp___15) {
 6528|      0|      while (1) {
 6529|      0|        tmp___13 = quote(file_full_name);
 6530|      0|        tmp___14 = gettext(
 6531|      0|            "WARNING: Circular directory structure.\nThis almost certainly "
 6532|      0|            "means that you have a corrupted file system.\nNOTIFY YOUR SYSTEM "
 6533|      0|            "MANAGER.\nThe following directory is part of the cycle:\n  %s\n");
 6534|      0|        error(0, 0, (char const *)tmp___14, tmp___13);
 6535|      0|        goto while_break___0;
 6536|      0|      }
 6537|      0|    while_break___0:;
 6538|      0|      return ((_Bool)0);
 6539|      0|    }
 6540|      0|    goto switch_break;
 6541|      2|  switch_default:
 6542|      2|    goto switch_break;
 6543|      4|  switch_break:;
 6544|      4|    if (!ok) {
 6545|      0|      do_chown = (_Bool)0;
 6546|      0|      file_stats = (struct stat const *)((void *)0);
 6547|      4|    } else {
 6548|      4|      if (required_uid == 4294967295U) {
 6549|      4|        if (required_gid == 4294967295U) {
 6550|      4|          if ((unsigned int const)chopt->verbosity == 2U) {
 6551|      4|            if (!chopt->root_dev_ino) {
 6552|      4|              if (!chopt->affect_symlink_referent) {
 6553|      4|                do_chown = (_Bool)1;
 6554|      4|                file_stats = (struct stat const *)(ent->fts_statp);
 6555|      4|              } else {
 6556|      0|                goto _L___3;
 6557|      0|              }
 6558|      4|            } else {
 6559|      0|              goto _L___3;
 6560|      0|            }
 6561|      4|          } else {
 6562|      0|            goto _L___3;
 6563|      0|          }
 6564|      4|        } else {
 6565|      0|          goto _L___3;
 6566|      0|        }
 6567|      4|      } else {
 6568|      0|      _L___3:
 6569|      0|        file_stats = (struct stat const *)(ent->fts_statp);
 6570|      0|        if (chopt->affect_symlink_referent) {
 6571|      0|          if ((file_stats->st_mode & 61440U) == 40960U) {
 6572|      0|            tmp___19 = fstatat(fts->fts_cwd_fd, file, &stat_buf, 0);
 6573|      0|            if (tmp___19 != 0) {
 6574|      0|              if (!chopt->force_silent) {
 6575|      0|                tmp___16 = quote(file_full_name);
 6576|      0|                tmp___17 = gettext("cannot dereference %s");
 6577|      0|                tmp___18 = __errno_location();
 6578|      0|                error(0, *tmp___18, (char const *)tmp___17, tmp___16);
 6579|      0|              }
 6580|      0|              ok = (_Bool)0;
 6581|      0|            }
 6582|      0|            file_stats = (struct stat const *)(&stat_buf);
 6583|      0|          }
 6584|      0|        }
 6585|      0|        if (ok) {
 6586|      0|          if (required_uid == 4294967295U) {
 6587|      0|            goto _L;
 6588|      0|          } else {
 6589|      0|            if (required_uid == (uid_t)file_stats->st_uid) {
 6590|      0|            _L:
 6591|      0|              if (required_gid == 4294967295U) {
 6592|      0|                tmp___20 = 1;
 6593|      0|              } else {
 6594|      0|                if (required_gid == (gid_t)file_stats->st_gid) {
 6595|      0|                  tmp___20 = 1;
 6596|      0|                } else {
 6597|      0|                  tmp___20 = 0;
 6598|      0|                }
 6599|      0|              }
 6600|      0|            } else {
 6601|      0|              tmp___20 = 0;
 6602|      0|            }
 6603|      0|          }
 6604|      0|        } else {
 6605|      0|          tmp___20 = 0;
 6606|      0|        }
 6607|      0|        do_chown = (_Bool)tmp___20;
 6608|      0|      }
 6609|      4|    }
 6610|      4|    if (ok) {
 6611|      4|      if ((int)ent->fts_info == 1) {
 6612|      0|        goto _L___4;
 6613|      4|      } else {
 6614|      4|        if ((int)ent->fts_info == 2) {
 6615|      0|          goto _L___4;
 6616|      4|        } else {
 6617|      4|          if ((int)ent->fts_info == 6) {
 6618|      2|            goto _L___4;
 6619|      2|          } else {
 6620|      2|            if ((int)ent->fts_info == 4) {
 6621|      2|            _L___4:
 6622|      2|              if (chopt->root_dev_ino) {
 6623|      0|                if (file_stats->st_ino ==
 6624|      0|                    (__ino_t const)(chopt->root_dev_ino)->st_ino) {
 6625|      0|                  if (file_stats->st_dev ==
 6626|      0|                      (__dev_t const)(chopt->root_dev_ino)->st_dev) {
 6627|      0|                    while (1) {
 6628|      0|                      tmp___26 = strcmp(file_full_name, "/");
 6629|      0|                      if (tmp___26 == 0) {
 6630|      0|                        tmp___21 = quote(file_full_name);
 6631|      0|                        tmp___22 = gettext(
 6632|      0|                            "it is dangerous to operate recursively on %s");
 6633|      0|                        error(0, 0, (char const *)tmp___22, tmp___21);
 6634|      0|                      } else {
 6635|      0|                        tmp___23 = quote_n(1, "/");
 6636|      0|                        tmp___24 = quote_n(0, file_full_name);
 6637|      0|                        tmp___25 = gettext("it is dangerous to operate "
 6638|      0|                                           "recursively on %s (same as %s)");
 6639|      0|                        error(0, 0, (char const *)tmp___25, tmp___24, tmp___23);
 6640|      0|                      }
 6641|      0|                      tmp___27 = gettext(
 6642|      0|                          "use --no-preserve-root to override this failsafe");
 6643|      0|                      error(0, 0, (char const *)tmp___27);
 6644|      0|                      goto while_break___1;
 6645|      0|                    }
 6646|      0|                  while_break___1:;
 6647|      0|                    return ((_Bool)0);
 6648|      0|                  }
 6649|      0|                }
 6650|      0|              }
 6651|      2|            }
 6652|      2|          }
 6653|      4|        }
 6654|      4|      }
 6655|      4|    }
 6656|      4|    if (do_chown) {
 6657|      4|      if (!chopt->affect_symlink_referent) {
 6658|      4|        tmp___28 = lchownat(fts->fts_cwd_fd, file, uid, gid);
 6659|      4|        ok = (_Bool)(tmp___28 == 0);
 6660|      4|        if (!ok) {
 6661|      0|          tmp___29 = __errno_location();
 6662|      0|          if (*tmp___29 == 95) {
 6663|      0|            ok = (_Bool)1;
 6664|      0|            symlink_changed = (_Bool)0;
 6665|      0|          }
 6666|      0|        }
 6667|      4|      } else {
 6668|      0|        tmp___30 = restricted_chown(fts->fts_cwd_fd, file, file_stats, uid, gid,
 6669|      0|                                    required_uid, required_gid);
 6670|      0|        err = tmp___30;
 6671|      0|        if ((unsigned int)err == 2U) {
 6672|      0|          goto case_2___0;
 6673|      0|        }
 6674|      0|        if ((unsigned int)err == 5U) {
 6675|      0|          goto case_5;
 6676|      0|        }
 6677|      0|        if ((unsigned int)err == 6U) {
 6678|      0|          goto case_6___0;
 6679|      0|        }
 6680|      0|        if ((unsigned int)err == 4U) {
 6681|      0|          goto case_4___0;
 6682|      0|        }
 6683|      0|        if ((unsigned int)err == 3U) {
 6684|      0|          goto case_4___0;
 6685|      0|        }
 6686|      0|        goto switch_default___0;
 6687|      0|      case_2___0:
 6688|      0|        goto switch_break___0;
 6689|      0|      case_5:
 6690|      0|        tmp___31 = chownat(fts->fts_cwd_fd, file, uid, gid);
 6691|      0|        ok = (_Bool)(tmp___31 == 0);
 6692|      0|        goto switch_break___0;
 6693|      0|      case_6___0:
 6694|      0|        ok = (_Bool)0;
 6695|      0|        goto switch_break___0;
 6696|      0|      case_4___0:
 6697|      0|        do_chown = (_Bool)0;
 6698|      0|        ok = (_Bool)0;
 6699|      0|        goto switch_break___0;
 6700|      0|      switch_default___0:
 6701|      0|        abort();
 6702|      0|      switch_break___0:;
 6703|      0|      }
 6704|      4|      if (do_chown) {
 6705|      4|        if (!ok) {
 6706|      0|          if (!chopt->force_silent) {
 6707|      0|            tmp___32 = quote(file_full_name);
 6708|      0|            if (uid != 4294967295U) {
 6709|      0|              tmp___33 = gettext("changing ownership of %s");
 6710|      0|              tmp___35 = tmp___33;
 6711|      0|            } else {
 6712|      0|              tmp___34 = gettext("changing group of %s");
 6713|      0|              tmp___35 = tmp___34;
 6714|      0|            }
 6715|      0|            tmp___36 = __errno_location();
 6716|      0|            error(0, *tmp___36, (char const *)tmp___35, tmp___32);
 6717|      0|          }
 6718|      0|        }
 6719|      4|      }
 6720|      4|    }
 6721|      4|    if ((unsigned int const)chopt->verbosity != 2U) {
 6722|      0|      if (do_chown) {
 6723|      0|        if (ok) {
 6724|      0|          if (symlink_changed) {
 6725|      0|            if (uid == 4294967295U) {
 6726|      0|              goto _L___5;
 6727|      0|            } else {
 6728|      0|              if (uid == (uid_t)file_stats->st_uid) {
 6729|      0|              _L___5:
 6730|      0|                if (gid == 4294967295U) {
 6731|      0|                  tmp___37 = 0;
 6732|      0|                } else {
 6733|      0|                  if (gid == (gid_t)file_stats->st_gid) {
 6734|      0|                    tmp___37 = 0;
 6735|      0|                  } else {
 6736|      0|                    tmp___37 = 1;
 6737|      0|                  }
 6738|      0|                }
 6739|      0|              } else {
 6740|      0|                tmp___37 = 1;
 6741|      0|              }
 6742|      0|            }
 6743|      0|          } else {
 6744|      0|            tmp___37 = 0;
 6745|      0|          }
 6746|      0|        } else {
 6747|      0|          tmp___37 = 0;
 6748|      0|        }
 6749|      0|      } else {
 6750|      0|        tmp___37 = 0;
 6751|      0|      }
 6752|      0|      changed = (_Bool)tmp___37;
 6753|      0|      if (changed) {
 6754|      0|        goto _L___6;
 6755|      0|      } else {
 6756|      0|        if ((unsigned int const)chopt->verbosity == 0U) {
 6757|      0|        _L___6:
 6758|      0|          if (!ok) {
 6759|      0|            tmp___40 = 3;
 6760|      0|          } else {
 6761|      0|            if (!symlink_changed) {
 6762|      0|              tmp___39 = 1;
 6763|      0|            } else {
 6764|      0|              if (!changed) {
 6765|      0|                tmp___38 = 4;
 6766|      0|              } else {
 6767|      0|                tmp___38 = 2;
 6768|      0|              }
 6769|      0|              tmp___39 = tmp___38;
 6770|      0|            }
 6771|      0|            tmp___40 = tmp___39;
 6772|      0|          }
 6773|      0|          ch_status = (enum Change_status)tmp___40;
 6774|      0|          describe_change(file_full_name, ch_status,
 6775|      0|                          (char const *)chopt->user_name,
 6776|      0|                          (char const *)chopt->group_name);
 6777|      0|        }
 6778|      0|      }
 6779|      0|    }
 6780|      4|    if (!chopt->recurse) {
 6781|      0|      fts_set(fts, ent, 4);
 6782|      0|    }
 6783|      4|    return (ok);
 6784|      4|  }
 6785|      4|}
 6786|       |extern _Bool chown_files(char **files, int bit_flags, uid_t uid, gid_t gid,
 6787|       |                         uid_t required_uid, gid_t required_gid,
 6788|      2|                         struct Chown_option const *chopt) {
 6789|      2|  _Bool ok;
 6790|      2|  int stat_flags;
 6791|      2|  int tmp;
 6792|      2|  FTS *fts;
 6793|      2|  FTS *tmp___0;
 6794|      2|  FTSENT *ent;
 6795|      2|  char *tmp___1;
 6796|      2|  int *tmp___2;
 6797|      2|  int *tmp___3;
 6798|      2|  _Bool tmp___4;
 6799|      2|  char *tmp___5;
 6800|      2|  int *tmp___6;
 6801|      2|  int tmp___7;
 6802|       |
 6803|      2|  {
 6804|      2|    ok = (_Bool)1;
 6805|      2|    if (required_uid != 4294967295U) {
 6806|      0|      tmp = 0;
 6807|      2|    } else {
 6808|      2|      if (required_gid != 4294967295U) {
 6809|      0|        tmp = 0;
 6810|      2|      } else {
 6811|      2|        if (chopt->affect_symlink_referent) {
 6812|      0|          tmp = 0;
 6813|      2|        } else {
 6814|      2|          if ((unsigned int const)chopt->verbosity != 2U) {
 6815|      0|            tmp = 0;
 6816|      2|          } else {
 6817|      2|            tmp = 8;
 6818|      2|          }
 6819|      2|        }
 6820|      2|      }
 6821|      2|    }
 6822|      2|    stat_flags = tmp;
 6823|      2|    tmp___0 = xfts_open((char *const *)files, bit_flags | stat_flags,
 6824|      2|                        (int (*)(FTSENT const **, FTSENT const **))((void *)0));
 6825|      2|    fts = tmp___0;
 6826|      8|    while (1) {
 6827|      8|      ent = fts_read(fts);
 6828|      8|      if ((unsigned long)ent == (unsigned long)((void *)0)) {
 6829|      2|        tmp___3 = __errno_location();
 6830|      2|        if (*tmp___3 != 0) {
 6831|      0|          if (!chopt->force_silent) {
 6832|      0|            tmp___1 = gettext("fts_read failed");
 6833|      0|            tmp___2 = __errno_location();
 6834|      0|            error(0, *tmp___2, (char const *)tmp___1);
 6835|      0|          }
 6836|      0|          ok = (_Bool)0;
 6837|      0|        }
 6838|      2|        goto while_break;
 6839|      2|      }
 6840|      6|      tmp___4 = change_file_owner(fts, ent, uid, gid, required_uid,
 6841|      6|                                  required_gid, chopt);
 6842|      6|      ok = (_Bool)((int)ok & (int)tmp___4);
 6843|      6|    }
 6844|      2|  while_break:
 6845|      2|    tmp___7 = fts_close(fts);
 6846|      2|    if (tmp___7 != 0) {
 6847|      0|      tmp___5 = gettext("fts_close failed");
 6848|      0|      tmp___6 = __errno_location();
 6849|      0|      error(0, *tmp___6, (char const *)tmp___5);
 6850|      0|      ok = (_Bool)0;
 6851|      0|    }
 6852|      2|    return (ok);
 6853|      2|  }
 6854|      2|}
 6855|       |extern char *optarg;
 6856|       |extern __attribute__((__nothrow__)) int(
 6857|       |    __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void));
 6858|       |extern __attribute__((__nothrow__)) char *(
 6859|       |    __attribute__((__leaf__)) textdomain)(char const *__domainname);
 6860|       |extern __attribute__((__nothrow__)) char *(__attribute__((
 6861|       |    __leaf__)) bindtextdomain)(char const *__domainname, char const *__dirname);
 6862|      0|__inline static void emit_ancillary_info(void) {
 6863|      0|  char *tmp;
 6864|      0|  char *tmp___0;
 6865|      0|  char *tmp___1;
 6866|      0|  char *tmp___2;
 6867|      0|  char const *lc_messages;
 6868|      0|  char const *tmp___3;
 6869|      0|  char *tmp___4;
 6870|      0|  char *tmp___5;
 6871|      0|  int tmp___6;
 6872|      0|  char *tmp___7;
 6873|      0|  char *tmp___8;
 6874|       |
 6875|      0|  {
 6876|      0|    tmp = last_component(program_name);
 6877|      0|    tmp___0 = gettext("\nReport %s bugs to %s\n");
 6878|      0|    printf((char const *)tmp___0, tmp, "bug-coreutils@gnu.org");
 6879|      0|    tmp___1 = gettext("%s home page: <http://www.gnu.org/software/%s/>\n");
 6880|      0|    printf((char const *)tmp___1, "GNU coreutils", "coreutils");
 6881|      0|    tmp___2 = gettext(
 6882|      0|        "General help using GNU software: <http://www.gnu.org/gethelp/>\n");
 6883|      0|    fputs_unlocked((char const *)tmp___2, stdout);
 6884|      0|    tmp___3 = (char const *)setlocale(5, (char const *)((void *)0));
 6885|      0|    lc_messages = tmp___3;
 6886|      0|    if (lc_messages) {
 6887|      0|      tmp___6 = strncmp(lc_messages, "en_", (size_t)3);
 6888|      0|      if (tmp___6) {
 6889|      0|        tmp___4 = last_component(program_name);
 6890|      0|        tmp___5 = gettext("Report %s translation bugs to "
 6891|      0|                          "<http://translationproject.org/team/>\n");
 6892|      0|        printf((char const *)tmp___5, tmp___4);
 6893|      0|      }
 6894|      0|    }
 6895|      0|    tmp___7 = last_component(program_name);
 6896|      0|    tmp___8 = gettext(
 6897|      0|        "For complete documentation, run: info coreutils \'%s invocation\'\n");
 6898|      0|    printf((char const *)tmp___8, tmp___7);
 6899|      0|    return;
 6900|      0|  }
 6901|      0|}
 6902|      1|__inline static char *bad_cast(char const *s) {
 6903|       |
 6904|      1|  { return ((char *)s); }
 6905|      1|}
 6906|       |static char *reference_file;
 6907|       |static struct option const long_options___1[14] = {
 6908|       |    {"recursive", 0, (int *)((void *)0), 'R'},
 6909|       |    {"changes", 0, (int *)((void *)0), 'c'},
 6910|       |    {"dereference", 0, (int *)((void *)0), 128},
 6911|       |    {"from", 1, (int *)((void *)0), 129},
 6912|       |    {"no-dereference", 0, (int *)((void *)0), 'h'},
 6913|       |    {"no-preserve-root", 0, (int *)((void *)0), 130},
 6914|       |    {"preserve-root", 0, (int *)((void *)0), 131},
 6915|       |    {"quiet", 0, (int *)((void *)0), 'f'},
 6916|       |    {"silent", 0, (int *)((void *)0), 'f'},
 6917|       |    {"reference", 1, (int *)((void *)0), 132},
 6918|       |    {"verbose", 0, (int *)((void *)0), 'v'},
 6919|       |    {"help", 0, (int *)((void *)0), -130},
 6920|       |    {"version", 0, (int *)((void *)0), -131},
 6921|       |    {(char const *)((void *)0), 0, (int *)((void *)0), 0}};
 6922|       |__attribute__((__noreturn__)) void usage(int status);
 6923|      0|void usage(int status) {
 6924|      0|  char *tmp;
 6925|      0|  char *tmp___0;
 6926|      0|  char *tmp___1;
 6927|      0|  char *tmp___2;
 6928|      0|  char *tmp___3;
 6929|      0|  char *tmp___4;
 6930|      0|  char *tmp___5;
 6931|      0|  char *tmp___6;
 6932|      0|  char *tmp___7;
 6933|      0|  char *tmp___8;
 6934|      0|  char *tmp___9;
 6935|      0|  char *tmp___10;
 6936|       |
 6937|      0|  {
 6938|      0|    if (status != 0) {
 6939|      0|      tmp = gettext("Try `%s --help\' for more information.\n");
 6940|      0|      fprintf(stderr, (char const *)tmp, program_name);
 6941|      0|    } else {
 6942|      0|      tmp___0 = gettext("Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n  "
 6943|      0|                        "or:  %s [OPTION]... --reference=RFILE FILE...\n");
 6944|      0|      printf((char const *)tmp___0, program_name, program_name);
 6945|      0|      tmp___1 = gettext(
 6946|      0|          "Change the owner and/or group of each FILE to OWNER and/or "
 6947|      0|          "GROUP.\nWith --reference, change the owner and group of each FILE "
 6948|      0|          "to those of RFILE.\n\n  -c, --changes          like verbose but "
 6949|      0|          "report only when a change is made\n      --dereference      affect "
 6950|      0|          "the referent of each symbolic link (this is\n                       "
 6951|      0|          "  the default), rather than the symbolic link itself\n");
 6952|      0|      fputs_unlocked((char const *)tmp___1, stdout);
 6953|      0|      tmp___2 = gettext("  -h, --no-dereference   affect each symbolic link "
 6954|      0|                        "instead of any referenced\n                         "
 6955|      0|                        "file (useful only on systems that can change the\n    "
 6956|      0|                        "                     ownership of a symlink)\n");
 6957|      0|      fputs_unlocked((char const *)tmp___2, stdout);
 6958|      0|      tmp___3 =
 6959|      0|          gettext("      --from=CURRENT_OWNER:CURRENT_GROUP\n                  "
 6960|      0|                  "       change the owner and/or group of each file only if\n "
 6961|      0|                  "                        its current owner and/or group "
 6962|      0|                  "match those specified\n                         here.  "
 6963|      0|                  "Either may be omitted, in which case a match\n              "
 6964|      0|                  "           is not required for the omitted attribute.\n");
 6965|      0|      fputs_unlocked((char const *)tmp___3, stdout);
 6966|      0|      tmp___4 = gettext("      --no-preserve-root  do not treat `/\' specially "
 6967|      0|                        "(the default)\n      --preserve-root    fail to "
 6968|      0|                        "operate recursively on `/\'\n");
 6969|      0|      fputs_unlocked((char const *)tmp___4, stdout);
 6970|      0|      tmp___5 = gettext(
 6971|      0|          "  -f, --silent, --quiet  suppress most error messages\n      "
 6972|      0|          "--reference=RFILE  use RFILE\'s owner and group rather than\n       "
 6973|      0|          "                  specifying OWNER:GROUP values\n  -R, --recursive  "
 6974|      0|          "      operate on files and directories recursively\n  -v, --verbose "
 6975|      0|          "         output a diagnostic for every file processed\n\n");
 6976|      0|      fputs_unlocked((char const *)tmp___5, stdout);
 6977|      0|      tmp___6 = gettext(
 6978|      0|          "The following options modify how a hierarchy is traversed when the "
 6979|      0|          "-R\noption is also specified.  If more than one is specified, only "
 6980|      0|          "the final\none takes effect.\n\n  -H                     if a "
 6981|      0|          "command line argument is a symbolic link\n                         "
 6982|      0|          "to a directory, traverse it\n  -L                     traverse "
 6983|      0|          "every symbolic link to a directory\n                         "
 6984|      0|          "encountered\n  -P                     do not traverse any symbolic "
 6985|      0|          "links (default)\n\n");
 6986|      0|      fputs_unlocked((char const *)tmp___6, stdout);
 6987|      0|      tmp___7 = gettext("      --help     display this help and exit\n");
 6988|      0|      fputs_unlocked((char const *)tmp___7, stdout);
 6989|      0|      tmp___8 =
 6990|      0|          gettext("      --version  output version information and exit\n");
 6991|      0|      fputs_unlocked((char const *)tmp___8, stdout);
 6992|      0|      tmp___9 = gettext("\nOwner is unchanged if missing.  Group is unchanged "
 6993|      0|                        "if missing, but changed\nto login group if implied by "
 6994|      0|                        "a `:\' following a symbolic OWNER.\nOWNER and GROUP "
 6995|      0|                        "may be numeric as well as symbolic.\n");
 6996|      0|      fputs_unlocked((char const *)tmp___9, stdout);
 6997|      0|      tmp___10 =
 6998|      0|          gettext("\nExamples:\n  %s root /u        Change the owner of /u to "
 6999|      0|                  "\"root\".\n  %s root:staff /u  Likewise, but also change "
 7000|      0|                  "its group to \"staff\".\n  %s -hR root /u    Change the "
 7001|      0|                  "owner of /u and subfiles to \"root\".\n");
 7002|      0|      printf((char const *)tmp___10, program_name, program_name, program_name);
 7003|      0|      emit_ancillary_info();
 7004|      0|    }
 7005|      0|    exit(status);
 7006|      0|  }
 7007|      0|}
 7008|       |static struct dev_ino dev_ino_buf;
 7009|      2|int main(int argc, char **argv) {
 7010|      2|  _Bool preserve_root;
 7011|      2|  uid_t uid;
 7012|      2|  gid_t gid;
 7013|      2|  uid_t required_uid;
 7014|      2|  gid_t required_gid;
 7015|      2|  int bit_flags;
 7016|      2|  int dereference;
 7017|      2|  struct Chown_option chopt;
 7018|      2|  _Bool ok;
 7019|      2|  int optc;
 7020|      2|  char *u_dummy;
 7021|      2|  char *g_dummy;
 7022|      2|  char const *e;
 7023|      2|  char const *tmp;
 7024|      2|  char const *tmp___0;
 7025|      2|  char *tmp___1;
 7026|      2|  char *tmp___2;
 7027|      2|  char const *tmp___3;
 7028|      2|  char *tmp___4;
 7029|      2|  int tmp___5;
 7030|      2|  struct stat ref_stats;
 7031|      2|  char const *tmp___6;
 7032|      2|  char *tmp___7;
 7033|      2|  int *tmp___8;
 7034|      2|  int tmp___9;
 7035|      2|  char const *e___0;
 7036|      2|  char const *tmp___10;
 7037|      2|  char const *tmp___11;
 7038|      2|  char const *tmp___12;
 7039|      2|  char *tmp___13;
 7040|      2|  int *tmp___14;
 7041|      2|  int tmp___15;
 7042|       |
 7043|      2|  {
 7044|      2|    preserve_root = (_Bool)0;
 7045|      2|    uid = (uid_t)-1;
 7046|      2|    gid = (gid_t)-1;
 7047|      2|    required_uid = (uid_t)-1;
 7048|      2|    required_gid = (gid_t)-1;
 7049|      2|    bit_flags = 16;
 7050|      2|    dereference = -1;
 7051|      2|    set_program_name((char const *)*(argv + 0));
 7052|      2|    setlocale(6, "");
 7053|      2|    bindtextdomain("coreutils", "/usr/local/share/locale");
 7054|      2|    textdomain("coreutils");
 7055|      2|    atexit(&close_stdout);
 7056|      2|    chopt_init(&chopt);
 7057|      4|    while (1) {
 7058|      4|      optc = getopt_long(argc, (char *const *)argv, "HLPRcfhv",
 7059|      4|                         long_options___1, (int *)((void *)0));
 7060|      4|      if (!(optc != -1)) {
 7061|      2|        goto while_break;
 7062|      2|      }
 7063|      2|      if (optc == 72) {
 7064|      0|        goto case_72;
 7065|      0|      }
 7066|      2|      if (optc == 76) {
 7067|      0|        goto case_76;
 7068|      0|      }
 7069|      2|      if (optc == 80) {
 7070|      0|        goto case_80;
 7071|      0|      }
 7072|      2|      if (optc == 104) {
 7073|      0|        goto case_104;
 7074|      0|      }
 7075|      2|      if (optc == 128) {
 7076|      0|        goto case_128;
 7077|      0|      }
 7078|      2|      if (optc == 130) {
 7079|      0|        goto case_130;
 7080|      0|      }
 7081|      2|      if (optc == 131) {
 7082|      0|        goto case_131;
 7083|      0|      }
 7084|      2|      if (optc == 132) {
 7085|      0|        goto case_132;
 7086|      0|      }
 7087|      2|      if (optc == 129) {
 7088|      0|        goto case_129;
 7089|      0|      }
 7090|      2|      if (optc == 82) {
 7091|      2|        goto case_82;
 7092|      2|      }
 7093|      0|      if (optc == 99) {
 7094|      0|        goto case_99;
 7095|      0|      }
 7096|      0|      if (optc == 102) {
 7097|      0|        goto case_102;
 7098|      0|      }
 7099|      0|      if (optc == 118) {
 7100|      0|        goto case_118;
 7101|      0|      }
 7102|      0|      if (optc == -130) {
 7103|      0|        goto case_neg_130;
 7104|      0|      }
 7105|      0|      if (optc == -131) {
 7106|      0|        goto case_neg_131;
 7107|      0|      }
 7108|      0|      goto switch_default;
 7109|      0|    case_72:
 7110|      0|      bit_flags = 17;
 7111|      0|      goto switch_break;
 7112|      0|    case_76:
 7113|      0|      bit_flags = 2;
 7114|      0|      goto switch_break;
 7115|      0|    case_80:
 7116|      0|      bit_flags = 16;
 7117|      0|      goto switch_break;
 7118|      0|    case_104:
 7119|      0|      dereference = 0;
 7120|      0|      goto switch_break;
 7121|      0|    case_128:
 7122|      0|      dereference = 1;
 7123|      0|      goto switch_break;
 7124|      0|    case_130:
 7125|      0|      preserve_root = (_Bool)0;
 7126|      0|      goto switch_break;
 7127|      0|    case_131:
 7128|      0|      preserve_root = (_Bool)1;
 7129|      0|      goto switch_break;
 7130|      0|    case_132:
 7131|      0|      reference_file = optarg;
 7132|      0|      goto switch_break;
 7133|      0|    case_129:
 7134|      0|      tmp = parse_user_spec((char const *)optarg, &required_uid, &required_gid,
 7135|      0|                            &u_dummy, &g_dummy);
 7136|      0|      e = tmp;
 7137|      0|      if (e) {
 7138|      0|        tmp___0 = quote((char const *)optarg);
 7139|      0|        error(1, 0, "%s: %s", e, tmp___0);
 7140|      0|      }
 7141|      0|      goto switch_break;
 7142|      2|    case_82:
 7143|      2|      chopt.recurse = (_Bool)1;
 7144|      2|      goto switch_break;
 7145|      0|    case_99:
 7146|      0|      chopt.verbosity = (enum Verbosity)1;
 7147|      0|      goto switch_break;
 7148|      0|    case_102:
 7149|      0|      chopt.force_silent = (_Bool)1;
 7150|      0|      goto switch_break;
 7151|      0|    case_118:
 7152|      0|      chopt.verbosity = (enum Verbosity)0;
 7153|      0|      goto switch_break;
 7154|      0|    case_neg_130:
 7155|      0|      usage(0);
 7156|      0|      goto switch_break;
 7157|      0|    case_neg_131:
 7158|      0|      version_etc(stdout, "chown", "GNU coreutils", Version, "David MacKenzie",
 7159|      0|                  "Jim Meyering", (char *)((void *)0));
 7160|      0|      exit(0);
 7161|      0|      goto switch_break;
 7162|      0|    switch_default:
 7163|      0|      usage(1);
 7164|      2|    switch_break:;
 7165|      2|    }
 7166|      2|  while_break:;
 7167|      2|    if (chopt.recurse) {
 7168|      2|      if (bit_flags == 16) {
 7169|      2|        if (dereference == 1) {
 7170|      0|          tmp___1 = gettext("-R --dereference requires either -H or -L");
 7171|      0|          error(1, 0, (char const *)tmp___1);
 7172|      0|        }
 7173|      2|        dereference = 0;
 7174|      2|      }
 7175|      2|    } else {
 7176|      0|      bit_flags = 16;
 7177|      0|    }
 7178|      2|    chopt.affect_symlink_referent = (_Bool)(dereference != 0);
 7179|      2|    if (reference_file) {
 7180|      0|      tmp___5 = 1;
 7181|      2|    } else {
 7182|      2|      tmp___5 = 2;
 7183|      2|    }
 7184|      2|    if (argc - optind < tmp___5) {
 7185|      0|      if (argc <= optind) {
 7186|      0|        tmp___2 = gettext("missing operand");
 7187|      0|        error(0, 0, (char const *)tmp___2);
 7188|      0|      } else {
 7189|      0|        tmp___3 = quote((char const *)*(argv + (argc - 1)));
 7190|      0|        tmp___4 = gettext("missing operand after %s");
 7191|      0|        error(0, 0, (char const *)tmp___4, tmp___3);
 7192|      0|      }
 7193|      0|      usage(1);
 7194|      0|    }
 7195|      2|    if (reference_file) {
 7196|      0|      tmp___9 = stat((char const *)reference_file, &ref_stats);
 7197|      0|      if (tmp___9) {
 7198|      0|        tmp___6 = quote((char const *)reference_file);
 7199|      0|        tmp___7 = gettext("failed to get attributes of %s");
 7200|      0|        tmp___8 = __errno_location();
 7201|      0|        error(1, *tmp___8, (char const *)tmp___7, tmp___6);
 7202|      0|      }
 7203|      0|      uid = ref_stats.st_uid;
 7204|      0|      gid = ref_stats.st_gid;
 7205|      0|      chopt.user_name = uid_to_name(ref_stats.st_uid);
 7206|      0|      chopt.group_name = gid_to_name(ref_stats.st_gid);
 7207|      2|    } else {
 7208|      2|      tmp___10 = parse_user_spec((char const *)*(argv + optind), &uid, &gid,
 7209|      2|                                 &chopt.user_name, &chopt.group_name);
 7210|      2|      e___0 = tmp___10;
 7211|      2|      if (e___0) {
 7212|      0|        tmp___11 = quote((char const *)*(argv + optind));
 7213|      0|        error(1, 0, "%s: %s", e___0, tmp___11);
 7214|      0|      }
 7215|      2|      if (!chopt.user_name) {
 7216|      1|        if (chopt.group_name) {
 7217|      1|          chopt.user_name = bad_cast("");
 7218|      1|        }
 7219|      1|      }
 7220|      2|      optind++;
 7221|      2|    }
 7222|      2|    if (chopt.recurse) {
 7223|      2|      if (preserve_root) {
 7224|      0|        chopt.root_dev_ino = get_root_dev_ino(&dev_ino_buf);
 7225|      0|        if ((unsigned long)chopt.root_dev_ino == (unsigned long)((void *)0)) {
 7226|      0|          tmp___12 = quote("/");
 7227|      0|          tmp___13 = gettext("failed to get attributes of %s");
 7228|      0|          tmp___14 = __errno_location();
 7229|      0|          error(1, *tmp___14, (char const *)tmp___13, tmp___12);
 7230|      0|        }
 7231|      0|      }
 7232|      2|    }
 7233|      2|    bit_flags |= 1024;
 7234|      2|    ok = chown_files(argv + optind, bit_flags, uid, gid, required_uid,
 7235|      2|                     required_gid, (struct Chown_option const *)(&chopt));
 7236|      2|    chopt_free(&chopt);
 7237|      2|    if (ok) {
 7238|      2|      tmp___15 = 0;
 7239|      2|    } else {
 7240|      0|      tmp___15 = 1;
 7241|      0|    }
 7242|      2|    exit(tmp___15);
 7243|      2|  }
 7244|      2|}


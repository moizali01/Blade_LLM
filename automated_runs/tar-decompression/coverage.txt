    1|       |typedef unsigned long __dev_t;
    2|       |typedef unsigned int __uid_t;
    3|       |typedef unsigned int __gid_t;
    4|       |typedef unsigned long __ino_t;
    5|       |typedef unsigned int __mode_t;
    6|       |typedef unsigned long __nlink_t;
    7|       |typedef long __off_t;
    8|       |typedef long __off64_t;
    9|       |typedef int __pid_t;
   10|       |typedef long __time_t;
   11|       |typedef int __clockid_t;
   12|       |typedef long __blksize_t;
   13|       |typedef long __blkcnt_t;
   14|       |typedef long __ssize_t;
   15|       |typedef long __syscall_slong_t;
   16|       |typedef __mode_t mode_t;
   17|       |typedef __off_t off_t;
   18|       |typedef __pid_t pid_t;
   19|       |typedef __ssize_t ssize_t;
   20|       |typedef __time_t time_t;
   21|       |typedef __clockid_t clockid_t;
   22|       |typedef unsigned long size_t;
   23|       |struct timespec {
   24|       |  __time_t tv_sec;
   25|       |  __syscall_slong_t tv_nsec;
   26|       |};
   27|       |struct stat {
   28|       |  __dev_t st_dev;
   29|       |  __ino_t st_ino;
   30|       |  __nlink_t st_nlink;
   31|       |  __mode_t st_mode;
   32|       |  __uid_t st_uid;
   33|       |  __gid_t st_gid;
   34|       |  int __pad0;
   35|       |  __dev_t st_rdev;
   36|       |  __off_t st_size;
   37|       |  __blksize_t st_blksize;
   38|       |  __blkcnt_t st_blocks;
   39|       |  struct timespec st_atim;
   40|       |  struct timespec st_mtim;
   41|       |  struct timespec st_ctim;
   42|       |  __syscall_slong_t __glibc_reserved[3];
   43|       |};
   44|       |struct mtop {
   45|       |  short mt_op;
   46|       |  int mt_count;
   47|       |};
   48|       |struct _IO_FILE;
   49|       |struct _IO_FILE;
   50|       |typedef struct _IO_FILE FILE;
   51|       |typedef void _IO_lock_t;
   52|       |struct _IO_marker {
   53|       |  struct _IO_marker *_next;
   54|       |  struct _IO_FILE *_sbuf;
   55|       |  int _pos;
   56|       |};
   57|       |struct _IO_FILE {
   58|       |  int _flags;
   59|       |  char *_IO_read_ptr;
   60|       |  char *_IO_read_end;
   61|       |  char *_IO_read_base;
   62|       |  char *_IO_write_base;
   63|       |  char *_IO_write_ptr;
   64|       |  char *_IO_write_end;
   65|       |  char *_IO_buf_base;
   66|       |  char *_IO_buf_end;
   67|       |  char *_IO_save_base;
   68|       |  char *_IO_backup_base;
   69|       |  char *_IO_save_end;
   70|       |  struct _IO_marker *_markers;
   71|       |  struct _IO_FILE *_chain;
   72|       |  int _fileno;
   73|       |  int _flags2;
   74|       |  __off_t _old_offset;
   75|       |  unsigned short _cur_column;
   76|       |  signed char _vtable_offset;
   77|       |  char _shortbuf[1];
   78|       |  _IO_lock_t *_lock;
   79|       |  __off64_t _offset;
   80|       |  void *__pad1;
   81|       |  void *__pad2;
   82|       |  void *__pad3;
   83|       |  void *__pad4;
   84|       |  size_t __pad5;
   85|       |  int _mode;
   86|       |  char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
   87|       |};
   88|       |typedef unsigned long uintmax_t;
   89|       |struct posix_header {
   90|       |  char name[100];
   91|       |  char mode[8];
   92|       |  char uid[8];
   93|       |  char gid[8];
   94|       |  char size[12];
   95|       |  char mtime[12];
   96|       |  char chksum[8];
   97|       |  char typeflag;
   98|       |  char linkname[100];
   99|       |  char magic[6];
  100|       |  char version[2];
  101|       |  char uname[32];
  102|       |  char gname[32];
  103|       |  char devmajor[8];
  104|       |  char devminor[8];
  105|       |  char prefix[155];
  106|       |};
  107|       |struct sparse {
  108|       |  char offset[12];
  109|       |  char numbytes[12];
  110|       |};
  111|       |struct sparse_header {
  112|       |  struct sparse sp[21];
  113|       |  char isextended;
  114|       |};
  115|       |struct oldgnu_header {
  116|       |  char unused_pad1[345];
  117|       |  char atime[12];
  118|       |  char ctime[12];
  119|       |  char offset[12];
  120|       |  char longnames[4];
  121|       |  char unused_pad2;
  122|       |  struct sparse sp[4];
  123|       |  char isextended;
  124|       |  char realsize[12];
  125|       |};
  126|       |struct star_header {
  127|       |  char name[100];
  128|       |  char mode[8];
  129|       |  char uid[8];
  130|       |  char gid[8];
  131|       |  char size[12];
  132|       |  char mtime[12];
  133|       |  char chksum[8];
  134|       |  char typeflag;
  135|       |  char linkname[100];
  136|       |  char magic[6];
  137|       |  char version[2];
  138|       |  char uname[32];
  139|       |  char gname[32];
  140|       |  char devmajor[8];
  141|       |  char devminor[8];
  142|       |  char prefix[131];
  143|       |  char atime[12];
  144|       |  char ctime[12];
  145|       |};
  146|       |struct star_in_header {
  147|       |  char fill[345];
  148|       |  char prefix[1];
  149|       |  char fill2;
  150|       |  char fill3[8];
  151|       |  char isextended;
  152|       |  struct sparse sp[4];
  153|       |  char realsize[12];
  154|       |  char offset[12];
  155|       |  char atime[12];
  156|       |  char ctime[12];
  157|       |  char mfill[8];
  158|       |  char xmagic[4];
  159|       |};
  160|       |struct star_ext_header {
  161|       |  struct sparse sp[21];
  162|       |  char isextended;
  163|       |};
  164|       |struct sp_array {
  165|       |  off_t offset;
  166|       |  size_t numbytes;
  167|       |};
  168|       |struct tar_stat_info {
  169|       |  char *orig_file_name;
  170|       |  char *file_name;
  171|       |  int had_trailing_slash;
  172|       |  char *link_name;
  173|       |  unsigned int devminor;
  174|       |  unsigned int devmajor;
  175|       |  char *uname;
  176|       |  char *gname;
  177|       |  struct stat stat;
  178|       |  unsigned long atime_nsec;
  179|       |  unsigned long mtime_nsec;
  180|       |  unsigned long ctime_nsec;
  181|       |  off_t archive_file_size;
  182|       |  _Bool is_sparse;
  183|       |  size_t sparse_map_avail;
  184|       |  size_t sparse_map_size;
  185|       |  struct sp_array *sparse_map;
  186|       |};
  187|       |union block {
  188|       |  char buffer[512];
  189|       |  struct posix_header header;
  190|       |  struct star_header star_header;
  191|       |  struct oldgnu_header oldgnu_header;
  192|       |  struct sparse_header sparse_header;
  193|       |  struct star_in_header star_in_header;
  194|       |  struct star_ext_header star_ext_header;
  195|       |};
  196|       |typedef double tarlong;
  197|       |enum subcommand {
  198|       |  UNKNOWN_SUBCOMMAND = 0,
  199|       |  APPEND_SUBCOMMAND = 1,
  200|       |  CAT_SUBCOMMAND = 2,
  201|       |  CREATE_SUBCOMMAND = 3,
  202|       |  DELETE_SUBCOMMAND = 4,
  203|       |  DIFF_SUBCOMMAND = 5,
  204|       |  EXTRACT_SUBCOMMAND = 6,
  205|       |  LIST_SUBCOMMAND = 7,
  206|       |  UPDATE_SUBCOMMAND = 8
  207|       |};
  208|       |enum access_mode { ACCESS_READ = 0, ACCESS_WRITE = 1, ACCESS_UPDATE = 2 };
  209|       |typedef __dev_t dev_t;
  210|       |typedef __builtin_va_list __gnuc_va_list;
  211|       |typedef __gnuc_va_list va_list;
  212|       |struct utimbuf {
  213|       |  __time_t actime;
  214|       |  __time_t modtime;
  215|       |};
  216|       |enum archive_format {
  217|       |  DEFAULT_FORMAT = 0,
  218|       |  V7_FORMAT = 1,
  219|       |  OLDGNU_FORMAT = 2,
  220|       |  USTAR_FORMAT = 3,
  221|       |  POSIX_FORMAT = 4,
  222|       |  STAR_FORMAT = 5,
  223|       |  GNU_FORMAT = 6
  224|       |};
  225|       |enum read_header {
  226|       |  HEADER_STILL_UNREAD = 0,
  227|       |  HEADER_SUCCESS = 1,
  228|       |  HEADER_SUCCESS_EXTENDED = 2,
  229|       |  HEADER_ZERO_BLOCK = 3,
  230|       |  HEADER_END_OF_FILE = 4,
  231|       |  HEADER_FAILURE = 5
  232|       |};
  233|       |typedef __ino_t ino_t;
  234|       |typedef __gid_t gid_t;
  235|       |typedef __uid_t uid_t;
  236|       |struct obstack;
  237|       |struct obstack;
  238|       |struct mode_change {
  239|       |  char op;
  240|       |  char flags;
  241|       |  mode_t affected;
  242|       |  mode_t value;
  243|       |  struct mode_change *next;
  244|       |};
  245|       |struct name {
  246|       |  struct name *next;
  247|       |  size_t length;
  248|       |  uintmax_t found_count;
  249|       |  int isdir;
  250|       |  char firstch;
  251|       |  char regexp;
  252|       |  int change_dir;
  253|       |  char const *dir_contents;
  254|       |  char fake;
  255|       |  char name[1];
  256|       |};
  257|       |enum dump_status {
  258|       |  dump_status_ok = 0,
  259|       |  dump_status_short = 1,
  260|       |  dump_status_fail = 2,
  261|       |  dump_status_not_implemented = 3
  262|       |};
  263|       |struct xheader {
  264|       |  struct obstack *stk;
  265|       |  size_t size;
  266|       |  char *buffer;
  267|       |};
  268|       |struct hash_tuning {
  269|       |  float shrink_threshold;
  270|       |  float shrink_factor;
  271|       |  float growth_threshold;
  272|       |  float growth_factor;
  273|       |  _Bool is_n_buckets;
  274|       |};
  275|       |typedef struct hash_tuning Hash_tuning;
  276|       |struct hash_table;
  277|       |struct hash_table;
  278|       |typedef struct hash_table Hash_table;
  279|       |struct link {
  280|       |  dev_t dev;
  281|       |  ino_t ino;
  282|       |  size_t nlink;
  283|       |  char name[1];
  284|       |};
  285|       |enum old_files {
  286|       |  DEFAULT_OLD_FILES = 0,
  287|       |  NO_OVERWRITE_DIR_OLD_FILES = 1,
  288|       |  OVERWRITE_OLD_FILES = 2,
  289|       |  UNLINK_FIRST_OLD_FILES = 3,
  290|       |  KEEP_OLD_FILES = 4,
  291|       |  KEEP_NEWER_FILES = 5
  292|       |};
  293|       |enum remove_option {
  294|       |  ORDINARY_REMOVE_OPTION = 0,
  295|       |  RECURSIVE_REMOVE_OPTION = 1,
  296|       |  WANT_DIRECTORY_REMOVE_OPTION = 2
  297|       |};
  298|       |enum permstatus {
  299|       |  UNKNOWN_PERMSTATUS = 0,
  300|       |  ARCHIVED_PERMSTATUS = 1,
  301|       |  INTERDIR_PERMSTATUS = 2
  302|       |};
  303|       |struct delayed_set_stat {
  304|       |  struct delayed_set_stat *next;
  305|       |  struct stat stat_info;
  306|       |  size_t file_name_len;
  307|       |  mode_t invert_permissions;
  308|       |  enum permstatus permstatus;
  309|       |  _Bool after_symlinks;
  310|       |  char file_name[1];
  311|       |};
  312|       |struct string_list;
  313|       |struct string_list;
  314|       |struct delayed_symlink {
  315|       |  struct delayed_symlink *next;
  316|       |  dev_t dev;
  317|       |  ino_t ino;
  318|       |  time_t mtime;
  319|       |  uid_t uid;
  320|       |  gid_t gid;
  321|       |  struct string_list *sources;
  322|       |  char target[1];
  323|       |};
  324|       |struct string_list {
  325|       |  struct string_list *next;
  326|       |  char string[1];
  327|       |};
  328|       |enum strtol_error {
  329|       |  LONGINT_OK = 0,
  330|       |  LONGINT_OVERFLOW = 1,
  331|       |  LONGINT_INVALID_SUFFIX_CHAR = 2,
  332|       |  LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
  333|       |  LONGINT_INVALID = 4
  334|       |};
  335|       |typedef enum strtol_error strtol_error;
  336|       |struct _obstack_chunk {
  337|       |  char *limit;
  338|       |  struct _obstack_chunk *prev;
  339|       |  char contents[4];
  340|       |};
  341|       |struct obstack {
  342|       |  long chunk_size;
  343|       |  struct _obstack_chunk *chunk;
  344|       |  char *object_base;
  345|       |  char *next_free;
  346|       |  char *chunk_limit;
  347|       |  long temp;
  348|       |  int alignment_mask;
  349|       |  struct _obstack_chunk *(*chunkfun)(void *, long);
  350|       |  void (*freefun)(void *, struct _obstack_chunk *);
  351|       |  void *extra_arg;
  352|       |  unsigned int use_extra_arg : 1;
  353|       |  unsigned int maybe_empty_object : 1;
  354|       |  unsigned int alloc_failed : 1;
  355|       |};
  356|       |struct keyword_list {
  357|       |  struct keyword_list *next;
  358|       |  char *pattern;
  359|       |  char *value;
  360|       |};
  361|       |struct xhdr_tab {
  362|       |  char const *keyword;
  363|       |  void (*coder)(struct tar_stat_info const *, char const *, struct xheader *,
  364|       |                void *data);
  365|       |  void (*decoder)(struct tar_stat_info *, char const *);
  366|       |  _Bool protect;
  367|       |};
  368|       |enum children { NO_CHILDREN = 0, CHANGED_CHILDREN = 1, ALL_CHILDREN = 2 };
  369|       |struct directory {
  370|       |  dev_t device_number;
  371|       |  ino_t inode_number;
  372|       |  enum children children;
  373|       |  _Bool nfs;
  374|       |  _Bool found;
  375|       |  char name[1];
  376|       |};
  377|       |struct tm {
  378|       |  int tm_sec;
  379|       |  int tm_min;
  380|       |  int tm_hour;
  381|       |  int tm_mday;
  382|       |  int tm_mon;
  383|       |  int tm_year;
  384|       |  int tm_wday;
  385|       |  int tm_yday;
  386|       |  int tm_isdst;
  387|       |  long tm_gmtoff;
  388|       |  char const *tm_zone;
  389|       |};
  390|       |enum quoting_style {
  391|       |  literal_quoting_style = 0,
  392|       |  shell_quoting_style = 1,
  393|       |  shell_always_quoting_style = 2,
  394|       |  c_quoting_style = 3,
  395|       |  escape_quoting_style = 4,
  396|       |  locale_quoting_style = 5,
  397|       |  clocale_quoting_style = 6
  398|       |};
  399|       |struct quoting_options;
  400|       |struct quoting_options;
  401|       |enum backup_type { none = 0, simple = 1, numbered_existing = 2, numbered = 3 };
  402|       |struct saved_cwd {
  403|       |  int desc;
  404|       |  char *name;
  405|       |};
  406|       |struct wd {
  407|       |  char const *name;
  408|       |  int saved;
  409|       |  struct saved_cwd saved_cwd;
  410|       |};
  411|       |struct passwd {
  412|       |  char *pw_name;
  413|       |  char *pw_passwd;
  414|       |  __uid_t pw_uid;
  415|       |  __gid_t pw_gid;
  416|       |  char *pw_gecos;
  417|       |  char *pw_dir;
  418|       |  char *pw_shell;
  419|       |};
  420|       |struct group {
  421|       |  char *gr_name;
  422|       |  char *gr_passwd;
  423|       |  __gid_t gr_gid;
  424|       |  char **gr_mem;
  425|       |};
  426|       |struct exclude;
  427|       |struct exclude;
  428|       |typedef int __daddr_t;
  429|       |typedef void (*__sighandler_t)(int);
  430|       |struct mtget {
  431|       |  long mt_type;
  432|       |  long mt_resid;
  433|       |  long mt_dsreg;
  434|       |  long mt_gstat;
  435|       |  long mt_erreg;
  436|       |  __daddr_t mt_fileno;
  437|       |  __daddr_t mt_blkno;
  438|       |};
  439|       |struct tar_sparse_file;
  440|       |struct tar_sparse_file;
  441|       |enum sparse_scan_state { scan_begin = 0, scan_block = 1, scan_end = 2 };
  442|       |struct tar_sparse_optab {
  443|       |  _Bool (*init)(struct tar_sparse_file *);
  444|       |  _Bool (*done)(struct tar_sparse_file *);
  445|       |  _Bool (*sparse_member_p)(struct tar_sparse_file *);
  446|       |  _Bool (*dump_header)(struct tar_sparse_file *);
  447|       |  _Bool (*fixup_header)(struct tar_sparse_file *);
  448|       |  _Bool (*decode_header)(struct tar_sparse_file *);
  449|       |  _Bool (*scan_block)(struct tar_sparse_file *, enum sparse_scan_state, void *);
  450|       |  _Bool (*dump_region)(struct tar_sparse_file *, size_t);
  451|       |  _Bool (*extract_region)(struct tar_sparse_file *, size_t);
  452|       |};
  453|       |struct tar_sparse_file {
  454|       |  int fd;
  455|       |  size_t dumped_size;
  456|       |  struct tar_stat_info *stat_info;
  457|       |  struct tar_sparse_optab *optab;
  458|       |  void *closure;
  459|       |};
  460|       |enum oldgnu_add_status { add_ok = 0, add_finish = 1, add_fail = 2 };
  461|       |union __anonunion_56 {
  462|       |  int __in;
  463|       |  int __i;
  464|       |};
  465|       |union __anonunion_57 {
  466|       |  int __in;
  467|       |  int __i;
  468|       |};
  469|       |union __anonunion_58 {
  470|       |  int __in;
  471|       |  int __i;
  472|       |};
  473|       |union __anonunion_59 {
  474|       |  int __in;
  475|       |  int __i;
  476|       |};
  477|       |union __anonunion_60 {
  478|       |  int __in;
  479|       |  int __i;
  480|       |};
  481|       |union __anonunion_61 {
  482|       |  int __in;
  483|       |  int __i;
  484|       |};
  485|       |union __anonunion_62 {
  486|       |  int __in;
  487|       |  int __i;
  488|       |};
  489|       |union __anonunion_63 {
  490|       |  int __in;
  491|       |  int __i;
  492|       |};
  493|       |union __anonunion_64 {
  494|       |  int __in;
  495|       |  int __i;
  496|       |};
  497|       |union __anonunion_65 {
  498|       |  int __in;
  499|       |  int __i;
  500|       |};
  501|       |union __anonunion_66 {
  502|       |  int __in;
  503|       |  int __i;
  504|       |};
  505|       |union __anonunion_67 {
  506|       |  int __in;
  507|       |  int __i;
  508|       |};
  509|       |struct option {
  510|       |  char const *name;
  511|       |  int has_arg;
  512|       |  int *flag;
  513|       |  int val;
  514|       |};
  515|       |struct fmttab {
  516|       |  char const *name;
  517|       |  enum archive_format fmt;
  518|       |};
  519|       |typedef void *iconv_t;
  520|       |struct dirent {
  521|       |  __ino_t d_ino;
  522|       |  __off_t d_off;
  523|       |  unsigned short d_reclen;
  524|       |  unsigned char d_type;
  525|       |  char d_name[256];
  526|       |};
  527|       |struct __dirstream;
  528|       |struct __dirstream;
  529|       |typedef struct __dirstream DIR;
  530|       |struct patopts {
  531|       |  char const *pattern;
  532|       |  int options;
  533|       |};
  534|       |struct exclude {
  535|       |  struct patopts *exclude;
  536|       |  size_t exclude_alloc;
  537|       |  size_t exclude_count;
  538|       |};
  539|       |struct __anonstruct_textint_27 {
  540|       |  long value;
  541|       |  size_t digits;
  542|       |};
  543|       |typedef struct __anonstruct_textint_27 textint;
  544|       |struct __anonstruct_table_28 {
  545|       |  char const *name;
  546|       |  int type;
  547|       |  int value;
  548|       |};
  549|       |typedef struct __anonstruct_table_28 table;
  550|       |struct __anonstruct_parser_control_31 {
  551|       |  char const *input;
  552|       |  long day_ordinal;
  553|       |  int day_number;
  554|       |  int local_isdst;
  555|       |  long time_zone;
  556|       |  int meridian;
  557|       |  textint year;
  558|       |  long month;
  559|       |  long day;
  560|       |  long hour;
  561|       |  long minutes;
  562|       |  struct timespec seconds;
  563|       |  long rel_year;
  564|       |  long rel_month;
  565|       |  long rel_day;
  566|       |  long rel_hour;
  567|       |  long rel_minutes;
  568|       |  long rel_seconds;
  569|       |  long rel_ns;
  570|       |  _Bool timespec_seen;
  571|       |  size_t dates_seen;
  572|       |  size_t days_seen;
  573|       |  size_t local_zones_seen;
  574|       |  size_t rels_seen;
  575|       |  size_t times_seen;
  576|       |  size_t zones_seen;
  577|       |  table local_time_zone_table[3];
  578|       |};
  579|       |typedef struct __anonstruct_parser_control_31 parser_control;
  580|       |union __anonunion_YYSTYPE_32 {
  581|       |  long intval;
  582|       |  textint textintval;
  583|       |  struct timespec timespec;
  584|       |};
  585|       |typedef union __anonunion_YYSTYPE_32 YYSTYPE;
  586|       |typedef long __suseconds_t;
  587|       |struct timeval {
  588|       |  __time_t tv_sec;
  589|       |  __suseconds_t tv_usec;
  590|       |};
  591|       |struct timezone {
  592|       |  int tz_minuteswest;
  593|       |  int tz_dsttime;
  594|       |};
  595|       |typedef struct timezone *__restrict __timezone_ptr_t;
  596|       |struct hash_entry {
  597|       |  void *data;
  598|       |  struct hash_entry *next;
  599|       |};
  600|       |typedef long ptrdiff_t;
  601|       |struct hash_table {
  602|       |  struct hash_entry *bucket;
  603|       |  struct hash_entry const *bucket_limit;
  604|       |  size_t n_buckets;
  605|       |  size_t n_buckets_used;
  606|       |  size_t n_entries;
  607|       |  Hash_tuning const *tuning;
  608|       |  size_t (*hasher)(void const *, size_t);
  609|       |  _Bool (*comparator)(void const *, void const *);
  610|       |  void (*data_freer)(void *);
  611|       |  struct hash_entry *free_entry_list;
  612|       |};
  613|       |struct lconv {
  614|       |  char *decimal_point;
  615|       |  char *thousands_sep;
  616|       |  char *grouping;
  617|       |  char *int_curr_symbol;
  618|       |  char *currency_symbol;
  619|       |  char *mon_decimal_point;
  620|       |  char *mon_thousands_sep;
  621|       |  char *mon_grouping;
  622|       |  char *positive_sign;
  623|       |  char *negative_sign;
  624|       |  char int_frac_digits;
  625|       |  char frac_digits;
  626|       |  char p_cs_precedes;
  627|       |  char p_sep_by_space;
  628|       |  char n_cs_precedes;
  629|       |  char n_sep_by_space;
  630|       |  char p_sign_posn;
  631|       |  char n_sign_posn;
  632|       |  char int_p_cs_precedes;
  633|       |  char int_p_sep_by_space;
  634|       |  char int_n_cs_precedes;
  635|       |  char int_n_sep_by_space;
  636|       |  char int_p_sign_posn;
  637|       |  char int_n_sign_posn;
  638|       |};
  639|       |typedef int wchar_t;
  640|       |union __anonunion___value_23 {
  641|       |  unsigned int __wch;
  642|       |  char __wchb[4];
  643|       |};
  644|       |struct __anonstruct___mbstate_t_22 {
  645|       |  int __count;
  646|       |  union __anonunion___value_23 __value;
  647|       |};
  648|       |typedef struct __anonstruct___mbstate_t_22 __mbstate_t;
  649|       |typedef unsigned int wint_t;
  650|       |typedef __mbstate_t mbstate_t;
  651|       |struct quoting_options {
  652|       |  enum quoting_style style;
  653|       |  int quote_these_too[255UL / (sizeof(int) * 8UL) + 1UL];
  654|       |};
  655|       |struct slotvec {
  656|       |  size_t size;
  657|       |  char *val;
  658|       |};
  659|       |/* #pragma merger("0","000.buffer.o.i","") */
  660|       |extern __attribute__((__nothrow__)) void *(
  661|       |    __attribute__((__nonnull__(1, 2), __leaf__))
  662|       |    memcpy)(void *__restrict __dest, void const *__restrict __src, size_t __n);
  663|       |extern
  664|       |    __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1),
  665|       |                                                       __leaf__))
  666|       |                                        memset)(void *__s, int __c, size_t __n);
  667|       |extern __attribute__((__nothrow__)) void *(
  668|       |    __attribute__((__nonnull__(1), __leaf__))
  669|       |    memchr)(void const *__s, int __c, size_t __n) __attribute__((__pure__));
  670|       |extern __attribute__((__nothrow__)) char *(
  671|       |    __attribute__((__nonnull__(1, 2), __leaf__))
  672|       |    strcpy)(char *__restrict __dest, char const *__restrict __src);
  673|       |extern __attribute__((__nothrow__)) char *(
  674|       |    __attribute__((__nonnull__(1, 2), __leaf__))
  675|       |    strcat)(char *__restrict __dest, char const *__restrict __src);
  676|       |extern __attribute__((__nothrow__)) int(
  677|       |    __attribute__((__nonnull__(1, 2), __leaf__))
  678|       |    strcmp)(char const *__s1, char const *__s2) __attribute__((__pure__));
  679|       |extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1),
  680|       |                                                          __leaf__))
  681|       |                                           strchr)(char const *__s, int __c)
  682|       |    __attribute__((__pure__));
  683|       |extern __attribute__((__nothrow__))
  684|       |size_t(__attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s)
  685|       |    __attribute__((__pure__));
  686|       |extern __attribute__((__nothrow__)) int *(
  687|       |    __attribute__((__leaf__)) __errno_location)(void)__attribute__((__const__));
  688|       |extern int(__attribute__((__nonnull__(1))) open)(char const *__file,
  689|       |                                                 int __oflag, ...);
  690|       |extern int(__attribute__((__nonnull__(1))) creat)(char const *__file,
  691|       |                                                  mode_t __mode);
  692|       |extern __attribute__((__nothrow__))
  693|       |__off_t(__attribute__((__leaf__)) lseek)(int __fd, __off_t __offset,
  694|       |                                         int __whence);
  695|       |extern int close(int __fd);
  696|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  697|       |                                        ioctl)(int __fd,
  698|       |                                               unsigned long __request, ...);
  699|       |extern __attribute__((__nothrow__)) void(__attribute__((__leaf__))
  700|       |                                         free)(void *__ptr);
  701|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
  702|       |                                           valloc)(size_t __size)
  703|       |    __attribute__((__malloc__));
  704|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__))
  705|       |                                                       abort)(void);
  706|       |extern int system(char const *__command);
  707|       |extern struct _IO_FILE *stdin;
  708|       |extern struct _IO_FILE *stdout;
  709|       |extern struct _IO_FILE *stderr;
  710|       |extern int fclose(FILE *__stream);
  711|       |extern int fflush_unlocked(FILE *__stream);
  712|       |extern FILE *fopen(char const *__restrict __filename,
  713|       |                   char const *__restrict __modes);
  714|       |extern int fprintf(FILE *__restrict __stream, char const *__restrict __format,
  715|       |                   ...);
  716|       |extern __attribute__((__nothrow__)) int
  717|       |sprintf(char *__restrict __s, char const *__restrict __format, ...);
  718|       |extern int fscanf(FILE *__restrict __stream, char const *__restrict __format,
  719|       |                  ...);
  720|       |extern int fputc_unlocked(int __c, FILE *__stream);
  721|       |extern char *fgets_unlocked(char *__restrict __s, int __n,
  722|       |                            FILE *__restrict __stream);
  723|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  724|       |                                        ferror_unlocked)(FILE *__stream);
  725|       |extern __attribute__((__nothrow__))
  726|       |time_t(__attribute__((__leaf__)) time)(time_t *__timer);
  727|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  728|       |                                        clock_gettime)(clockid_t __clock_id,
  729|       |                                                       struct timespec *__tp);
  730|       |int strip_trailing_slashes(char *path);
  731|       |extern void error(int __status, int __errnum, char const *__format, ...);
  732|       |void *xmalloc(size_t n);
  733|       |char *xstrdup(char const *string);
  734|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
  735|       |                                           gettext)(char const *__msgid)
  736|       |    __attribute__((__format_arg__(1)));
  737|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
  738|       |                                           ngettext)(char const *__msgid1,
  739|       |                                                     char const *__msgid2,
  740|       |                                                     unsigned long __n)
  741|       |    __attribute__((__format_arg__(1), __format_arg__(2)));
  742|       |extern int fnmatch(char const *__pattern, char const *__name, int __flags);
  743|       |char *human_readable(uintmax_t n, char *buf, int opts,
  744|       |                     uintmax_t from_block_size, uintmax_t to_block_size);
  745|       |char *quotearg_colon(char const *arg);
  746|       |char const *quote_n(int n, char const *name);
  747|       |char const *quote(char const *name);
  748|       |size_t safe_read(int fd, void *buf, size_t count);
  749|       |enum subcommand subcommand_option;
  750|       |int blocking_factor;
  751|       |size_t record_size;
  752|       |_Bool backup_option;
  753|       |_Bool checkpoint_option;
  754|       |char const *use_compress_program_option;
  755|       |_Bool force_local_option;
  756|       |char const *info_script_option;
  757|       |_Bool multi_volume_option;
  758|       |_Bool read_full_records_option;
  759|       |char const *rsh_command_option;
  760|       |tarlong tape_length_option;
  761|       |_Bool to_stdout_option;
  762|       |_Bool totals_option;
  763|       |int verbose_option;
  764|       |_Bool verify_option;
  765|       |char const *volno_file_option;
  766|       |char const *volume_label_option;
  767|       |int archive;
  768|       |_Bool dev_null_output;
  769|       |struct timespec start_timespec;
  770|       |struct tar_stat_info current_stat_info;
  771|       |char const **archive_name_array;
  772|       |int archive_names;
  773|       |char const **archive_name_cursor;
  774|       |char const *index_file_name;
  775|       |enum access_mode access_mode;
  776|       |FILE *stdlis;
  777|       |char *save_name;
  778|       |off_t save_sizeleft;
  779|       |off_t save_totsize;
  780|       |_Bool write_archive_to_stdout;
  781|       |size_t available_space_after(union block *pointer);
  782|       |off_t current_block_ordinal(void);
  783|       |void close_archive(void);
  784|       |void closeout_volume_number(void);
  785|       |union block *find_next_block(void);
  786|       |void flush_read(void);
  787|       |void flush_write(void);
  788|       |void flush_archive(void);
  789|       |void init_volume_number(void);
  790|       |void open_archive(enum access_mode wanted_access);
  791|       |void print_total_written(void);
  792|       |void reset_eof(void);
  793|       |void set_next_block_after(union block *block);
  794|       |void clear_read_error_count(void);
  795|       |void xclose(int fd);
  796|       |__attribute__((__noreturn__)) void archive_write_error(ssize_t status);
  797|       |void archive_read_error(void);
  798|       |void finish_header(struct tar_stat_info *st, union block *header,
  799|       |                   off_t block_ordinal);
  800|       |void off_to_chars(off_t v, char *p, size_t s);
  801|       |void time_to_chars(time_t v, char *p, size_t s);
  802|       |_Bool now_verifying;
  803|       |void verify_volume(void);
  804|       |__attribute__((__noreturn__)) void fatal_exit(void);
  805|       |char *stringify_uintmax_t_backwards(uintmax_t o___0, char *buf);
  806|       |off_t off_from_header(char const *p, size_t s);
  807|       |uintmax_t uintmax_from_header(char const *p, size_t s);
  808|       |void assign_string(char **string, char const *value);
  809|       |_Bool maybe_backup_file(char const *path, int this_is_the_archive);
  810|       |void undo_last_backup(void);
  811|       |void close_error(char const *name);
  812|       |void close_warn(char const *name);
  813|       |void open_error(char const *name);
  814|       |__attribute__((__noreturn__)) void open_fatal(char const *name);
  815|       |void open_warn(char const *name);
  816|       |void read_error(char const *name);
  817|       |void write_error(char const *name);
  818|       |__attribute__((__noreturn__)) void
  819|       |write_fatal_details(char const *name, ssize_t status, size_t size);
  820|       |char *safer_name_suffix(char const *file_name, _Bool link_target);
  821|       |void tar_stat_destroy(struct tar_stat_info *st);
  822|       |char *output_start;
  823|       |void sys_detect_dev_null_output(void);
  824|       |void sys_save_archive_dev_ino(void);
  825|       |void sys_drain_input_pipe(void);
  826|       |void sys_wait_for_child(pid_t child_pid___0);
  827|       |void sys_spawn_shell(void);
  828|       |pid_t sys_child_open_for_compress(void);
  829|       |pid_t sys_child_open_for_uncompress(void);
  830|       |size_t sys_write_archive_buffer(void);
  831|       |_Bool sys_get_archive_stat(void);
  832|       |char *rmt_path__;
  833|       |int rmt_open__(char const *path, int open_mode, int bias,
  834|       |               char const *remote_shell);
  835|       |int rmt_close__(int handle);
  836|       |size_t rmt_read__(int handle, char *buffer___2, size_t length);
  837|       |off_t rmt_lseek__(int handle, off_t offset, int whence);
  838|       |int rmt_ioctl__(int handle, int operation, char *argument);
  839|       |static tarlong prev_written;
  840|       |static tarlong bytes_written;
  841|       |union block *record_start;
  842|       |union block *record_end;
  843|       |union block *current_block;
  844|       |off_t records_read;
  845|       |off_t records_written;
  846|       |static off_t record_start_block;
  847|       |static void backspace_output(void);
  848|       |static _Bool new_volume(enum access_mode mode);
  849|       |static pid_t child_pid;
  850|       |static int read_error_count;
  851|       |static int hit_eof;
  852|       |static int checkpoint;
  853|       |_Bool time_to_start_writing;
  854|       |static int volno = 1;
  855|       |static int global_volno = 1;
  856|       |static char *real_s_name;
  857|       |static off_t real_s_totsize;
  858|       |static off_t real_s_sizeleft;
  859|      0|void clear_read_error_count(void) {
  860|       |
  861|      0|  {
  862|      0|    read_error_count = 0;
  863|      0|    return;
  864|      0|  }
  865|      0|}
  866|      0|void print_total_written(void) {
  867|      0|  tarlong written;
  868|      0|  char bytes[sizeof(tarlong) * 8UL];
  869|      0|  char abbr[((((((2UL * sizeof(uintmax_t)) * 8UL) * 302UL) / 1000UL + 1UL) *
  870|      0|                  17UL -
  871|      0|              16UL) +
  872|      0|             3UL) +
  873|      0|            1UL];
  874|      0|  char rate[((((((2UL * sizeof(uintmax_t)) * 8UL) * 302UL) / 1000UL + 1UL) *
  875|      0|                  17UL -
  876|      0|              16UL) +
  877|      0|             3UL) +
  878|      0|            1UL];
  879|      0|  double seconds;
  880|      0|  int human_opts;
  881|      0|  struct timespec now;
  882|      0|  time_t tmp;
  883|      0|  int tmp___0;
  884|      0|  char *tmp___1;
  885|      0|  char const *tmp___2;
  886|      0|  char *tmp___3;
  887|      0|  char *tmp___4;
  888|      0|  void *__cil_tmp14;
  889|      0|  void *__cil_tmp15;
  890|      0|  void *__cil_tmp16;
  891|      0|  char *__cil_tmp17;
  892|      0|  char *__cil_tmp18;
  893|      0|  char *__cil_tmp19;
  894|      0|  char *__cil_tmp20;
  895|       |
  896|      0|  {
  897|      0|    {
  898|      0|      written = prev_written + bytes_written;
  899|      0|      human_opts = 240;
  900|      0|      tmp___0 = clock_gettime(0, &now);
  901|      0|    }
  902|      0|    if (tmp___0 == 0) {
  903|      0|      seconds = (double)(now.tv_sec - start_timespec.tv_sec) +
  904|      0|                (double)(now.tv_nsec - start_timespec.tv_nsec) / 1e9;
  905|      0|    } else {
  906|      0|      {
  907|      0|        tmp = time((time_t *)0);
  908|      0|        seconds = (double)(tmp - start_timespec.tv_sec);
  909|      0|      }
  910|      0|    }
  911|      0|    {
  912|      0|      sprintf((char * /* __restrict  */)(bytes),
  913|      0|              (char const * /* __restrict  */) "%.0f", written);
  914|      0|    }
  915|      0|    if ((double)0 < seconds) {
  916|      0|      if (written / seconds < (tarlong)0xffffffffffffffffUL) {
  917|      0|        {
  918|      0|          tmp___1 = human_readable((uintmax_t)(written / seconds), rate,
  919|      0|                                   human_opts, (uintmax_t)1, (uintmax_t)1);
  920|      0|          tmp___2 = (char const *)tmp___1;
  921|      0|        }
  922|      0|      } else {
  923|      0|        tmp___2 = "?";
  924|      0|      }
  925|      0|    } else {
  926|      0|      tmp___2 = "?";
  927|      0|    }
  928|      0|    {
  929|      0|      tmp___3 = human_readable((uintmax_t)written, abbr, human_opts,
  930|      0|                               (uintmax_t)1, (uintmax_t)1);
  931|      0|      tmp___4 = gettext("Total bytes written: %s (%s, %s/s)\n");
  932|      0|      fprintf((FILE * /* __restrict  */) stderr,
  933|      0|              (char const * /* __restrict  */)tmp___4, bytes, tmp___3, tmp___2);
  934|      0|    }
  935|      0|    return;
  936|      0|  }
  937|      0|}
  938|      0|off_t current_block_ordinal(void) {
  939|       |
  940|      0|  { return (record_start_block + (current_block - record_start)); }
  941|      0|}
  942|      0|void reset_eof(void) {
  943|       |
  944|      0|  {
  945|      0|    if (hit_eof) {
  946|      0|      hit_eof = 0;
  947|      0|      current_block = record_start;
  948|      0|      record_end = record_start + blocking_factor;
  949|      0|      access_mode = (enum access_mode)1;
  950|      0|    }
  951|      0|    return;
  952|      0|  }
  953|      0|}
  954|      0|union block *find_next_block(void) {
  955|       |
  956|      0|  {
  957|      0|    if ((unsigned long)current_block == (unsigned long)record_end) {
  958|      0|      if (hit_eof) {
  959|      0|        return ((union block *)0);
  960|      0|      }
  961|      0|      { flush_archive(); }
  962|      0|      if ((unsigned long)current_block == (unsigned long)record_end) {
  963|      0|        hit_eof = 1;
  964|      0|        return ((union block *)0);
  965|      0|      }
  966|      0|    }
  967|      0|    return (current_block);
  968|      0|  }
  969|      0|}
  970|      0|void set_next_block_after(union block *block) {
  971|       |
  972|      0|  {
  973|      0|    {
  974|      0|      while (1) {
  975|      0|      while_continue: /* CIL Label */;
  976|      0|        if (!((unsigned long)block >= (unsigned long)current_block)) {
  977|      0|          goto while_break;
  978|      0|        }
  979|      0|        current_block++;
  980|      0|      }
  981|      0|    while_break: /* CIL Label */;
  982|      0|    }
  983|      0|    if ((unsigned long)current_block > (unsigned long)record_end) {
  984|      0|      {
  985|      0|        abort();
  986|      0|      }
  987|      0|    }
  988|      0|    return;
  989|      0|  }
  990|      0|}
  991|      0|size_t available_space_after(union block *pointer) {
  992|       |
  993|      0|  { return ((size_t)(record_end->buffer - pointer->buffer)); }
  994|      0|}
  995|      0|void xclose(int fd) {
  996|      0|  char *tmp;
  997|      0|  int tmp___0;
  998|      0|  char *__cil_tmp4;
  999|       |
 1000|      0|  {
 1001|      0|    { tmp___0 = close(fd); }
 1002|      0|    if (tmp___0 != 0) {
 1003|      0|      {
 1004|      0|        tmp = gettext("(pipe)");
 1005|      0|        close_error((char const *)tmp);
 1006|      0|      }
 1007|      0|    }
 1008|      0|    return;
 1009|      0|  }
 1010|      0|}
 1011|      0|static _Bool check_label_pattern(union block *label) {
 1012|      0|  char *string;
 1013|      0|  _Bool result;
 1014|      0|  void *tmp;
 1015|      0|  int tmp___0;
 1016|      0|  size_t tmp___1;
 1017|      0|  void *tmp___2;
 1018|      0|  int tmp___3;
 1019|      0|  char *__cil_tmp9;
 1020|      0|  char *__cil_tmp10;
 1021|       |
 1022|      0|  {
 1023|      0|    {
 1024|      0|      tmp = memchr((void const *)(label->header.name), '\000',
 1025|      0|                   sizeof(label->header.name));
 1026|      0|    }
 1027|      0|    if (!tmp) {
 1028|      0|      return ((_Bool)0);
 1029|      0|    }
 1030|      0|    {
 1031|      0|      tmp___0 =
 1032|      0|          fnmatch(volume_label_option, (char const *)(label->header.name), 0);
 1033|      0|    }
 1034|      0|    if (tmp___0 == 0) {
 1035|      0|      return ((_Bool)1);
 1036|      0|    }
 1037|      0|    if (!multi_volume_option) {
 1038|      0|      return ((_Bool)0);
 1039|      0|    }
 1040|      0|    {
 1041|      0|      tmp___1 = strlen(volume_label_option);
 1042|      0|      tmp___2 = xmalloc((tmp___1 + sizeof(" Volume [1-9]*")) + 1UL);
 1043|      0|      string = (char *)tmp___2;
 1044|      0|      strcpy((char * /* __restrict  */)string,
 1045|      0|             (char const * /* __restrict  */)volume_label_option);
 1046|      0|      strcat((char * /* __restrict  */)string,
 1047|      0|             (char const * /* __restrict  */) " Volume [1-9]*");
 1048|      0|      tmp___3 =
 1049|      0|          fnmatch((char const *)string, (char const *)(label->header.name), 0);
 1050|      0|      result = (_Bool)(tmp___3 == 0);
 1051|      0|      free((void *)string);
 1052|      0|    }
 1053|      0|    return (result);
 1054|      0|  }
 1055|      0|}
 1056|      0|void open_archive(enum access_mode wanted_access) {
 1057|      0|  int backed_up_flag;
 1058|      0|  char *tmp;
 1059|      0|  char *tmp___0;
 1060|      0|  void *tmp___1;
 1061|      0|  void *tmp___2;
 1062|      0|  char *tmp___3;
 1063|      0|  int tmp___4;
 1064|      0|  char *tmp___5;
 1065|      0|  int tmp___7;
 1066|      0|  int tmp___8;
 1067|      0|  void *tmp___9;
 1068|      0|  int tmp___11;
 1069|      0|  int tmp___12;
 1070|      0|  void *tmp___13;
 1071|      0|  int tmp___15;
 1072|      0|  int tmp___16;
 1073|      0|  void *tmp___17;
 1074|      0|  int tmp___19;
 1075|      0|  int tmp___20;
 1076|      0|  void *tmp___21;
 1077|      0|  int tmp___22;
 1078|      0|  int saved_errno;
 1079|      0|  int *tmp___23;
 1080|      0|  int *tmp___24;
 1081|      0|  _Bool tmp___25;
 1082|      0|  union block *label;
 1083|      0|  union block *tmp___26;
 1084|      0|  char const *tmp___27;
 1085|      0|  char *tmp___28;
 1086|      0|  char const *tmp___29;
 1087|      0|  char const *tmp___30;
 1088|      0|  char *tmp___31;
 1089|      0|  _Bool tmp___32;
 1090|      0|  unsigned int tmp___33;
 1091|      0|  char *__cil_tmp36;
 1092|      0|  char *__cil_tmp37;
 1093|      0|  char *__cil_tmp38;
 1094|      0|  char *__cil_tmp39;
 1095|      0|  char *__cil_tmp40;
 1096|      0|  char *__cil_tmp41;
 1097|      0|  char *__cil_tmp42;
 1098|       |
 1099|      0|  {
 1100|      0|    backed_up_flag = 0;
 1101|      0|    if (index_file_name) {
 1102|      0|      {
 1103|      0|        stdlis = fopen((char const * /* __restrict  */)index_file_name,
 1104|      0|                       (char const * /* __restrict  */) "w");
 1105|      0|      }
 1106|      0|      if (!stdlis) {
 1107|      0|        {
 1108|      0|          open_error(index_file_name);
 1109|      0|        }
 1110|      0|      }
 1111|      0|    } else {
 1112|      0|      if (to_stdout_option) {
 1113|      0|        stdlis = stderr;
 1114|      0|      } else {
 1115|      0|        stdlis = stdout;
 1116|      0|      }
 1117|      0|    }
 1118|      0|    if (record_size == 0UL) {
 1119|      0|      {
 1120|      0|        tmp = gettext("Invalid value for record_size");
 1121|      0|        error(0, 0, (char const *)tmp);
 1122|      0|        fatal_exit();
 1123|      0|      }
 1124|      0|    }
 1125|      0|    if (archive_names == 0) {
 1126|      0|      {
 1127|      0|        tmp___0 = gettext("No archive name given");
 1128|      0|        error(0, 0, (char const *)tmp___0);
 1129|      0|        fatal_exit();
 1130|      0|      }
 1131|      0|    }
 1132|      0|    {
 1133|      0|      tar_stat_destroy(&current_stat_info);
 1134|      0|      save_name = (char *)0;
 1135|      0|      real_s_name = (char *)0;
 1136|      0|    }
 1137|      0|    if (multi_volume_option) {
 1138|      0|      {
 1139|      0|        tmp___1 = valloc(record_size + 1024UL);
 1140|      0|        record_start = (union block *)tmp___1;
 1141|      0|      }
 1142|      0|      if (record_start) {
 1143|      0|        record_start += 2;
 1144|      0|      }
 1145|      0|    } else {
 1146|      0|      {
 1147|      0|        tmp___2 = valloc(record_size);
 1148|      0|        record_start = (union block *)tmp___2;
 1149|      0|      }
 1150|      0|    }
 1151|      0|    if (!record_start) {
 1152|      0|      {
 1153|      0|        tmp___3 = gettext("Cannot allocate memory for blocking factor %d");
 1154|      0|        error(0, 0, (char const *)tmp___3, blocking_factor);
 1155|      0|        fatal_exit();
 1156|      0|      }
 1157|      0|    }
 1158|      0|    current_block = record_start;
 1159|      0|    record_end = record_start + blocking_factor;
 1160|      0|    if ((unsigned int)wanted_access == 2U) {
 1161|      0|      tmp___33 = 0U;
 1162|      0|    } else {
 1163|      0|      tmp___33 = (unsigned int)wanted_access;
 1164|      0|    }
 1165|      0|    access_mode = (enum access_mode)tmp___33;
 1166|      0|    if (use_compress_program_option) {
 1167|      0|      {
 1168|      0|        if ((unsigned int)wanted_access == 0U) {
 1169|      0|          goto case_0;
 1170|      0|        }
 1171|      0|        if ((unsigned int)wanted_access == 1U) {
 1172|      0|          goto case_1;
 1173|      0|        }
 1174|      0|        if ((unsigned int)wanted_access == 2U) {
 1175|      0|          goto case_2;
 1176|      0|        }
 1177|      0|        goto switch_break;
 1178|      0|      case_0 : /* CIL Label */
 1179|      0|      {
 1180|      0|        child_pid = sys_child_open_for_uncompress();
 1181|      0|        read_full_records_option = (_Bool)0;
 1182|      0|      }
 1183|      0|        goto switch_break;
 1184|      0|      case_1 : /* CIL Label */
 1185|      0|      {
 1186|      0|        child_pid = sys_child_open_for_compress();
 1187|      0|      }
 1188|      0|        goto switch_break;
 1189|      0|      case_2 : /* CIL Label */
 1190|      0|      {
 1191|      0|        abort();
 1192|      0|      }
 1193|      0|        goto switch_break;
 1194|      0|      switch_break: /* CIL Label */;
 1195|      0|      }
 1196|      0|      if ((unsigned int)wanted_access == 1U) {
 1197|      0|        {
 1198|      0|          tmp___4 = strcmp(*(archive_name_array + 0), "-");
 1199|      0|        }
 1200|      0|        if (tmp___4 == 0) {
 1201|      0|          stdlis = stderr;
 1202|      0|        }
 1203|      0|      }
 1204|      0|    } else {
 1205|      0|      { tmp___22 = strcmp(*(archive_name_array + 0), "-"); }
 1206|      0|      if (tmp___22 == 0) {
 1207|      0|        read_full_records_option = (_Bool)1;
 1208|      0|        if (verify_option) {
 1209|      0|          {
 1210|      0|            tmp___5 = gettext("Cannot verify stdin/stdout archive");
 1211|      0|            error(0, 0, (char const *)tmp___5);
 1212|      0|            fatal_exit();
 1213|      0|          }
 1214|      0|        }
 1215|      0|        {
 1216|      0|          if ((unsigned int)wanted_access == 0U) {
 1217|      0|            goto case_0___0;
 1218|      0|          }
 1219|      0|          if ((unsigned int)wanted_access == 1U) {
 1220|      0|            goto case_1___0;
 1221|      0|          }
 1222|      0|          if ((unsigned int)wanted_access == 2U) {
 1223|      0|            goto case_2___0;
 1224|      0|          }
 1225|      0|          goto switch_break___0;
 1226|      0|        case_0___0: /* CIL Label */
 1227|      0|          archive = 0;
 1228|      0|          goto switch_break___0;
 1229|      0|        case_1___0: /* CIL Label */
 1230|      0|          archive = 1;
 1231|      0|          stdlis = stderr;
 1232|      0|          goto switch_break___0;
 1233|      0|        case_2___0: /* CIL Label */
 1234|      0|          archive = 0;
 1235|      0|          stdlis = stderr;
 1236|      0|          write_archive_to_stdout = (_Bool)1;
 1237|      0|          goto switch_break___0;
 1238|      0|        switch_break___0: /* CIL Label */;
 1239|      0|        }
 1240|      0|      } else {
 1241|      0|        if (verify_option) {
 1242|      0|          if (!force_local_option) {
 1243|      0|            {
 1244|      0|              rmt_path__ = strchr(*(archive_name_array + 0), ':');
 1245|      0|            }
 1246|      0|            if (rmt_path__) {
 1247|      0|              if ((unsigned long)rmt_path__ >
 1248|      0|                  (unsigned long)*(archive_name_array + 0)) {
 1249|      0|                {
 1250|      0|                  tmp___9 = memchr(
 1251|      0|                      (void const *)*(archive_name_array + 0), '/',
 1252|      0|                      (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));
 1253|      0|                }
 1254|      0|                if (tmp___9) {
 1255|      0|                  {
 1256|      0|                    tmp___8 =
 1257|      0|                        open(*(archive_name_array + 0), 66,
 1258|      0|                             ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1259|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1260|      0|                    archive = tmp___8;
 1261|      0|                  }
 1262|      0|                } else {
 1263|      0|                  {
 1264|      0|                    tmp___7 = rmt_open__(*(archive_name_array + 0), 66, 1 << 30,
 1265|      0|                                         rsh_command_option);
 1266|      0|                    archive = tmp___7;
 1267|      0|                  }
 1268|      0|                }
 1269|      0|              } else {
 1270|      0|                {
 1271|      0|                  tmp___8 = open(*(archive_name_array + 0), 66,
 1272|      0|                                 ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1273|      0|                                     ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1274|      0|                  archive = tmp___8;
 1275|      0|                }
 1276|      0|              }
 1277|      0|            } else {
 1278|      0|              {
 1279|      0|                tmp___8 = open(*(archive_name_array + 0), 66,
 1280|      0|                               ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1281|      0|                                   ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1282|      0|                archive = tmp___8;
 1283|      0|              }
 1284|      0|            }
 1285|      0|          } else {
 1286|      0|            {
 1287|      0|              tmp___8 = open(*(archive_name_array + 0), 66,
 1288|      0|                             ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1289|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1290|      0|              archive = tmp___8;
 1291|      0|            }
 1292|      0|          }
 1293|      0|        } else {
 1294|      0|          {
 1295|      0|            if ((unsigned int)wanted_access == 0U) {
 1296|      0|              goto case_0___1;
 1297|      0|            }
 1298|      0|            if ((unsigned int)wanted_access == 1U) {
 1299|      0|              goto case_1___1;
 1300|      0|            }
 1301|      0|            if ((unsigned int)wanted_access == 2U) {
 1302|      0|              goto case_2___1;
 1303|      0|            }
 1304|      0|            goto switch_break___1;
 1305|      0|          case_0___1: /* CIL Label */
 1306|      0|            if (!force_local_option) {
 1307|      0|              {
 1308|      0|                rmt_path__ = strchr(*(archive_name_array + 0), ':');
 1309|      0|              }
 1310|      0|              if (rmt_path__) {
 1311|      0|                if ((unsigned long)rmt_path__ >
 1312|      0|                    (unsigned long)*(archive_name_array + 0)) {
 1313|      0|                  {
 1314|      0|                    tmp___13 =
 1315|      0|                        memchr((void const *)*(archive_name_array + 0), '/',
 1316|      0|                               (size_t)(rmt_path__ -
 1317|      0|                                        (char *)*(archive_name_array + 0)));
 1318|      0|                  }
 1319|      0|                  if (tmp___13) {
 1320|      0|                    {
 1321|      0|                      tmp___12 =
 1322|      0|                          open(*(archive_name_array + 0), 0,
 1323|      0|                               ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1324|      0|                                   ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1325|      0|                      archive = tmp___12;
 1326|      0|                    }
 1327|      0|                  } else {
 1328|      0|                    {
 1329|      0|                      tmp___11 = rmt_open__(*(archive_name_array + 0), 0,
 1330|      0|                                            1 << 30, rsh_command_option);
 1331|      0|                      archive = tmp___11;
 1332|      0|                    }
 1333|      0|                  }
 1334|      0|                } else {
 1335|      0|                  {
 1336|      0|                    tmp___12 =
 1337|      0|                        open(*(archive_name_array + 0), 0,
 1338|      0|                             ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1339|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1340|      0|                    archive = tmp___12;
 1341|      0|                  }
 1342|      0|                }
 1343|      0|              } else {
 1344|      0|                {
 1345|      0|                  tmp___12 = open(*(archive_name_array + 0), 0,
 1346|      0|                                  ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1347|      0|                                      ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1348|      0|                  archive = tmp___12;
 1349|      0|                }
 1350|      0|              }
 1351|      0|            } else {
 1352|      0|              {
 1353|      0|                tmp___12 = open(*(archive_name_array + 0), 0,
 1354|      0|                                ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1355|      0|                                    ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1356|      0|                archive = tmp___12;
 1357|      0|              }
 1358|      0|            }
 1359|      0|            goto switch_break___1;
 1360|      0|          case_1___1: /* CIL Label */
 1361|      0|            if (backup_option) {
 1362|      0|              {
 1363|      0|                maybe_backup_file(*(archive_name_array + 0), 1);
 1364|      0|                backed_up_flag = 1;
 1365|      0|              }
 1366|      0|            }
 1367|      0|            if (!force_local_option) {
 1368|      0|              {
 1369|      0|                rmt_path__ = strchr(*(archive_name_array + 0), ':');
 1370|      0|              }
 1371|      0|              if (rmt_path__) {
 1372|      0|                if ((unsigned long)rmt_path__ >
 1373|      0|                    (unsigned long)*(archive_name_array + 0)) {
 1374|      0|                  {
 1375|      0|                    tmp___17 =
 1376|      0|                        memchr((void const *)*(archive_name_array + 0), '/',
 1377|      0|                               (size_t)(rmt_path__ -
 1378|      0|                                        (char *)*(archive_name_array + 0)));
 1379|      0|                  }
 1380|      0|                  if (tmp___17) {
 1381|      0|                    {
 1382|      0|                      tmp___16 = creat(
 1383|      0|                          *(archive_name_array + 0),
 1384|      0|                          (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1385|      0|                                   ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
 1386|      0|                      archive = tmp___16;
 1387|      0|                    }
 1388|      0|                  } else {
 1389|      0|                    {
 1390|      0|                      tmp___15 = rmt_open__(*(archive_name_array + 0), 65,
 1391|      0|                                            1 << 30, rsh_command_option);
 1392|      0|                      archive = tmp___15;
 1393|      0|                    }
 1394|      0|                  }
 1395|      0|                } else {
 1396|      0|                  {
 1397|      0|                    tmp___16 = creat(
 1398|      0|                        *(archive_name_array + 0),
 1399|      0|                        (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1400|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
 1401|      0|                    archive = tmp___16;
 1402|      0|                  }
 1403|      0|                }
 1404|      0|              } else {
 1405|      0|                {
 1406|      0|                  tmp___16 =
 1407|      0|                      creat(*(archive_name_array + 0),
 1408|      0|                            (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1409|      0|                                     ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
 1410|      0|                  archive = tmp___16;
 1411|      0|                }
 1412|      0|              }
 1413|      0|            } else {
 1414|      0|              {
 1415|      0|                tmp___16 =
 1416|      0|                    creat(*(archive_name_array + 0),
 1417|      0|                          (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1418|      0|                                   ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
 1419|      0|                archive = tmp___16;
 1420|      0|              }
 1421|      0|            }
 1422|      0|            goto switch_break___1;
 1423|      0|          case_2___1: /* CIL Label */
 1424|      0|            if (!force_local_option) {
 1425|      0|              {
 1426|      0|                rmt_path__ = strchr(*(archive_name_array + 0), ':');
 1427|      0|              }
 1428|      0|              if (rmt_path__) {
 1429|      0|                if ((unsigned long)rmt_path__ >
 1430|      0|                    (unsigned long)*(archive_name_array + 0)) {
 1431|      0|                  {
 1432|      0|                    tmp___21 =
 1433|      0|                        memchr((void const *)*(archive_name_array + 0), '/',
 1434|      0|                               (size_t)(rmt_path__ -
 1435|      0|                                        (char *)*(archive_name_array + 0)));
 1436|      0|                  }
 1437|      0|                  if (tmp___21) {
 1438|      0|                    {
 1439|      0|                      tmp___20 =
 1440|      0|                          open(*(archive_name_array + 0), 66,
 1441|      0|                               ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1442|      0|                                   ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1443|      0|                      archive = tmp___20;
 1444|      0|                    }
 1445|      0|                  } else {
 1446|      0|                    {
 1447|      0|                      tmp___19 = rmt_open__(*(archive_name_array + 0), 66,
 1448|      0|                                            1 << 30, rsh_command_option);
 1449|      0|                      archive = tmp___19;
 1450|      0|                    }
 1451|      0|                  }
 1452|      0|                } else {
 1453|      0|                  {
 1454|      0|                    tmp___20 =
 1455|      0|                        open(*(archive_name_array + 0), 66,
 1456|      0|                             ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1457|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1458|      0|                    archive = tmp___20;
 1459|      0|                  }
 1460|      0|                }
 1461|      0|              } else {
 1462|      0|                {
 1463|      0|                  tmp___20 = open(*(archive_name_array + 0), 66,
 1464|      0|                                  ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1465|      0|                                      ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1466|      0|                  archive = tmp___20;
 1467|      0|                }
 1468|      0|              }
 1469|      0|            } else {
 1470|      0|              {
 1471|      0|                tmp___20 = open(*(archive_name_array + 0), 66,
 1472|      0|                                ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 1473|      0|                                    ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 1474|      0|                archive = tmp___20;
 1475|      0|              }
 1476|      0|            }
 1477|      0|            goto switch_break___1;
 1478|      0|          switch_break___1: /* CIL Label */;
 1479|      0|          }
 1480|      0|        }
 1481|      0|      }
 1482|      0|    }
 1483|      0|    if (archive < 0) {
 1484|      0|      goto _L;
 1485|      0|    } else {
 1486|      0|      if (!(archive >= 1 << 30)) {
 1487|      0|        {
 1488|      0|          tmp___25 = sys_get_archive_stat();
 1489|      0|        }
 1490|      0|        if (!tmp___25) {
 1491|      0|        _L : {
 1492|      0|          tmp___23 = __errno_location();
 1493|      0|          saved_errno = *tmp___23;
 1494|      0|        }
 1495|      0|          if (backed_up_flag) {
 1496|      0|            {
 1497|      0|              undo_last_backup();
 1498|      0|            }
 1499|      0|          }
 1500|      0|          {
 1501|      0|            tmp___24 = __errno_location();
 1502|      0|            *tmp___24 = saved_errno;
 1503|      0|            open_fatal(*(archive_name_array + 0));
 1504|      0|          }
 1505|      0|        }
 1506|      0|      }
 1507|      0|    }
 1508|      0|    {
 1509|      0|      sys_detect_dev_null_output();
 1510|      0|      sys_save_archive_dev_ino();
 1511|      0|    }
 1512|      0|    {
 1513|      0|      if ((unsigned int)wanted_access == 2U) {
 1514|      0|        goto case_2___2;
 1515|      0|      }
 1516|      0|      if ((unsigned int)wanted_access == 0U) {
 1517|      0|        goto case_0___2;
 1518|      0|      }
 1519|      0|      if ((unsigned int)wanted_access == 1U) {
 1520|      0|        goto case_1___2;
 1521|      0|      }
 1522|      0|      goto switch_break___2;
 1523|      0|    case_2___2: /* CIL Label */
 1524|      0|      records_written = (off_t)0;
 1525|      0|    case_0___2 : /* CIL Label */
 1526|      0|    {
 1527|      0|      records_read = (off_t)0;
 1528|      0|      record_end = record_start;
 1529|      0|      find_next_block();
 1530|      0|    }
 1531|      0|      if (volume_label_option) {
 1532|      0|        {
 1533|      0|          tmp___26 = find_next_block();
 1534|      0|          label = tmp___26;
 1535|      0|        }
 1536|      0|        if (!label) {
 1537|      0|          {
 1538|      0|            tmp___27 = quote(volume_label_option);
 1539|      0|            tmp___28 = gettext("Archive not labeled to match %s");
 1540|      0|            error(0, 0, (char const *)tmp___28, tmp___27);
 1541|      0|            fatal_exit();
 1542|      0|          }
 1543|      0|        }
 1544|      0|        { tmp___32 = check_label_pattern(label); }
 1545|      0|        if (!tmp___32) {
 1546|      0|          {
 1547|      0|            tmp___29 = quote_n(1, volume_label_option);
 1548|      0|            tmp___30 = quote_n(0, (char const *)(label->header.name));
 1549|      0|            tmp___31 = gettext("Volume %s does not match %s");
 1550|      0|            error(0, 0, (char const *)tmp___31, tmp___30, tmp___29);
 1551|      0|            fatal_exit();
 1552|      0|          }
 1553|      0|        }
 1554|      0|      }
 1555|      0|      goto switch_break___2;
 1556|      0|    case_1___2: /* CIL Label */
 1557|      0|      records_written = (off_t)0;
 1558|      0|      if (volume_label_option) {
 1559|      0|        {
 1560|      0|          memset((void *)record_start, 0, (size_t)512);
 1561|      0|        }
 1562|      0|        if (multi_volume_option) {
 1563|      0|          {
 1564|      0|            sprintf((char * /* __restrict  */)(record_start->header.name),
 1565|      0|                    (char const * /* __restrict  */) "%s Volume 1",
 1566|      0|                    volume_label_option);
 1567|      0|          }
 1568|      0|        } else {
 1569|      0|          {
 1570|      0|            strcpy((char * /* __restrict  */)(record_start->header.name),
 1571|      0|                   (char const * /* __restrict  */)volume_label_option);
 1572|      0|          }
 1573|      0|        }
 1574|      0|        {
 1575|      0|          assign_string(&current_stat_info.file_name,
 1576|      0|                        (char const *)(record_start->header.name));
 1577|      0|          current_stat_info.had_trailing_slash =
 1578|      0|              strip_trailing_slashes(current_stat_info.file_name);
 1579|      0|          record_start->header.typeflag = (char)'V';
 1580|      0|          time_to_chars(start_timespec.tv_sec, record_start->header.mtime,
 1581|      0|                        sizeof(record_start->header.mtime));
 1582|      0|          finish_header(&current_stat_info, record_start, (off_t)-1);
 1583|      0|        }
 1584|      0|      }
 1585|      0|      goto switch_break___2;
 1586|      0|    switch_break___2: /* CIL Label */;
 1587|      0|    }
 1588|      0|    return;
 1589|      0|  }
 1590|      0|}
 1591|      0|void flush_write(void) {
 1592|      0|  int copy_back;
 1593|      0|  ssize_t status;
 1594|      0|  char *tmp;
 1595|      0|  int *tmp___0;
 1596|      0|  size_t tmp___1;
 1597|      0|  char *tmp___2;
 1598|      0|  int *tmp___3;
 1599|      0|  int *tmp___4;
 1600|      0|  int *tmp___5;
 1601|      0|  _Bool tmp___6;
 1602|      0|  int tmp___7;
 1603|      0|  size_t tmp___8;
 1604|      0|  char *tmp___9;
 1605|      0|  char *__cil_tmp14;
 1606|      0|  char *__cil_tmp15;
 1607|       |
 1608|      0|  {
 1609|      0|    if (checkpoint_option) {
 1610|      0|      checkpoint++;
 1611|      0|      if (!(checkpoint % 10)) {
 1612|      0|        {
 1613|      0|          tmp = gettext("Write checkpoint %d");
 1614|      0|          error(0, 0, (char const *)tmp, checkpoint);
 1615|      0|        }
 1616|      0|      }
 1617|      0|    }
 1618|      0|    if (tape_length_option) {
 1619|      0|      if (tape_length_option <= bytes_written) {
 1620|      0|        {
 1621|      0|          tmp___0 = __errno_location();
 1622|      0|          *tmp___0 = 28;
 1623|      0|          status = (ssize_t)0;
 1624|      0|        }
 1625|      0|      } else {
 1626|      0|        goto _L___0;
 1627|      0|      }
 1628|      0|    } else {
 1629|      0|    _L___0: /* CIL Label */
 1630|      0|      if (dev_null_output) {
 1631|      0|        status = (ssize_t)record_size;
 1632|      0|      } else {
 1633|      0|        {
 1634|      0|          tmp___1 = sys_write_archive_buffer();
 1635|      0|          status = (ssize_t)tmp___1;
 1636|      0|        }
 1637|      0|      }
 1638|      0|    }
 1639|      0|    if ((size_t)status != record_size) {
 1640|      0|      if (!multi_volume_option) {
 1641|      0|        {
 1642|      0|          archive_write_error(status);
 1643|      0|        }
 1644|      0|      }
 1645|      0|    }
 1646|      0|    if (status > 0L) {
 1647|      0|      records_written++;
 1648|      0|      bytes_written += (tarlong)status;
 1649|      0|    }
 1650|      0|    if ((size_t)status == record_size) {
 1651|      0|      if (multi_volume_option) {
 1652|      0|        if (save_name) {
 1653|      0|          {
 1654|      0|            tmp___2 = safer_name_suffix((char const *)save_name, (_Bool)0);
 1655|      0|            assign_string(&real_s_name, (char const *)tmp___2);
 1656|      0|            real_s_totsize = save_totsize;
 1657|      0|            real_s_sizeleft = save_sizeleft;
 1658|      0|          }
 1659|      0|        } else {
 1660|      0|          {
 1661|      0|            assign_string(&real_s_name, (char const *)0);
 1662|      0|            real_s_totsize = (off_t)0;
 1663|      0|            real_s_sizeleft = (off_t)0;
 1664|      0|          }
 1665|      0|        }
 1666|      0|      }
 1667|      0|      return;
 1668|      0|    }
 1669|      0|    if (status < 0L) {
 1670|      0|      {
 1671|      0|        tmp___3 = __errno_location();
 1672|      0|      }
 1673|      0|      if (*tmp___3 != 28) {
 1674|      0|        {
 1675|      0|          tmp___4 = __errno_location();
 1676|      0|        }
 1677|      0|        if (*tmp___4 != 5) {
 1678|      0|          {
 1679|      0|            tmp___5 = __errno_location();
 1680|      0|          }
 1681|      0|          if (*tmp___5 != 6) {
 1682|      0|            {
 1683|      0|              archive_write_error(status);
 1684|      0|            }
 1685|      0|          }
 1686|      0|        }
 1687|      0|      }
 1688|      0|    }
 1689|      0|    { tmp___6 = new_volume((enum access_mode)1); }
 1690|      0|    if (!tmp___6) {
 1691|      0|      return;
 1692|      0|    }
 1693|      0|    if (totals_option) {
 1694|      0|      prev_written += bytes_written;
 1695|      0|    }
 1696|      0|    bytes_written = (tarlong)0;
 1697|      0|    if (volume_label_option) {
 1698|      0|      if (real_s_name) {
 1699|      0|        copy_back = 2;
 1700|      0|        record_start -= 2;
 1701|      0|      } else {
 1702|      0|        goto _L___1;
 1703|      0|      }
 1704|      0|    } else {
 1705|      0|    _L___1: /* CIL Label */
 1706|      0|      if (volume_label_option) {
 1707|      0|        copy_back = 1;
 1708|      0|        record_start--;
 1709|      0|      } else {
 1710|      0|        if (real_s_name) {
 1711|      0|          copy_back = 1;
 1712|      0|          record_start--;
 1713|      0|        } else {
 1714|      0|          copy_back = 0;
 1715|      0|        }
 1716|      0|      }
 1717|      0|    }
 1718|      0|    if (volume_label_option) {
 1719|      0|      {
 1720|      0|        memset((void *)record_start, 0, (size_t)512);
 1721|      0|        sprintf((char * /* __restrict  */)(record_start->header.name),
 1722|      0|                (char const * /* __restrict  */) "%s Volume %d",
 1723|      0|                volume_label_option, volno);
 1724|      0|        time_to_chars(start_timespec.tv_sec, record_start->header.mtime,
 1725|      0|                      sizeof(record_start->header.mtime));
 1726|      0|        record_start->header.typeflag = (char)'V';
 1727|      0|        finish_header(&current_stat_info, record_start, (off_t)-1);
 1728|      0|      }
 1729|      0|    }
 1730|      0|    if (real_s_name) {
 1731|      0|      if (volume_label_option) {
 1732|      0|        record_start++;
 1733|      0|      }
 1734|      0|      {
 1735|      0|        memset((void *)record_start, 0, (size_t)512);
 1736|      0|        strcpy((char * /* __restrict  */)(record_start->header.name),
 1737|      0|               (char const * /* __restrict  */)real_s_name);
 1738|      0|        record_start->header.typeflag = (char)'M';
 1739|      0|        off_to_chars(real_s_sizeleft, record_start->header.size,
 1740|      0|                     sizeof(record_start->header.size));
 1741|      0|        off_to_chars(real_s_totsize - real_s_sizeleft,
 1742|      0|                     record_start->oldgnu_header.offset,
 1743|      0|                     sizeof(record_start->oldgnu_header.offset));
 1744|      0|        tmp___7 = verbose_option;
 1745|      0|        verbose_option = 0;
 1746|      0|        finish_header(&current_stat_info, record_start, (off_t)-1);
 1747|      0|        verbose_option = tmp___7;
 1748|      0|      }
 1749|      0|      if (volume_label_option) {
 1750|      0|        record_start--;
 1751|      0|      }
 1752|      0|    }
 1753|      0|    {
 1754|      0|      tmp___8 = sys_write_archive_buffer();
 1755|      0|      status = (ssize_t)tmp___8;
 1756|      0|    }
 1757|      0|    if ((size_t)status != record_size) {
 1758|      0|      {
 1759|      0|        archive_write_error(status);
 1760|      0|      }
 1761|      0|    }
 1762|      0|    bytes_written += (tarlong)status;
 1763|      0|    if (copy_back) {
 1764|      0|      {
 1765|      0|        record_start += copy_back;
 1766|      0|        memcpy((void * /* __restrict  */)current_block,
 1767|      0|               (void const * /* __restrict  */)(
 1768|      0|                   (record_start + blocking_factor) - copy_back),
 1769|      0|               (size_t)(copy_back * 512));
 1770|      0|        current_block += copy_back;
 1771|      0|      }
 1772|      0|      if (real_s_sizeleft >= (off_t)(copy_back * 512)) {
 1773|      0|        real_s_sizeleft -= (off_t)(copy_back * 512);
 1774|      0|      } else {
 1775|      0|        if (((real_s_sizeleft + 512L) - 1L) / 512L <= (off_t)copy_back) {
 1776|      0|          {
 1777|      0|            assign_string(&real_s_name, (char const *)0);
 1778|      0|          }
 1779|      0|        } else {
 1780|      0|          {
 1781|      0|            tmp___9 = safer_name_suffix((char const *)save_name, (_Bool)0);
 1782|      0|            assign_string(&real_s_name, (char const *)tmp___9);
 1783|      0|            real_s_sizeleft = save_sizeleft;
 1784|      0|            real_s_totsize = save_totsize;
 1785|      0|          }
 1786|      0|        }
 1787|      0|      }
 1788|      0|      copy_back = 0;
 1789|      0|    }
 1790|      0|    return;
 1791|      0|  }
 1792|      0|}
 1793|       |__attribute__((__noreturn__)) void archive_write_error(ssize_t status);
 1794|      0|void archive_write_error(ssize_t status) {
 1795|      0|  int e;
 1796|      0|  int *tmp;
 1797|      0|  int *tmp___0;
 1798|       |
 1799|      0|  {
 1800|      0|    if (totals_option) {
 1801|      0|      {
 1802|      0|        tmp = __errno_location();
 1803|      0|        e = *tmp;
 1804|      0|        print_total_written();
 1805|      0|        tmp___0 = __errno_location();
 1806|      0|        *tmp___0 = e;
 1807|      0|      }
 1808|      0|    }
 1809|      0|    { write_fatal_details(*archive_name_cursor, status, record_size); }
 1810|      0|  }
 1811|      0|}
 1812|      0|void archive_read_error(void) {
 1813|      0|  char *tmp;
 1814|      0|  char *tmp___0;
 1815|      0|  int tmp___1;
 1816|      0|  char *__cil_tmp4;
 1817|      0|  char *__cil_tmp5;
 1818|       |
 1819|      0|  {
 1820|      0|    { read_error(*archive_name_cursor); }
 1821|      0|    if (record_start_block == 0L) {
 1822|      0|      {
 1823|      0|        tmp = gettext("At beginning of tape, quitting now");
 1824|      0|        error(0, 0, (char const *)tmp);
 1825|      0|        fatal_exit();
 1826|      0|      }
 1827|      0|    }
 1828|      0|    tmp___1 = read_error_count;
 1829|      0|    read_error_count++;
 1830|      0|    if (tmp___1 > 10) {
 1831|      0|      {
 1832|      0|        tmp___0 = gettext("Too many errors, quitting");
 1833|      0|        error(0, 0, (char const *)tmp___0);
 1834|      0|        fatal_exit();
 1835|      0|      }
 1836|      0|    }
 1837|      0|    return;
 1838|      0|  }
 1839|      0|}
 1840|      0|static void short_read(size_t status) {
 1841|      0|  size_t left;
 1842|      0|  char *more;
 1843|      0|  size_t tmp;
 1844|      0|  size_t tmp___0;
 1845|      0|  char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
 1846|      0|  char *tmp___1;
 1847|      0|  char *tmp___2;
 1848|      0|  unsigned long rest;
 1849|      0|  char *tmp___3;
 1850|      0|  unsigned long rsize;
 1851|      0|  char *tmp___4;
 1852|      0|  void *__cil_tmp13;
 1853|      0|  char *__cil_tmp14;
 1854|       |
 1855|      0|  {
 1856|      0|    more = record_start->buffer + status;
 1857|      0|    left = record_size - status;
 1858|      0|    {
 1859|      0|      while (1) {
 1860|      0|      while_continue: /* CIL Label */;
 1861|      0|        if (!(left % 512UL != 0UL)) {
 1862|      0|          if (left) {
 1863|      0|            if (status) {
 1864|      0|              if (!read_full_records_option) {
 1865|      0|                goto while_break;
 1866|      0|              }
 1867|      0|            } else {
 1868|      0|              goto while_break;
 1869|      0|            }
 1870|      0|          } else {
 1871|      0|            goto while_break;
 1872|      0|          }
 1873|      0|        }
 1874|      0|        if (status) {
 1875|      0|          {
 1876|      0|            while (1) {
 1877|      0|            while_continue___0: /* CIL Label */;
 1878|      0|              if (archive >= 1 << 30) {
 1879|      0|                {
 1880|      0|                  tmp = rmt_read__(archive - (1 << 30), more, left);
 1881|      0|                  status = tmp;
 1882|      0|                }
 1883|      0|              } else {
 1884|      0|                {
 1885|      0|                  tmp___0 = safe_read(archive, (void *)more, left);
 1886|      0|                  status = tmp___0;
 1887|      0|                }
 1888|      0|              }
 1889|      0|              if (!(status == 0xffffffffffffffffUL)) {
 1890|      0|                goto while_break___0;
 1891|      0|              }
 1892|      0|              { archive_read_error(); }
 1893|      0|            }
 1894|      0|          while_break___0: /* CIL Label */;
 1895|      0|          }
 1896|      0|        }
 1897|      0|        if (status == 0UL) {
 1898|      0|          {
 1899|      0|            tmp___1 = stringify_uintmax_t_backwards(
 1900|      0|                record_size - left,
 1901|      0|                buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
 1902|      0|                       1UL));
 1903|      0|            tmp___2 = gettext("Read %s bytes from %s");
 1904|      0|            error(0, 0, (char const *)tmp___2, tmp___1, *archive_name_cursor);
 1905|      0|          }
 1906|      0|          goto while_break;
 1907|      0|        }
 1908|      0|        if (!read_full_records_option) {
 1909|      0|          {
 1910|      0|            rest = record_size - left;
 1911|      0|            tmp___3 = ngettext("Unaligned block (%lu byte) in archive",
 1912|      0|                               "Unaligned block (%lu bytes) in archive", rest);
 1913|      0|            error(0, 0, (char const *)tmp___3, rest);
 1914|      0|            fatal_exit();
 1915|      0|          }
 1916|      0|        }
 1917|      0|        left -= status;
 1918|      0|        more += status;
 1919|      0|      }
 1920|      0|    while_break: /* CIL Label */;
 1921|      0|    }
 1922|      0|    if (!read_full_records_option) {
 1923|      0|      if (verbose_option > 1) {
 1924|      0|        if (record_start_block == 0L) {
 1925|      0|          if (status != 0UL) {
 1926|      0|            {
 1927|      0|              rsize = (record_size - left) / 512UL;
 1928|      0|              tmp___4 = ngettext("Record size = %lu block",
 1929|      0|                                 "Record size = %lu blocks", rsize);
 1930|      0|              error(0, 0, (char const *)tmp___4, rsize);
 1931|      0|            }
 1932|      0|          }
 1933|      0|        }
 1934|      0|      }
 1935|      0|    }
 1936|      0|    record_end = record_start + (record_size - left) / 512UL;
 1937|      0|    records_read++;
 1938|      0|    return;
 1939|      0|  }
 1940|      0|}
 1941|      0|void flush_read(void) {
 1942|      0|  size_t status;
 1943|      0|  char *tmp;
 1944|      0|  char *tmp___0;
 1945|      0|  size_t tmp___1;
 1946|      0|  size_t tmp___2;
 1947|      0|  union block *cursor;
 1948|      0|  _Bool tmp___3;
 1949|      0|  _Bool tmp___4;
 1950|      0|  size_t tmp___5;
 1951|      0|  size_t tmp___6;
 1952|      0|  char const *tmp___7;
 1953|      0|  char const *tmp___8;
 1954|      0|  char *tmp___9;
 1955|      0|  _Bool tmp___10;
 1956|      0|  char const *tmp___11;
 1957|      0|  char *tmp___12;
 1958|      0|  char *tmp___13;
 1959|      0|  uintmax_t s1;
 1960|      0|  uintmax_t s2;
 1961|      0|  char const *tmp___14;
 1962|      0|  char *tmp___15;
 1963|      0|  int tmp___16;
 1964|      0|  char totsizebuf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
 1965|      0|  char s1buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
 1966|      0|  char s2buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
 1967|      0|  char *tmp___17;
 1968|      0|  char *tmp___18;
 1969|      0|  char *tmp___19;
 1970|      0|  char const *tmp___20;
 1971|      0|  char *tmp___21;
 1972|      0|  char *tmp___22;
 1973|      0|  off_t tmp___23;
 1974|      0|  int *tmp___24;
 1975|      0|  void *__cil_tmp34;
 1976|      0|  void *__cil_tmp35;
 1977|      0|  void *__cil_tmp36;
 1978|      0|  char *__cil_tmp37;
 1979|      0|  char *__cil_tmp38;
 1980|      0|  char *__cil_tmp39;
 1981|      0|  char *__cil_tmp40;
 1982|      0|  char *__cil_tmp41;
 1983|      0|  char *__cil_tmp42;
 1984|      0|  char *__cil_tmp43;
 1985|       |
 1986|      0|  {
 1987|      0|    if (checkpoint_option) {
 1988|      0|      checkpoint++;
 1989|      0|      if (!(checkpoint % 10)) {
 1990|      0|        {
 1991|      0|          tmp = gettext("Read checkpoint %d");
 1992|      0|          error(0, 0, (char const *)tmp, checkpoint);
 1993|      0|        }
 1994|      0|      }
 1995|      0|    }
 1996|      0|    read_error_count = 0;
 1997|      0|    if (write_archive_to_stdout) {
 1998|      0|      if (record_start_block != 0L) {
 1999|      0|        {
 2000|      0|          archive = 1;
 2001|      0|          status = sys_write_archive_buffer();
 2002|      0|          archive = 0;
 2003|      0|        }
 2004|      0|        if (status != record_size) {
 2005|      0|          {
 2006|      0|            archive_write_error((ssize_t)status);
 2007|      0|          }
 2008|      0|        }
 2009|      0|      }
 2010|      0|    }
 2011|      0|    if (multi_volume_option) {
 2012|      0|      if (save_name) {
 2013|      0|        {
 2014|      0|          tmp___0 = safer_name_suffix((char const *)save_name, (_Bool)0);
 2015|      0|          assign_string(&real_s_name, (char const *)tmp___0);
 2016|      0|          real_s_sizeleft = save_sizeleft;
 2017|      0|          real_s_totsize = save_totsize;
 2018|      0|        }
 2019|      0|      } else {
 2020|      0|        {
 2021|      0|          assign_string(&real_s_name, (char const *)0);
 2022|      0|          real_s_totsize = (off_t)0;
 2023|      0|          real_s_sizeleft = (off_t)0;
 2024|      0|        }
 2025|      0|      }
 2026|      0|    }
 2027|      0|  error_loop:
 2028|      0|    if (archive >= 1 << 30) {
 2029|      0|      {
 2030|      0|        tmp___1 =
 2031|      0|            rmt_read__(archive - (1 << 30), record_start->buffer, record_size);
 2032|      0|        status = tmp___1;
 2033|      0|      }
 2034|      0|    } else {
 2035|      0|      {
 2036|      0|        tmp___2 =
 2037|      0|            safe_read(archive, (void *)(record_start->buffer), record_size);
 2038|      0|        status = tmp___2;
 2039|      0|      }
 2040|      0|    }
 2041|      0|    if (status == record_size) {
 2042|      0|      records_read++;
 2043|      0|      return;
 2044|      0|    }
 2045|      0|    if (status == 0UL) {
 2046|      0|      goto _L___1;
 2047|      0|    } else {
 2048|      0|      if (status == 0xffffffffffffffffUL) {
 2049|      0|        {
 2050|      0|          tmp___24 = __errno_location();
 2051|      0|        }
 2052|      0|        if (*tmp___24 == 28) {
 2053|      0|        _L___1:
 2054|      0|          if (multi_volume_option) {
 2055|      0|          try_volume : {
 2056|      0|            if ((unsigned int)subcommand_option == 1U) {
 2057|      0|              goto case_1;
 2058|      0|            }
 2059|      0|            if ((unsigned int)subcommand_option == 2U) {
 2060|      0|              goto case_1;
 2061|      0|            }
 2062|      0|            if ((unsigned int)subcommand_option == 8U) {
 2063|      0|              goto case_1;
 2064|      0|            }
 2065|      0|            goto switch_default;
 2066|      0|          case_1:  /* CIL Label */
 2067|      0|          case_2:  /* CIL Label */
 2068|      0|          case_8 : /* CIL Label */
 2069|      0|          {
 2070|      0|            tmp___3 = new_volume((enum access_mode)2);
 2071|      0|          }
 2072|      0|            if (!tmp___3) {
 2073|      0|              return;
 2074|      0|            }
 2075|      0|            goto switch_break;
 2076|      0|          switch_default : /* CIL Label */
 2077|      0|          {
 2078|      0|            tmp___4 = new_volume((enum access_mode)0);
 2079|      0|          }
 2080|      0|            if (!tmp___4) {
 2081|      0|              return;
 2082|      0|            }
 2083|      0|            goto switch_break;
 2084|      0|          switch_break: /* CIL Label */;
 2085|      0|          }
 2086|      0|            {
 2087|      0|              while (1) {
 2088|      0|              while_continue: /* CIL Label */;
 2089|      0|                if (archive >= 1 << 30) {
 2090|      0|                  {
 2091|      0|                    tmp___5 = rmt_read__(archive - (1 << 30),
 2092|      0|                                         record_start->buffer, record_size);
 2093|      0|                    status = tmp___5;
 2094|      0|                  }
 2095|      0|                } else {
 2096|      0|                  {
 2097|      0|                    tmp___6 = safe_read(archive, (void *)(record_start->buffer),
 2098|      0|                                        record_size);
 2099|      0|                    status = tmp___6;
 2100|      0|                  }
 2101|      0|                }
 2102|      0|                if (!(status == 0xffffffffffffffffUL)) {
 2103|      0|                  goto while_break;
 2104|      0|                }
 2105|      0|                { archive_read_error(); }
 2106|      0|              }
 2107|      0|            while_break: /* CIL Label */;
 2108|      0|            }
 2109|      0|            if (status != record_size) {
 2110|      0|              {
 2111|      0|                short_read(status);
 2112|      0|              }
 2113|      0|            }
 2114|      0|            cursor = record_start;
 2115|      0|            if ((int)cursor->header.typeflag == 86) {
 2116|      0|              if (volume_label_option) {
 2117|      0|                {
 2118|      0|                  tmp___10 = check_label_pattern(cursor);
 2119|      0|                }
 2120|      0|                if (!tmp___10) {
 2121|      0|                  {
 2122|      0|                    tmp___7 = quote_n(1, volume_label_option);
 2123|      0|                    tmp___8 = quote_n(0, (char const *)(cursor->header.name));
 2124|      0|                    tmp___9 = gettext("Volume %s does not match %s");
 2125|      0|                    error(0, 0, (char const *)tmp___9, tmp___8, tmp___7);
 2126|      0|                    volno--;
 2127|      0|                    global_volno--;
 2128|      0|                  }
 2129|      0|                  goto try_volume;
 2130|      0|                }
 2131|      0|              }
 2132|      0|              if (verbose_option) {
 2133|      0|                {
 2134|      0|                  tmp___11 = quote((char const *)(cursor->header.name));
 2135|      0|                  tmp___12 = gettext("Reading %s\n");
 2136|      0|                  fprintf((FILE * /* __restrict  */) stdlis,
 2137|      0|                          (char const * /* __restrict  */)tmp___12, tmp___11);
 2138|      0|                }
 2139|      0|              }
 2140|      0|              cursor++;
 2141|      0|            } else {
 2142|      0|              if (volume_label_option) {
 2143|      0|                {
 2144|      0|                  tmp___13 = gettext("WARNING: No volume header");
 2145|      0|                  error(0, 0, (char const *)tmp___13);
 2146|      0|                }
 2147|      0|              }
 2148|      0|            }
 2149|      0|            if (real_s_name) {
 2150|      0|              if ((int)cursor->header.typeflag != 77) {
 2151|      0|                goto _L;
 2152|      0|              } else {
 2153|      0|                {
 2154|      0|                  tmp___16 = strcmp((char const *)(cursor->header.name),
 2155|      0|                                    (char const *)real_s_name);
 2156|      0|                }
 2157|      0|                if (tmp___16) {
 2158|      0|                _L : {
 2159|      0|                  tmp___14 = quote((char const *)real_s_name);
 2160|      0|                  tmp___15 = gettext("%s is not continued on this volume");
 2161|      0|                  error(0, 0, (char const *)tmp___15, tmp___14);
 2162|      0|                  volno--;
 2163|      0|                  global_volno--;
 2164|      0|                }
 2165|      0|                  goto try_volume;
 2166|      0|                }
 2167|      0|              }
 2168|      0|              {
 2169|      0|                s1 = uintmax_from_header((char const *)(cursor->header.size),
 2170|      0|                                         sizeof(cursor->header.size));
 2171|      0|                s2 = uintmax_from_header(
 2172|      0|                    (char const *)(cursor->oldgnu_header.offset),
 2173|      0|                    sizeof(cursor->oldgnu_header.offset));
 2174|      0|              }
 2175|      0|              if ((uintmax_t)real_s_totsize != s1 + s2) {
 2176|      0|                goto _L___3;
 2177|      0|              } else {
 2178|      0|                if (s1 + s2 < s2) {
 2179|      0|                _L___3 : /* CIL Label */
 2180|      0|                {
 2181|      0|                  tmp___17 = stringify_uintmax_t_backwards(
 2182|      0|                      s2,
 2183|      0|                      s2buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL +
 2184|      0|                                1UL) +
 2185|      0|                               1UL));
 2186|      0|                  tmp___18 = stringify_uintmax_t_backwards(
 2187|      0|                      s1,
 2188|      0|                      s1buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL +
 2189|      0|                                1UL) +
 2190|      0|                               1UL));
 2191|      0|                  tmp___19 = stringify_uintmax_t_backwards(
 2192|      0|                      (uintmax_t)save_totsize,
 2193|      0|                      totsizebuf +
 2194|      0|                          ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL +
 2195|      0|                            1UL) +
 2196|      0|                           1UL));
 2197|      0|                  tmp___20 = quote((char const *)(cursor->header.name));
 2198|      0|                  tmp___21 = gettext("%s is the wrong size (%s != %s + %s)");
 2199|      0|                  error(0, 0, (char const *)tmp___21, tmp___20, tmp___19,
 2200|      0|                        tmp___18, tmp___17);
 2201|      0|                  volno--;
 2202|      0|                  global_volno--;
 2203|      0|                }
 2204|      0|                  goto try_volume;
 2205|      0|                }
 2206|      0|              }
 2207|      0|              {
 2208|      0|                tmp___23 = off_from_header(
 2209|      0|                    (char const *)(cursor->oldgnu_header.offset),
 2210|      0|                    sizeof(cursor->oldgnu_header.offset));
 2211|      0|              }
 2212|      0|              if (real_s_totsize - real_s_sizeleft != tmp___23) {
 2213|      0|                {
 2214|      0|                  tmp___22 = gettext("This volume is out of sequence");
 2215|      0|                  error(0, 0, (char const *)tmp___22);
 2216|      0|                  volno--;
 2217|      0|                  global_volno--;
 2218|      0|                }
 2219|      0|                goto try_volume;
 2220|      0|              }
 2221|      0|              cursor++;
 2222|      0|            }
 2223|      0|            current_block = cursor;
 2224|      0|            records_read++;
 2225|      0|            return;
 2226|      0|          } else {
 2227|      0|            goto _L___2;
 2228|      0|          }
 2229|      0|        } else {
 2230|      0|          goto _L___2;
 2231|      0|        }
 2232|      0|      } else {
 2233|      0|      _L___2:
 2234|      0|        if (status == 0xffffffffffffffffUL) {
 2235|      0|          {
 2236|      0|            archive_read_error();
 2237|      0|          }
 2238|      0|          goto error_loop;
 2239|      0|        }
 2240|      0|      }
 2241|      0|    }
 2242|      0|    { short_read(status); }
 2243|      0|    return;
 2244|      0|  }
 2245|      0|}
 2246|      0|void flush_archive(void) {
 2247|       |
 2248|      0|  {
 2249|      0|    record_start_block += record_end - record_start;
 2250|      0|    current_block = record_start;
 2251|      0|    record_end = record_start + blocking_factor;
 2252|      0|    if ((unsigned int)access_mode == 0U) {
 2253|      0|      if (time_to_start_writing) {
 2254|      0|        {
 2255|      0|          access_mode = (enum access_mode)1;
 2256|      0|          time_to_start_writing = (_Bool)0;
 2257|      0|          backspace_output();
 2258|      0|        }
 2259|      0|      }
 2260|      0|    }
 2261|      0|    {
 2262|      0|      if ((unsigned int)access_mode == 0U) {
 2263|      0|        goto case_0;
 2264|      0|      }
 2265|      0|      if ((unsigned int)access_mode == 1U) {
 2266|      0|        goto case_1;
 2267|      0|      }
 2268|      0|      if ((unsigned int)access_mode == 2U) {
 2269|      0|        goto case_2;
 2270|      0|      }
 2271|      0|      goto switch_break;
 2272|      0|    case_0 : /* CIL Label */
 2273|      0|    {
 2274|      0|      flush_read();
 2275|      0|    }
 2276|      0|      goto switch_break;
 2277|      0|    case_1 : /* CIL Label */
 2278|      0|    {
 2279|      0|      flush_write();
 2280|      0|    }
 2281|      0|      goto switch_break;
 2282|      0|    case_2 : /* CIL Label */
 2283|      0|    {
 2284|      0|      abort();
 2285|      0|    }
 2286|      0|    switch_break: /* CIL Label */;
 2287|      0|    }
 2288|      0|    return;
 2289|      0|  }
 2290|      0|}
 2291|      0|static void backspace_output(void) {
 2292|      0|  struct mtop operation;
 2293|      0|  int tmp;
 2294|      0|  int tmp___0;
 2295|      0|  int tmp___1;
 2296|      0|  int *tmp___2;
 2297|      0|  int tmp___3;
 2298|      0|  int tmp___4;
 2299|      0|  int tmp___5;
 2300|      0|  off_t position;
 2301|      0|  off_t tmp___6;
 2302|      0|  __off_t tmp___7;
 2303|      0|  off_t tmp___8;
 2304|      0|  char *tmp___9;
 2305|      0|  off_t tmp___10;
 2306|      0|  __off_t tmp___11;
 2307|      0|  off_t tmp___12;
 2308|      0|  char *__cil_tmp17;
 2309|       |
 2310|      0|  {
 2311|      0|    operation.mt_op = (short)4;
 2312|      0|    operation.mt_count = 1;
 2313|      0|    if (archive >= 1 << 30) {
 2314|      0|      {
 2315|      0|        tmp = rmt_ioctl__(
 2316|      0|            archive - (1 << 30),
 2317|      0|            (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) |
 2318|      0|                                  1U) |
 2319|      0|                  (sizeof(struct mtop) << 16)),
 2320|      0|            (char *)(&operation));
 2321|      0|        tmp___1 = tmp;
 2322|      0|      }
 2323|      0|    } else {
 2324|      0|      {
 2325|      0|        tmp___0 = ioctl(
 2326|      0|            archive,
 2327|      0|            (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) |
 2328|      0|                (sizeof(struct mtop) << 16),
 2329|      0|            (char *)(&operation));
 2330|      0|        tmp___1 = tmp___0;
 2331|      0|      }
 2332|      0|    }
 2333|      0|    if (tmp___1 >= 0) {
 2334|      0|      return;
 2335|      0|    }
 2336|      0|    { tmp___2 = __errno_location(); }
 2337|      0|    if (*tmp___2 == 5) {
 2338|      0|      if (archive >= 1 << 30) {
 2339|      0|        {
 2340|      0|          tmp___3 = rmt_ioctl__(
 2341|      0|              archive - (1 << 30),
 2342|      0|              (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) |
 2343|      0|                                    1U) |
 2344|      0|                    (sizeof(struct mtop) << 16)),
 2345|      0|              (char *)(&operation));
 2346|      0|          tmp___5 = tmp___3;
 2347|      0|        }
 2348|      0|      } else {
 2349|      0|        {
 2350|      0|          tmp___4 = ioctl(
 2351|      0|              archive,
 2352|      0|              (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) |
 2353|      0|                  (sizeof(struct mtop) << 16),
 2354|      0|              (char *)(&operation));
 2355|      0|          tmp___5 = tmp___4;
 2356|      0|        }
 2357|      0|      }
 2358|      0|      if (tmp___5 >= 0) {
 2359|      0|        return;
 2360|      0|      }
 2361|      0|    }
 2362|      0|    if (archive >= 1 << 30) {
 2363|      0|      {
 2364|      0|        tmp___6 = rmt_lseek__(archive - (1 << 30), (off_t)0, 1);
 2365|      0|        tmp___8 = tmp___6;
 2366|      0|      }
 2367|      0|    } else {
 2368|      0|      {
 2369|      0|        tmp___7 = lseek(archive, (off_t)0, 1);
 2370|      0|        tmp___8 = tmp___7;
 2371|      0|      }
 2372|      0|    }
 2373|      0|    position = tmp___8;
 2374|      0|    position = (off_t)((size_t)position - record_size);
 2375|      0|    if (position < 0L) {
 2376|      0|      position = (off_t)0;
 2377|      0|    }
 2378|      0|    if (archive >= 1 << 30) {
 2379|      0|      {
 2380|      0|        tmp___10 = rmt_lseek__(archive - (1 << 30), position, 0);
 2381|      0|        tmp___12 = tmp___10;
 2382|      0|      }
 2383|      0|    } else {
 2384|      0|      {
 2385|      0|        tmp___11 = lseek(archive, position, 0);
 2386|      0|        tmp___12 = tmp___11;
 2387|      0|      }
 2388|      0|    }
 2389|      0|    if (tmp___12 != position) {
 2390|      0|      {
 2391|      0|        tmp___9 = gettext(
 2392|      0|            "Cannot backspace archive file; it may be unreadable without -i");
 2393|      0|        error(0, 0, (char const *)tmp___9);
 2394|      0|      }
 2395|      0|      if ((unsigned long)(record_start->buffer) !=
 2396|      0|          (unsigned long)output_start) {
 2397|      0|        {
 2398|      0|          memset((void *)(record_start->buffer), 0,
 2399|      0|                 (size_t)(output_start - record_start->buffer));
 2400|      0|        }
 2401|      0|      }
 2402|      0|    }
 2403|      0|    return;
 2404|      0|  }
 2405|      0|}
 2406|      0|void close_archive(void) {
 2407|      0|  int tmp;
 2408|      0|  int tmp___0;
 2409|      0|  int tmp___1;
 2410|      0|  union block *tmp___2;
 2411|       |
 2412|      0|  {
 2413|      0|    if (time_to_start_writing) {
 2414|      0|      {
 2415|      0|        flush_archive();
 2416|      0|      }
 2417|      0|    } else {
 2418|      0|      if ((unsigned int)access_mode == 1U) {
 2419|      0|        {
 2420|      0|          flush_archive();
 2421|      0|        }
 2422|      0|      }
 2423|      0|    }
 2424|      0|    { sys_drain_input_pipe(); }
 2425|      0|    if (verify_option) {
 2426|      0|      {
 2427|      0|        verify_volume();
 2428|      0|      }
 2429|      0|    }
 2430|      0|    if (archive >= 1 << 30) {
 2431|      0|      {
 2432|      0|        tmp = rmt_close__(archive - (1 << 30));
 2433|      0|        tmp___1 = tmp;
 2434|      0|      }
 2435|      0|    } else {
 2436|      0|      {
 2437|      0|        tmp___0 = close(archive);
 2438|      0|        tmp___1 = tmp___0;
 2439|      0|      }
 2440|      0|    }
 2441|      0|    if (tmp___1 != 0) {
 2442|      0|      {
 2443|      0|        close_warn(*archive_name_cursor);
 2444|      0|      }
 2445|      0|    }
 2446|      0|    {
 2447|      0|      sys_wait_for_child(child_pid);
 2448|      0|      tar_stat_destroy(&current_stat_info);
 2449|      0|    }
 2450|      0|    if (save_name) {
 2451|      0|      {
 2452|      0|        free((void *)save_name);
 2453|      0|      }
 2454|      0|    }
 2455|      0|    if (real_s_name) {
 2456|      0|      {
 2457|      0|        free((void *)real_s_name);
 2458|      0|      }
 2459|      0|    }
 2460|      0|    if (multi_volume_option) {
 2461|      0|      tmp___2 = record_start - 2;
 2462|      0|    } else {
 2463|      0|      tmp___2 = record_start;
 2464|      0|    }
 2465|      0|    { free((void *)tmp___2); }
 2466|      0|    return;
 2467|      0|  }
 2468|      0|}
 2469|      0|void init_volume_number(void) {
 2470|      0|  FILE *file;
 2471|      0|  FILE *tmp;
 2472|      0|  char *tmp___0;
 2473|      0|  char *tmp___1;
 2474|      0|  int tmp___2;
 2475|      0|  int tmp___3;
 2476|      0|  int tmp___4;
 2477|      0|  int *tmp___5;
 2478|      0|  char *__cil_tmp9;
 2479|      0|  char *__cil_tmp10;
 2480|       |
 2481|      0|  {
 2482|      0|    {
 2483|      0|      tmp = fopen((char const * /* __restrict  */)volno_file_option,
 2484|      0|                  (char const * /* __restrict  */) "r");
 2485|      0|      file = tmp;
 2486|      0|    }
 2487|      0|    if (file) {
 2488|      0|      {
 2489|      0|        tmp___2 = fscanf((FILE * /* __restrict  */) file,
 2490|      0|                         (char const * /* __restrict  */) "%d", &global_volno);
 2491|      0|      }
 2492|      0|      if (tmp___2 != 1) {
 2493|      0|        {
 2494|      0|          tmp___0 = quotearg_colon(volno_file_option);
 2495|      0|          tmp___1 = gettext("%s: contains invalid volume number");
 2496|      0|          error(0, 0, (char const *)tmp___1, tmp___0);
 2497|      0|          fatal_exit();
 2498|      0|        }
 2499|      0|      } else {
 2500|      0|        if (global_volno < 0) {
 2501|      0|          {
 2502|      0|            tmp___0 = quotearg_colon(volno_file_option);
 2503|      0|            tmp___1 = gettext("%s: contains invalid volume number");
 2504|      0|            error(0, 0, (char const *)tmp___1, tmp___0);
 2505|      0|            fatal_exit();
 2506|      0|          }
 2507|      0|        }
 2508|      0|      }
 2509|      0|      { tmp___3 = ferror_unlocked(file); }
 2510|      0|      if (tmp___3) {
 2511|      0|        {
 2512|      0|          read_error(volno_file_option);
 2513|      0|        }
 2514|      0|      }
 2515|      0|      { tmp___4 = fclose(file); }
 2516|      0|      if (tmp___4 != 0) {
 2517|      0|        {
 2518|      0|          close_error(volno_file_option);
 2519|      0|        }
 2520|      0|      }
 2521|      0|    } else {
 2522|      0|      { tmp___5 = __errno_location(); }
 2523|      0|      if (*tmp___5 != 2) {
 2524|      0|        {
 2525|      0|          open_error(volno_file_option);
 2526|      0|        }
 2527|      0|      }
 2528|      0|    }
 2529|      0|    return;
 2530|      0|  }
 2531|      0|}
 2532|      0|void closeout_volume_number(void) {
 2533|      0|  FILE *file;
 2534|      0|  FILE *tmp;
 2535|      0|  int tmp___0;
 2536|      0|  int tmp___1;
 2537|       |
 2538|      0|  {
 2539|      0|    {
 2540|      0|      tmp = fopen((char const * /* __restrict  */)volno_file_option,
 2541|      0|                  (char const * /* __restrict  */) "w");
 2542|      0|      file = tmp;
 2543|      0|    }
 2544|      0|    if (file) {
 2545|      0|      {
 2546|      0|        fprintf((FILE * /* __restrict  */) file,
 2547|      0|                (char const * /* __restrict  */) "%d\n", global_volno);
 2548|      0|        tmp___0 = ferror_unlocked(file);
 2549|      0|      }
 2550|      0|      if (tmp___0) {
 2551|      0|        {
 2552|      0|          write_error(volno_file_option);
 2553|      0|        }
 2554|      0|      }
 2555|      0|      { tmp___1 = fclose(file); }
 2556|      0|      if (tmp___1 != 0) {
 2557|      0|        {
 2558|      0|          close_error(volno_file_option);
 2559|      0|        }
 2560|      0|      }
 2561|      0|    } else {
 2562|      0|      { open_error(volno_file_option); }
 2563|      0|    }
 2564|      0|    return;
 2565|      0|  }
 2566|      0|}
 2567|       |static FILE *read_file;
 2568|       |static int looped;
 2569|      0|static _Bool new_volume(enum access_mode mode) {
 2570|      0|  FILE *tmp;
 2571|      0|  int tmp___0;
 2572|      0|  int tmp___1;
 2573|      0|  int tmp___2;
 2574|      0|  char *tmp___3;
 2575|      0|  char *tmp___4;
 2576|      0|  int tmp___5;
 2577|      0|  char input_buffer[80];
 2578|      0|  char const *tmp___6;
 2579|      0|  char *tmp___7;
 2580|      0|  char *tmp___8;
 2581|      0|  char *tmp___9;
 2582|      0|  char *tmp___10;
 2583|      0|  char *tmp___11;
 2584|      0|  char *tmp___12;
 2585|      0|  char *tmp___13;
 2586|      0|  char *name;
 2587|      0|  char *cursor;
 2588|      0|  char *tmp___14;
 2589|      0|  int tmp___16;
 2590|      0|  int tmp___17;
 2591|      0|  void *tmp___18;
 2592|      0|  int tmp___20;
 2593|      0|  int tmp___21;
 2594|      0|  void *tmp___22;
 2595|      0|  int tmp___24;
 2596|      0|  int tmp___25;
 2597|      0|  void *tmp___26;
 2598|      0|  int tmp___28;
 2599|      0|  int tmp___29;
 2600|      0|  void *tmp___30;
 2601|      0|  int tmp___31;
 2602|      0|  void *__cil_tmp34;
 2603|      0|  char *__cil_tmp35;
 2604|      0|  char *__cil_tmp36;
 2605|      0|  char *__cil_tmp37;
 2606|      0|  char *__cil_tmp38;
 2607|      0|  char *__cil_tmp39;
 2608|      0|  char *__cil_tmp40;
 2609|      0|  char *__cil_tmp41;
 2610|      0|  char *__cil_tmp42;
 2611|       |
 2612|      0|  {
 2613|      0|    if (!read_file) {
 2614|      0|      if (!info_script_option) {
 2615|      0|        if (archive == 0) {
 2616|      0|          {
 2617|      0|            tmp = fopen((char const * /* __restrict  */) "/dev/tty",
 2618|      0|                        (char const * /* __restrict  */) "r");
 2619|      0|            read_file = tmp;
 2620|      0|          }
 2621|      0|        } else {
 2622|      0|          read_file = stdin;
 2623|      0|        }
 2624|      0|      }
 2625|      0|    }
 2626|      0|    if (now_verifying) {
 2627|      0|      return ((_Bool)0);
 2628|      0|    }
 2629|      0|    if (verify_option) {
 2630|      0|      {
 2631|      0|        verify_volume();
 2632|      0|      }
 2633|      0|    }
 2634|      0|    if (archive >= 1 << 30) {
 2635|      0|      {
 2636|      0|        tmp___0 = rmt_close__(archive - (1 << 30));
 2637|      0|        tmp___2 = tmp___0;
 2638|      0|      }
 2639|      0|    } else {
 2640|      0|      {
 2641|      0|        tmp___1 = close(archive);
 2642|      0|        tmp___2 = tmp___1;
 2643|      0|      }
 2644|      0|    }
 2645|      0|    if (tmp___2 != 0) {
 2646|      0|      {
 2647|      0|        close_warn(*archive_name_cursor);
 2648|      0|      }
 2649|      0|    }
 2650|      0|    global_volno++;
 2651|      0|    if (global_volno < 0) {
 2652|      0|      {
 2653|      0|        tmp___3 = gettext("Volume number overflow");
 2654|      0|        error(0, 0, (char const *)tmp___3);
 2655|      0|        fatal_exit();
 2656|      0|      }
 2657|      0|    }
 2658|      0|    volno++;
 2659|      0|    archive_name_cursor++;
 2660|      0|    if ((unsigned long)archive_name_cursor ==
 2661|      0|        (unsigned long)(archive_name_array + archive_names)) {
 2662|      0|      archive_name_cursor = archive_name_array;
 2663|      0|      looped = 1;
 2664|      0|    }
 2665|      0|  tryagain:
 2666|      0|    if (looped) {
 2667|      0|      if (info_script_option) {
 2668|      0|        if (volno_file_option) {
 2669|      0|          {
 2670|      0|            closeout_volume_number();
 2671|      0|          }
 2672|      0|        }
 2673|      0|        { tmp___5 = system(info_script_option); }
 2674|      0|        if (tmp___5 != 0) {
 2675|      0|          {
 2676|      0|            tmp___4 = gettext("`%s\' command failed");
 2677|      0|            error(0, 0, (char const *)tmp___4, info_script_option);
 2678|      0|            fatal_exit();
 2679|      0|          }
 2680|      0|        }
 2681|      0|      } else {
 2682|      0|        {
 2683|      0|          while (1) {
 2684|      0|          while_continue: /* CIL Label */;
 2685|      0|            {
 2686|      0|              fputc_unlocked('\a', stderr);
 2687|      0|              tmp___6 = quote(*archive_name_cursor);
 2688|      0|              tmp___7 = gettext("Prepare volume #%d for %s and hit return: ");
 2689|      0|              fprintf((FILE * /* __restrict  */) stderr,
 2690|      0|                      (char const * /* __restrict  */)tmp___7, global_volno,
 2691|      0|                      tmp___6);
 2692|      0|              fflush_unlocked(stderr);
 2693|      0|              tmp___10 =
 2694|      0|                  fgets_unlocked((char * /* __restrict  */)(input_buffer),
 2695|      0|                                 (int)sizeof(input_buffer),
 2696|      0|                                 (FILE * /* __restrict  */) read_file);
 2697|      0|            }
 2698|      0|            if ((unsigned long)tmp___10 == (unsigned long)((char *)0)) {
 2699|      0|              {
 2700|      0|                tmp___8 = gettext("EOF where user reply was expected");
 2701|      0|                error(0, 0, (char const *)tmp___8);
 2702|      0|              }
 2703|      0|              if ((unsigned int)subcommand_option != 6U) {
 2704|      0|                if ((unsigned int)subcommand_option != 7U) {
 2705|      0|                  if ((unsigned int)subcommand_option != 5U) {
 2706|      0|                    {
 2707|      0|                      tmp___9 = gettext("WARNING: Archive is incomplete");
 2708|      0|                      error(0, 0, (char const *)tmp___9);
 2709|      0|                    }
 2710|      0|                  }
 2711|      0|                }
 2712|      0|              }
 2713|      0|              { fatal_exit(); }
 2714|      0|            }
 2715|      0|            if ((int)input_buffer[0] == 10) {
 2716|      0|              goto while_break;
 2717|      0|            } else {
 2718|      0|              if ((int)input_buffer[0] == 121) {
 2719|      0|                goto while_break;
 2720|      0|              } else {
 2721|      0|                if ((int)input_buffer[0] == 89) {
 2722|      0|                  goto while_break;
 2723|      0|                }
 2724|      0|              }
 2725|      0|            }
 2726|      0|            {
 2727|      0|              if ((int)input_buffer[0] == 63) {
 2728|      0|                goto case_63;
 2729|      0|              }
 2730|      0|              if ((int)input_buffer[0] == 113) {
 2731|      0|                goto case_113;
 2732|      0|              }
 2733|      0|              if ((int)input_buffer[0] == 110) {
 2734|      0|                goto case_110;
 2735|      0|              }
 2736|      0|              if ((int)input_buffer[0] == 33) {
 2737|      0|                goto case_33;
 2738|      0|              }
 2739|      0|              goto switch_break;
 2740|      0|            case_63 : /* CIL Label */
 2741|      0|            {
 2742|      0|              tmp___11 = gettext(
 2743|      0|                  " n [name]   Give a new file name for the next (and "
 2744|      0|                  "subsequent) volume(s)\n q          Abort tar\n !          "
 2745|      0|                  "Spawn a subshell\n ?          Print this list\n");
 2746|      0|              fprintf((FILE * /* __restrict  */) stderr,
 2747|      0|                      (char const * /* __restrict  */)tmp___11);
 2748|      0|            }
 2749|      0|              goto switch_break;
 2750|      0|            case_113 : /* CIL Label */
 2751|      0|            {
 2752|      0|              tmp___12 = gettext("No new volume; exiting.\n");
 2753|      0|              error(0, 0, (char const *)tmp___12);
 2754|      0|            }
 2755|      0|              if ((unsigned int)subcommand_option != 6U) {
 2756|      0|                if ((unsigned int)subcommand_option != 7U) {
 2757|      0|                  if ((unsigned int)subcommand_option != 5U) {
 2758|      0|                    {
 2759|      0|                      tmp___13 = gettext("WARNING: Archive is incomplete");
 2760|      0|                      error(0, 0, (char const *)tmp___13);
 2761|      0|                    }
 2762|      0|                  }
 2763|      0|                }
 2764|      0|              }
 2765|      0|              { fatal_exit(); }
 2766|      0|            case_110: /* CIL Label */
 2767|      0|              name = &input_buffer[1];
 2768|      0|              name = input_buffer + 1;
 2769|      0|              {
 2770|      0|                while (1) {
 2771|      0|                while_continue___0: /* CIL Label */;
 2772|      0|                  if (!((int)*name == 32)) {
 2773|      0|                    if (!((int)*name == 9)) {
 2774|      0|                      goto while_break___0;
 2775|      0|                    }
 2776|      0|                  }
 2777|      0|                  name++;
 2778|      0|                }
 2779|      0|              while_break___0: /* CIL Label */;
 2780|      0|              }
 2781|      0|              cursor = name;
 2782|      0|              {
 2783|      0|                while (1) {
 2784|      0|                while_continue___1: /* CIL Label */;
 2785|      0|                  if (*cursor) {
 2786|      0|                    if (!((int)*cursor != 10)) {
 2787|      0|                      goto while_break___1;
 2788|      0|                    }
 2789|      0|                  } else {
 2790|      0|                    goto while_break___1;
 2791|      0|                  }
 2792|      0|                  cursor++;
 2793|      0|                }
 2794|      0|              while_break___1: /* CIL Label */;
 2795|      0|              }
 2796|      0|              {
 2797|      0|                *cursor = (char)'\000';
 2798|      0|                tmp___14 = xstrdup((char const *)name);
 2799|      0|                *archive_name_cursor = (char const *)tmp___14;
 2800|      0|              }
 2801|      0|              goto switch_break;
 2802|      0|            case_33 : /* CIL Label */
 2803|      0|            {
 2804|      0|              sys_spawn_shell();
 2805|      0|            }
 2806|      0|              goto switch_break;
 2807|      0|            switch_break: /* CIL Label */;
 2808|      0|            }
 2809|      0|          }
 2810|      0|        while_break: /* CIL Label */;
 2811|      0|        }
 2812|      0|      }
 2813|      0|    }
 2814|      0|    { tmp___31 = strcmp(*(archive_name_cursor + 0), "-"); }
 2815|      0|    if (tmp___31 == 0) {
 2816|      0|      read_full_records_option = (_Bool)1;
 2817|      0|      archive = 0;
 2818|      0|    } else {
 2819|      0|      if (verify_option) {
 2820|      0|        if (!force_local_option) {
 2821|      0|          {
 2822|      0|            rmt_path__ = strchr(*archive_name_cursor, ':');
 2823|      0|          }
 2824|      0|          if (rmt_path__) {
 2825|      0|            if ((unsigned long)rmt_path__ >
 2826|      0|                (unsigned long)*archive_name_cursor) {
 2827|      0|              {
 2828|      0|                tmp___18 =
 2829|      0|                    memchr((void const *)*archive_name_cursor, '/',
 2830|      0|                           (size_t)(rmt_path__ - (char *)*archive_name_cursor));
 2831|      0|              }
 2832|      0|              if (tmp___18) {
 2833|      0|                {
 2834|      0|                  tmp___17 = open(*archive_name_cursor, 66,
 2835|      0|                                  ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2836|      0|                                      ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 2837|      0|                  archive = tmp___17;
 2838|      0|                }
 2839|      0|              } else {
 2840|      0|                {
 2841|      0|                  tmp___16 = rmt_open__(*archive_name_cursor, 66, 1 << 30,
 2842|      0|                                        rsh_command_option);
 2843|      0|                  archive = tmp___16;
 2844|      0|                }
 2845|      0|              }
 2846|      0|            } else {
 2847|      0|              {
 2848|      0|                tmp___17 = open(*archive_name_cursor, 66,
 2849|      0|                                ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2850|      0|                                    ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 2851|      0|                archive = tmp___17;
 2852|      0|              }
 2853|      0|            }
 2854|      0|          } else {
 2855|      0|            {
 2856|      0|              tmp___17 = open(*archive_name_cursor, 66,
 2857|      0|                              ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2858|      0|                                  ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 2859|      0|              archive = tmp___17;
 2860|      0|            }
 2861|      0|          }
 2862|      0|        } else {
 2863|      0|          {
 2864|      0|            tmp___17 = open(*archive_name_cursor, 66,
 2865|      0|                            ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2866|      0|                                ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 2867|      0|            archive = tmp___17;
 2868|      0|          }
 2869|      0|        }
 2870|      0|      } else {
 2871|      0|        {
 2872|      0|          if ((unsigned int)mode == 0U) {
 2873|      0|            goto case_0;
 2874|      0|          }
 2875|      0|          if ((unsigned int)mode == 1U) {
 2876|      0|            goto case_1;
 2877|      0|          }
 2878|      0|          if ((unsigned int)mode == 2U) {
 2879|      0|            goto case_2;
 2880|      0|          }
 2881|      0|          goto switch_break___0;
 2882|      0|        case_0: /* CIL Label */
 2883|      0|          if (!force_local_option) {
 2884|      0|            {
 2885|      0|              rmt_path__ = strchr(*archive_name_cursor, ':');
 2886|      0|            }
 2887|      0|            if (rmt_path__) {
 2888|      0|              if ((unsigned long)rmt_path__ >
 2889|      0|                  (unsigned long)*archive_name_cursor) {
 2890|      0|                {
 2891|      0|                  tmp___22 = memchr(
 2892|      0|                      (void const *)*archive_name_cursor, '/',
 2893|      0|                      (size_t)(rmt_path__ - (char *)*archive_name_cursor));
 2894|      0|                }
 2895|      0|                if (tmp___22) {
 2896|      0|                  {
 2897|      0|                    tmp___21 =
 2898|      0|                        open(*archive_name_cursor, 0,
 2899|      0|                             ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2900|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 2901|      0|                    archive = tmp___21;
 2902|      0|                  }
 2903|      0|                } else {
 2904|      0|                  {
 2905|      0|                    tmp___20 = rmt_open__(*archive_name_cursor, 0, 1 << 30,
 2906|      0|                                          rsh_command_option);
 2907|      0|                    archive = tmp___20;
 2908|      0|                  }
 2909|      0|                }
 2910|      0|              } else {
 2911|      0|                {
 2912|      0|                  tmp___21 = open(*archive_name_cursor, 0,
 2913|      0|                                  ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2914|      0|                                      ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 2915|      0|                  archive = tmp___21;
 2916|      0|                }
 2917|      0|              }
 2918|      0|            } else {
 2919|      0|              {
 2920|      0|                tmp___21 = open(*archive_name_cursor, 0,
 2921|      0|                                ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2922|      0|                                    ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 2923|      0|                archive = tmp___21;
 2924|      0|              }
 2925|      0|            }
 2926|      0|          } else {
 2927|      0|            {
 2928|      0|              tmp___21 = open(*archive_name_cursor, 0,
 2929|      0|                              ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2930|      0|                                  ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 2931|      0|              archive = tmp___21;
 2932|      0|            }
 2933|      0|          }
 2934|      0|          goto switch_break___0;
 2935|      0|        case_1: /* CIL Label */
 2936|      0|          if (backup_option) {
 2937|      0|            {
 2938|      0|              maybe_backup_file(*archive_name_cursor, 1);
 2939|      0|            }
 2940|      0|          }
 2941|      0|          if (!force_local_option) {
 2942|      0|            {
 2943|      0|              rmt_path__ = strchr(*archive_name_cursor, ':');
 2944|      0|            }
 2945|      0|            if (rmt_path__) {
 2946|      0|              if ((unsigned long)rmt_path__ >
 2947|      0|                  (unsigned long)*archive_name_cursor) {
 2948|      0|                {
 2949|      0|                  tmp___26 = memchr(
 2950|      0|                      (void const *)*archive_name_cursor, '/',
 2951|      0|                      (size_t)(rmt_path__ - (char *)*archive_name_cursor));
 2952|      0|                }
 2953|      0|                if (tmp___26) {
 2954|      0|                  {
 2955|      0|                    tmp___25 = creat(
 2956|      0|                        *archive_name_cursor,
 2957|      0|                        (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2958|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
 2959|      0|                    archive = tmp___25;
 2960|      0|                  }
 2961|      0|                } else {
 2962|      0|                  {
 2963|      0|                    tmp___24 = rmt_open__(*archive_name_cursor, 65, 1 << 30,
 2964|      0|                                          rsh_command_option);
 2965|      0|                    archive = tmp___24;
 2966|      0|                  }
 2967|      0|                }
 2968|      0|              } else {
 2969|      0|                {
 2970|      0|                  tmp___25 =
 2971|      0|                      creat(*archive_name_cursor,
 2972|      0|                            (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2973|      0|                                     ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
 2974|      0|                  archive = tmp___25;
 2975|      0|                }
 2976|      0|              }
 2977|      0|            } else {
 2978|      0|              {
 2979|      0|                tmp___25 =
 2980|      0|                    creat(*archive_name_cursor,
 2981|      0|                          (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2982|      0|                                   ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
 2983|      0|                archive = tmp___25;
 2984|      0|              }
 2985|      0|            }
 2986|      0|          } else {
 2987|      0|            {
 2988|      0|              tmp___25 =
 2989|      0|                  creat(*archive_name_cursor,
 2990|      0|                        (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 2991|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
 2992|      0|              archive = tmp___25;
 2993|      0|            }
 2994|      0|          }
 2995|      0|          goto switch_break___0;
 2996|      0|        case_2: /* CIL Label */
 2997|      0|          if (!force_local_option) {
 2998|      0|            {
 2999|      0|              rmt_path__ = strchr(*archive_name_cursor, ':');
 3000|      0|            }
 3001|      0|            if (rmt_path__) {
 3002|      0|              if ((unsigned long)rmt_path__ >
 3003|      0|                  (unsigned long)*archive_name_cursor) {
 3004|      0|                {
 3005|      0|                  tmp___30 = memchr(
 3006|      0|                      (void const *)*archive_name_cursor, '/',
 3007|      0|                      (size_t)(rmt_path__ - (char *)*archive_name_cursor));
 3008|      0|                }
 3009|      0|                if (tmp___30) {
 3010|      0|                  {
 3011|      0|                    tmp___29 =
 3012|      0|                        open(*archive_name_cursor, 66,
 3013|      0|                             ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 3014|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 3015|      0|                    archive = tmp___29;
 3016|      0|                  }
 3017|      0|                } else {
 3018|      0|                  {
 3019|      0|                    tmp___28 = rmt_open__(*archive_name_cursor, 66, 1 << 30,
 3020|      0|                                          rsh_command_option);
 3021|      0|                    archive = tmp___28;
 3022|      0|                  }
 3023|      0|                }
 3024|      0|              } else {
 3025|      0|                {
 3026|      0|                  tmp___29 = open(*archive_name_cursor, 66,
 3027|      0|                                  ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 3028|      0|                                      ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 3029|      0|                  archive = tmp___29;
 3030|      0|                }
 3031|      0|              }
 3032|      0|            } else {
 3033|      0|              {
 3034|      0|                tmp___29 = open(*archive_name_cursor, 66,
 3035|      0|                                ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 3036|      0|                                    ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 3037|      0|                archive = tmp___29;
 3038|      0|              }
 3039|      0|            }
 3040|      0|          } else {
 3041|      0|            {
 3042|      0|              tmp___29 = open(*archive_name_cursor, 66,
 3043|      0|                              ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 3044|      0|                                  ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
 3045|      0|              archive = tmp___29;
 3046|      0|            }
 3047|      0|          }
 3048|      0|          goto switch_break___0;
 3049|      0|        switch_break___0: /* CIL Label */;
 3050|      0|        }
 3051|      0|      }
 3052|      0|    }
 3053|      0|    if (archive < 0) {
 3054|      0|      {
 3055|      0|        open_warn(*archive_name_cursor);
 3056|      0|      }
 3057|      0|      if (!verify_option) {
 3058|      0|        if ((unsigned int)mode == 1U) {
 3059|      0|          if (backup_option) {
 3060|      0|            {
 3061|      0|              undo_last_backup();
 3062|      0|            }
 3063|      0|          }
 3064|      0|        }
 3065|      0|      }
 3066|      0|      goto tryagain;
 3067|      0|    }
 3068|      0|    return ((_Bool)1);
 3069|      0|  }
 3070|      0|}
 3071|       |/* #pragma merger("0","001.compare.o.i","") */
 3072|       |extern __attribute__((__nothrow__)) int(
 3073|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 3074|       |    memcmp)(void const *__s1, void const *__s2, size_t __n)
 3075|       |    __attribute__((__pure__));
 3076|       |extern __attribute__((__nothrow__)) int(
 3077|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 3078|       |    strncmp)(char const *__s1, char const *__s2, size_t __n)
 3079|       |    __attribute__((__pure__));
 3080|       |extern __attribute__((__nothrow__))
 3081|       |ssize_t(__attribute__((__nonnull__(1, 2), __leaf__))
 3082|       |        readlink)(char const *__restrict __path, char *__restrict __buf,
 3083|       |                  size_t __len);
 3084|       |extern int fsync(int __fd);
 3085|       |extern int vfprintf(FILE *__restrict __s, char const *__restrict __format,
 3086|       |                    __gnuc_va_list __arg);
 3087|       |extern
 3088|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 3089|       |                                     utime)(char const *__file,
 3090|       |                                            struct utimbuf const *__file_times);
 3091|       |__attribute__((__noreturn__)) void xalloc_die(void);
 3092|       |int exit_status;
 3093|       |_Bool atime_preserve_option;
 3094|       |_Bool dereference_option;
 3095|       |void diff_archive(void);
 3096|       |void diff_init(void);
 3097|       |char *get_directory_contents(char *path, dev_t device);
 3098|       |union block *current_header;
 3099|       |enum archive_format current_format;
 3100|       |void decode_header(union block *header, struct tar_stat_info *stat_info,
 3101|       |                   enum archive_format *format_pointer, int do_user_group);
 3102|       |void print_header(struct tar_stat_info *st, off_t block_ordinal);
 3103|       |enum read_header read_header(_Bool raw_extended_headers);
 3104|       |void skip_member(void);
 3105|       |int deref_stat(_Bool deref, char const *name, struct stat *buf);
 3106|       |void readlink_error(char const *name);
 3107|       |void readlink_warn(char const *name);
 3108|       |void seek_error_details(char const *name, off_t offset);
 3109|       |void seek_warn(char const *name);
 3110|       |void stat_error(char const *name);
 3111|       |void stat_warn(char const *name);
 3112|       |_Bool sys_compare_uid(struct stat *a, struct stat *b);
 3113|       |_Bool sys_compare_gid(struct stat *a, struct stat *b);
 3114|       |_Bool sys_compare_links(struct stat *link_data, struct stat *stat_data);
 3115|       |void report_difference(struct tar_stat_info *st __attribute__((__unused__)),
 3116|       |                       char const *fmt, ...);
 3117|       |_Bool sparse_diff_file(int fd, struct tar_stat_info *st);
 3118|       |static int diff_handle;
 3119|       |static char *diff_buffer;
 3120|      0|void diff_init(void) {
 3121|      0|  void *tmp;
 3122|       |
 3123|      0|  {
 3124|      0|    {
 3125|      0|      tmp = valloc(record_size);
 3126|      0|      diff_buffer = (char *)tmp;
 3127|      0|    }
 3128|      0|    if (!diff_buffer) {
 3129|      0|      {
 3130|      0|        xalloc_die();
 3131|      0|      }
 3132|      0|    }
 3133|      0|    return;
 3134|      0|  }
 3135|      0|}
 3136|       |void report_difference(struct tar_stat_info *st __attribute__((__unused__)),
 3137|      0|                       char const *fmt, ...) {
 3138|      0|  va_list ap;
 3139|      0|  char *tmp;
 3140|       |
 3141|      0|  {
 3142|      0|    if (fmt) {
 3143|      0|      {
 3144|      0|        tmp = quotearg_colon((char const *)current_stat_info.file_name);
 3145|      0|        fprintf((FILE * /* __restrict  */) stdlis,
 3146|      0|                (char const * /* __restrict  */) "%s: ", tmp);
 3147|      0|        __builtin_va_start(ap, fmt);
 3148|      0|        vfprintf((FILE * /* __restrict  */) stdlis,
 3149|      0|                 (char const * /* __restrict  */)fmt, ap);
 3150|      0|        __builtin_va_end(ap);
 3151|      0|        fprintf((FILE * /* __restrict  */) stdlis,
 3152|      0|                (char const * /* __restrict  */) "\n");
 3153|      0|      }
 3154|      0|    }
 3155|      0|    if (exit_status == 0) {
 3156|      0|      exit_status = 1;
 3157|      0|    }
 3158|      0|    return;
 3159|      0|  }
 3160|      0|}
 3161|       |static int process_noop(size_t size __attribute__((__unused__)),
 3162|      0|                        char *data __attribute__((__unused__))) {
 3163|       |
 3164|      0|  { return (1); }
 3165|      0|}
 3166|      0|static int process_rawdata(size_t bytes, char *buffer___2) {
 3167|      0|  size_t status;
 3168|      0|  size_t tmp;
 3169|      0|  char *tmp___0;
 3170|      0|  char *tmp___1;
 3171|      0|  int tmp___2;
 3172|      0|  char *__cil_tmp8;
 3173|       |
 3174|      0|  {
 3175|      0|    {
 3176|      0|      tmp = safe_read(diff_handle, (void *)diff_buffer, bytes);
 3177|      0|      status = tmp;
 3178|      0|    }
 3179|      0|    if (status != bytes) {
 3180|      0|      if (status == 0xffffffffffffffffUL) {
 3181|      0|        {
 3182|      0|          read_error((char const *)current_stat_info.file_name);
 3183|      0|          report_difference(&current_stat_info, (char const *)((void *)0));
 3184|      0|        }
 3185|      0|      } else {
 3186|      0|        {
 3187|      0|          tmp___0 = ngettext("Could only read %lu of %lu byte",
 3188|      0|                             "Could only read %lu of %lu bytes", bytes);
 3189|      0|          report_difference(&current_stat_info, (char const *)tmp___0, status,
 3190|      0|                            bytes);
 3191|      0|        }
 3192|      0|      }
 3193|      0|      return (0);
 3194|      0|    }
 3195|      0|    {
 3196|      0|      tmp___2 =
 3197|      0|          memcmp((void const *)buffer___2, (void const *)diff_buffer, bytes);
 3198|      0|    }
 3199|      0|    if (tmp___2) {
 3200|      0|      {
 3201|      0|        tmp___1 = gettext("Contents differ");
 3202|      0|        report_difference(&current_stat_info, (char const *)tmp___1);
 3203|      0|      }
 3204|      0|      return (0);
 3205|      0|    }
 3206|      0|    return (1);
 3207|      0|  }
 3208|      0|}
 3209|       |static char *dumpdir_cursor;
 3210|      0|static int process_dumpdir(size_t bytes, char *buffer___2) {
 3211|      0|  char *tmp;
 3212|      0|  int tmp___0;
 3213|      0|  char *__cil_tmp5;
 3214|       |
 3215|      0|  {
 3216|      0|    {
 3217|      0|      tmp___0 =
 3218|      0|          memcmp((void const *)buffer___2, (void const *)dumpdir_cursor, bytes);
 3219|      0|    }
 3220|      0|    if (tmp___0) {
 3221|      0|      {
 3222|      0|        tmp = gettext("Contents differ");
 3223|      0|        report_difference(&current_stat_info, (char const *)tmp);
 3224|      0|      }
 3225|      0|      return (0);
 3226|      0|    }
 3227|      0|    dumpdir_cursor += bytes;
 3228|      0|    return (1);
 3229|      0|  }
 3230|      0|}
 3231|      0|static void read_and_process(off_t size, int (*processor)(size_t, char *)) {
 3232|      0|  union block *data_block;
 3233|      0|  size_t data_size;
 3234|      0|  char *tmp;
 3235|      0|  int tmp___0;
 3236|      0|  char *__cil_tmp7;
 3237|       |
 3238|      0|  {
 3239|      0|    if (multi_volume_option) {
 3240|      0|      save_sizeleft = size;
 3241|      0|    }
 3242|      0|    {
 3243|      0|      while (1) {
 3244|      0|      while_continue: /* CIL Label */;
 3245|      0|        if (!size) {
 3246|      0|          goto while_break;
 3247|      0|        }
 3248|      0|        { data_block = find_next_block(); }
 3249|      0|        if (!data_block) {
 3250|      0|          {
 3251|      0|            tmp = gettext("Unexpected EOF in archive");
 3252|      0|            error(0, 0, (char const *)tmp);
 3253|      0|            exit_status = 2;
 3254|      0|          }
 3255|      0|          return;
 3256|      0|        }
 3257|      0|        { data_size = available_space_after(data_block); }
 3258|      0|        if (data_size > (size_t)size) {
 3259|      0|          data_size = (size_t)size;
 3260|      0|        }
 3261|      0|        { tmp___0 = (*processor)(data_size, data_block->buffer); }
 3262|      0|        if (!tmp___0) {
 3263|      0|          processor = &process_noop;
 3264|      0|        }
 3265|      0|        {
 3266|      0|          set_next_block_after(
 3267|      0|              (union block *)((data_block->buffer + data_size) - 1));
 3268|      0|          size = (off_t)((size_t)size - data_size);
 3269|      0|        }
 3270|      0|        if (multi_volume_option) {
 3271|      0|          save_sizeleft = (off_t)((size_t)save_sizeleft - data_size);
 3272|      0|        }
 3273|      0|      }
 3274|      0|    while_break: /* CIL Label */;
 3275|      0|    }
 3276|      0|    return;
 3277|      0|  }
 3278|      0|}
 3279|      0|static int get_stat_data(char const *file_name, struct stat *stat_data) {
 3280|      0|  int status;
 3281|      0|  int tmp;
 3282|      0|  int *tmp___0;
 3283|       |
 3284|      0|  {
 3285|      0|    {
 3286|      0|      tmp = deref_stat(dereference_option, file_name, stat_data);
 3287|      0|      status = tmp;
 3288|      0|    }
 3289|      0|    if (status != 0) {
 3290|      0|      {
 3291|      0|        tmp___0 = __errno_location();
 3292|      0|      }
 3293|      0|      if (*tmp___0 == 2) {
 3294|      0|        {
 3295|      0|          stat_warn(file_name);
 3296|      0|        }
 3297|      0|      } else {
 3298|      0|        { stat_error(file_name); }
 3299|      0|      }
 3300|      0|      { report_difference(&current_stat_info, (char const *)((void *)0)); }
 3301|      0|      return (0);
 3302|      0|    }
 3303|      0|    return (1);
 3304|      0|  }
 3305|      0|}
 3306|      0|void diff_archive(void) {
 3307|      0|  struct stat stat_data;
 3308|      0|  int status;
 3309|      0|  struct utimbuf restore_times;
 3310|      0|  char *tmp;
 3311|      0|  char *tmp___0;
 3312|      0|  char *tmp___1;
 3313|      0|  int tmp___2;
 3314|      0|  char *tmp___3;
 3315|      0|  char *tmp___4;
 3316|      0|  char *tmp___5;
 3317|      0|  _Bool tmp___6;
 3318|      0|  char *tmp___7;
 3319|      0|  _Bool tmp___8;
 3320|      0|  char *tmp___9;
 3321|      0|  char *tmp___10;
 3322|      0|  struct stat file_data;
 3323|      0|  struct stat link_data;
 3324|      0|  int tmp___11;
 3325|      0|  int tmp___12;
 3326|      0|  char const *tmp___13;
 3327|      0|  char *tmp___14;
 3328|      0|  _Bool tmp___15;
 3329|      0|  size_t len;
 3330|      0|  size_t tmp___16;
 3331|      0|  char *linkbuf;
 3332|      0|  void *tmp___17;
 3333|      0|  ssize_t tmp___18;
 3334|      0|  int *tmp___19;
 3335|      0|  char *tmp___20;
 3336|      0|  int tmp___21;
 3337|      0|  int tmp___22;
 3338|      0|  char *tmp___23;
 3339|      0|  char *tmp___24;
 3340|      0|  char *tmp___25;
 3341|      0|  char *dumpdir_buffer;
 3342|      0|  char *tmp___26;
 3343|      0|  int tmp___27;
 3344|      0|  char *tmp___28;
 3345|      0|  char *tmp___29;
 3346|      0|  off_t offset;
 3347|      0|  int tmp___30;
 3348|      0|  char *tmp___31;
 3349|      0|  char *tmp___32;
 3350|      0|  __off_t tmp___33;
 3351|      0|  int tmp___34;
 3352|      0|  int tmp___35;
 3353|      0|  void *__cil_tmp47;
 3354|      0|  void *__cil_tmp48;
 3355|      0|  void *__cil_tmp49;
 3356|      0|  char *__cil_tmp50;
 3357|      0|  char *__cil_tmp51;
 3358|      0|  char *__cil_tmp52;
 3359|      0|  char *__cil_tmp53;
 3360|      0|  char *__cil_tmp54;
 3361|      0|  char *__cil_tmp55;
 3362|      0|  char *__cil_tmp56;
 3363|      0|  char *__cil_tmp57;
 3364|      0|  char *__cil_tmp58;
 3365|      0|  char *__cil_tmp59;
 3366|      0|  char *__cil_tmp60;
 3367|      0|  char *__cil_tmp61;
 3368|      0|  char *__cil_tmp62;
 3369|      0|  char *__cil_tmp63;
 3370|      0|  char *__cil_tmp64;
 3371|      0|  char *__cil_tmp65;
 3372|      0|  char *__cil_tmp66;
 3373|      0|  char *__cil_tmp67;
 3374|       |
 3375|      0|  {
 3376|      0|    {
 3377|      0|      set_next_block_after(current_header);
 3378|      0|      decode_header(current_header, &current_stat_info, &current_format, 1);
 3379|      0|    }
 3380|      0|    if (verbose_option) {
 3381|      0|      if (now_verifying) {
 3382|      0|        {
 3383|      0|          tmp = gettext("Verify ");
 3384|      0|          fprintf((FILE * /* __restrict  */) stdlis,
 3385|      0|                  (char const * /* __restrict  */)tmp);
 3386|      0|        }
 3387|      0|      }
 3388|      0|      { print_header(&current_stat_info, (off_t)-1); }
 3389|      0|    }
 3390|      0|    {
 3391|      0|      if ((int)current_header->header.typeflag == 0) {
 3392|      0|        goto case_0;
 3393|      0|      }
 3394|      0|      if ((int)current_header->header.typeflag == 48) {
 3395|      0|        goto case_0;
 3396|      0|      }
 3397|      0|      if ((int)current_header->header.typeflag == 83) {
 3398|      0|        goto case_0;
 3399|      0|      }
 3400|      0|      if ((int)current_header->header.typeflag == 55) {
 3401|      0|        goto case_0;
 3402|      0|      }
 3403|      0|      if ((int)current_header->header.typeflag == 49) {
 3404|      0|        goto case_49;
 3405|      0|      }
 3406|      0|      if ((int)current_header->header.typeflag == 50) {
 3407|      0|        goto case_50;
 3408|      0|      }
 3409|      0|      if ((int)current_header->header.typeflag == 51) {
 3410|      0|        goto case_51;
 3411|      0|      }
 3412|      0|      if ((int)current_header->header.typeflag == 52) {
 3413|      0|        goto case_51;
 3414|      0|      }
 3415|      0|      if ((int)current_header->header.typeflag == 54) {
 3416|      0|        goto case_51;
 3417|      0|      }
 3418|      0|      if ((int)current_header->header.typeflag == 68) {
 3419|      0|        goto case_68;
 3420|      0|      }
 3421|      0|      if ((int)current_header->header.typeflag == 53) {
 3422|      0|        goto really_dir;
 3423|      0|      }
 3424|      0|      if ((int)current_header->header.typeflag == 86) {
 3425|      0|        goto case_86;
 3426|      0|      }
 3427|      0|      if ((int)current_header->header.typeflag == 77) {
 3428|      0|        goto case_77;
 3429|      0|      }
 3430|      0|      goto switch_default;
 3431|      0|    switch_default : /* CIL Label */
 3432|      0|    {
 3433|      0|      tmp___0 = quotearg_colon((char const *)current_stat_info.file_name);
 3434|      0|      tmp___1 = gettext("%s: Unknown file type \'%c\', diffed as normal file");
 3435|      0|      error(0, 0, (char const *)tmp___1, tmp___0,
 3436|      0|            (int)current_header->header.typeflag);
 3437|      0|      exit_status = 2;
 3438|      0|    }
 3439|      0|    case_0:  /* CIL Label */
 3440|      0|    case_48: /* CIL Label */
 3441|      0|    case_83: /* CIL Label */
 3442|      0|    case_55: /* CIL Label */
 3443|      0|      if (current_stat_info.had_trailing_slash) {
 3444|      0|        goto really_dir;
 3445|      0|      }
 3446|      0|      {
 3447|      0|        tmp___2 = get_stat_data((char const *)current_stat_info.file_name,
 3448|      0|                                &stat_data);
 3449|      0|      }
 3450|      0|      if (!tmp___2) {
 3451|      0|        {
 3452|      0|          skip_member();
 3453|      0|        }
 3454|      0|        goto quit;
 3455|      0|      }
 3456|      0|      if (!((stat_data.st_mode & 61440U) == 32768U)) {
 3457|      0|        {
 3458|      0|          tmp___3 = gettext("File type differs");
 3459|      0|          report_difference(&current_stat_info, (char const *)tmp___3);
 3460|      0|          skip_member();
 3461|      0|        }
 3462|      0|        goto quit;
 3463|      0|      }
 3464|      0|      if ((current_stat_info.stat.st_mode &
 3465|      0|           (unsigned int)(3584 |
 3466|      0|                          (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 3467|      0|                           (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 3468|      0|                            ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))) !=
 3469|      0|          (stat_data.st_mode &
 3470|      0|           (unsigned int)(3584 |
 3471|      0|                          (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 3472|      0|                           (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 3473|      0|                            ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))))) {
 3474|      0|        {
 3475|      0|          tmp___4 = gettext("Mode differs");
 3476|      0|          report_difference(&current_stat_info, (char const *)tmp___4);
 3477|      0|        }
 3478|      0|      }
 3479|      0|      { tmp___6 = sys_compare_uid(&stat_data, &current_stat_info.stat); }
 3480|      0|      if (!tmp___6) {
 3481|      0|        {
 3482|      0|          tmp___5 = gettext("Uid differs");
 3483|      0|          report_difference(&current_stat_info, (char const *)tmp___5);
 3484|      0|        }
 3485|      0|      }
 3486|      0|      { tmp___8 = sys_compare_gid(&stat_data, &current_stat_info.stat); }
 3487|      0|      if (!tmp___8) {
 3488|      0|        {
 3489|      0|          tmp___7 = gettext("Gid differs");
 3490|      0|          report_difference(&current_stat_info, (char const *)tmp___7);
 3491|      0|        }
 3492|      0|      }
 3493|      0|      if (stat_data.st_mtim.tv_sec != current_stat_info.stat.st_mtim.tv_sec) {
 3494|      0|        {
 3495|      0|          tmp___9 = gettext("Mod time differs");
 3496|      0|          report_difference(&current_stat_info, (char const *)tmp___9);
 3497|      0|        }
 3498|      0|      }
 3499|      0|      if ((int)current_header->header.typeflag != 83) {
 3500|      0|        if (stat_data.st_size != current_stat_info.stat.st_size) {
 3501|      0|          {
 3502|      0|            tmp___10 = gettext("Size differs");
 3503|      0|            report_difference(&current_stat_info, (char const *)tmp___10);
 3504|      0|            skip_member();
 3505|      0|          }
 3506|      0|          goto quit;
 3507|      0|        }
 3508|      0|      }
 3509|      0|      { diff_handle = open((char const *)current_stat_info.file_name, 0); }
 3510|      0|      if (diff_handle < 0) {
 3511|      0|        {
 3512|      0|          open_error((char const *)current_stat_info.file_name);
 3513|      0|          skip_member();
 3514|      0|          report_difference(&current_stat_info, (char const *)((void *)0));
 3515|      0|        }
 3516|      0|        goto quit;
 3517|      0|      }
 3518|      0|      restore_times.actime = stat_data.st_atim.tv_sec;
 3519|      0|      restore_times.modtime = stat_data.st_mtim.tv_sec;
 3520|      0|      if (current_stat_info.is_sparse) {
 3521|      0|        {
 3522|      0|          sparse_diff_file(diff_handle, &current_stat_info);
 3523|      0|        }
 3524|      0|      } else {
 3525|      0|        if (multi_volume_option) {
 3526|      0|          {
 3527|      0|            assign_string(&save_name,
 3528|      0|                          (char const *)current_stat_info.file_name);
 3529|      0|            save_totsize = current_stat_info.stat.st_size;
 3530|      0|          }
 3531|      0|        }
 3532|      0|        { read_and_process(current_stat_info.stat.st_size, &process_rawdata); }
 3533|      0|        if (multi_volume_option) {
 3534|      0|          {
 3535|      0|            assign_string(&save_name, (char const *)0);
 3536|      0|          }
 3537|      0|        }
 3538|      0|      }
 3539|      0|      { status = close(diff_handle); }
 3540|      0|      if (status != 0) {
 3541|      0|        {
 3542|      0|          close_error((char const *)current_stat_info.file_name);
 3543|      0|        }
 3544|      0|      }
 3545|      0|      if (atime_preserve_option) {
 3546|      0|        {
 3547|      0|          utime((char const *)current_stat_info.file_name,
 3548|      0|                (struct utimbuf const *)(&restore_times));
 3549|      0|        }
 3550|      0|      }
 3551|      0|    quit:
 3552|      0|      goto switch_break;
 3553|      0|    case_49 : /* CIL Label */
 3554|      0|    {
 3555|      0|      tmp___11 =
 3556|      0|          get_stat_data((char const *)current_stat_info.file_name, &file_data);
 3557|      0|    }
 3558|      0|      if (!tmp___11) {
 3559|      0|        goto switch_break;
 3560|      0|      }
 3561|      0|      {
 3562|      0|        tmp___12 = get_stat_data((char const *)current_stat_info.link_name,
 3563|      0|                                 &link_data);
 3564|      0|      }
 3565|      0|      if (!tmp___12) {
 3566|      0|        goto switch_break;
 3567|      0|      }
 3568|      0|      { tmp___15 = sys_compare_links(&file_data, &link_data); }
 3569|      0|      if (!tmp___15) {
 3570|      0|        {
 3571|      0|          tmp___13 = quote((char const *)current_stat_info.link_name);
 3572|      0|          tmp___14 = gettext("Not linked to %s");
 3573|      0|          report_difference(&current_stat_info, (char const *)tmp___14,
 3574|      0|                            tmp___13);
 3575|      0|        }
 3576|      0|      }
 3577|      0|      goto switch_break;
 3578|      0|    case_50 : /* CIL Label */
 3579|      0|    {
 3580|      0|      tmp___16 = strlen((char const *)current_stat_info.link_name);
 3581|      0|      len = tmp___16;
 3582|      0|      tmp___17 = __builtin_alloca(len + 1UL);
 3583|      0|      linkbuf = (char *)tmp___17;
 3584|      0|      tmp___18 =
 3585|      0|          readlink((char const * /* __restrict  */)current_stat_info.file_name,
 3586|      0|                   (char * /* __restrict  */)linkbuf, len + 1UL);
 3587|      0|      status = (int)tmp___18;
 3588|      0|    }
 3589|      0|      if (status < 0) {
 3590|      0|        {
 3591|      0|          tmp___19 = __errno_location();
 3592|      0|        }
 3593|      0|        if (*tmp___19 == 2) {
 3594|      0|          {
 3595|      0|            readlink_warn((char const *)current_stat_info.file_name);
 3596|      0|          }
 3597|      0|        } else {
 3598|      0|          { readlink_error((char const *)current_stat_info.file_name); }
 3599|      0|        }
 3600|      0|        { report_difference(&current_stat_info, (char const *)((void *)0)); }
 3601|      0|      } else {
 3602|      0|        if ((size_t)status != len) {
 3603|      0|          {
 3604|      0|            tmp___20 = gettext("Symlink differs");
 3605|      0|            report_difference(&current_stat_info, (char const *)tmp___20);
 3606|      0|          }
 3607|      0|        } else {
 3608|      0|          {
 3609|      0|            tmp___21 = strncmp((char const *)current_stat_info.link_name,
 3610|      0|                               (char const *)linkbuf, len);
 3611|      0|          }
 3612|      0|          if (tmp___21 != 0) {
 3613|      0|            {
 3614|      0|              tmp___20 = gettext("Symlink differs");
 3615|      0|              report_difference(&current_stat_info, (char const *)tmp___20);
 3616|      0|            }
 3617|      0|          }
 3618|      0|        }
 3619|      0|      }
 3620|      0|      goto switch_break;
 3621|      0|    case_51:  /* CIL Label */
 3622|      0|    case_52:  /* CIL Label */
 3623|      0|    case_54 : /* CIL Label */
 3624|      0|    {
 3625|      0|      tmp___22 =
 3626|      0|          get_stat_data((char const *)current_stat_info.file_name, &stat_data);
 3627|      0|    }
 3628|      0|      if (!tmp___22) {
 3629|      0|        goto switch_break;
 3630|      0|      }
 3631|      0|      if ((int)current_header->header.typeflag == 51) {
 3632|      0|        tmp___35 = !((stat_data.st_mode & 61440U) == 8192U);
 3633|      0|      } else {
 3634|      0|        if ((int)current_header->header.typeflag == 52) {
 3635|      0|          tmp___34 = !((stat_data.st_mode & 61440U) == 24576U);
 3636|      0|        } else {
 3637|      0|          tmp___34 = !((stat_data.st_mode & 61440U) == 4096U);
 3638|      0|        }
 3639|      0|        tmp___35 = tmp___34;
 3640|      0|      }
 3641|      0|      if (tmp___35) {
 3642|      0|        {
 3643|      0|          tmp___23 = gettext("File type differs");
 3644|      0|          report_difference(&current_stat_info, (char const *)tmp___23);
 3645|      0|        }
 3646|      0|        goto switch_break;
 3647|      0|      }
 3648|      0|      if ((int)current_header->header.typeflag == 51) {
 3649|      0|        goto _L___3;
 3650|      0|      } else {
 3651|      0|        if ((int)current_header->header.typeflag == 52) {
 3652|      0|        _L___3: /* CIL Label */
 3653|      0|          if (current_stat_info.stat.st_rdev != stat_data.st_rdev) {
 3654|      0|            {
 3655|      0|              tmp___24 = gettext("Device number differs");
 3656|      0|              report_difference(&current_stat_info, (char const *)tmp___24);
 3657|      0|            }
 3658|      0|            goto switch_break;
 3659|      0|          }
 3660|      0|        }
 3661|      0|      }
 3662|      0|      if ((current_stat_info.stat.st_mode &
 3663|      0|           (unsigned int)(3584 |
 3664|      0|                          (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 3665|      0|                           (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 3666|      0|                            ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))) !=
 3667|      0|          (stat_data.st_mode &
 3668|      0|           (unsigned int)(3584 |
 3669|      0|                          (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 3670|      0|                           (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 3671|      0|                            ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))))) {
 3672|      0|        {
 3673|      0|          tmp___25 = gettext("Mode differs");
 3674|      0|          report_difference(&current_stat_info, (char const *)tmp___25);
 3675|      0|        }
 3676|      0|        goto switch_break;
 3677|      0|      }
 3678|      0|      goto switch_break;
 3679|      0|    case_68 : /* CIL Label */
 3680|      0|    {
 3681|      0|      tmp___26 = get_directory_contents(current_stat_info.file_name, (dev_t)0);
 3682|      0|      dumpdir_buffer = tmp___26;
 3683|      0|    }
 3684|      0|      if (multi_volume_option) {
 3685|      0|        {
 3686|      0|          assign_string(&save_name, (char const *)current_stat_info.file_name);
 3687|      0|          save_totsize = current_stat_info.stat.st_size;
 3688|      0|        }
 3689|      0|      }
 3690|      0|      if (dumpdir_buffer) {
 3691|      0|        {
 3692|      0|          dumpdir_cursor = dumpdir_buffer;
 3693|      0|          read_and_process(current_stat_info.stat.st_size, &process_dumpdir);
 3694|      0|          free((void *)dumpdir_buffer);
 3695|      0|        }
 3696|      0|      } else {
 3697|      0|        { read_and_process(current_stat_info.stat.st_size, &process_noop); }
 3698|      0|      }
 3699|      0|      if (multi_volume_option) {
 3700|      0|        {
 3701|      0|          assign_string(&save_name, (char const *)0);
 3702|      0|        }
 3703|      0|      }
 3704|      0|    really_dir:
 3705|      0|    case_53 : /* CIL Label */
 3706|      0|    {
 3707|      0|      tmp___27 =
 3708|      0|          get_stat_data((char const *)current_stat_info.file_name, &stat_data);
 3709|      0|    }
 3710|      0|      if (!tmp___27) {
 3711|      0|        goto switch_break;
 3712|      0|      }
 3713|      0|      if (!((stat_data.st_mode & 61440U) == 16384U)) {
 3714|      0|        {
 3715|      0|          tmp___28 = gettext("File type differs");
 3716|      0|          report_difference(&current_stat_info, (char const *)tmp___28);
 3717|      0|        }
 3718|      0|        goto switch_break;
 3719|      0|      }
 3720|      0|      if ((current_stat_info.stat.st_mode &
 3721|      0|           (unsigned int)(3584 |
 3722|      0|                          (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 3723|      0|                           (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 3724|      0|                            ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))) !=
 3725|      0|          (stat_data.st_mode &
 3726|      0|           (unsigned int)(3584 |
 3727|      0|                          (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 3728|      0|                           (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 3729|      0|                            ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))))) {
 3730|      0|        {
 3731|      0|          tmp___29 = gettext("Mode differs");
 3732|      0|          report_difference(&current_stat_info, (char const *)tmp___29);
 3733|      0|        }
 3734|      0|        goto switch_break;
 3735|      0|      }
 3736|      0|      goto switch_break;
 3737|      0|    case_86: /* CIL Label */
 3738|      0|      goto switch_break;
 3739|      0|    case_77: /* CIL Label */
 3740|      0|      if (current_stat_info.had_trailing_slash) {
 3741|      0|        goto really_dir;
 3742|      0|      }
 3743|      0|      {
 3744|      0|        tmp___30 = get_stat_data((char const *)current_stat_info.file_name,
 3745|      0|                                 &stat_data);
 3746|      0|      }
 3747|      0|      if (!tmp___30) {
 3748|      0|        goto switch_break;
 3749|      0|      }
 3750|      0|      if (!((stat_data.st_mode & 61440U) == 32768U)) {
 3751|      0|        {
 3752|      0|          tmp___31 = gettext("File type differs");
 3753|      0|          report_difference(&current_stat_info, (char const *)tmp___31);
 3754|      0|          skip_member();
 3755|      0|        }
 3756|      0|        goto switch_break;
 3757|      0|      }
 3758|      0|      {
 3759|      0|        offset = off_from_header(
 3760|      0|            (char const *)(current_header->oldgnu_header.offset),
 3761|      0|            sizeof(current_header->oldgnu_header.offset));
 3762|      0|      }
 3763|      0|      if (stat_data.st_size != current_stat_info.stat.st_size + offset) {
 3764|      0|        {
 3765|      0|          tmp___32 = gettext("Size differs");
 3766|      0|          report_difference(&current_stat_info, (char const *)tmp___32);
 3767|      0|          skip_member();
 3768|      0|        }
 3769|      0|        goto switch_break;
 3770|      0|      }
 3771|      0|      { diff_handle = open((char const *)current_stat_info.file_name, 0); }
 3772|      0|      if (diff_handle < 0) {
 3773|      0|        {
 3774|      0|          open_error((char const *)current_stat_info.file_name);
 3775|      0|          report_difference(&current_stat_info, (char const *)((void *)0));
 3776|      0|          skip_member();
 3777|      0|        }
 3778|      0|        goto switch_break;
 3779|      0|      }
 3780|      0|      { tmp___33 = lseek(diff_handle, offset, 0); }
 3781|      0|      if (tmp___33 < 0L) {
 3782|      0|        {
 3783|      0|          seek_error_details((char const *)current_stat_info.file_name, offset);
 3784|      0|          report_difference(&current_stat_info, (char const *)((void *)0));
 3785|      0|        }
 3786|      0|        goto switch_break;
 3787|      0|      }
 3788|      0|      if (multi_volume_option) {
 3789|      0|        {
 3790|      0|          assign_string(&save_name, (char const *)current_stat_info.file_name);
 3791|      0|          save_totsize = stat_data.st_size;
 3792|      0|        }
 3793|      0|      }
 3794|      0|      { read_and_process(current_stat_info.stat.st_size, &process_rawdata); }
 3795|      0|      if (multi_volume_option) {
 3796|      0|        {
 3797|      0|          assign_string(&save_name, (char const *)0);
 3798|      0|        }
 3799|      0|      }
 3800|      0|      { status = close(diff_handle); }
 3801|      0|      if (status != 0) {
 3802|      0|        {
 3803|      0|          close_error((char const *)current_stat_info.file_name);
 3804|      0|        }
 3805|      0|      }
 3806|      0|      goto switch_break;
 3807|      0|    switch_break: /* CIL Label */;
 3808|      0|    }
 3809|      0|    return;
 3810|      0|  }
 3811|      0|}
 3812|      0|void verify_volume(void) {
 3813|      0|  struct mtop operation;
 3814|      0|  int status;
 3815|      0|  off_t tmp;
 3816|      0|  __off_t tmp___0;
 3817|      0|  off_t tmp___1;
 3818|      0|  int *tmp___2;
 3819|      0|  int tmp___3;
 3820|      0|  int tmp___4;
 3821|      0|  int tmp___5;
 3822|      0|  int tmp___6;
 3823|      0|  enum read_header status___0;
 3824|      0|  enum read_header tmp___7;
 3825|      0|  int counter;
 3826|      0|  char *tmp___8;
 3827|       |
 3828|      0|  {
 3829|      0|    if (!diff_buffer) {
 3830|      0|      {
 3831|      0|        diff_init();
 3832|      0|      }
 3833|      0|    }
 3834|      0|    {
 3835|      0|      fsync(archive);
 3836|      0|      ioctl(archive, (unsigned long)((unsigned int)(2 << 8) | 75U));
 3837|      0|      operation.mt_op = (short)2;
 3838|      0|      operation.mt_count = 1;
 3839|      0|    }
 3840|      0|    if (archive >= 1 << 30) {
 3841|      0|      {
 3842|      0|        tmp___5 = rmt_ioctl__(
 3843|      0|            archive - (1 << 30),
 3844|      0|            (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) |
 3845|      0|                                  1U) |
 3846|      0|                  (sizeof(struct mtop) << 16)),
 3847|      0|            (char *)(&operation));
 3848|      0|        status = tmp___5;
 3849|      0|      }
 3850|      0|    } else {
 3851|      0|      {
 3852|      0|        tmp___6 = ioctl(
 3853|      0|            archive,
 3854|      0|            (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) |
 3855|      0|                (sizeof(struct mtop) << 16),
 3856|      0|            (char *)(&operation));
 3857|      0|        status = tmp___6;
 3858|      0|      }
 3859|      0|    }
 3860|      0|    if (status < 0) {
 3861|      0|      {
 3862|      0|        tmp___2 = __errno_location();
 3863|      0|      }
 3864|      0|      if (*tmp___2 != 5) {
 3865|      0|        goto _L;
 3866|      0|      } else {
 3867|      0|        if (archive >= 1 << 30) {
 3868|      0|          {
 3869|      0|            tmp___3 = rmt_ioctl__(
 3870|      0|                archive - (1 << 30),
 3871|      0|                (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) |
 3872|      0|                                      1U) |
 3873|      0|                      (sizeof(struct mtop) << 16)),
 3874|      0|                (char *)(&operation));
 3875|      0|            status = tmp___3;
 3876|      0|          }
 3877|      0|        } else {
 3878|      0|          {
 3879|      0|            tmp___4 = ioctl(
 3880|      0|                archive,
 3881|      0|                (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) |
 3882|      0|                    (sizeof(struct mtop) << 16),
 3883|      0|                (char *)(&operation));
 3884|      0|            status = tmp___4;
 3885|      0|          }
 3886|      0|        }
 3887|      0|        if (status < 0) {
 3888|      0|        _L:
 3889|      0|          if (archive >= 1 << 30) {
 3890|      0|            {
 3891|      0|              tmp = rmt_lseek__(archive - (1 << 30), (off_t)0, 0);
 3892|      0|              tmp___1 = tmp;
 3893|      0|            }
 3894|      0|          } else {
 3895|      0|            {
 3896|      0|              tmp___0 = lseek(archive, (off_t)0, 0);
 3897|      0|              tmp___1 = tmp___0;
 3898|      0|            }
 3899|      0|          }
 3900|      0|          if (tmp___1 != 0L) {
 3901|      0|            {
 3902|      0|              seek_warn(*(archive_name_array + 0));
 3903|      0|            }
 3904|      0|            return;
 3905|      0|          }
 3906|      0|        }
 3907|      0|      }
 3908|      0|    }
 3909|      0|    {
 3910|      0|      access_mode = (enum access_mode)0;
 3911|      0|      now_verifying = (_Bool)1;
 3912|      0|      flush_read();
 3913|      0|    }
 3914|      0|    {
 3915|      0|      while (1) {
 3916|      0|      while_continue: /* CIL Label */;
 3917|      0|        {
 3918|      0|          tmp___7 = read_header((_Bool)0);
 3919|      0|          status___0 = tmp___7;
 3920|      0|        }
 3921|      0|        if ((unsigned int)status___0 == 5U) {
 3922|      0|          counter = 0;
 3923|      0|          {
 3924|      0|            while (1) {
 3925|      0|            while_continue___0: /* CIL Label */;
 3926|      0|              {
 3927|      0|                counter++;
 3928|      0|                status___0 = read_header((_Bool)0);
 3929|      0|              }
 3930|      0|              if (!((unsigned int)status___0 == 5U)) {
 3931|      0|                goto while_break___0;
 3932|      0|              }
 3933|      0|            }
 3934|      0|          while_break___0: /* CIL Label */;
 3935|      0|          }
 3936|      0|          {
 3937|      0|            tmp___8 = ngettext("VERIFY FAILURE: %d invalid header detected",
 3938|      0|                               "VERIFY FAILURE: %d invalid headers detected",
 3939|      0|                               (unsigned long)counter);
 3940|      0|            error(0, 0, (char const *)tmp___8, counter);
 3941|      0|            exit_status = 2;
 3942|      0|          }
 3943|      0|        }
 3944|      0|        if ((unsigned int)status___0 == 3U) {
 3945|      0|          goto while_break;
 3946|      0|        } else {
 3947|      0|          if ((unsigned int)status___0 == 4U) {
 3948|      0|            goto while_break;
 3949|      0|          }
 3950|      0|        }
 3951|      0|        { diff_archive(); }
 3952|      0|      }
 3953|      0|    while_break: /* CIL Label */;
 3954|      0|    }
 3955|      0|    access_mode = (enum access_mode)1;
 3956|      0|    now_verifying = (_Bool)0;
 3957|      0|    return;
 3958|      0|  }
 3959|      0|}
 3960|       |/* #pragma merger("0","002.create.o.i","") */
 3961|       |extern __attribute__((__nothrow__)) unsigned int(
 3962|       |    __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev)
 3963|       |    __attribute__((__const__));
 3964|       |extern __attribute__((__nothrow__)) unsigned int(
 3965|       |    __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev)
 3966|       |    __attribute__((__const__));
 3967|       |extern __attribute__((__nothrow__)) char *(
 3968|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 3969|       |    strncpy)(char *__restrict __dest, char const *__restrict __src, size_t __n);
 3970|       |extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1),
 3971|       |                                                          __leaf__))
 3972|       |                                           strdup)(char const *__s)
 3973|       |    __attribute__((__malloc__));
 3974|       |extern
 3975|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
 3976|       |                                     fstat)(int __fd, struct stat *__buf);
 3977|       |extern __attribute__((__nothrow__))
 3978|       |__uid_t(__attribute__((__leaf__)) getuid)(void);
 3979|       |extern __attribute__((__nothrow__))
 3980|       |__gid_t(__attribute__((__leaf__)) getgid)(void);
 3981|       |extern
 3982|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 3983|       |                                     unlink)(char const *__name);
 3984|       |char *savedir(char const *dir);
 3985|       |void *xrealloc(void *p, size_t n);
 3986|       |mode_t mode_adjust(mode_t oldmode, struct mode_change const *changes);
 3987|       |enum archive_format archive_format;
 3988|       |int after_date_option;
 3989|       |gid_t group_option;
 3990|       |_Bool ignore_failed_read_option;
 3991|       |_Bool incremental_option;
 3992|       |_Bool interactive_option;
 3993|       |char const *listed_incremental_option;
 3994|       |struct mode_change *mode_option;
 3995|       |struct timespec newer_mtime_option;
 3996|       |int recursion_option;
 3997|       |_Bool numeric_owner_option;
 3998|       |_Bool one_file_system_option;
 3999|       |uid_t owner_option;
 4000|       |_Bool remove_files_option;
 4001|       |_Bool sparse_option;
 4002|       |_Bool file_dumpable_p(struct tar_stat_info *st);
 4003|       |void create_archive(void);
 4004|       |void pad_archive(off_t size_left);
 4005|       |void dump_file(char *p, int top_level, dev_t parent_device);
 4006|       |union block *start_header(struct tar_stat_info *st);
 4007|       |void simple_finish_header(union block *header);
 4008|       |union block *start_private_header(char const *name, size_t size);
 4009|       |void write_eot(void);
 4010|       |void check_links(void);
 4011|       |void gid_to_chars(gid_t v, char *p, size_t s);
 4012|       |void major_to_chars(int v, char *p, size_t s);
 4013|       |void minor_to_chars(int v, char *p, size_t s);
 4014|       |void mode_to_chars(mode_t v, char *p, size_t s);
 4015|       |void size_to_chars(size_t v, char *p, size_t s);
 4016|       |void uid_to_chars(uid_t v, char *p, size_t s);
 4017|       |void uintmax_to_chars(uintmax_t v, char *p, size_t s);
 4018|       |void string_to_chars(char *str, char *p, size_t s);
 4019|       |void write_directory_file(void);
 4020|       |struct xheader extended_header;
 4021|       |void close_diag(char const *name);
 4022|       |void open_diag(char const *name);
 4023|       |void read_diag_details(char const *name, off_t offset, size_t size);
 4024|       |void readlink_diag(char const *name);
 4025|       |void savedir_diag(char const *name);
 4026|       |void stat_diag(char const *name);
 4027|       |void unlink_error(char const *name);
 4028|       |struct name *gnu_list_name;
 4029|       |void gid_to_gname(gid_t gid, char **gname);
 4030|       |int gname_to_gid(char const *gname, gid_t *gidp);
 4031|       |void uid_to_uname(uid_t uid, char **uname);
 4032|       |int uname_to_uid(char const *uname, uid_t *uidp);
 4033|       |char *name_next(int change_dirs);
 4034|       |void collect_and_sort_names(void);
 4035|       |char *name_from_list(void);
 4036|       |void blank_name_list(void);
 4037|       |_Bool excluded_name(char const *name);
 4038|       |_Bool is_avoided_name(char const *name);
 4039|       |int confirm(char const *message_action, char const *message_name);
 4040|       |void tar_stat_init(struct tar_stat_info *st);
 4041|       |void xheader_store(char const *keyword, struct tar_stat_info const *st,
 4042|       |                   void *data);
 4043|       |void xheader_write(char type, char *name, struct xheader *xhdr);
 4044|       |void xheader_write_global(void);
 4045|       |void xheader_finish(struct xheader *xhdr);
 4046|       |char *xheader_xhdr_name(struct tar_stat_info *st);
 4047|       |void sys_stat_nanoseconds(struct tar_stat_info *st);
 4048|       |_Bool sys_file_is_archive(struct tar_stat_info *p);
 4049|       |_Bool sparse_file_p(struct tar_stat_info *st);
 4050|       |enum dump_status sparse_dump_file(int fd, struct tar_stat_info *st);
 4051|       |_Bool string_ascii_p(char const *str);
 4052|       |void *hash_lookup(Hash_table const *table___0, void const *entry);
 4053|       |void *hash_get_first(Hash_table const *table___0);
 4054|       |void *hash_get_next(Hash_table const *table___0, void const *entry);
 4055|       |Hash_table *hash_initialize(size_t candidate, Hash_tuning const *tuning,
 4056|       |                            size_t (*hasher)(void const *, size_t),
 4057|       |                            _Bool (*comparator)(void const *, void const *),
 4058|       |                            void (*data_freer)(void *));
 4059|       |void *hash_insert(Hash_table *table___0, void const *entry);
 4060|      0|static void to_octal(uintmax_t value, char *where, size_t size) {
 4061|      0|  uintmax_t v;
 4062|      0|  size_t i;
 4063|       |
 4064|      0|  {
 4065|      0|    v = value;
 4066|      0|    i = size;
 4067|      0|    {
 4068|      0|      while (1) {
 4069|      0|      while_continue: /* CIL Label */;
 4070|      0|        i--;
 4071|      0|        *(where + i) = (char)(48UL + (v & (unsigned long)((1 << 3) - 1)));
 4072|      0|        v >>= 3;
 4073|      0|        if (!i) {
 4074|      0|          goto while_break;
 4075|      0|        }
 4076|      0|      }
 4077|      0|    while_break: /* CIL Label */;
 4078|      0|    }
 4079|      0|    return;
 4080|      0|  }
 4081|      0|}
 4082|       |static void to_base256(int negative, uintmax_t value, char *where,
 4083|      0|                       size_t size) {
 4084|      0|  uintmax_t v;
 4085|      0|  uintmax_t propagated_sign_bits;
 4086|      0|  size_t i;
 4087|       |
 4088|      0|  {
 4089|      0|    v = value;
 4090|      0|    propagated_sign_bits = (uintmax_t)(-negative) << (8UL * sizeof(v) - 8UL);
 4091|      0|    i = size;
 4092|      0|    {
 4093|      0|      while (1) {
 4094|      0|      while_continue: /* CIL Label */;
 4095|      0|        i--;
 4096|      0|        *(where + i) = (char)(v & (unsigned long)((1 << 8) - 1));
 4097|      0|        v = propagated_sign_bits | (v >> 8);
 4098|      0|        if (!i) {
 4099|      0|          goto while_break;
 4100|      0|        }
 4101|      0|      }
 4102|      0|    while_break: /* CIL Label */;
 4103|      0|    }
 4104|      0|    return;
 4105|      0|  }
 4106|      0|}
 4107|       |static int warned_once;
 4108|       |static void to_chars(int negative, uintmax_t value, size_t valsize,
 4109|       |                     uintmax_t (*substitute)(int *), char *where, size_t size,
 4110|      0|                     char const *type) {
 4111|      0|  int base256_allowed;
 4112|      0|  char *tmp;
 4113|      0|  uintmax_t maxval;
 4114|      0|  char valbuf[((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL) +
 4115|      0|              1UL];
 4116|      0|  char maxbuf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
 4117|      0|  char minbuf[((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL) +
 4118|      0|              1UL];
 4119|      0|  char const *minval_string;
 4120|      0|  char const *maxval_string;
 4121|      0|  char *tmp___0;
 4122|      0|  char const *value_string;
 4123|      0|  uintmax_t m;
 4124|      0|  char *p;
 4125|      0|  char *tmp___1;
 4126|      0|  char *p___0;
 4127|      0|  char *tmp___2;
 4128|      0|  char *tmp___3;
 4129|      0|  int negsub;
 4130|      0|  uintmax_t sub;
 4131|      0|  uintmax_t tmp___4;
 4132|      0|  uintmax_t s;
 4133|      0|  char subbuf[((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL) +
 4134|      0|              1UL];
 4135|      0|  char *sub_string;
 4136|      0|  char *tmp___5;
 4137|      0|  char *tmp___6;
 4138|      0|  char *tmp___7;
 4139|      0|  int tmp___8;
 4140|      0|  int tmp___9;
 4141|      0|  unsigned long tmp___10;
 4142|      0|  unsigned long tmp___11;
 4143|      0|  unsigned long tmp___12;
 4144|      0|  unsigned long tmp___13;
 4145|      0|  unsigned long tmp___14;
 4146|      0|  unsigned long tmp___15;
 4147|      0|  void *__cil_tmp41;
 4148|      0|  void *__cil_tmp42;
 4149|      0|  void *__cil_tmp43;
 4150|      0|  void *__cil_tmp44;
 4151|      0|  char *__cil_tmp45;
 4152|      0|  char *__cil_tmp46;
 4153|      0|  char *__cil_tmp47;
 4154|      0|  char *__cil_tmp48;
 4155|       |
 4156|      0|  {
 4157|      0|    if ((unsigned int)archive_format == 6U) {
 4158|      0|      tmp___8 = 1;
 4159|      0|    } else {
 4160|      0|      if ((unsigned int)archive_format == 2U) {
 4161|      0|        tmp___8 = 1;
 4162|      0|      } else {
 4163|      0|        tmp___8 = 0;
 4164|      0|      }
 4165|      0|    }
 4166|      0|    base256_allowed = tmp___8;
 4167|      0|    if (!negative) {
 4168|      0|      if ((size - 1UL) * 3UL < sizeof(uintmax_t) * 8UL) {
 4169|      0|        tmp___15 = (1UL << (size - 1UL) * 3UL) - 1UL;
 4170|      0|      } else {
 4171|      0|        tmp___15 = (uintmax_t)-1;
 4172|      0|      }
 4173|      0|      if (value <= tmp___15) {
 4174|      0|        {
 4175|      0|          *(where + (size - 1UL)) = (char)'\000';
 4176|      0|          to_octal(value, where, size - 1UL);
 4177|      0|        }
 4178|      0|      } else {
 4179|      0|        goto _L___5;
 4180|      0|      }
 4181|      0|    } else {
 4182|      0|    _L___5: /* CIL Label */
 4183|      0|      if (negative) {
 4184|      0|        tmp___13 = 0xffffffffffffffffUL - value;
 4185|      0|      } else {
 4186|      0|        tmp___13 = value;
 4187|      0|      }
 4188|      0|      if ((size - 1UL) * 8UL < sizeof(uintmax_t) * 8UL) {
 4189|      0|        tmp___14 = (1UL << (size - 1UL) * 8UL) - 1UL;
 4190|      0|      } else {
 4191|      0|        tmp___14 = (uintmax_t)-1;
 4192|      0|      }
 4193|      0|      if (tmp___13 <= tmp___14) {
 4194|      0|        if (base256_allowed) {
 4195|      0|          if (negative) {
 4196|      0|            tmp___9 = -1;
 4197|      0|          } else {
 4198|      0|            tmp___9 = 1 << 7;
 4199|      0|          }
 4200|      0|          {
 4201|      0|            *(where + 0) = (char)tmp___9;
 4202|      0|            to_base256(negative, value, where + 1, size - 1UL);
 4203|      0|          }
 4204|      0|        } else {
 4205|      0|          goto _L___4;
 4206|      0|        }
 4207|      0|      } else {
 4208|      0|      _L___4: /* CIL Label */
 4209|      0|        if (negative) {
 4210|      0|          if (valsize * 8UL <= (size - 1UL) * 3UL) {
 4211|      0|            if (!warned_once) {
 4212|      0|              {
 4213|      0|                warned_once = 1;
 4214|      0|                tmp = gettext("Generating negative octal headers");
 4215|      0|                error(0, 0, (char const *)tmp);
 4216|      0|              }
 4217|      0|            }
 4218|      0|            *(where + (size - 1UL)) = (char)'\000';
 4219|      0|            if (valsize * 8UL < sizeof(uintmax_t) * 8UL) {
 4220|      0|              tmp___10 = (1UL << valsize * 8UL) - 1UL;
 4221|      0|            } else {
 4222|      0|              tmp___10 = (uintmax_t)-1;
 4223|      0|            }
 4224|      0|            { to_octal(value & tmp___10, where, size - 1UL); }
 4225|      0|          } else {
 4226|      0|            goto _L___3;
 4227|      0|          }
 4228|      0|        } else {
 4229|      0|        _L___3: /* CIL Label */
 4230|      0|          if (base256_allowed) {
 4231|      0|            if ((size - 1UL) * 8UL < sizeof(uintmax_t) * 8UL) {
 4232|      0|              tmp___11 = (1UL << (size - 1UL) * 8UL) - 1UL;
 4233|      0|            } else {
 4234|      0|              tmp___11 = (uintmax_t)-1;
 4235|      0|            }
 4236|      0|            maxval = tmp___11;
 4237|      0|          } else {
 4238|      0|            if ((size - 1UL) * 3UL < sizeof(uintmax_t) * 8UL) {
 4239|      0|              tmp___12 = (1UL << (size - 1UL) * 3UL) - 1UL;
 4240|      0|            } else {
 4241|      0|              tmp___12 = (uintmax_t)-1;
 4242|      0|            }
 4243|      0|            maxval = tmp___12;
 4244|      0|          }
 4245|      0|          {
 4246|      0|            tmp___0 = stringify_uintmax_t_backwards(
 4247|      0|                maxval,
 4248|      0|                maxbuf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
 4249|      0|                          1UL));
 4250|      0|            maxval_string = (char const *)tmp___0;
 4251|      0|          }
 4252|      0|          if (base256_allowed) {
 4253|      0|            if (maxval + 1UL) {
 4254|      0|              m = maxval + 1UL;
 4255|      0|            } else {
 4256|      0|              m = maxval / 2UL + 1UL;
 4257|      0|            }
 4258|      0|            {
 4259|      0|              tmp___1 = stringify_uintmax_t_backwards(
 4260|      0|                  m, (minbuf + 1) +
 4261|      0|                         ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
 4262|      0|                          1UL));
 4263|      0|              p = tmp___1;
 4264|      0|              p--;
 4265|      0|              *p = (char)'-';
 4266|      0|              minval_string = (char const *)p;
 4267|      0|            }
 4268|      0|          } else {
 4269|      0|            minval_string = "0";
 4270|      0|          }
 4271|      0|          if (negative) {
 4272|      0|            {
 4273|      0|              tmp___2 = stringify_uintmax_t_backwards(
 4274|      0|                  -value,
 4275|      0|                  (valbuf + 1) +
 4276|      0|                      ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
 4277|      0|                       1UL));
 4278|      0|              p___0 = tmp___2;
 4279|      0|              p___0--;
 4280|      0|              *p___0 = (char)'-';
 4281|      0|              value_string = (char const *)p___0;
 4282|      0|            }
 4283|      0|          } else {
 4284|      0|            {
 4285|      0|              tmp___3 = stringify_uintmax_t_backwards(
 4286|      0|                  value,
 4287|      0|                  valbuf +
 4288|      0|                      ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
 4289|      0|                       1UL));
 4290|      0|              value_string = (char const *)tmp___3;
 4291|      0|            }
 4292|      0|          }
 4293|      0|          if (substitute) {
 4294|      0|            {
 4295|      0|              tmp___4 = (*substitute)(&negsub);
 4296|      0|              sub = tmp___4 & maxval;
 4297|      0|              negsub &= (unsigned int)archive_format == 6U;
 4298|      0|            }
 4299|      0|            if (negsub) {
 4300|      0|              s = -sub;
 4301|      0|            } else {
 4302|      0|              s = sub;
 4303|      0|            }
 4304|      0|            {
 4305|      0|              tmp___5 = stringify_uintmax_t_backwards(
 4306|      0|                  s, (subbuf + 1) +
 4307|      0|                         ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
 4308|      0|                          1UL));
 4309|      0|              sub_string = tmp___5;
 4310|      0|            }
 4311|      0|            if (negsub) {
 4312|      0|              sub_string--;
 4313|      0|              *sub_string = (char)'-';
 4314|      0|            }
 4315|      0|            {
 4316|      0|              tmp___6 =
 4317|      0|                  gettext("value %s out of %s range %s..%s; substituting %s");
 4318|      0|              error(0, 0, (char const *)tmp___6, value_string, type,
 4319|      0|                    minval_string, maxval_string, sub_string);
 4320|      0|              to_chars(negsub, s, valsize, (uintmax_t(*)(int *))0, where, size,
 4321|      0|                       type);
 4322|      0|            }
 4323|      0|          } else {
 4324|      0|            {
 4325|      0|              tmp___7 = gettext("value %s out of %s range %s..%s");
 4326|      0|              error(0, 0, (char const *)tmp___7, value_string, type,
 4327|      0|                    minval_string, maxval_string);
 4328|      0|              exit_status = 2;
 4329|      0|            }
 4330|      0|          }
 4331|      0|        }
 4332|      0|      }
 4333|      0|    }
 4334|      0|    return;
 4335|      0|  }
 4336|      0|}
 4337|       |static gid_t gid_nobody;
 4338|      0|static uintmax_t gid_substitute(int *negative) {
 4339|      0|  gid_t r;
 4340|      0|  int tmp;
 4341|      0|  char *__cil_tmp4;
 4342|       |
 4343|      0|  {
 4344|      0|    if (!gid_nobody) {
 4345|      0|      {
 4346|      0|        tmp = gname_to_gid("nobody", &gid_nobody);
 4347|      0|      }
 4348|      0|      if (!tmp) {
 4349|      0|        gid_nobody = (gid_t)-2;
 4350|      0|      }
 4351|      0|    }
 4352|      0|    r = gid_nobody;
 4353|      0|    *negative = r < 0U;
 4354|      0|    return ((uintmax_t)r);
 4355|      0|  }
 4356|      0|}
 4357|      0|void gid_to_chars(gid_t v, char *p, size_t s) {
 4358|      0|  char *__cil_tmp4;
 4359|       |
 4360|      0|  {
 4361|      0|    {
 4362|      0|      to_chars(v < 0U, (uintmax_t)v, sizeof(v), &gid_substitute, p, s, "gid_t");
 4363|      0|    }
 4364|      0|    return;
 4365|      0|  }
 4366|      0|}
 4367|      0|void major_to_chars(int v, char *p, size_t s) {
 4368|      0|  char *__cil_tmp4;
 4369|       |
 4370|      0|  {
 4371|      0|    {
 4372|      0|      to_chars(v < 0, (uintmax_t)v, sizeof(v), (uintmax_t(*)(int *))0, p, s,
 4373|      0|               "major_t");
 4374|      0|    }
 4375|      0|    return;
 4376|      0|  }
 4377|      0|}
 4378|      0|void minor_to_chars(int v, char *p, size_t s) {
 4379|      0|  char *__cil_tmp4;
 4380|       |
 4381|      0|  {
 4382|      0|    {
 4383|      0|      to_chars(v < 0, (uintmax_t)v, sizeof(v), (uintmax_t(*)(int *))0, p, s,
 4384|      0|               "minor_t");
 4385|      0|    }
 4386|      0|    return;
 4387|      0|  }
 4388|      0|}
 4389|      0|void mode_to_chars(mode_t v, char *p, size_t s) {
 4390|      0|  int negative;
 4391|      0|  uintmax_t u;
 4392|      0|  int tmp;
 4393|      0|  int tmp___0;
 4394|      0|  int tmp___1;
 4395|      0|  int tmp___2;
 4396|      0|  int tmp___3;
 4397|      0|  int tmp___4;
 4398|      0|  int tmp___5;
 4399|      0|  int tmp___6;
 4400|      0|  int tmp___7;
 4401|      0|  int tmp___8;
 4402|      0|  int tmp___9;
 4403|      0|  int tmp___10;
 4404|      0|  char *__cil_tmp18;
 4405|       |
 4406|      0|  {
 4407|      0|    if (256 >> 3 == 32) {
 4408|      0|      if (128 >> 3 == 16) {
 4409|      0|        if (64 >> 3 == 8) {
 4410|      0|          if ((256 >> 3) >> 3 == 4) {
 4411|      0|            if ((128 >> 3) >> 3 == 2) {
 4412|      0|              if ((64 >> 3) >> 3 == 1) {
 4413|      0|                if ((unsigned int)archive_format != 4U) {
 4414|      0|                  if ((unsigned int)archive_format != 3U) {
 4415|      0|                    if ((unsigned int)archive_format != 6U) {
 4416|      0|                      negative = v < 0U;
 4417|      0|                      u = (uintmax_t)v;
 4418|      0|                    } else {
 4419|      0|                      goto _L___10;
 4420|      0|                    }
 4421|      0|                  } else {
 4422|      0|                    goto _L___10;
 4423|      0|                  }
 4424|      0|                } else {
 4425|      0|                  goto _L___10;
 4426|      0|                }
 4427|      0|              } else {
 4428|      0|                goto _L___10;
 4429|      0|              }
 4430|      0|            } else {
 4431|      0|              goto _L___10;
 4432|      0|            }
 4433|      0|          } else {
 4434|      0|            goto _L___10;
 4435|      0|          }
 4436|      0|        } else {
 4437|      0|          goto _L___10;
 4438|      0|        }
 4439|      0|      } else {
 4440|      0|        goto _L___10;
 4441|      0|      }
 4442|      0|    } else {
 4443|      0|    _L___10: /* CIL Label */
 4444|      0|      negative = 0;
 4445|      0|      if (v & 2048U) {
 4446|      0|        tmp = 2048;
 4447|      0|      } else {
 4448|      0|        tmp = 0;
 4449|      0|      }
 4450|      0|      if (v & 1024U) {
 4451|      0|        tmp___0 = 1024;
 4452|      0|      } else {
 4453|      0|        tmp___0 = 0;
 4454|      0|      }
 4455|      0|      if (v & 512U) {
 4456|      0|        tmp___1 = 512;
 4457|      0|      } else {
 4458|      0|        tmp___1 = 0;
 4459|      0|      }
 4460|      0|      if (v & 256U) {
 4461|      0|        tmp___2 = 256;
 4462|      0|      } else {
 4463|      0|        tmp___2 = 0;
 4464|      0|      }
 4465|      0|      if (v & 128U) {
 4466|      0|        tmp___3 = 128;
 4467|      0|      } else {
 4468|      0|        tmp___3 = 0;
 4469|      0|      }
 4470|      0|      if (v & 64U) {
 4471|      0|        tmp___4 = 64;
 4472|      0|      } else {
 4473|      0|        tmp___4 = 0;
 4474|      0|      }
 4475|      0|      if (v & (unsigned int)(256 >> 3)) {
 4476|      0|        tmp___5 = 32;
 4477|      0|      } else {
 4478|      0|        tmp___5 = 0;
 4479|      0|      }
 4480|      0|      if (v & (unsigned int)(128 >> 3)) {
 4481|      0|        tmp___6 = 16;
 4482|      0|      } else {
 4483|      0|        tmp___6 = 0;
 4484|      0|      }
 4485|      0|      if (v & (unsigned int)(64 >> 3)) {
 4486|      0|        tmp___7 = 8;
 4487|      0|      } else {
 4488|      0|        tmp___7 = 0;
 4489|      0|      }
 4490|      0|      if (v & (unsigned int)((256 >> 3) >> 3)) {
 4491|      0|        tmp___8 = 4;
 4492|      0|      } else {
 4493|      0|        tmp___8 = 0;
 4494|      0|      }
 4495|      0|      if (v & (unsigned int)((128 >> 3) >> 3)) {
 4496|      0|        tmp___9 = 2;
 4497|      0|      } else {
 4498|      0|        tmp___9 = 0;
 4499|      0|      }
 4500|      0|      if (v & (unsigned int)((64 >> 3) >> 3)) {
 4501|      0|        tmp___10 = 1;
 4502|      0|      } else {
 4503|      0|        tmp___10 = 0;
 4504|      0|      }
 4505|      0|      u = (uintmax_t)(
 4506|      0|          ((((((((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) |
 4507|      0|               tmp___5) |
 4508|      0|              tmp___6) |
 4509|      0|             tmp___7) |
 4510|      0|            tmp___8) |
 4511|      0|           tmp___9) |
 4512|      0|          tmp___10);
 4513|      0|    }
 4514|      0|    {
 4515|      0|      to_chars(negative, u, sizeof(v), (uintmax_t(*)(int *))0, p, s, "mode_t");
 4516|      0|    }
 4517|      0|    return;
 4518|      0|  }
 4519|      0|}
 4520|      0|void off_to_chars(off_t v, char *p, size_t s) {
 4521|      0|  char *__cil_tmp4;
 4522|       |
 4523|      0|  {
 4524|      0|    {
 4525|      0|      to_chars(v < 0L, (uintmax_t)v, sizeof(v), (uintmax_t(*)(int *))0, p, s,
 4526|      0|               "off_t");
 4527|      0|    }
 4528|      0|    return;
 4529|      0|  }
 4530|      0|}
 4531|      0|void size_to_chars(size_t v, char *p, size_t s) {
 4532|      0|  char *__cil_tmp4;
 4533|       |
 4534|      0|  {
 4535|      0|    { to_chars(0, v, sizeof(v), (uintmax_t(*)(int *))0, p, s, "size_t"); }
 4536|      0|    return;
 4537|      0|  }
 4538|      0|}
 4539|      0|void time_to_chars(time_t v, char *p, size_t s) {
 4540|      0|  char *__cil_tmp4;
 4541|       |
 4542|      0|  {
 4543|      0|    {
 4544|      0|      to_chars(v < 0L, (uintmax_t)v, sizeof(v), (uintmax_t(*)(int *))0, p, s,
 4545|      0|               "time_t");
 4546|      0|    }
 4547|      0|    return;
 4548|      0|  }
 4549|      0|}
 4550|       |static uid_t uid_nobody;
 4551|      0|static uintmax_t uid_substitute(int *negative) {
 4552|      0|  uid_t r;
 4553|      0|  int tmp;
 4554|      0|  char *__cil_tmp4;
 4555|       |
 4556|      0|  {
 4557|      0|    if (!uid_nobody) {
 4558|      0|      {
 4559|      0|        tmp = uname_to_uid("nobody", &uid_nobody);
 4560|      0|      }
 4561|      0|      if (!tmp) {
 4562|      0|        uid_nobody = (uid_t)-2;
 4563|      0|      }
 4564|      0|    }
 4565|      0|    r = uid_nobody;
 4566|      0|    *negative = r < 0U;
 4567|      0|    return ((uintmax_t)r);
 4568|      0|  }
 4569|      0|}
 4570|      0|void uid_to_chars(uid_t v, char *p, size_t s) {
 4571|      0|  char *__cil_tmp4;
 4572|       |
 4573|      0|  {
 4574|      0|    {
 4575|      0|      to_chars(v < 0U, (uintmax_t)v, sizeof(v), &uid_substitute, p, s, "uid_t");
 4576|      0|    }
 4577|      0|    return;
 4578|      0|  }
 4579|      0|}
 4580|      0|void uintmax_to_chars(uintmax_t v, char *p, size_t s) {
 4581|      0|  char *__cil_tmp4;
 4582|       |
 4583|      0|  {
 4584|      0|    { to_chars(0, v, sizeof(v), (uintmax_t(*)(int *))0, p, s, "uintmax_t"); }
 4585|      0|    return;
 4586|      0|  }
 4587|      0|}
 4588|      0|void string_to_chars(char *str, char *p, size_t s) {
 4589|       |
 4590|      0|  {
 4591|      0|    {
 4592|      0|      strncpy((char * /* __restrict  */)p, (char const * /* __restrict  */)str,
 4593|      0|              s);
 4594|      0|      *(p + (s - 1UL)) = (char)0;
 4595|      0|    }
 4596|      0|    return;
 4597|      0|  }
 4598|      0|}
 4599|      0|_Bool file_dumpable_p(struct tar_stat_info *st) {
 4600|      0|  int tmp;
 4601|       |
 4602|      0|  {
 4603|      0|    if (dev_null_output) {
 4604|      0|      tmp = 0;
 4605|      0|    } else {
 4606|      0|      if (st->archive_file_size == 0L) {
 4607|      0|        if ((st->stat.st_mode &
 4608|      0|             (unsigned int)((256 | (256 >> 3)) | ((256 >> 3) >> 3))) ==
 4609|      0|            (unsigned int)((256 | (256 >> 3)) | ((256 >> 3) >> 3))) {
 4610|      0|          tmp = 0;
 4611|      0|        } else {
 4612|      0|          tmp = 1;
 4613|      0|        }
 4614|      0|      } else {
 4615|      0|        tmp = 1;
 4616|      0|      }
 4617|      0|    }
 4618|      0|    return ((_Bool)tmp);
 4619|      0|  }
 4620|      0|}
 4621|      0|void write_eot(void) {
 4622|      0|  union block *pointer;
 4623|      0|  union block *tmp;
 4624|      0|  size_t tmp___0;
 4625|       |
 4626|      0|  {
 4627|      0|    {
 4628|      0|      tmp = find_next_block();
 4629|      0|      pointer = tmp;
 4630|      0|      memset((void *)(pointer->buffer), 0, (size_t)512);
 4631|      0|      set_next_block_after(pointer);
 4632|      0|      pointer = find_next_block();
 4633|      0|      tmp___0 = available_space_after(pointer);
 4634|      0|      memset((void *)(pointer->buffer), 0, tmp___0);
 4635|      0|      set_next_block_after(pointer);
 4636|      0|    }
 4637|      0|    return;
 4638|      0|  }
 4639|      0|}
 4640|      0|static void tar_copy_str(char *dst, char const *src, size_t len) {
 4641|       |
 4642|      0|  {
 4643|      0|    {
 4644|      0|      *(dst + (len - 1UL)) = (char)0;
 4645|      0|      strncpy((char * /* __restrict  */)dst,
 4646|      0|              (char const * /* __restrict  */)src, len);
 4647|      0|    }
 4648|      0|    return;
 4649|      0|  }
 4650|      0|}
 4651|      0|union block *start_private_header(char const *name, size_t size) {
 4652|      0|  time_t t;
 4653|      0|  union block *header;
 4654|      0|  union block *tmp;
 4655|      0|  __uid_t tmp___0;
 4656|      0|  __gid_t tmp___1;
 4657|      0|  char *__cil_tmp8;
 4658|      0|  char *__cil_tmp9;
 4659|       |
 4660|      0|  {
 4661|      0|    {
 4662|      0|      tmp = find_next_block();
 4663|      0|      header = tmp;
 4664|      0|      memset((void *)(header->buffer), 0, sizeof(union block));
 4665|      0|      tar_copy_str(header->header.name, name, (size_t)100);
 4666|      0|      off_to_chars((off_t)size, header->header.size,
 4667|      0|                   sizeof(header->header.size));
 4668|      0|      time(&t);
 4669|      0|      time_to_chars(t, header->header.mtime, sizeof(header->header.mtime));
 4670|      0|      mode_to_chars((mode_t)((33152 | (256 >> 3)) | ((256 >> 3) >> 3)),
 4671|      0|                    header->header.mode, sizeof(header->header.mode));
 4672|      0|      tmp___0 = getuid();
 4673|      0|      uid_to_chars(tmp___0, header->header.uid, sizeof(header->header.uid));
 4674|      0|      tmp___1 = getgid();
 4675|      0|      gid_to_chars(tmp___1, header->header.gid, sizeof(header->header.gid));
 4676|      0|      major_to_chars(0, header->header.devmajor,
 4677|      0|                     sizeof(header->header.devmajor));
 4678|      0|      major_to_chars(0, header->header.devminor,
 4679|      0|                     sizeof(header->header.devminor));
 4680|      0|      strncpy((char * /* __restrict  */)(header->header.magic),
 4681|      0|              (char const * /* __restrict  */) "ustar", (size_t)6);
 4682|      0|      strncpy((char * /* __restrict  */)(header->header.version),
 4683|      0|              (char const * /* __restrict  */) "00", (size_t)2);
 4684|      0|    }
 4685|      0|    return (header);
 4686|      0|  }
 4687|      0|}
 4688|      0|static union block *write_short_name(struct tar_stat_info *st) {
 4689|      0|  union block *header;
 4690|      0|  union block *tmp;
 4691|       |
 4692|      0|  {
 4693|      0|    {
 4694|      0|      tmp = find_next_block();
 4695|      0|      header = tmp;
 4696|      0|      memset((void *)(header->buffer), 0, sizeof(union block));
 4697|      0|      tar_copy_str(header->header.name, (char const *)st->file_name,
 4698|      0|                   (size_t)100);
 4699|      0|    }
 4700|      0|    return (header);
 4701|      0|  }
 4702|      0|}
 4703|       |static void write_gnu_long_link(struct tar_stat_info *st, char const *p,
 4704|      0|                                char type) {
 4705|      0|  size_t size;
 4706|      0|  size_t tmp;
 4707|      0|  size_t bufsize;
 4708|      0|  union block *header;
 4709|      0|  char *__cil_tmp8;
 4710|      0|  char *__cil_tmp9;
 4711|       |
 4712|      0|  {
 4713|      0|    {
 4714|      0|      tmp = strlen(p);
 4715|      0|      size = tmp + 1UL;
 4716|      0|      header = start_private_header("././@LongLink", size);
 4717|      0|      strcpy((char * /* __restrict  */)(header->header.magic),
 4718|      0|             (char const * /* __restrict  */) "ustar  ");
 4719|      0|      header->header.typeflag = type;
 4720|      0|      finish_header(st, header, (off_t)-1);
 4721|      0|      header = find_next_block();
 4722|      0|      bufsize = available_space_after(header);
 4723|      0|    }
 4724|      0|    {
 4725|      0|      while (1) {
 4726|      0|      while_continue: /* CIL Label */;
 4727|      0|        if (!(bufsize < size)) {
 4728|      0|          goto while_break;
 4729|      0|        }
 4730|      0|        {
 4731|      0|          memcpy((void * /* __restrict  */)(header->buffer),
 4732|      0|                 (void const * /* __restrict  */)p, bufsize);
 4733|      0|          p += bufsize;
 4734|      0|          size -= bufsize;
 4735|      0|          set_next_block_after(header + (bufsize - 1UL) / 512UL);
 4736|      0|          header = find_next_block();
 4737|      0|          bufsize = available_space_after(header);
 4738|      0|        }
 4739|      0|      }
 4740|      0|    while_break: /* CIL Label */;
 4741|      0|    }
 4742|      0|    {
 4743|      0|      memcpy((void * /* __restrict  */)(header->buffer),
 4744|      0|             (void const * /* __restrict  */)p, size);
 4745|      0|      memset((void *)(header->buffer + size), 0, bufsize - size);
 4746|      0|      set_next_block_after(header + (size - 1UL) / 512UL);
 4747|      0|    }
 4748|      0|    return;
 4749|      0|  }
 4750|      0|}
 4751|      0|static size_t split_long_name(char const *name, size_t length) {
 4752|      0|  size_t i;
 4753|       |
 4754|      0|  {
 4755|      0|    if (length > 155UL) {
 4756|      0|      length = (size_t)157;
 4757|      0|    }
 4758|      0|    i = length - 1UL;
 4759|      0|    {
 4760|      0|      while (1) {
 4761|      0|      while_continue: /* CIL Label */;
 4762|      0|        if (!(i > 0UL)) {
 4763|      0|          goto while_break;
 4764|      0|        }
 4765|      0|        if ((int const) * (name + i) == 47) {
 4766|      0|          goto while_break;
 4767|      0|        }
 4768|      0|        i--;
 4769|      0|      }
 4770|      0|    while_break: /* CIL Label */;
 4771|      0|    }
 4772|      0|    return (i);
 4773|      0|  }
 4774|      0|}
 4775|      0|static union block *write_ustar_long_name(char const *name) {
 4776|      0|  size_t length;
 4777|      0|  size_t tmp;
 4778|      0|  size_t i;
 4779|      0|  union block *header;
 4780|      0|  char *tmp___0;
 4781|      0|  char *tmp___1;
 4782|      0|  char *tmp___2;
 4783|      0|  char *tmp___3;
 4784|      0|  char *__cil_tmp10;
 4785|      0|  char *__cil_tmp11;
 4786|      0|  char *__cil_tmp12;
 4787|       |
 4788|      0|  {
 4789|      0|    {
 4790|      0|      tmp = strlen(name);
 4791|      0|      length = tmp;
 4792|      0|    }
 4793|      0|    if (length > 256UL) {
 4794|      0|      {
 4795|      0|        tmp___0 = quotearg_colon(name);
 4796|      0|        tmp___1 = gettext("%s: file name is too long (max %d); not dumped");
 4797|      0|        error(0, 0, (char const *)tmp___1, tmp___0, 256);
 4798|      0|        exit_status = 2;
 4799|      0|      }
 4800|      0|      return ((union block *)((void *)0));
 4801|      0|    }
 4802|      0|    { i = split_long_name(name, length); }
 4803|      0|    if (i == 0UL) {
 4804|      0|      {
 4805|      0|        tmp___2 = quotearg_colon(name);
 4806|      0|        tmp___3 =
 4807|      0|            gettext("%s: file name is too long (cannot be split); not dumped");
 4808|      0|        error(0, 0, (char const *)tmp___3, tmp___2);
 4809|      0|        exit_status = 2;
 4810|      0|      }
 4811|      0|      return ((union block *)((void *)0));
 4812|      0|    } else {
 4813|      0|      if ((length - i) - 1UL > 100UL) {
 4814|      0|        {
 4815|      0|          tmp___2 = quotearg_colon(name);
 4816|      0|          tmp___3 = gettext(
 4817|      0|              "%s: file name is too long (cannot be split); not dumped");
 4818|      0|          error(0, 0, (char const *)tmp___3, tmp___2);
 4819|      0|          exit_status = 2;
 4820|      0|        }
 4821|      0|        return ((union block *)((void *)0));
 4822|      0|      }
 4823|      0|    }
 4824|      0|    {
 4825|      0|      header = find_next_block();
 4826|      0|      memset((void *)(header->buffer), 0, sizeof(header->buffer));
 4827|      0|      memcpy((void * /* __restrict  */)(header->header.prefix),
 4828|      0|             (void const * /* __restrict  */)name, i);
 4829|      0|      memcpy((void * /* __restrict  */)(header->header.name),
 4830|      0|             (void const * /* __restrict  */)((name + i) + 1),
 4831|      0|             (length - i) - 1UL);
 4832|      0|    }
 4833|      0|    return (header);
 4834|      0|  }
 4835|      0|}
 4836|      0|static void write_long_link(struct tar_stat_info *st) {
 4837|      0|  char *tmp;
 4838|      0|  char *tmp___0;
 4839|      0|  char *__cil_tmp4;
 4840|      0|  char *__cil_tmp5;
 4841|       |
 4842|      0|  {
 4843|      0|    {
 4844|      0|      if ((unsigned int)archive_format == 4U) {
 4845|      0|        goto case_4;
 4846|      0|      }
 4847|      0|      if ((unsigned int)archive_format == 1U) {
 4848|      0|        goto case_1;
 4849|      0|      }
 4850|      0|      if ((unsigned int)archive_format == 3U) {
 4851|      0|        goto case_1;
 4852|      0|      }
 4853|      0|      if ((unsigned int)archive_format == 5U) {
 4854|      0|        goto case_1;
 4855|      0|      }
 4856|      0|      if ((unsigned int)archive_format == 2U) {
 4857|      0|        goto case_2;
 4858|      0|      }
 4859|      0|      if ((unsigned int)archive_format == 6U) {
 4860|      0|        goto case_2;
 4861|      0|      }
 4862|      0|      goto switch_default;
 4863|      0|    case_4 : /* CIL Label */
 4864|      0|    {
 4865|      0|      xheader_store("linkpath", (struct tar_stat_info const *)st, (void *)0);
 4866|      0|    }
 4867|      0|      goto switch_break;
 4868|      0|    case_1:  /* CIL Label */
 4869|      0|    case_3:  /* CIL Label */
 4870|      0|    case_5 : /* CIL Label */
 4871|      0|    {
 4872|      0|      tmp = quotearg_colon((char const *)st->link_name);
 4873|      0|      tmp___0 = gettext("%s: link name is too long; not dumped");
 4874|      0|      error(0, 0, (char const *)tmp___0, tmp);
 4875|      0|      exit_status = 2;
 4876|      0|    }
 4877|      0|      goto switch_break;
 4878|      0|    case_2:  /* CIL Label */
 4879|      0|    case_6 : /* CIL Label */
 4880|      0|    {
 4881|      0|      write_gnu_long_link(st, (char const *)st->link_name, (char)'K');
 4882|      0|    }
 4883|      0|      goto switch_break;
 4884|      0|    switch_default : /* CIL Label */
 4885|      0|    {
 4886|      0|      abort();
 4887|      0|    }
 4888|      0|    switch_break: /* CIL Label */;
 4889|      0|    }
 4890|      0|    return;
 4891|      0|  }
 4892|      0|}
 4893|      0|static union block *write_long_name(struct tar_stat_info *st) {
 4894|      0|  char *tmp;
 4895|      0|  char *tmp___0;
 4896|      0|  size_t tmp___1;
 4897|      0|  union block *tmp___2;
 4898|      0|  union block *tmp___3;
 4899|      0|  char *__cil_tmp7;
 4900|      0|  char *__cil_tmp8;
 4901|       |
 4902|      0|  {
 4903|      0|    {
 4904|      0|      if ((unsigned int)archive_format == 4U) {
 4905|      0|        goto case_4;
 4906|      0|      }
 4907|      0|      if ((unsigned int)archive_format == 1U) {
 4908|      0|        goto case_1;
 4909|      0|      }
 4910|      0|      if ((unsigned int)archive_format == 3U) {
 4911|      0|        goto case_3;
 4912|      0|      }
 4913|      0|      if ((unsigned int)archive_format == 5U) {
 4914|      0|        goto case_3;
 4915|      0|      }
 4916|      0|      if ((unsigned int)archive_format == 2U) {
 4917|      0|        goto case_2;
 4918|      0|      }
 4919|      0|      if ((unsigned int)archive_format == 6U) {
 4920|      0|        goto case_2;
 4921|      0|      }
 4922|      0|      goto switch_default;
 4923|      0|    case_4 : /* CIL Label */
 4924|      0|    {
 4925|      0|      xheader_store("path", (struct tar_stat_info const *)st, (void *)0);
 4926|      0|    }
 4927|      0|      goto switch_break;
 4928|      0|    case_1 : /* CIL Label */
 4929|      0|    {
 4930|      0|      tmp___1 = strlen((char const *)st->file_name);
 4931|      0|    }
 4932|      0|      if (tmp___1 > 99UL) {
 4933|      0|        {
 4934|      0|          tmp = quotearg_colon((char const *)st->file_name);
 4935|      0|          tmp___0 = gettext("%s: file name is too long (max %d); not dumped");
 4936|      0|          error(0, 0, (char const *)tmp___0, tmp, 99);
 4937|      0|          exit_status = 2;
 4938|      0|        }
 4939|      0|        return ((union block *)((void *)0));
 4940|      0|      }
 4941|      0|      goto switch_break;
 4942|      0|    case_3:  /* CIL Label */
 4943|      0|    case_5 : /* CIL Label */
 4944|      0|    {
 4945|      0|      tmp___2 = write_ustar_long_name((char const *)st->file_name);
 4946|      0|    }
 4947|      0|      return (tmp___2);
 4948|      0|    case_2:  /* CIL Label */
 4949|      0|    case_6 : /* CIL Label */
 4950|      0|    {
 4951|      0|      write_gnu_long_link(st, (char const *)st->file_name, (char)'L');
 4952|      0|    }
 4953|      0|      goto switch_break;
 4954|      0|    switch_default : /* CIL Label */
 4955|      0|    {
 4956|      0|      abort();
 4957|      0|    }
 4958|      0|    switch_break: /* CIL Label */;
 4959|      0|    }
 4960|      0|    { tmp___3 = write_short_name(st); }
 4961|      0|    return (tmp___3);
 4962|      0|  }
 4963|      0|}
 4964|       |static union block *write_extended(struct tar_stat_info *st,
 4965|      0|                                   union block *old_header) {
 4966|      0|  union block *header;
 4967|      0|  union block hp;
 4968|      0|  char *p;
 4969|      0|  void *__cil_tmp6;
 4970|      0|  void *__cil_tmp7;
 4971|      0|  void *__cil_tmp8;
 4972|      0|  void *__cil_tmp9;
 4973|      0|  void *__cil_tmp10;
 4974|      0|  void *__cil_tmp11;
 4975|      0|  void *__cil_tmp12;
 4976|      0|  void *__cil_tmp13;
 4977|      0|  void *__cil_tmp14;
 4978|      0|  void *__cil_tmp15;
 4979|      0|  void *__cil_tmp16;
 4980|      0|  void *__cil_tmp17;
 4981|      0|  void *__cil_tmp18;
 4982|      0|  void *__cil_tmp19;
 4983|      0|  void *__cil_tmp20;
 4984|      0|  void *__cil_tmp21;
 4985|      0|  void *__cil_tmp22;
 4986|      0|  void *__cil_tmp23;
 4987|      0|  void *__cil_tmp24;
 4988|      0|  void *__cil_tmp25;
 4989|      0|  void *__cil_tmp26;
 4990|      0|  void *__cil_tmp27;
 4991|      0|  void *__cil_tmp28;
 4992|      0|  void *__cil_tmp29;
 4993|      0|  void *__cil_tmp30;
 4994|      0|  void *__cil_tmp31;
 4995|      0|  void *__cil_tmp32;
 4996|      0|  void *__cil_tmp33;
 4997|      0|  void *__cil_tmp34;
 4998|      0|  void *__cil_tmp35;
 4999|      0|  void *__cil_tmp36;
 5000|      0|  void *__cil_tmp37;
 5001|      0|  void *__cil_tmp38;
 5002|      0|  void *__cil_tmp39;
 5003|      0|  void *__cil_tmp40;
 5004|      0|  void *__cil_tmp41;
 5005|      0|  void *__cil_tmp42;
 5006|      0|  void *__cil_tmp43;
 5007|      0|  void *__cil_tmp44;
 5008|      0|  int __cil_tmp45;
 5009|      0|  void *__cil_tmp46;
 5010|      0|  void *__cil_tmp47;
 5011|      0|  void *__cil_tmp48;
 5012|      0|  void *__cil_tmp49;
 5013|      0|  int __cil_tmp50;
 5014|      0|  void *__cil_tmp51;
 5015|      0|  void *__cil_tmp52;
 5016|      0|  void *__cil_tmp53;
 5017|      0|  void *__cil_tmp54;
 5018|      0|  void *__cil_tmp55;
 5019|      0|  void *__cil_tmp56;
 5020|      0|  int __cil_tmp57;
 5021|      0|  void *__cil_tmp58;
 5022|      0|  void *__cil_tmp59;
 5023|      0|  void *__cil_tmp60;
 5024|      0|  void *__cil_tmp61;
 5025|      0|  void *__cil_tmp62;
 5026|      0|  void *__cil_tmp63;
 5027|      0|  void *__cil_tmp64;
 5028|      0|  void *__cil_tmp65;
 5029|      0|  void *__cil_tmp66;
 5030|      0|  int __cil_tmp67;
 5031|      0|  void *__cil_tmp68;
 5032|      0|  void *__cil_tmp69;
 5033|       |
 5034|      0|  {
 5035|      0|    if (extended_header.buffer) {
 5036|      0|      return (old_header);
 5037|      0|    } else {
 5038|      0|      if ((unsigned long)extended_header.stk == (unsigned long)((void *)0)) {
 5039|      0|        return (old_header);
 5040|      0|      }
 5041|      0|    }
 5042|      0|    {
 5043|      0|      xheader_finish(&extended_header);
 5044|      0|      memcpy((void * /* __restrict  */)(hp.buffer),
 5045|      0|             (void const * /* __restrict  */)old_header, sizeof(hp));
 5046|      0|      p = xheader_xhdr_name(st);
 5047|      0|      xheader_write((char)'x', p, &extended_header);
 5048|      0|      free((void *)p);
 5049|      0|      header = find_next_block();
 5050|      0|      memcpy((void * /* __restrict  */)header,
 5051|      0|             (void const * /* __restrict  */)(&hp.buffer), sizeof(hp.buffer));
 5052|      0|    }
 5053|      0|    return (header);
 5054|      0|  }
 5055|      0|}
 5056|      0|static union block *write_header_name(struct tar_stat_info *st) {
 5057|      0|  union block *tmp;
 5058|      0|  union block *tmp___0;
 5059|      0|  union block *tmp___1;
 5060|      0|  size_t tmp___2;
 5061|      0|  _Bool tmp___3;
 5062|      0|  char *__cil_tmp7;
 5063|       |
 5064|      0|  {
 5065|      0|    if ((unsigned int)archive_format == 4U) {
 5066|      0|      {
 5067|      0|        tmp___3 = string_ascii_p((char const *)st->file_name);
 5068|      0|      }
 5069|      0|      if (tmp___3) {
 5070|      0|        goto _L;
 5071|      0|      } else {
 5072|      0|        {
 5073|      0|          xheader_store("path", (struct tar_stat_info const *)st, (void *)0);
 5074|      0|          tmp = write_short_name(st);
 5075|      0|        }
 5076|      0|        return (tmp);
 5077|      0|      }
 5078|      0|    } else {
 5079|      0|    _L : { tmp___2 = strlen((char const *)st->file_name); }
 5080|      0|      if (100UL < tmp___2) {
 5081|      0|        {
 5082|      0|          tmp___0 = write_long_name(st);
 5083|      0|        }
 5084|      0|        return (tmp___0);
 5085|      0|      } else {
 5086|      0|        { tmp___1 = write_short_name(st); }
 5087|      0|        return (tmp___1);
 5088|      0|      }
 5089|      0|    }
 5090|      0|  }
 5091|      0|}
 5092|      0|union block *start_header(struct tar_stat_info *st) {
 5093|      0|  union block *header;
 5094|      0|  mode_t tmp;
 5095|      0|  size_t tmp___0;
 5096|      0|  _Bool tmp___1;
 5097|      0|  size_t tmp___2;
 5098|      0|  _Bool tmp___3;
 5099|      0|  int tmp___4;
 5100|      0|  char *__cil_tmp9;
 5101|      0|  char *__cil_tmp10;
 5102|      0|  char *__cil_tmp11;
 5103|      0|  char *__cil_tmp12;
 5104|      0|  char *__cil_tmp13;
 5105|      0|  char *__cil_tmp14;
 5106|      0|  char *__cil_tmp15;
 5107|      0|  char *__cil_tmp16;
 5108|      0|  char *__cil_tmp17;
 5109|      0|  char *__cil_tmp18;
 5110|      0|  char *__cil_tmp19;
 5111|      0|  char *__cil_tmp20;
 5112|      0|  char *__cil_tmp21;
 5113|      0|  char *__cil_tmp22;
 5114|       |
 5115|      0|  {
 5116|      0|    { header = write_header_name(st); }
 5117|      0|    if (!header) {
 5118|      0|      return ((union block *)((void *)0));
 5119|      0|    }
 5120|      0|    if (owner_option != 4294967295U) {
 5121|      0|      st->stat.st_uid = owner_option;
 5122|      0|    }
 5123|      0|    if (group_option != 4294967295U) {
 5124|      0|      st->stat.st_gid = group_option;
 5125|      0|    }
 5126|      0|    if (mode_option) {
 5127|      0|      {
 5128|      0|        tmp = mode_adjust(st->stat.st_mode,
 5129|      0|                          (struct mode_change const *)mode_option);
 5130|      0|        st->stat.st_mode =
 5131|      0|            (st->stat.st_mode &
 5132|      0|             (unsigned int)(~(3584 |
 5133|      0|                              (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 5134|      0|                               (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 5135|      0|                                ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))))) |
 5136|      0|            tmp;
 5137|      0|      }
 5138|      0|    }
 5139|      0|    if ((unsigned int)archive_format == 1U) {
 5140|      0|      {
 5141|      0|        mode_to_chars(
 5142|      0|            st->stat.st_mode &
 5143|      0|                (unsigned int)(3584 |
 5144|      0|                               (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 5145|      0|                                (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 5146|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))),
 5147|      0|            header->header.mode, sizeof(header->header.mode));
 5148|      0|      }
 5149|      0|    } else {
 5150|      0|      if ((unsigned int)archive_format == 3U) {
 5151|      0|        {
 5152|      0|          mode_to_chars(
 5153|      0|              st->stat.st_mode &
 5154|      0|                  (unsigned int)(3584 |
 5155|      0|                                 (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 5156|      0|                                  (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 5157|      0|                                   ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))),
 5158|      0|              header->header.mode, sizeof(header->header.mode));
 5159|      0|        }
 5160|      0|      } else {
 5161|      0|        {
 5162|      0|          mode_to_chars(st->stat.st_mode, header->header.mode,
 5163|      0|                        sizeof(header->header.mode));
 5164|      0|        }
 5165|      0|      }
 5166|      0|    }
 5167|      0|    if (st->stat.st_uid > 2097151U) {
 5168|      0|      if ((unsigned int)archive_format == 4U) {
 5169|      0|        {
 5170|      0|          xheader_store("uid", (struct tar_stat_info const *)st, (void *)0);
 5171|      0|        }
 5172|      0|      } else {
 5173|      0|        {
 5174|      0|          uid_to_chars(st->stat.st_uid, header->header.uid,
 5175|      0|                       sizeof(header->header.uid));
 5176|      0|        }
 5177|      0|      }
 5178|      0|    } else {
 5179|      0|      {
 5180|      0|        uid_to_chars(st->stat.st_uid, header->header.uid,
 5181|      0|                     sizeof(header->header.uid));
 5182|      0|      }
 5183|      0|    }
 5184|      0|    if (st->stat.st_gid > 2097151U) {
 5185|      0|      if ((unsigned int)archive_format == 4U) {
 5186|      0|        {
 5187|      0|          xheader_store("gid", (struct tar_stat_info const *)st, (void *)0);
 5188|      0|        }
 5189|      0|      } else {
 5190|      0|        {
 5191|      0|          gid_to_chars(st->stat.st_gid, header->header.gid,
 5192|      0|                       sizeof(header->header.gid));
 5193|      0|        }
 5194|      0|      }
 5195|      0|    } else {
 5196|      0|      {
 5197|      0|        gid_to_chars(st->stat.st_gid, header->header.gid,
 5198|      0|                     sizeof(header->header.gid));
 5199|      0|      }
 5200|      0|    }
 5201|      0|    if (st->stat.st_size > 2147483647L) {
 5202|      0|      if ((unsigned int)archive_format == 4U) {
 5203|      0|        {
 5204|      0|          xheader_store("size", (struct tar_stat_info const *)st, (void *)0);
 5205|      0|        }
 5206|      0|      } else {
 5207|      0|        {
 5208|      0|          off_to_chars(st->stat.st_size, header->header.size,
 5209|      0|                       sizeof(header->header.size));
 5210|      0|        }
 5211|      0|      }
 5212|      0|    } else {
 5213|      0|      {
 5214|      0|        off_to_chars(st->stat.st_size, header->header.size,
 5215|      0|                     sizeof(header->header.size));
 5216|      0|      }
 5217|      0|    }
 5218|      0|    {
 5219|      0|      time_to_chars(st->stat.st_mtim.tv_sec, header->header.mtime,
 5220|      0|                    sizeof(header->header.mtime));
 5221|      0|    }
 5222|      0|    if ((st->stat.st_mode & 61440U) == 8192U) {
 5223|      0|      goto _L___3;
 5224|      0|    } else {
 5225|      0|      if ((st->stat.st_mode & 61440U) == 24576U) {
 5226|      0|      _L___3 : /* CIL Label */
 5227|      0|      {
 5228|      0|        st->devmajor = gnu_dev_major((unsigned long long)st->stat.st_rdev);
 5229|      0|        st->devminor = gnu_dev_minor((unsigned long long)st->stat.st_rdev);
 5230|      0|      }
 5231|      0|        if (st->devmajor > 2097151U) {
 5232|      0|          if ((unsigned int)archive_format == 4U) {
 5233|      0|            {
 5234|      0|              xheader_store("devmajor", (struct tar_stat_info const *)st,
 5235|      0|                            (void *)0);
 5236|      0|            }
 5237|      0|          } else {
 5238|      0|            {
 5239|      0|              major_to_chars((int)st->devmajor, header->header.devmajor,
 5240|      0|                             sizeof(header->header.devmajor));
 5241|      0|            }
 5242|      0|          }
 5243|      0|        } else {
 5244|      0|          {
 5245|      0|            major_to_chars((int)st->devmajor, header->header.devmajor,
 5246|      0|                           sizeof(header->header.devmajor));
 5247|      0|          }
 5248|      0|        }
 5249|      0|        if (st->devminor > 2097151U) {
 5250|      0|          if ((unsigned int)archive_format == 4U) {
 5251|      0|            {
 5252|      0|              xheader_store("devminor", (struct tar_stat_info const *)st,
 5253|      0|                            (void *)0);
 5254|      0|            }
 5255|      0|          } else {
 5256|      0|            {
 5257|      0|              major_to_chars((int)st->devminor, header->header.devminor,
 5258|      0|                             sizeof(header->header.devminor));
 5259|      0|            }
 5260|      0|          }
 5261|      0|        } else {
 5262|      0|          {
 5263|      0|            major_to_chars((int)st->devminor, header->header.devminor,
 5264|      0|                           sizeof(header->header.devminor));
 5265|      0|          }
 5266|      0|        }
 5267|      0|      } else {
 5268|      0|        {
 5269|      0|          major_to_chars(0, header->header.devmajor,
 5270|      0|                         sizeof(header->header.devmajor));
 5271|      0|          minor_to_chars(0, header->header.devminor,
 5272|      0|                         sizeof(header->header.devminor));
 5273|      0|        }
 5274|      0|      }
 5275|      0|    }
 5276|      0|    if ((unsigned int)archive_format == 4U) {
 5277|      0|      {
 5278|      0|        xheader_store("atime", (struct tar_stat_info const *)st, (void *)0);
 5279|      0|        xheader_store("ctime", (struct tar_stat_info const *)st, (void *)0);
 5280|      0|      }
 5281|      0|    } else {
 5282|      0|      if (incremental_option) {
 5283|      0|        if ((unsigned int)archive_format == 2U) {
 5284|      0|          {
 5285|      0|            time_to_chars(st->stat.st_atim.tv_sec, header->oldgnu_header.atime,
 5286|      0|                          sizeof(header->oldgnu_header.atime));
 5287|      0|            time_to_chars(st->stat.st_ctim.tv_sec, header->oldgnu_header.ctime,
 5288|      0|                          sizeof(header->oldgnu_header.ctime));
 5289|      0|          }
 5290|      0|        } else {
 5291|      0|          if ((unsigned int)archive_format == 6U) {
 5292|      0|            {
 5293|      0|              time_to_chars(st->stat.st_atim.tv_sec,
 5294|      0|                            header->oldgnu_header.atime,
 5295|      0|                            sizeof(header->oldgnu_header.atime));
 5296|      0|              time_to_chars(st->stat.st_ctim.tv_sec,
 5297|      0|                            header->oldgnu_header.ctime,
 5298|      0|                            sizeof(header->oldgnu_header.ctime));
 5299|      0|            }
 5300|      0|          }
 5301|      0|        }
 5302|      0|      }
 5303|      0|    }
 5304|      0|    if ((unsigned int)archive_format == 1U) {
 5305|      0|      tmp___4 = '\000';
 5306|      0|    } else {
 5307|      0|      tmp___4 = '0';
 5308|      0|    }
 5309|      0|    header->header.typeflag = (char)tmp___4;
 5310|      0|    {
 5311|      0|      if ((unsigned int)archive_format == 1U) {
 5312|      0|        goto case_1;
 5313|      0|      }
 5314|      0|      if ((unsigned int)archive_format == 2U) {
 5315|      0|        goto case_2;
 5316|      0|      }
 5317|      0|      if ((unsigned int)archive_format == 6U) {
 5318|      0|        goto case_2;
 5319|      0|      }
 5320|      0|      if ((unsigned int)archive_format == 4U) {
 5321|      0|        goto case_4;
 5322|      0|      }
 5323|      0|      if ((unsigned int)archive_format == 3U) {
 5324|      0|        goto case_4;
 5325|      0|      }
 5326|      0|      goto switch_default;
 5327|      0|    case_1: /* CIL Label */
 5328|      0|      goto switch_break;
 5329|      0|    case_2:  /* CIL Label */
 5330|      0|    case_6 : /* CIL Label */
 5331|      0|    {
 5332|      0|      strcpy((char * /* __restrict  */)(header->header.magic),
 5333|      0|             (char const * /* __restrict  */) "ustar  ");
 5334|      0|    }
 5335|      0|      goto switch_break;
 5336|      0|    case_4:  /* CIL Label */
 5337|      0|    case_3 : /* CIL Label */
 5338|      0|    {
 5339|      0|      strncpy((char * /* __restrict  */)(header->header.magic),
 5340|      0|              (char const * /* __restrict  */) "ustar", (size_t)6);
 5341|      0|      strncpy((char * /* __restrict  */)(header->header.version),
 5342|      0|              (char const * /* __restrict  */) "00", (size_t)2);
 5343|      0|    }
 5344|      0|      goto switch_break;
 5345|      0|    switch_default : /* CIL Label */
 5346|      0|    {
 5347|      0|      abort();
 5348|      0|    }
 5349|      0|    switch_break: /* CIL Label */;
 5350|      0|    }
 5351|      0|    if (!((unsigned int)archive_format == 1U)) {
 5352|      0|      if (!numeric_owner_option) {
 5353|      0|        {
 5354|      0|          uid_to_uname(st->stat.st_uid, &st->uname);
 5355|      0|          gid_to_gname(st->stat.st_gid, &st->gname);
 5356|      0|        }
 5357|      0|        if ((unsigned int)archive_format == 4U) {
 5358|      0|          {
 5359|      0|            tmp___0 = strlen((char const *)st->uname);
 5360|      0|          }
 5361|      0|          if (tmp___0 > 32UL) {
 5362|      0|            {
 5363|      0|              xheader_store("uname", (struct tar_stat_info const *)st,
 5364|      0|                            (void *)0);
 5365|      0|            }
 5366|      0|          } else {
 5367|      0|            { tmp___1 = string_ascii_p((char const *)st->uname); }
 5368|      0|            if (tmp___1) {
 5369|      0|              {
 5370|      0|                string_to_chars(st->uname, header->header.uname,
 5371|      0|                                sizeof(header->header.uname));
 5372|      0|              }
 5373|      0|            } else {
 5374|      0|              {
 5375|      0|                xheader_store("uname", (struct tar_stat_info const *)st,
 5376|      0|                              (void *)0);
 5377|      0|              }
 5378|      0|            }
 5379|      0|          }
 5380|      0|        } else {
 5381|      0|          {
 5382|      0|            string_to_chars(st->uname, header->header.uname,
 5383|      0|                            sizeof(header->header.uname));
 5384|      0|          }
 5385|      0|        }
 5386|      0|        if ((unsigned int)archive_format == 4U) {
 5387|      0|          {
 5388|      0|            tmp___2 = strlen((char const *)st->gname);
 5389|      0|          }
 5390|      0|          if (tmp___2 > 32UL) {
 5391|      0|            {
 5392|      0|              xheader_store("gname", (struct tar_stat_info const *)st,
 5393|      0|                            (void *)0);
 5394|      0|            }
 5395|      0|          } else {
 5396|      0|            { tmp___3 = string_ascii_p((char const *)st->gname); }
 5397|      0|            if (tmp___3) {
 5398|      0|              {
 5399|      0|                string_to_chars(st->gname, header->header.gname,
 5400|      0|                                sizeof(header->header.gname));
 5401|      0|              }
 5402|      0|            } else {
 5403|      0|              {
 5404|      0|                xheader_store("gname", (struct tar_stat_info const *)st,
 5405|      0|                              (void *)0);
 5406|      0|              }
 5407|      0|            }
 5408|      0|          }
 5409|      0|        } else {
 5410|      0|          {
 5411|      0|            string_to_chars(st->gname, header->header.gname,
 5412|      0|                            sizeof(header->header.gname));
 5413|      0|          }
 5414|      0|        }
 5415|      0|      }
 5416|      0|    }
 5417|      0|    return (header);
 5418|      0|  }
 5419|      0|}
 5420|      0|void simple_finish_header(union block *header) {
 5421|      0|  size_t i;
 5422|      0|  int sum;
 5423|      0|  char *p;
 5424|      0|  char *tmp;
 5425|      0|  size_t tmp___0;
 5426|      0|  char *__cil_tmp7;
 5427|       |
 5428|      0|  {
 5429|      0|    {
 5430|      0|      memcpy((void * /* __restrict  */)(header->header.chksum),
 5431|      0|             (void const * /* __restrict  */) "        ",
 5432|      0|             sizeof(header->header.chksum));
 5433|      0|      sum = 0;
 5434|      0|      p = header->buffer;
 5435|      0|      i = sizeof(*header);
 5436|      0|    }
 5437|      0|    {
 5438|      0|      while (1) {
 5439|      0|      while_continue: /* CIL Label */;
 5440|      0|        tmp___0 = i;
 5441|      0|        i--;
 5442|      0|        if (!(tmp___0 != 0UL)) {
 5443|      0|          goto while_break;
 5444|      0|        }
 5445|      0|        tmp = p;
 5446|      0|        p++;
 5447|      0|        sum += 255 & (int)*tmp;
 5448|      0|      }
 5449|      0|    while_break: /* CIL Label */;
 5450|      0|    }
 5451|      0|    {
 5452|      0|      uintmax_to_chars((uintmax_t)sum, header->header.chksum, (size_t)7);
 5453|      0|      set_next_block_after(header);
 5454|      0|    }
 5455|      0|    return;
 5456|      0|  }
 5457|      0|}
 5458|       |void finish_header(struct tar_stat_info *st, union block *header,
 5459|      0|                   off_t block_ordinal) {
 5460|       |
 5461|      0|  {
 5462|      0|    if (verbose_option) {
 5463|      0|      if ((int)header->header.typeflag != 75) {
 5464|      0|        if ((int)header->header.typeflag != 76) {
 5465|      0|          if ((int)header->header.typeflag != 120) {
 5466|      0|            if ((int)header->header.typeflag != 103) {
 5467|      0|              {
 5468|      0|                current_header = header;
 5469|      0|                current_format = archive_format;
 5470|      0|                print_header(st, block_ordinal);
 5471|      0|              }
 5472|      0|            }
 5473|      0|          }
 5474|      0|        }
 5475|      0|      }
 5476|      0|    }
 5477|      0|    {
 5478|      0|      header = write_extended(st, header);
 5479|      0|      simple_finish_header(header);
 5480|      0|    }
 5481|      0|    return;
 5482|      0|  }
 5483|      0|}
 5484|      0|void pad_archive(off_t size_left) {
 5485|      0|  union block *blk;
 5486|       |
 5487|      0|  {
 5488|      0|    {
 5489|      0|      while (1) {
 5490|      0|      while_continue: /* CIL Label */;
 5491|      0|        if (!(size_left > 0L)) {
 5492|      0|          goto while_break;
 5493|      0|        }
 5494|      0|        {
 5495|      0|          save_sizeleft = size_left;
 5496|      0|          blk = find_next_block();
 5497|      0|          memset((void *)(blk->buffer), 0, (size_t)512);
 5498|      0|          set_next_block_after(blk);
 5499|      0|          size_left -= 512L;
 5500|      0|        }
 5501|      0|      }
 5502|      0|    while_break: /* CIL Label */;
 5503|      0|    }
 5504|      0|    return;
 5505|      0|  }
 5506|      0|}
 5507|      0|static enum dump_status dump_regular_file(int fd, struct tar_stat_info *st) {
 5508|      0|  off_t size_left;
 5509|      0|  off_t block_ordinal;
 5510|      0|  union block *blk;
 5511|      0|  size_t bufsize;
 5512|      0|  size_t count;
 5513|      0|  size_t tmp;
 5514|      0|  char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
 5515|      0|  char *tmp___0;
 5516|      0|  char *tmp___1;
 5517|      0|  char *tmp___2;
 5518|      0|  void *__cil_tmp13;
 5519|       |
 5520|      0|  {
 5521|      0|    {
 5522|      0|      size_left = st->stat.st_size;
 5523|      0|      block_ordinal = current_block_ordinal();
 5524|      0|      blk = start_header(st);
 5525|      0|    }
 5526|      0|    if (!blk) {
 5527|      0|      return ((enum dump_status)2);
 5528|      0|    }
 5529|      0|    if ((unsigned int)archive_format != 1U) {
 5530|      0|    }
 5531|      0|    { finish_header(st, blk, block_ordinal); }
 5532|      0|    {
 5533|      0|      while (1) {
 5534|      0|      while_continue: /* CIL Label */;
 5535|      0|        if (!(size_left > 0L)) {
 5536|      0|          goto while_break;
 5537|      0|        }
 5538|      0|        if (multi_volume_option) {
 5539|      0|          {
 5540|      0|            assign_string(&save_name, (char const *)st->file_name);
 5541|      0|            save_sizeleft = size_left;
 5542|      0|            save_totsize = st->stat.st_size;
 5543|      0|          }
 5544|      0|        }
 5545|      0|        {
 5546|      0|          blk = find_next_block();
 5547|      0|          bufsize = available_space_after(blk);
 5548|      0|        }
 5549|      0|        if ((size_t)size_left < bufsize) {
 5550|      0|          bufsize = (size_t)size_left;
 5551|      0|          count = bufsize % 512UL;
 5552|      0|          if (count) {
 5553|      0|            {
 5554|      0|              memset((void *)(blk->buffer + size_left), 0, 512UL - count);
 5555|      0|            }
 5556|      0|          }
 5557|      0|        }
 5558|      0|        if (fd < 0) {
 5559|      0|          count = bufsize;
 5560|      0|        } else {
 5561|      0|          {
 5562|      0|            tmp = safe_read(fd, (void *)(blk->buffer), bufsize);
 5563|      0|            count = tmp;
 5564|      0|          }
 5565|      0|        }
 5566|      0|        if (count == 0xffffffffffffffffUL) {
 5567|      0|          {
 5568|      0|            read_diag_details((char const *)st->orig_file_name,
 5569|      0|                              st->stat.st_size - size_left, bufsize);
 5570|      0|            pad_archive(size_left);
 5571|      0|          }
 5572|      0|          return ((enum dump_status)1);
 5573|      0|        }
 5574|      0|        {
 5575|      0|          size_left = (off_t)((size_t)size_left - count);
 5576|      0|          set_next_block_after(blk + (bufsize - 1UL) / 512UL);
 5577|      0|        }
 5578|      0|        if (count != bufsize) {
 5579|      0|          {
 5580|      0|            memset((void *)(blk->buffer + count), 0, bufsize - count);
 5581|      0|            tmp___0 = stringify_uintmax_t_backwards(
 5582|      0|                (uintmax_t)size_left,
 5583|      0|                buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
 5584|      0|                       1UL));
 5585|      0|            tmp___1 = quotearg_colon((char const *)st->orig_file_name);
 5586|      0|            tmp___2 =
 5587|      0|                ngettext("%s: File shrank by %s byte; padding with zeros",
 5588|      0|                         "%s: File shrank by %s bytes; padding with zeros",
 5589|      0|                         (unsigned long)size_left);
 5590|      0|            error(0, 0, (char const *)tmp___2, tmp___1, tmp___0);
 5591|      0|          }
 5592|      0|          if (!ignore_failed_read_option) {
 5593|      0|            exit_status = 2;
 5594|      0|          }
 5595|      0|          { pad_archive(size_left); }
 5596|      0|          return ((enum dump_status)1);
 5597|      0|        }
 5598|      0|      }
 5599|      0|    while_break: /* CIL Label */;
 5600|      0|    }
 5601|      0|    return ((enum dump_status)0);
 5602|      0|  }
 5603|      0|}
 5604|       |static void dump_regular_finish(int fd, struct tar_stat_info *st,
 5605|      0|                                time_t original_ctime) {
 5606|      0|  struct stat final_stat;
 5607|      0|  char *tmp;
 5608|      0|  char *tmp___0;
 5609|      0|  int tmp___1;
 5610|      0|  int tmp___2;
 5611|      0|  int tmp___3;
 5612|      0|  void *__cil_tmp10;
 5613|      0|  char *__cil_tmp11;
 5614|       |
 5615|      0|  {
 5616|      0|    if (fd >= 0) {
 5617|      0|      {
 5618|      0|        tmp___1 = fstat(fd, &final_stat);
 5619|      0|      }
 5620|      0|      if (tmp___1 != 0) {
 5621|      0|        {
 5622|      0|          stat_diag((char const *)st->orig_file_name);
 5623|      0|        }
 5624|      0|      } else {
 5625|      0|        if (final_stat.st_ctim.tv_sec != original_ctime) {
 5626|      0|          {
 5627|      0|            tmp = quotearg_colon((char const *)st->orig_file_name);
 5628|      0|            tmp___0 = gettext("%s: file changed as we read it");
 5629|      0|            error(0, 0, (char const *)tmp___0, tmp);
 5630|      0|          }
 5631|      0|        }
 5632|      0|      }
 5633|      0|      { tmp___2 = close(fd); }
 5634|      0|      if (tmp___2 != 0) {
 5635|      0|        {
 5636|      0|          close_diag((char const *)st->orig_file_name);
 5637|      0|        }
 5638|      0|      }
 5639|      0|    }
 5640|      0|    if (remove_files_option) {
 5641|      0|      {
 5642|      0|        tmp___3 = unlink((char const *)st->orig_file_name);
 5643|      0|      }
 5644|      0|      if (tmp___3 == -1) {
 5645|      0|        {
 5646|      0|          unlink_error((char const *)st->orig_file_name);
 5647|      0|        }
 5648|      0|      }
 5649|      0|    }
 5650|      0|    return;
 5651|      0|  }
 5652|      0|}
 5653|       |static void dump_dir0(char *directory, struct tar_stat_info *st, int top_level,
 5654|      0|                      dev_t parent_device) {
 5655|      0|  dev_t our_device;
 5656|      0|  union block *blk;
 5657|      0|  off_t block_ordinal;
 5658|      0|  off_t tmp;
 5659|      0|  off_t size_left;
 5660|      0|  off_t totsize;
 5661|      0|  size_t bufsize;
 5662|      0|  ssize_t count;
 5663|      0|  char const *buffer___2;
 5664|      0|  char const *p_buffer;
 5665|      0|  size_t size;
 5666|      0|  size_t tmp___0;
 5667|      0|  _Bool tmp___1;
 5668|      0|  char *tmp___2;
 5669|      0|  char *tmp___3;
 5670|      0|  char const *entry;
 5671|      0|  size_t entry_len;
 5672|      0|  char *name_buf;
 5673|      0|  char *tmp___4;
 5674|      0|  size_t name_size;
 5675|      0|  size_t tmp___5;
 5676|      0|  size_t name_len;
 5677|      0|  void *tmp___6;
 5678|      0|  _Bool tmp___7;
 5679|      0|  char *__cil_tmp29;
 5680|       |
 5681|      0|  {
 5682|      0|    {
 5683|      0|      our_device = st->stat.st_dev;
 5684|      0|      tmp___1 = is_avoided_name((char const *)st->orig_file_name);
 5685|      0|    }
 5686|      0|    if (!tmp___1) {
 5687|      0|      {
 5688|      0|        blk = (union block *)((void *)0);
 5689|      0|        tmp = current_block_ordinal();
 5690|      0|        block_ordinal = tmp;
 5691|      0|        st->stat.st_size = (__off_t)0;
 5692|      0|        blk = start_header(st);
 5693|      0|      }
 5694|      0|      if (!blk) {
 5695|      0|        return;
 5696|      0|      }
 5697|      0|      if (incremental_option) {
 5698|      0|        blk->header.typeflag = (char)'D';
 5699|      0|      } else {
 5700|      0|        blk->header.typeflag = (char)'5';
 5701|      0|      }
 5702|      0|      if (!incremental_option) {
 5703|      0|        {
 5704|      0|          finish_header(st, blk, block_ordinal);
 5705|      0|        }
 5706|      0|      } else {
 5707|      0|        if (gnu_list_name->dir_contents) {
 5708|      0|          {
 5709|      0|            block_ordinal = current_block_ordinal();
 5710|      0|            buffer___2 = gnu_list_name->dir_contents;
 5711|      0|            totsize = (off_t)0;
 5712|      0|          }
 5713|      0|          if (buffer___2) {
 5714|      0|            p_buffer = buffer___2;
 5715|      0|            {
 5716|      0|              while (1) {
 5717|      0|              while_continue: /* CIL Label */;
 5718|      0|                if (!*p_buffer) {
 5719|      0|                  goto while_break;
 5720|      0|                }
 5721|      0|                {
 5722|      0|                  tmp___0 = strlen(p_buffer);
 5723|      0|                  size = tmp___0 + 1UL;
 5724|      0|                  totsize = (off_t)((size_t)totsize + size);
 5725|      0|                  p_buffer += size;
 5726|      0|                }
 5727|      0|              }
 5728|      0|            while_break: /* CIL Label */;
 5729|      0|            }
 5730|      0|          }
 5731|      0|          {
 5732|      0|            totsize++;
 5733|      0|            off_to_chars(totsize, blk->header.size, sizeof(blk->header.size));
 5734|      0|            finish_header(st, blk, block_ordinal);
 5735|      0|            p_buffer = buffer___2;
 5736|      0|            size_left = totsize;
 5737|      0|          }
 5738|      0|          {
 5739|      0|            while (1) {
 5740|      0|            while_continue___0: /* CIL Label */;
 5741|      0|              if (!(size_left > 0L)) {
 5742|      0|                goto while_break___0;
 5743|      0|              }
 5744|      0|              if (multi_volume_option) {
 5745|      0|                {
 5746|      0|                  assign_string(&save_name, (char const *)st->orig_file_name);
 5747|      0|                  save_sizeleft = size_left;
 5748|      0|                  save_totsize = totsize;
 5749|      0|                }
 5750|      0|              }
 5751|      0|              {
 5752|      0|                blk = find_next_block();
 5753|      0|                bufsize = available_space_after(blk);
 5754|      0|              }
 5755|      0|              if ((size_t)size_left < bufsize) {
 5756|      0|                bufsize = (size_t)size_left;
 5757|      0|                count = (ssize_t)(bufsize % 512UL);
 5758|      0|                if (count) {
 5759|      0|                  {
 5760|      0|                    memset((void *)(blk->buffer + size_left), 0,
 5761|      0|                           (size_t)(512L - count));
 5762|      0|                  }
 5763|      0|                }
 5764|      0|              }
 5765|      0|              {
 5766|      0|                memcpy((void * /* __restrict  */)(blk->buffer),
 5767|      0|                       (void const * /* __restrict  */)p_buffer, bufsize);
 5768|      0|                size_left = (off_t)((size_t)size_left - bufsize);
 5769|      0|                p_buffer += bufsize;
 5770|      0|                set_next_block_after(blk + (bufsize - 1UL) / 512UL);
 5771|      0|              }
 5772|      0|            }
 5773|      0|          while_break___0: /* CIL Label */;
 5774|      0|          }
 5775|      0|          if (multi_volume_option) {
 5776|      0|            {
 5777|      0|              assign_string(&save_name, (char const *)0);
 5778|      0|            }
 5779|      0|          }
 5780|      0|          return;
 5781|      0|        }
 5782|      0|      }
 5783|      0|    }
 5784|      0|    if (!recursion_option) {
 5785|      0|      return;
 5786|      0|    }
 5787|      0|    if (one_file_system_option) {
 5788|      0|      if (!top_level) {
 5789|      0|        if (parent_device != st->stat.st_dev) {
 5790|      0|          if (verbose_option) {
 5791|      0|            {
 5792|      0|              tmp___2 = quotearg_colon((char const *)st->orig_file_name);
 5793|      0|              tmp___3 =
 5794|      0|                  gettext("%s: file is on a different filesystem; not dumped");
 5795|      0|              error(0, 0, (char const *)tmp___3, tmp___2);
 5796|      0|            }
 5797|      0|          }
 5798|      0|          return;
 5799|      0|        }
 5800|      0|      }
 5801|      0|    }
 5802|      0|    {
 5803|      0|      tmp___4 = strdup((char const *)st->orig_file_name);
 5804|      0|      name_buf = tmp___4;
 5805|      0|      tmp___5 = strlen((char const *)name_buf);
 5806|      0|      name_size = tmp___5;
 5807|      0|      name_len = name_size;
 5808|      0|      entry = (char const *)directory;
 5809|      0|    }
 5810|      0|    {
 5811|      0|      while (1) {
 5812|      0|      while_continue___1: /* CIL Label */;
 5813|      0|        { entry_len = strlen(entry); }
 5814|      0|        if (!(entry_len != 0UL)) {
 5815|      0|          goto while_break___1;
 5816|      0|        }
 5817|      0|        if (name_size < name_len + entry_len) {
 5818|      0|          {
 5819|      0|            name_size = name_len + entry_len;
 5820|      0|            tmp___6 = xrealloc((void *)name_buf, name_size + 1UL);
 5821|      0|            name_buf = (char *)tmp___6;
 5822|      0|          }
 5823|      0|        }
 5824|      0|        {
 5825|      0|          strcpy((char * /* __restrict  */)(name_buf + name_len),
 5826|      0|                 (char const * /* __restrict  */)entry);
 5827|      0|          tmp___7 = excluded_name((char const *)name_buf);
 5828|      0|        }
 5829|      0|        if (!tmp___7) {
 5830|      0|          {
 5831|      0|            dump_file(name_buf, 0, our_device);
 5832|      0|          }
 5833|      0|        }
 5834|      0|        entry += entry_len + 1UL;
 5835|      0|      }
 5836|      0|    while_break___1: /* CIL Label */;
 5837|      0|    }
 5838|      0|    { free((void *)name_buf); }
 5839|      0|    return;
 5840|      0|  }
 5841|      0|}
 5842|      0|static void ensure_slash(char **pstr) {
 5843|      0|  size_t len;
 5844|      0|  size_t tmp;
 5845|      0|  void *tmp___0;
 5846|      0|  size_t tmp___1;
 5847|       |
 5848|      0|  {
 5849|      0|    {
 5850|      0|      tmp = strlen((char const *)*pstr);
 5851|      0|      len = tmp;
 5852|      0|    }
 5853|      0|    {
 5854|      0|      while (1) {
 5855|      0|      while_continue: /* CIL Label */;
 5856|      0|        if (len >= 1UL) {
 5857|      0|          if (!((int)*(*pstr + (len - 1UL)) == 47)) {
 5858|      0|            goto while_break;
 5859|      0|          }
 5860|      0|        } else {
 5861|      0|          goto while_break;
 5862|      0|        }
 5863|      0|        len--;
 5864|      0|      }
 5865|      0|    while_break: /* CIL Label */;
 5866|      0|    }
 5867|      0|    if (!((int)*(*pstr + len) == 47)) {
 5868|      0|      {
 5869|      0|        tmp___0 = xrealloc((void *)*pstr, len + 2UL);
 5870|      0|        *pstr = (char *)tmp___0;
 5871|      0|      }
 5872|      0|    }
 5873|      0|    tmp___1 = len;
 5874|      0|    len++;
 5875|      0|    *(*pstr + tmp___1) = (char)'/';
 5876|      0|    *(*pstr + len) = (char)'\000';
 5877|      0|    return;
 5878|      0|  }
 5879|      0|}
 5880|       |static _Bool dump_dir(struct tar_stat_info *st, int top_level,
 5881|      0|                      dev_t parent_device) {
 5882|      0|  char *directory;
 5883|       |
 5884|      0|  {
 5885|      0|    { directory = savedir((char const *)st->orig_file_name); }
 5886|      0|    if (!directory) {
 5887|      0|      {
 5888|      0|        savedir_diag((char const *)st->orig_file_name);
 5889|      0|      }
 5890|      0|      return ((_Bool)0);
 5891|      0|    }
 5892|      0|    {
 5893|      0|      ensure_slash(&st->orig_file_name);
 5894|      0|      ensure_slash(&st->file_name);
 5895|      0|      dump_dir0(directory, st, top_level, parent_device);
 5896|      0|      free((void *)directory);
 5897|      0|    }
 5898|      0|    return ((_Bool)1);
 5899|      0|  }
 5900|      0|}
 5901|      0|void create_archive(void) {
 5902|      0|  char *p;
 5903|      0|  size_t buffer_size;
 5904|      0|  char *buffer___2;
 5905|      0|  void *tmp;
 5906|      0|  char const *q;
 5907|      0|  _Bool tmp___0;
 5908|      0|  size_t plen;
 5909|      0|  size_t tmp___1;
 5910|      0|  void *tmp___2;
 5911|      0|  size_t tmp___3;
 5912|      0|  size_t qlen;
 5913|      0|  size_t tmp___4;
 5914|      0|  void *tmp___5;
 5915|      0|  _Bool tmp___6;
 5916|      0|  _Bool tmp___7;
 5917|       |
 5918|      0|  {
 5919|      0|    {
 5920|      0|      open_archive((enum access_mode)1);
 5921|      0|      xheader_write_global();
 5922|      0|    }
 5923|      0|    if (incremental_option) {
 5924|      0|      {
 5925|      0|        buffer_size = (size_t)1000;
 5926|      0|        tmp = xmalloc(buffer_size);
 5927|      0|        buffer___2 = (char *)tmp;
 5928|      0|        collect_and_sort_names();
 5929|      0|      }
 5930|      0|      {
 5931|      0|        while (1) {
 5932|      0|        while_continue: /* CIL Label */;
 5933|      0|          { p = name_from_list(); }
 5934|      0|          if (!((unsigned long)p != (unsigned long)((void *)0))) {
 5935|      0|            goto while_break;
 5936|      0|          }
 5937|      0|          { tmp___0 = excluded_name((char const *)p); }
 5938|      0|          if (!tmp___0) {
 5939|      0|            {
 5940|      0|              dump_file(p, -1, (dev_t)0);
 5941|      0|            }
 5942|      0|          }
 5943|      0|        }
 5944|      0|      while_break: /* CIL Label */;
 5945|      0|      }
 5946|      0|      { blank_name_list(); }
 5947|      0|      {
 5948|      0|        while (1) {
 5949|      0|        while_continue___0: /* CIL Label */;
 5950|      0|          { p = name_from_list(); }
 5951|      0|          if (!((unsigned long)p != (unsigned long)((void *)0))) {
 5952|      0|            goto while_break___0;
 5953|      0|          }
 5954|      0|          { tmp___6 = excluded_name((char const *)p); }
 5955|      0|          if (!tmp___6) {
 5956|      0|            {
 5957|      0|              tmp___1 = strlen((char const *)p);
 5958|      0|              plen = tmp___1;
 5959|      0|            }
 5960|      0|            if (buffer_size <= plen) {
 5961|      0|              {
 5962|      0|                while (1) {
 5963|      0|                while_continue___1: /* CIL Label */;
 5964|      0|                  buffer_size *= 2UL;
 5965|      0|                  if (!(buffer_size <= plen)) {
 5966|      0|                    goto while_break___1;
 5967|      0|                  }
 5968|      0|                  goto while_continue___1;
 5969|      0|                }
 5970|      0|              while_break___1: /* CIL Label */;
 5971|      0|              }
 5972|      0|              {
 5973|      0|                tmp___2 = xrealloc((void *)buffer___2, buffer_size);
 5974|      0|                buffer___2 = (char *)tmp___2;
 5975|      0|              }
 5976|      0|            }
 5977|      0|            {
 5978|      0|              memcpy((void * /* __restrict  */)buffer___2,
 5979|      0|                     (void const * /* __restrict  */)p, plen);
 5980|      0|            }
 5981|      0|            if (!((int)*(buffer___2 + (plen - 1UL)) == 47)) {
 5982|      0|              tmp___3 = plen;
 5983|      0|              plen++;
 5984|      0|              *(buffer___2 + tmp___3) = (char)'/';
 5985|      0|            }
 5986|      0|            q = gnu_list_name->dir_contents;
 5987|      0|            if (q) {
 5988|      0|              {
 5989|      0|                while (1) {
 5990|      0|                while_continue___2: /* CIL Label */;
 5991|      0|                  if (!*q) {
 5992|      0|                    goto while_break___2;
 5993|      0|                  }
 5994|      0|                  {
 5995|      0|                    tmp___4 = strlen(q);
 5996|      0|                    qlen = tmp___4;
 5997|      0|                  }
 5998|      0|                  if ((int const) * q == 89) {
 5999|      0|                    if (buffer_size < plen + qlen) {
 6000|      0|                      {
 6001|      0|                        while (1) {
 6002|      0|                        while_continue___3: /* CIL Label */;
 6003|      0|                          buffer_size *= 2UL;
 6004|      0|                          if (!(buffer_size < plen + qlen)) {
 6005|      0|                            goto while_break___3;
 6006|      0|                          }
 6007|      0|                          goto while_continue___3;
 6008|      0|                        }
 6009|      0|                      while_break___3: /* CIL Label */;
 6010|      0|                      }
 6011|      0|                      {
 6012|      0|                        tmp___5 = xrealloc((void *)buffer___2, buffer_size);
 6013|      0|                        buffer___2 = (char *)tmp___5;
 6014|      0|                      }
 6015|      0|                    }
 6016|      0|                    {
 6017|      0|                      strcpy((char * /* __restrict  */)(buffer___2 + plen),
 6018|      0|                             (char const * /* __restrict  */)(q + 1));
 6019|      0|                      dump_file(buffer___2, -1, (dev_t)0);
 6020|      0|                    }
 6021|      0|                  }
 6022|      0|                  q += qlen + 1UL;
 6023|      0|                }
 6024|      0|              while_break___2: /* CIL Label */;
 6025|      0|              }
 6026|      0|            }
 6027|      0|          }
 6028|      0|        }
 6029|      0|      while_break___0: /* CIL Label */;
 6030|      0|      }
 6031|      0|      { free((void *)buffer___2); }
 6032|      0|    } else {
 6033|      0|      {
 6034|      0|        while (1) {
 6035|      0|        while_continue___4: /* CIL Label */;
 6036|      0|          { p = name_next(1); }
 6037|      0|          if (!((unsigned long)p != (unsigned long)((void *)0))) {
 6038|      0|            goto while_break___4;
 6039|      0|          }
 6040|      0|          { tmp___7 = excluded_name((char const *)p); }
 6041|      0|          if (!tmp___7) {
 6042|      0|            {
 6043|      0|              dump_file(p, 1, (dev_t)0);
 6044|      0|            }
 6045|      0|          }
 6046|      0|        }
 6047|      0|      while_break___4: /* CIL Label */;
 6048|      0|      }
 6049|      0|    }
 6050|      0|    {
 6051|      0|      write_eot();
 6052|      0|      close_archive();
 6053|      0|    }
 6054|      0|    if (listed_incremental_option) {
 6055|      0|      {
 6056|      0|        write_directory_file();
 6057|      0|      }
 6058|      0|    }
 6059|      0|    return;
 6060|      0|  }
 6061|      0|}
 6062|      0|static unsigned int hash_link(void const *entry, unsigned int n_buckets) {
 6063|      0|  struct link const *l;
 6064|      0|  uintmax_t num;
 6065|       |
 6066|      0|  {
 6067|      0|    l = (struct link const *)entry;
 6068|      0|    num = (uintmax_t)(l->dev ^ l->ino);
 6069|      0|    return ((unsigned int)(num % (unsigned long)n_buckets));
 6070|      0|  }
 6071|      0|}
 6072|      0|static _Bool compare_links(void const *entry1, void const *entry2) {
 6073|      0|  struct link const *link1;
 6074|      0|  struct link const *link2;
 6075|       |
 6076|      0|  {
 6077|      0|    link1 = (struct link const *)entry1;
 6078|      0|    link2 = (struct link const *)entry2;
 6079|      0|    return ((_Bool)(((link1->dev ^ link2->dev) | (link1->ino ^ link2->ino)) ==
 6080|      0|                    0UL));
 6081|      0|  }
 6082|      0|}
 6083|      0|static void unknown_file_error(char *p) {
 6084|      0|  char *tmp;
 6085|      0|  char *tmp___0;
 6086|      0|  char *__cil_tmp4;
 6087|       |
 6088|      0|  {
 6089|      0|    {
 6090|      0|      tmp = quotearg_colon((char const *)p);
 6091|      0|      tmp___0 = gettext("%s: Unknown file type; file ignored");
 6092|      0|      error(0, 0, (char const *)tmp___0, tmp);
 6093|      0|    }
 6094|      0|    if (!ignore_failed_read_option) {
 6095|      0|      exit_status = 2;
 6096|      0|    }
 6097|      0|    return;
 6098|      0|  }
 6099|      0|}
 6100|       |static Hash_table *link_table;
 6101|      0|static _Bool dump_hard_link(struct tar_stat_info *st) {
 6102|      0|  struct link lp;
 6103|      0|  struct link *duplicate;
 6104|      0|  off_t block_ordinal;
 6105|      0|  union block *blk;
 6106|      0|  char const *link_name;
 6107|      0|  char *tmp;
 6108|      0|  size_t tmp___0;
 6109|      0|  int tmp___1;
 6110|      0|  void *tmp___2;
 6111|      0|  void *__cil_tmp11;
 6112|       |
 6113|      0|  {
 6114|      0|    if (link_table) {
 6115|      0|      if (st->stat.st_nlink > 1UL) {
 6116|      0|        {
 6117|      0|          lp.ino = st->stat.st_ino;
 6118|      0|          lp.dev = st->stat.st_dev;
 6119|      0|          tmp___2 =
 6120|      0|              hash_lookup((Hash_table const *)link_table, (void const *)(&lp));
 6121|      0|          duplicate = (struct link *)tmp___2;
 6122|      0|        }
 6123|      0|        if (duplicate) {
 6124|      0|          {
 6125|      0|            tmp = safer_name_suffix((char const *)(duplicate->name), (_Bool)1);
 6126|      0|            link_name = (char const *)tmp;
 6127|      0|            (duplicate->nlink)--;
 6128|      0|            block_ordinal = current_block_ordinal();
 6129|      0|            assign_string(&st->link_name, link_name);
 6130|      0|            tmp___0 = strlen(link_name);
 6131|      0|          }
 6132|      0|          if (100UL < tmp___0) {
 6133|      0|            {
 6134|      0|              write_long_link(st);
 6135|      0|            }
 6136|      0|          }
 6137|      0|          {
 6138|      0|            st->stat.st_size = (__off_t)0;
 6139|      0|            blk = start_header(st);
 6140|      0|          }
 6141|      0|          if (!blk) {
 6142|      0|            return ((_Bool)1);
 6143|      0|          }
 6144|      0|          {
 6145|      0|            tar_copy_str(blk->header.linkname, link_name, (size_t)100);
 6146|      0|            blk->header.typeflag = (char)'1';
 6147|      0|            finish_header(st, blk, block_ordinal);
 6148|      0|          }
 6149|      0|          if (remove_files_option) {
 6150|      0|            {
 6151|      0|              tmp___1 = unlink((char const *)st->orig_file_name);
 6152|      0|            }
 6153|      0|            if (tmp___1 != 0) {
 6154|      0|              {
 6155|      0|                unlink_error((char const *)st->orig_file_name);
 6156|      0|              }
 6157|      0|            }
 6158|      0|          }
 6159|      0|          return ((_Bool)1);
 6160|      0|        }
 6161|      0|      }
 6162|      0|    }
 6163|      0|    return ((_Bool)0);
 6164|      0|  }
 6165|      0|}
 6166|      0|static void file_count_links(struct tar_stat_info *st) {
 6167|      0|  struct link *duplicate;
 6168|      0|  struct link *lp;
 6169|      0|  size_t tmp;
 6170|      0|  void *tmp___0;
 6171|      0|  void *tmp___1;
 6172|       |
 6173|      0|  {
 6174|      0|    if (st->stat.st_nlink > 1UL) {
 6175|      0|      {
 6176|      0|        tmp = strlen((char const *)st->orig_file_name);
 6177|      0|        tmp___0 =
 6178|      0|            xmalloc(((unsigned long)(&((struct link *)0)->name) + tmp) + 1UL);
 6179|      0|        lp = (struct link *)tmp___0;
 6180|      0|        lp->ino = st->stat.st_ino;
 6181|      0|        lp->dev = st->stat.st_dev;
 6182|      0|        lp->nlink = st->stat.st_nlink;
 6183|      0|        strcpy((char * /* __restrict  */)(lp->name),
 6184|      0|               (char const * /* __restrict  */)st->orig_file_name);
 6185|      0|      }
 6186|      0|      if (link_table) {
 6187|      0|        goto _L;
 6188|      0|      } else {
 6189|      0|        {
 6190|      0|          link_table =
 6191|      0|              hash_initialize((size_t)0, (Hash_tuning const *)0,
 6192|      0|                              (size_t(*)(void const *, size_t))(&hash_link),
 6193|      0|                              &compare_links, (void (*)(void *))0);
 6194|      0|        }
 6195|      0|        if (link_table) {
 6196|      0|        _L : {
 6197|      0|          tmp___1 = hash_insert(link_table, (void const *)lp);
 6198|      0|          duplicate = (struct link *)tmp___1;
 6199|      0|        }
 6200|      0|          if (!duplicate) {
 6201|      0|            {
 6202|      0|              xalloc_die();
 6203|      0|            }
 6204|      0|          }
 6205|      0|        } else {
 6206|      0|          { xalloc_die(); }
 6207|      0|        }
 6208|      0|      }
 6209|      0|      if ((unsigned long)duplicate != (unsigned long)lp) {
 6210|      0|        {
 6211|      0|          abort();
 6212|      0|        }
 6213|      0|      }
 6214|      0|      (lp->nlink)--;
 6215|      0|    }
 6216|      0|    return;
 6217|      0|  }
 6218|      0|}
 6219|      0|void check_links(void) {
 6220|      0|  struct link *lp;
 6221|      0|  void *tmp;
 6222|      0|  void *tmp___0;
 6223|      0|  char *tmp___1;
 6224|      0|  char *__cil_tmp5;
 6225|       |
 6226|      0|  {
 6227|      0|    if (!link_table) {
 6228|      0|      return;
 6229|      0|    }
 6230|      0|    {
 6231|      0|      tmp = hash_get_first((Hash_table const *)link_table);
 6232|      0|      lp = (struct link *)tmp;
 6233|      0|    }
 6234|      0|    {
 6235|      0|      while (1) {
 6236|      0|      while_continue: /* CIL Label */;
 6237|      0|        if (!lp) {
 6238|      0|          goto while_break;
 6239|      0|        }
 6240|      0|        if (lp->nlink) {
 6241|      0|          {
 6242|      0|            tmp___1 = gettext("Missing links to \'%s\'.\n");
 6243|      0|            error(0, 0, (char const *)tmp___1, lp->name);
 6244|      0|          }
 6245|      0|        }
 6246|      0|        {
 6247|      0|          tmp___0 =
 6248|      0|              hash_get_next((Hash_table const *)link_table, (void const *)lp);
 6249|      0|          lp = (struct link *)tmp___0;
 6250|      0|        }
 6251|      0|      }
 6252|      0|    while_break: /* CIL Label */;
 6253|      0|    }
 6254|      0|    return;
 6255|      0|  }
 6256|      0|}
 6257|       |static void dump_file0(struct tar_stat_info *st, char *p, int top_level,
 6258|      0|                       dev_t parent_device) {
 6259|      0|  union block *header;
 6260|      0|  char type;
 6261|      0|  time_t original_ctime;
 6262|      0|  struct utimbuf restore_times;
 6263|      0|  off_t block_ordinal;
 6264|      0|  int tmp;
 6265|      0|  char *tmp___0;
 6266|      0|  int tmp___1;
 6267|      0|  char *tmp___2;
 6268|      0|  char *tmp___3;
 6269|      0|  char *tmp___4;
 6270|      0|  char *tmp___5;
 6271|      0|  _Bool tmp___6;
 6272|      0|  _Bool tmp___7;
 6273|      0|  int fd;
 6274|      0|  enum dump_status status;
 6275|      0|  char *tmp___8;
 6276|      0|  char *tmp___9;
 6277|      0|  int *tmp___10;
 6278|      0|  _Bool tmp___11;
 6279|      0|  _Bool tmp___12;
 6280|      0|  char *buffer___2;
 6281|      0|  int size;
 6282|      0|  size_t linklen;
 6283|      0|  void *tmp___13;
 6284|      0|  ssize_t tmp___14;
 6285|      0|  int tmp___15;
 6286|      0|  char *tmp___16;
 6287|      0|  char *tmp___17;
 6288|      0|  _Bool tmp___20;
 6289|      0|  unsigned int tmp___21;
 6290|      0|  unsigned int tmp___22;
 6291|      0|  int tmp___23;
 6292|      0|  char *__cil_tmp38;
 6293|      0|  char *__cil_tmp39;
 6294|      0|  char *__cil_tmp40;
 6295|      0|  char *__cil_tmp41;
 6296|      0|  char *__cil_tmp42;
 6297|       |
 6298|      0|  {
 6299|      0|    block_ordinal = (off_t)-1;
 6300|      0|    if (interactive_option) {
 6301|      0|      {
 6302|      0|        tmp = confirm("add", (char const *)p);
 6303|      0|      }
 6304|      0|      if (!tmp) {
 6305|      0|        return;
 6306|      0|      }
 6307|      0|    }
 6308|      0|    {
 6309|      0|      assign_string(&st->orig_file_name, (char const *)p);
 6310|      0|      tmp___0 = safer_name_suffix((char const *)p, (_Bool)0);
 6311|      0|      assign_string(&st->file_name, (char const *)tmp___0);
 6312|      0|      tmp___1 = deref_stat(dereference_option, (char const *)p, &st->stat);
 6313|      0|    }
 6314|      0|    if (tmp___1 != 0) {
 6315|      0|      {
 6316|      0|        stat_diag((char const *)p);
 6317|      0|      }
 6318|      0|      return;
 6319|      0|    }
 6320|      0|    {
 6321|      0|      st->archive_file_size = st->stat.st_size;
 6322|      0|      sys_stat_nanoseconds(st);
 6323|      0|      original_ctime = st->stat.st_ctim.tv_sec;
 6324|      0|      restore_times.actime = st->stat.st_atim.tv_sec;
 6325|      0|      restore_times.modtime = st->stat.st_mtim.tv_sec;
 6326|      0|    }
 6327|      0|    if (!((st->stat.st_mode & 61440U) == 16384U)) {
 6328|      0|      if (st->stat.st_mtim.tv_sec < newer_mtime_option.tv_sec) {
 6329|      0|        goto _L___5;
 6330|      0|      } else {
 6331|      0|        if (st->stat.st_mtim.tv_sec == newer_mtime_option.tv_sec) {
 6332|      0|          if (st->stat.st_mtim.tv_nsec < newer_mtime_option.tv_nsec) {
 6333|      0|          _L___5: /* CIL Label */
 6334|      0|            if (!after_date_option) {
 6335|      0|              goto _L___4;
 6336|      0|            } else {
 6337|      0|              if (st->stat.st_ctim.tv_sec < newer_mtime_option.tv_sec) {
 6338|      0|                goto _L___4;
 6339|      0|              } else {
 6340|      0|                if (st->stat.st_ctim.tv_sec == newer_mtime_option.tv_sec) {
 6341|      0|                  if (st->stat.st_ctim.tv_nsec < newer_mtime_option.tv_nsec) {
 6342|      0|                  _L___4: /* CIL Label */
 6343|      0|                    if (0 < top_level) {
 6344|      0|                      {
 6345|      0|                        tmp___2 = quotearg_colon((char const *)p);
 6346|      0|                        tmp___3 = gettext("%s: file is unchanged; not dumped");
 6347|      0|                        error(0, 0, (char const *)tmp___3, tmp___2);
 6348|      0|                      }
 6349|      0|                    }
 6350|      0|                    return;
 6351|      0|                  }
 6352|      0|                }
 6353|      0|              }
 6354|      0|            }
 6355|      0|          }
 6356|      0|        }
 6357|      0|      }
 6358|      0|    }
 6359|      0|    { tmp___6 = sys_file_is_archive(st); }
 6360|      0|    if (tmp___6) {
 6361|      0|      {
 6362|      0|        tmp___4 = quotearg_colon((char const *)p);
 6363|      0|        tmp___5 = gettext("%s: file is the archive; not dumped");
 6364|      0|        error(0, 0, (char const *)tmp___5, tmp___4);
 6365|      0|      }
 6366|      0|      return;
 6367|      0|    }
 6368|      0|    if ((st->stat.st_mode & 61440U) == 16384U) {
 6369|      0|      {
 6370|      0|        dump_dir(st, top_level, parent_device);
 6371|      0|      }
 6372|      0|      if (atime_preserve_option) {
 6373|      0|        {
 6374|      0|          utime((char const *)p, (struct utimbuf const *)(&restore_times));
 6375|      0|        }
 6376|      0|      }
 6377|      0|      return;
 6378|      0|    } else {
 6379|      0|      { tmp___20 = is_avoided_name((char const *)p); }
 6380|      0|      if (tmp___20) {
 6381|      0|        return;
 6382|      0|      } else {
 6383|      0|        { tmp___7 = dump_hard_link(st); }
 6384|      0|        if (tmp___7) {
 6385|      0|          return;
 6386|      0|        }
 6387|      0|        if ((st->stat.st_mode & 61440U) == 32768U) {
 6388|      0|          goto _L___6;
 6389|      0|        } else {
 6390|      0|          if (0) {
 6391|      0|          _L___6 : /* CIL Label */
 6392|      0|          {
 6393|      0|            tmp___11 = file_dumpable_p(st);
 6394|      0|          }
 6395|      0|            if (tmp___11) {
 6396|      0|              {
 6397|      0|                fd = open((char const *)st->orig_file_name, 0);
 6398|      0|              }
 6399|      0|              if (fd < 0) {
 6400|      0|                if (!top_level) {
 6401|      0|                  {
 6402|      0|                    tmp___10 = __errno_location();
 6403|      0|                  }
 6404|      0|                  if (*tmp___10 == 2) {
 6405|      0|                    {
 6406|      0|                      tmp___8 =
 6407|      0|                          quotearg_colon((char const *)st->orig_file_name);
 6408|      0|                      tmp___9 = gettext("%s: File removed before we read it");
 6409|      0|                      error(0, 0, (char const *)tmp___9, tmp___8);
 6410|      0|                    }
 6411|      0|                  } else {
 6412|      0|                    { open_diag((char const *)st->orig_file_name); }
 6413|      0|                  }
 6414|      0|                } else {
 6415|      0|                  { open_diag((char const *)st->orig_file_name); }
 6416|      0|                }
 6417|      0|                return;
 6418|      0|              }
 6419|      0|            } else {
 6420|      0|              fd = -1;
 6421|      0|            }
 6422|      0|            if (sparse_option) {
 6423|      0|              {
 6424|      0|                tmp___12 = sparse_file_p(st);
 6425|      0|              }
 6426|      0|              if (tmp___12) {
 6427|      0|                {
 6428|      0|                  status = sparse_dump_file(fd, st);
 6429|      0|                }
 6430|      0|                if ((unsigned int)status == 3U) {
 6431|      0|                  {
 6432|      0|                    status = dump_regular_file(fd, st);
 6433|      0|                  }
 6434|      0|                }
 6435|      0|              } else {
 6436|      0|                { status = dump_regular_file(fd, st); }
 6437|      0|              }
 6438|      0|            } else {
 6439|      0|              { status = dump_regular_file(fd, st); }
 6440|      0|            }
 6441|      0|            {
 6442|      0|              if ((unsigned int)status == 0U) {
 6443|      0|                goto case_0;
 6444|      0|              }
 6445|      0|              if ((unsigned int)status == 1U) {
 6446|      0|                goto case_1;
 6447|      0|              }
 6448|      0|              if ((unsigned int)status == 2U) {
 6449|      0|                goto case_2;
 6450|      0|              }
 6451|      0|              if ((unsigned int)status == 3U) {
 6452|      0|                goto case_3;
 6453|      0|              }
 6454|      0|              goto switch_break;
 6455|      0|            case_0: /* CIL Label */
 6456|      0|              if (multi_volume_option) {
 6457|      0|                {
 6458|      0|                  assign_string(&save_name, (char const *)0);
 6459|      0|                }
 6460|      0|              }
 6461|      0|              { dump_regular_finish(fd, st, original_ctime); }
 6462|      0|              goto switch_break;
 6463|      0|            case_1: /* CIL Label */
 6464|      0|              if (multi_volume_option) {
 6465|      0|                {
 6466|      0|                  assign_string(&save_name, (char const *)0);
 6467|      0|                }
 6468|      0|              }
 6469|      0|              { close(fd); }
 6470|      0|              goto switch_break;
 6471|      0|            case_2 : /* CIL Label */
 6472|      0|            {
 6473|      0|              close(fd);
 6474|      0|            }
 6475|      0|              return;
 6476|      0|            case_3 : /* CIL Label */
 6477|      0|            {
 6478|      0|              abort();
 6479|      0|            }
 6480|      0|            switch_break: /* CIL Label */;
 6481|      0|            }
 6482|      0|            if (atime_preserve_option) {
 6483|      0|              {
 6484|      0|                utime((char const *)st->orig_file_name,
 6485|      0|                      (struct utimbuf const *)(&restore_times));
 6486|      0|              }
 6487|      0|            }
 6488|      0|            { file_count_links(st); }
 6489|      0|            return;
 6490|      0|          } else {
 6491|      0|            if ((st->stat.st_mode & 61440U) == 40960U) {
 6492|      0|              linklen = (size_t)st->stat.st_size;
 6493|      0|              if (linklen != (size_t)st->stat.st_size) {
 6494|      0|                {
 6495|      0|                  xalloc_die();
 6496|      0|                }
 6497|      0|              } else {
 6498|      0|                if (linklen + 1UL == 0UL) {
 6499|      0|                  {
 6500|      0|                    xalloc_die();
 6501|      0|                  }
 6502|      0|                }
 6503|      0|              }
 6504|      0|              {
 6505|      0|                tmp___13 = __builtin_alloca(linklen + 1UL);
 6506|      0|                buffer___2 = (char *)tmp___13;
 6507|      0|                tmp___14 = readlink((char const * /* __restrict  */)p,
 6508|      0|                                    (char * /* __restrict  */)buffer___2,
 6509|      0|                                    linklen + 1UL);
 6510|      0|                size = (int)tmp___14;
 6511|      0|              }
 6512|      0|              if (size < 0) {
 6513|      0|                {
 6514|      0|                  readlink_diag((char const *)p);
 6515|      0|                }
 6516|      0|                return;
 6517|      0|              }
 6518|      0|              {
 6519|      0|                *(buffer___2 + size) = (char)'\000';
 6520|      0|                assign_string(&st->link_name, (char const *)buffer___2);
 6521|      0|              }
 6522|      0|              if (size > 100) {
 6523|      0|                {
 6524|      0|                  write_long_link(st);
 6525|      0|                }
 6526|      0|              }
 6527|      0|              {
 6528|      0|                block_ordinal = current_block_ordinal();
 6529|      0|                st->stat.st_size = (__off_t)0;
 6530|      0|                header = start_header(st);
 6531|      0|              }
 6532|      0|              if (!header) {
 6533|      0|                return;
 6534|      0|              }
 6535|      0|              {
 6536|      0|                tar_copy_str(header->header.linkname, (char const *)buffer___2,
 6537|      0|                             (size_t)100);
 6538|      0|                header->header.typeflag = (char)'2';
 6539|      0|                finish_header(st, header, block_ordinal);
 6540|      0|              }
 6541|      0|              if (remove_files_option) {
 6542|      0|                {
 6543|      0|                  tmp___15 = unlink((char const *)p);
 6544|      0|                }
 6545|      0|                if (tmp___15 == -1) {
 6546|      0|                  {
 6547|      0|                    unlink_error((char const *)p);
 6548|      0|                  }
 6549|      0|                }
 6550|      0|              }
 6551|      0|              { file_count_links(st); }
 6552|      0|              return;
 6553|      0|            } else {
 6554|      0|              if ((st->stat.st_mode & 61440U) == 8192U) {
 6555|      0|                type = (char)'3';
 6556|      0|              } else {
 6557|      0|                if ((st->stat.st_mode & 61440U) == 24576U) {
 6558|      0|                  type = (char)'4';
 6559|      0|                } else {
 6560|      0|                  if ((st->stat.st_mode & 61440U) == 4096U) {
 6561|      0|                    type = (char)'6';
 6562|      0|                  } else {
 6563|      0|                    if ((st->stat.st_mode & 61440U) == 49152U) {
 6564|      0|                      {
 6565|      0|                        tmp___16 = quotearg_colon((char const *)p);
 6566|      0|                        tmp___17 = gettext("%s: socket ignored");
 6567|      0|                        error(0, 0, (char const *)tmp___17, tmp___16);
 6568|      0|                      }
 6569|      0|                      return;
 6570|      0|                    } else {
 6571|      0|                      { unknown_file_error(p); }
 6572|      0|                      return;
 6573|      0|                    }
 6574|      0|                  }
 6575|      0|                }
 6576|      0|              }
 6577|      0|            }
 6578|      0|          }
 6579|      0|        }
 6580|      0|      }
 6581|      0|    }
 6582|      0|    if ((unsigned int)archive_format == 1U) {
 6583|      0|      {
 6584|      0|        unknown_file_error(p);
 6585|      0|      }
 6586|      0|      return;
 6587|      0|    }
 6588|      0|    {
 6589|      0|      block_ordinal = current_block_ordinal();
 6590|      0|      st->stat.st_size = (__off_t)0;
 6591|      0|      header = start_header(st);
 6592|      0|    }
 6593|      0|    if (!header) {
 6594|      0|      return;
 6595|      0|    }
 6596|      0|    header->header.typeflag = type;
 6597|      0|    if ((int)type != 54) {
 6598|      0|      {
 6599|      0|        tmp___21 = gnu_dev_major((unsigned long long)st->stat.st_rdev);
 6600|      0|        major_to_chars((int)tmp___21, header->header.devmajor,
 6601|      0|                       sizeof(header->header.devmajor));
 6602|      0|        tmp___22 = gnu_dev_minor((unsigned long long)st->stat.st_rdev);
 6603|      0|        minor_to_chars((int)tmp___22, header->header.devminor,
 6604|      0|                       sizeof(header->header.devminor));
 6605|      0|      }
 6606|      0|    }
 6607|      0|    { finish_header(st, header, block_ordinal); }
 6608|      0|    if (remove_files_option) {
 6609|      0|      {
 6610|      0|        tmp___23 = unlink((char const *)p);
 6611|      0|      }
 6612|      0|      if (tmp___23 == -1) {
 6613|      0|        {
 6614|      0|          unlink_error((char const *)p);
 6615|      0|        }
 6616|      0|      }
 6617|      0|    }
 6618|      0|    return;
 6619|      0|  }
 6620|      0|}
 6621|      0|void dump_file(char *p, int top_level, dev_t parent_device) {
 6622|      0|  struct tar_stat_info st;
 6623|      0|  void *__cil_tmp5;
 6624|       |
 6625|      0|  {
 6626|      0|    {
 6627|      0|      tar_stat_init(&st);
 6628|      0|      dump_file0(&st, p, top_level, parent_device);
 6629|      0|      tar_stat_destroy(&st);
 6630|      0|    }
 6631|      0|    return;
 6632|      0|  }
 6633|      0|}
 6634|       |/* #pragma merger("0","003.delete.o.i","") */
 6635|       |_Bool ignore_zeros_option;
 6636|       |uintmax_t occurrence_option;
 6637|       |void delete_archive_members(void);
 6638|       |size_t recent_long_name_blocks;
 6639|       |size_t recent_long_link_blocks;
 6640|       |void truncate_warn(char const *name);
 6641|       |void name_gather(void);
 6642|       |void names_notfound(void);
 6643|       |struct name *name_scan(char const *path);
 6644|       |void xheader_decode(struct tar_stat_info *st);
 6645|       |int sys_truncate(int fd);
 6646|       |static union block *new_record;
 6647|       |static int new_blocks;
 6648|       |static _Bool acting_as_filter;
 6649|       |union block *recent_long_name;
 6650|       |union block *recent_long_link;
 6651|       |static off_t records_skipped;
 6652|      0|static void move_archive(off_t count) {
 6653|      0|  struct mtop operation;
 6654|      0|  int tmp;
 6655|      0|  int tmp___0;
 6656|      0|  int tmp___1;
 6657|      0|  int *tmp___2;
 6658|      0|  int tmp___3;
 6659|      0|  int tmp___4;
 6660|      0|  int tmp___5;
 6661|      0|  int tmp___6;
 6662|      0|  off_t position0;
 6663|      0|  off_t tmp___7;
 6664|      0|  __off_t tmp___8;
 6665|      0|  off_t tmp___9;
 6666|      0|  off_t increment;
 6667|      0|  off_t position;
 6668|      0|  off_t tmp___10;
 6669|      0|  __off_t tmp___11;
 6670|      0|  off_t tmp___12;
 6671|       |
 6672|      0|  {
 6673|      0|    if (count == 0L) {
 6674|      0|      return;
 6675|      0|    }
 6676|      0|    if (count < 0L) {
 6677|      0|      operation.mt_op = (short)4;
 6678|      0|      operation.mt_count = (int)(-count);
 6679|      0|      tmp___6 = (off_t)operation.mt_count == -count;
 6680|      0|    } else {
 6681|      0|      operation.mt_op = (short)3;
 6682|      0|      operation.mt_count = (int)count;
 6683|      0|      tmp___6 = (off_t)operation.mt_count == count;
 6684|      0|    }
 6685|      0|    if (tmp___6) {
 6686|      0|      if (archive >= 1 << 30) {
 6687|      0|        {
 6688|      0|          tmp = rmt_ioctl__(
 6689|      0|              archive - (1 << 30),
 6690|      0|              (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) |
 6691|      0|                                    1U) |
 6692|      0|                    (sizeof(struct mtop) << 16)),
 6693|      0|              (char *)(&operation));
 6694|      0|          tmp___1 = tmp;
 6695|      0|        }
 6696|      0|      } else {
 6697|      0|        {
 6698|      0|          tmp___0 = ioctl(
 6699|      0|              archive,
 6700|      0|              (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) |
 6701|      0|                  (sizeof(struct mtop) << 16),
 6702|      0|              (char *)(&operation));
 6703|      0|          tmp___1 = tmp___0;
 6704|      0|        }
 6705|      0|      }
 6706|      0|      if (0 <= tmp___1) {
 6707|      0|        return;
 6708|      0|      }
 6709|      0|      { tmp___2 = __errno_location(); }
 6710|      0|      if (*tmp___2 == 5) {
 6711|      0|        if (archive >= 1 << 30) {
 6712|      0|          {
 6713|      0|            tmp___3 = rmt_ioctl__(
 6714|      0|                archive - (1 << 30),
 6715|      0|                (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) |
 6716|      0|                                      1U) |
 6717|      0|                      (sizeof(struct mtop) << 16)),
 6718|      0|                (char *)(&operation));
 6719|      0|            tmp___5 = tmp___3;
 6720|      0|          }
 6721|      0|        } else {
 6722|      0|          {
 6723|      0|            tmp___4 = ioctl(
 6724|      0|                archive,
 6725|      0|                (unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) |
 6726|      0|                    (sizeof(struct mtop) << 16),
 6727|      0|                (char *)(&operation));
 6728|      0|            tmp___5 = tmp___4;
 6729|      0|          }
 6730|      0|        }
 6731|      0|        if (0 <= tmp___5) {
 6732|      0|          return;
 6733|      0|        }
 6734|      0|      }
 6735|      0|    }
 6736|      0|    if (archive >= 1 << 30) {
 6737|      0|      {
 6738|      0|        tmp___7 = rmt_lseek__(archive - (1 << 30), (off_t)0, 1);
 6739|      0|        tmp___9 = tmp___7;
 6740|      0|      }
 6741|      0|    } else {
 6742|      0|      {
 6743|      0|        tmp___8 = lseek(archive, (off_t)0, 1);
 6744|      0|        tmp___9 = tmp___8;
 6745|      0|      }
 6746|      0|    }
 6747|      0|    position0 = tmp___9;
 6748|      0|    increment = (off_t)(record_size * (size_t)count);
 6749|      0|    position = position0 + increment;
 6750|      0|    if ((size_t)(increment / count) != record_size) {
 6751|      0|      {
 6752|      0|        seek_error_details(*(archive_name_array + 0), position);
 6753|      0|      }
 6754|      0|    } else {
 6755|      0|      if ((position < position0) != (increment < 0L)) {
 6756|      0|        {
 6757|      0|          seek_error_details(*(archive_name_array + 0), position);
 6758|      0|        }
 6759|      0|      } else {
 6760|      0|        if (position < 0L) {
 6761|      0|          position = (off_t)0;
 6762|      0|        } else {
 6763|      0|          position = position;
 6764|      0|        }
 6765|      0|        if (archive >= 1 << 30) {
 6766|      0|          {
 6767|      0|            tmp___10 = rmt_lseek__(archive - (1 << 30), position, 0);
 6768|      0|            tmp___12 = tmp___10;
 6769|      0|          }
 6770|      0|        } else {
 6771|      0|          {
 6772|      0|            tmp___11 = lseek(archive, position, 0);
 6773|      0|            tmp___12 = tmp___11;
 6774|      0|          }
 6775|      0|        }
 6776|      0|        if (tmp___12 != position) {
 6777|      0|          {
 6778|      0|            seek_error_details(*(archive_name_array + 0), position);
 6779|      0|          }
 6780|      0|        }
 6781|      0|      }
 6782|      0|    }
 6783|      0|    return;
 6784|      0|  }
 6785|      0|}
 6786|      0|static void write_record(int move_back_flag) {
 6787|      0|  union block *save_record;
 6788|       |
 6789|      0|  {
 6790|      0|    save_record = record_start;
 6791|      0|    record_start = new_record;
 6792|      0|    if (acting_as_filter) {
 6793|      0|      {
 6794|      0|        archive = 1;
 6795|      0|        flush_write();
 6796|      0|        archive = 0;
 6797|      0|      }
 6798|      0|    } else {
 6799|      0|      {
 6800|      0|        move_archive((records_written + records_skipped) - records_read);
 6801|      0|        flush_write();
 6802|      0|      }
 6803|      0|    }
 6804|      0|    record_start = save_record;
 6805|      0|    if (move_back_flag) {
 6806|      0|      if (!acting_as_filter) {
 6807|      0|        {
 6808|      0|          move_archive(records_read - (records_written + records_skipped));
 6809|      0|        }
 6810|      0|      }
 6811|      0|    }
 6812|      0|    new_blocks = 0;
 6813|      0|    return;
 6814|      0|  }
 6815|      0|}
 6816|      0|static void write_recent_blocks(union block *h, size_t blocks) {
 6817|      0|  size_t i;
 6818|      0|  int tmp;
 6819|       |
 6820|      0|  {
 6821|      0|    i = (size_t)0;
 6822|      0|    {
 6823|      0|      while (1) {
 6824|      0|      while_continue: /* CIL Label */;
 6825|      0|        if (!(i < blocks)) {
 6826|      0|          goto while_break;
 6827|      0|        }
 6828|      0|        tmp = new_blocks;
 6829|      0|        new_blocks++;
 6830|      0|        *(new_record + tmp) = *(h + i);
 6831|      0|        if (new_blocks == blocking_factor) {
 6832|      0|          {
 6833|      0|            write_record(1);
 6834|      0|          }
 6835|      0|        }
 6836|      0|        i++;
 6837|      0|      }
 6838|      0|    while_break: /* CIL Label */;
 6839|      0|    }
 6840|      0|    return;
 6841|      0|  }
 6842|      0|}
 6843|      0|static void write_recent_bytes(char *data, size_t bytes) {
 6844|      0|  size_t blocks;
 6845|      0|  size_t rest;
 6846|       |
 6847|      0|  {
 6848|      0|    {
 6849|      0|      blocks = bytes / 512UL;
 6850|      0|      rest = bytes - blocks * 512UL;
 6851|      0|      write_recent_blocks((union block *)data, blocks);
 6852|      0|      memcpy((void * /* __restrict  */)((new_record + new_blocks)->buffer),
 6853|      0|             (void const * /* __restrict  */)(data + blocks * 512UL), rest);
 6854|      0|    }
 6855|      0|    if (rest < 512UL) {
 6856|      0|      {
 6857|      0|        memset((void *)((new_record + new_blocks)->buffer + rest), 0,
 6858|      0|               512UL - rest);
 6859|      0|      }
 6860|      0|    }
 6861|      0|    new_blocks++;
 6862|      0|    if (new_blocks == blocking_factor) {
 6863|      0|      {
 6864|      0|        write_record(1);
 6865|      0|      }
 6866|      0|    }
 6867|      0|    return;
 6868|      0|  }
 6869|      0|}
 6870|      0|void delete_archive_members(void) {
 6871|      0|  enum read_header logical_status;
 6872|      0|  enum read_header previous_status;
 6873|      0|  struct name *name;
 6874|      0|  off_t blocks_to_skip;
 6875|      0|  off_t blocks_to_keep;
 6876|      0|  int kept_blocks_in_record;
 6877|      0|  int tmp;
 6878|      0|  enum read_header status;
 6879|      0|  enum read_header tmp___0;
 6880|      0|  char *tmp___1;
 6881|      0|  char *tmp___2;
 6882|      0|  void *tmp___3;
 6883|      0|  enum read_header status___0;
 6884|      0|  char *tmp___4;
 6885|      0|  int count;
 6886|      0|  int total_zero_blocks;
 6887|      0|  int zero_blocks;
 6888|      0|  int tmp___5;
 6889|      0|  uintmax_t tmp___6;
 6890|      0|  uintmax_t tmp___7;
 6891|      0|  char *__cil_tmp21;
 6892|      0|  char *__cil_tmp22;
 6893|      0|  char *__cil_tmp23;
 6894|       |
 6895|      0|  {
 6896|      0|    {
 6897|      0|      logical_status = (enum read_header)0;
 6898|      0|      previous_status = (enum read_header)0;
 6899|      0|      blocks_to_skip = (off_t)0;
 6900|      0|      blocks_to_keep = (off_t)0;
 6901|      0|      name_gather();
 6902|      0|      open_archive((enum access_mode)2);
 6903|      0|      tmp = strcmp(*(archive_name_array + 0), "-");
 6904|      0|      acting_as_filter = (_Bool)(tmp == 0);
 6905|      0|    }
 6906|      0|    {
 6907|      0|      while (1) {
 6908|      0|      while_continue: /* CIL Label */;
 6909|      0|        {
 6910|      0|          tmp___0 = read_header((_Bool)1);
 6911|      0|          status = tmp___0;
 6912|      0|        }
 6913|      0|        {
 6914|      0|          if ((unsigned int)status == 0U) {
 6915|      0|            goto case_0;
 6916|      0|          }
 6917|      0|          if ((unsigned int)status == 1U) {
 6918|      0|            goto case_1;
 6919|      0|          }
 6920|      0|          if ((unsigned int)status == 2U) {
 6921|      0|            goto case_2;
 6922|      0|          }
 6923|      0|          if ((unsigned int)status == 3U) {
 6924|      0|            goto case_3;
 6925|      0|          }
 6926|      0|          if ((unsigned int)status == 4U) {
 6927|      0|            goto case_4;
 6928|      0|          }
 6929|      0|          if ((unsigned int)status == 5U) {
 6930|      0|            goto case_5;
 6931|      0|          }
 6932|      0|          goto switch_break;
 6933|      0|        case_0 : /* CIL Label */
 6934|      0|        {
 6935|      0|          abort();
 6936|      0|        }
 6937|      0|        case_1 : /* CIL Label */
 6938|      0|        {
 6939|      0|          name = name_scan((char const *)current_stat_info.file_name);
 6940|      0|        }
 6941|      0|          if ((unsigned long)name == (unsigned long)((void *)0)) {
 6942|      0|            {
 6943|      0|              skip_member();
 6944|      0|            }
 6945|      0|            goto switch_break;
 6946|      0|          }
 6947|      0|          (name->found_count)++;
 6948|      0|          if (occurrence_option == 0UL) {
 6949|      0|            tmp___6 = name->found_count;
 6950|      0|          } else {
 6951|      0|            tmp___6 = (uintmax_t)(name->found_count == occurrence_option);
 6952|      0|          }
 6953|      0|          if (!tmp___6) {
 6954|      0|            {
 6955|      0|              skip_member();
 6956|      0|            }
 6957|      0|            goto switch_break;
 6958|      0|          }
 6959|      0|        case_2: /* CIL Label */
 6960|      0|          logical_status = status;
 6961|      0|          goto switch_break;
 6962|      0|        case_3: /* CIL Label */
 6963|      0|          if (ignore_zeros_option) {
 6964|      0|            {
 6965|      0|              set_next_block_after(current_header);
 6966|      0|            }
 6967|      0|            goto switch_break;
 6968|      0|          }
 6969|      0|        case_4: /* CIL Label */
 6970|      0|          logical_status = (enum read_header)4;
 6971|      0|          goto switch_break;
 6972|      0|        case_5 : /* CIL Label */
 6973|      0|        {
 6974|      0|          set_next_block_after(current_header);
 6975|      0|        }
 6976|      0|          {
 6977|      0|            if ((unsigned int)previous_status == 0U) {
 6978|      0|              goto case_0___0;
 6979|      0|            }
 6980|      0|            if ((unsigned int)previous_status == 1U) {
 6981|      0|              goto case_1___0;
 6982|      0|            }
 6983|      0|            if ((unsigned int)previous_status == 2U) {
 6984|      0|              goto case_1___0;
 6985|      0|            }
 6986|      0|            if ((unsigned int)previous_status == 3U) {
 6987|      0|              goto case_1___0;
 6988|      0|            }
 6989|      0|            if ((unsigned int)previous_status == 5U) {
 6990|      0|              goto case_5___0;
 6991|      0|            }
 6992|      0|            if ((unsigned int)previous_status == 4U) {
 6993|      0|              goto case_4___0;
 6994|      0|            }
 6995|      0|            goto switch_break___0;
 6996|      0|          case_0___0 : /* CIL Label */
 6997|      0|          {
 6998|      0|            tmp___1 = gettext("This does not look like a tar archive");
 6999|      0|            error(0, 0, (char const *)tmp___1);
 7000|      0|          }
 7001|      0|          case_1___0:  /* CIL Label */
 7002|      0|          case_2___0:  /* CIL Label */
 7003|      0|          case_3___0 : /* CIL Label */
 7004|      0|          {
 7005|      0|            tmp___2 = gettext("Skipping to next header");
 7006|      0|            error(0, 0, (char const *)tmp___2);
 7007|      0|            exit_status = 2;
 7008|      0|          }
 7009|      0|          case_5___0: /* CIL Label */
 7010|      0|            goto switch_break___0;
 7011|      0|          case_4___0 : /* CIL Label */
 7012|      0|          {
 7013|      0|            abort();
 7014|      0|          }
 7015|      0|          switch_break___0: /* CIL Label */;
 7016|      0|          }
 7017|      0|          goto switch_break;
 7018|      0|        switch_break: /* CIL Label */;
 7019|      0|        }
 7020|      0|        previous_status = status;
 7021|      0|        if (!((unsigned int)logical_status == 0U)) {
 7022|      0|          goto while_break;
 7023|      0|        }
 7024|      0|      }
 7025|      0|    while_break: /* CIL Label */;
 7026|      0|    }
 7027|      0|    {
 7028|      0|      records_skipped = records_read - 1L;
 7029|      0|      tmp___3 = xmalloc(record_size);
 7030|      0|      new_record = (union block *)tmp___3;
 7031|      0|    }
 7032|      0|    if ((unsigned int)logical_status == 1U) {
 7033|      0|      goto _L___3;
 7034|      0|    } else {
 7035|      0|      if ((unsigned int)logical_status == 2U) {
 7036|      0|      _L___3: /* CIL Label */
 7037|      0|        write_archive_to_stdout = (_Bool)0;
 7038|      0|        new_blocks = (int)(current_block - record_start);
 7039|      0|        if (new_blocks) {
 7040|      0|          {
 7041|      0|            memcpy((void * /* __restrict  */)new_record,
 7042|      0|                   (void const * /* __restrict  */)record_start,
 7043|      0|                   (size_t)(new_blocks * 512));
 7044|      0|          }
 7045|      0|        }
 7046|      0|        if ((unsigned int)logical_status == 1U) {
 7047|      0|          logical_status = (enum read_header)0;
 7048|      0|          goto flush_file;
 7049|      0|        }
 7050|      0|        {
 7051|      0|          while (1) {
 7052|      0|          while_continue___0: /* CIL Label */;
 7053|      0|            if ((unsigned long)current_block == (unsigned long)record_end) {
 7054|      0|              {
 7055|      0|                flush_archive();
 7056|      0|              }
 7057|      0|            }
 7058|      0|            {
 7059|      0|              status___0 = read_header((_Bool)0);
 7060|      0|              xheader_decode(&current_stat_info);
 7061|      0|            }
 7062|      0|            if ((unsigned int)status___0 == 3U) {
 7063|      0|              if (ignore_zeros_option) {
 7064|      0|                {
 7065|      0|                  set_next_block_after(current_header);
 7066|      0|                }
 7067|      0|                goto while_continue___0;
 7068|      0|              }
 7069|      0|            }
 7070|      0|            if ((unsigned int)status___0 == 4U) {
 7071|      0|              logical_status = (enum read_header)4;
 7072|      0|              goto while_break___0;
 7073|      0|            } else {
 7074|      0|              if ((unsigned int)status___0 == 3U) {
 7075|      0|                logical_status = (enum read_header)4;
 7076|      0|                goto while_break___0;
 7077|      0|              }
 7078|      0|            }
 7079|      0|            if ((unsigned int)status___0 == 5U) {
 7080|      0|              {
 7081|      0|                tmp___4 = gettext("Deleting non-header from archive");
 7082|      0|                error(0, 0, (char const *)tmp___4);
 7083|      0|                exit_status = 2;
 7084|      0|                set_next_block_after(current_header);
 7085|      0|              }
 7086|      0|              goto while_continue___0;
 7087|      0|            }
 7088|      0|            { name = name_scan((char const *)current_stat_info.file_name); }
 7089|      0|            if ((unsigned long)name != (unsigned long)((void *)0)) {
 7090|      0|              (name->found_count)++;
 7091|      0|              if (occurrence_option == 0UL) {
 7092|      0|                tmp___7 = name->found_count;
 7093|      0|              } else {
 7094|      0|                tmp___7 = (uintmax_t)(name->found_count == occurrence_option);
 7095|      0|              }
 7096|      0|              if (tmp___7) {
 7097|      0|              flush_file : {
 7098|      0|                set_next_block_after(current_header);
 7099|      0|                blocks_to_skip =
 7100|      0|                    ((current_stat_info.stat.st_size + 512L) - 1L) / 512L;
 7101|      0|              }
 7102|      0|                {
 7103|      0|                  while (1) {
 7104|      0|                  while_continue___1: /* CIL Label */;
 7105|      0|                    if (!(record_end - current_block <= blocks_to_skip)) {
 7106|      0|                      goto while_break___1;
 7107|      0|                    }
 7108|      0|                    {
 7109|      0|                      blocks_to_skip -= record_end - current_block;
 7110|      0|                      flush_archive();
 7111|      0|                    }
 7112|      0|                  }
 7113|      0|                while_break___1: /* CIL Label */;
 7114|      0|                }
 7115|      0|                current_block += blocks_to_skip;
 7116|      0|                blocks_to_skip = (off_t)0;
 7117|      0|                goto while_continue___0;
 7118|      0|              }
 7119|      0|            }
 7120|      0|            if (extended_header.size) {
 7121|      0|              {
 7122|      0|                write_recent_bytes(extended_header.buffer,
 7123|      0|                                   extended_header.size);
 7124|      0|              }
 7125|      0|            } else {
 7126|      0|              {
 7127|      0|                write_recent_blocks(recent_long_name, recent_long_name_blocks);
 7128|      0|                write_recent_blocks(recent_long_link, recent_long_link_blocks);
 7129|      0|              }
 7130|      0|            }
 7131|      0|            {
 7132|      0|              *(new_record + new_blocks) = *current_header;
 7133|      0|              new_blocks++;
 7134|      0|              blocks_to_keep =
 7135|      0|                  ((current_stat_info.stat.st_size + 512L) - 1L) / 512L;
 7136|      0|              set_next_block_after(current_header);
 7137|      0|            }
 7138|      0|            if (new_blocks == blocking_factor) {
 7139|      0|              {
 7140|      0|                write_record(1);
 7141|      0|              }
 7142|      0|            }
 7143|      0|            kept_blocks_in_record = (int)(record_end - current_block);
 7144|      0|            if ((off_t)kept_blocks_in_record > blocks_to_keep) {
 7145|      0|              kept_blocks_in_record = (int)blocks_to_keep;
 7146|      0|            }
 7147|      0|            {
 7148|      0|              while (1) {
 7149|      0|              while_continue___2: /* CIL Label */;
 7150|      0|                if (!blocks_to_keep) {
 7151|      0|                  goto while_break___2;
 7152|      0|                }
 7153|      0|                if ((unsigned long)current_block == (unsigned long)record_end) {
 7154|      0|                  {
 7155|      0|                    flush_read();
 7156|      0|                    current_block = record_start;
 7157|      0|                    kept_blocks_in_record = blocking_factor;
 7158|      0|                  }
 7159|      0|                  if ((off_t)kept_blocks_in_record > blocks_to_keep) {
 7160|      0|                    kept_blocks_in_record = (int)blocks_to_keep;
 7161|      0|                  }
 7162|      0|                }
 7163|      0|                count = kept_blocks_in_record;
 7164|      0|                if (blocking_factor - new_blocks < count) {
 7165|      0|                  count = blocking_factor - new_blocks;
 7166|      0|                }
 7167|      0|                if (!count) {
 7168|      0|                  {
 7169|      0|                    abort();
 7170|      0|                  }
 7171|      0|                }
 7172|      0|                {
 7173|      0|                  memcpy((void * /* __restrict  */)(new_record + new_blocks),
 7174|      0|                         (void const * /* __restrict  */)current_block,
 7175|      0|                         (size_t)(count * 512));
 7176|      0|                  new_blocks += count;
 7177|      0|                  current_block += count;
 7178|      0|                  blocks_to_keep -= (off_t)count;
 7179|      0|                  kept_blocks_in_record -= count;
 7180|      0|                }
 7181|      0|                if (new_blocks == blocking_factor) {
 7182|      0|                  {
 7183|      0|                    write_record(1);
 7184|      0|                  }
 7185|      0|                }
 7186|      0|              }
 7187|      0|            while_break___2: /* CIL Label */;
 7188|      0|            }
 7189|      0|          }
 7190|      0|        while_break___0: /* CIL Label */;
 7191|      0|        }
 7192|      0|      }
 7193|      0|    }
 7194|      0|    if ((unsigned int)logical_status == 4U) {
 7195|      0|      total_zero_blocks = 0;
 7196|      0|      {
 7197|      0|        while (1) {
 7198|      0|        while_continue___3: /* CIL Label */;
 7199|      0|          {
 7200|      0|            zero_blocks = blocking_factor - new_blocks;
 7201|      0|            memset((void *)(new_record + new_blocks), 0,
 7202|      0|                   (size_t)(512 * zero_blocks));
 7203|      0|            total_zero_blocks += zero_blocks;
 7204|      0|            write_record(total_zero_blocks < 2);
 7205|      0|          }
 7206|      0|          if (!(total_zero_blocks < 2)) {
 7207|      0|            goto while_break___3;
 7208|      0|          }
 7209|      0|        }
 7210|      0|      while_break___3: /* CIL Label */;
 7211|      0|      }
 7212|      0|    }
 7213|      0|    { free((void *)new_record); }
 7214|      0|    if (!acting_as_filter) {
 7215|      0|      if (!(archive >= 1 << 30)) {
 7216|      0|        {
 7217|      0|          tmp___5 = sys_truncate(archive);
 7218|      0|        }
 7219|      0|        if (tmp___5) {
 7220|      0|          {
 7221|      0|            truncate_warn(*(archive_name_array + 0));
 7222|      0|          }
 7223|      0|        }
 7224|      0|      }
 7225|      0|    }
 7226|      0|    {
 7227|      0|      close_archive();
 7228|      0|      names_notfound();
 7229|      0|    }
 7230|      0|    return;
 7231|      0|  }
 7232|      0|}
 7233|       |/* #pragma merger("0","004.extract.o.i","") */
 7234|       |extern __attribute__((__nothrow__)) int(
 7235|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 7236|       |    stat)(char const *__restrict __file, struct stat *__restrict __buf);
 7237|       |extern __attribute__((__nothrow__)) int(
 7238|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 7239|       |    lstat)(char const *__restrict __file, struct stat *__restrict __buf);
 7240|       |extern
 7241|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 7242|       |                                     chmod)(char const *__file,
 7243|       |                                            __mode_t __mode);
 7244|       |extern __attribute__((__nothrow__))
 7245|       |__mode_t(__attribute__((__leaf__)) umask)(__mode_t __mask);
 7246|       |extern
 7247|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 7248|       |                                     mkdir)(char const *__path,
 7249|       |                                            __mode_t __mode);
 7250|       |extern
 7251|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 7252|       |                                     mknod)(char const *__path, __mode_t __mode,
 7253|       |                                            __dev_t __dev);
 7254|       |extern
 7255|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 7256|       |                                     mkfifo)(char const *__path,
 7257|       |                                             __mode_t __mode);
 7258|       |extern
 7259|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 7260|       |                                     access)(char const *__name, int __type);
 7261|       |extern
 7262|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 7263|       |                                     chown)(char const *__file, __uid_t __owner,
 7264|       |                                            __gid_t __group);
 7265|       |extern
 7266|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 7267|       |                                     lchown)(char const *__file,
 7268|       |                                             __uid_t __owner, __gid_t __group);
 7269|       |extern __attribute__((__nothrow__))
 7270|       |__uid_t(__attribute__((__leaf__)) geteuid)(void);
 7271|       |extern __attribute__((__nothrow__)) int(__attribute__((
 7272|       |    __nonnull__(1, 2), __leaf__)) link)(char const *__from, char const *__to);
 7273|       |extern __attribute__((__nothrow__)) int(
 7274|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 7275|       |    symlink)(char const *__from, char const *__to);
 7276|       |char *base_name(char const *name);
 7277|       |void (*xalloc_fail_func)(void);
 7278|       |size_t full_write(int fd, void const *buf, size_t count);
 7279|       |_Bool absolute_names_option;
 7280|       |enum old_files old_files_option;
 7281|       |_Bool recursive_unlink_option;
 7282|       |int same_owner_option;
 7283|       |int same_permissions_option;
 7284|       |size_t strip_path_elements;
 7285|       |_Bool touch_option;
 7286|       |_Bool we_are_root;
 7287|       |void extr_init(void);
 7288|       |void extract_archive(void);
 7289|       |void extract_finish(void);
 7290|       |void gnu_restore(char const *directory_name);
 7291|       |char const *tartime(time_t t);
 7292|       |void print_for_mkdir(char *pathname, int length, mode_t mode);
 7293|       |void skip_file(off_t size);
 7294|       |void extract_mangle(void);
 7295|       |int remove_any_file(char const *path, enum remove_option option);
 7296|       |void chmod_error_details(char const *name, mode_t mode);
 7297|       |void chown_error_details(char const *name, uid_t uid, gid_t gid);
 7298|       |void link_error(char const *target, char const *source);
 7299|       |void mkdir_error(char const *name);
 7300|       |void mkfifo_error(char const *name);
 7301|       |void mknod_error(char const *name);
 7302|       |void symlink_error(char const *contents, char const *name);
 7303|       |void utime_error(char const *name);
 7304|       |void write_error_details(char const *name, size_t status, size_t size);
 7305|       |size_t stripped_prefix_len(char const *file_name, size_t num);
 7306|       |_Bool contains_dot_dot(char const *name);
 7307|       |_Bool sparse_member_p(struct tar_stat_info *st);
 7308|       |enum dump_status sparse_extract_file(int fd, struct tar_stat_info *st,
 7309|       |                                     off_t *size);
 7310|       |static mode_t newdir_umask;
 7311|       |static mode_t current_umask;
 7312|       |static struct delayed_set_stat *delayed_set_stat_head;
 7313|       |static struct delayed_symlink *delayed_symlink_head;
 7314|      0|void extr_init(void) {
 7315|      0|  __uid_t tmp;
 7316|       |
 7317|      0|  {
 7318|      0|    {
 7319|      0|      tmp = geteuid();
 7320|      0|      we_are_root = (_Bool)(tmp == 0U);
 7321|      0|      same_permissions_option += (int)we_are_root;
 7322|      0|      same_owner_option += (int)we_are_root;
 7323|      0|      xalloc_fail_func = &extract_finish;
 7324|      0|      newdir_umask = umask((__mode_t)0);
 7325|      0|    }
 7326|      0|    if (0 < same_permissions_option) {
 7327|      0|      current_umask = (mode_t)0;
 7328|      0|    } else {
 7329|      0|      {
 7330|      0|        umask(newdir_umask);
 7331|      0|        current_umask = newdir_umask;
 7332|      0|      }
 7333|      0|    }
 7334|      0|    return;
 7335|      0|  }
 7336|      0|}
 7337|       |static void set_mode(char const *file_name, struct stat const *stat_info,
 7338|       |                     struct stat const *cur_info, mode_t invert_permissions,
 7339|      0|                     enum permstatus permstatus, char typeflag) {
 7340|      0|  mode_t mode;
 7341|      0|  struct stat st;
 7342|      0|  int tmp;
 7343|      0|  int tmp___0;
 7344|      0|  void *__cil_tmp11;
 7345|       |
 7346|      0|  {
 7347|      0|    if (0 < same_permissions_option) {
 7348|      0|      if ((unsigned int)permstatus != 2U) {
 7349|      0|        mode = (mode_t)stat_info->st_mode;
 7350|      0|        if ((unsigned int)permstatus == 1U) {
 7351|      0|          if (!(mode & (unsigned int)(~(
 7352|      0|                           ((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 7353|      0|                           (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 7354|      0|                            ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))))) {
 7355|      0|            if ((int)typeflag != 53) {
 7356|      0|              if ((int)typeflag != 68) {
 7357|      0|                return;
 7358|      0|              }
 7359|      0|            }
 7360|      0|          }
 7361|      0|        }
 7362|      0|      } else {
 7363|      0|        goto _L___3;
 7364|      0|      }
 7365|      0|    } else {
 7366|      0|    _L___3: /* CIL Label */
 7367|      0|      if (!invert_permissions) {
 7368|      0|        return;
 7369|      0|      } else {
 7370|      0|        if (!cur_info) {
 7371|      0|          {
 7372|      0|            tmp = stat((char const * /* __restrict  */)file_name,
 7373|      0|                       (struct stat * /* __restrict  */)(&st));
 7374|      0|          }
 7375|      0|          if (tmp != 0) {
 7376|      0|            {
 7377|      0|              stat_error(file_name);
 7378|      0|            }
 7379|      0|            return;
 7380|      0|          }
 7381|      0|          cur_info = (struct stat const *)(&st);
 7382|      0|        }
 7383|      0|        mode = (mode_t)(cur_info->st_mode ^
 7384|      0|                        (unsigned int const)invert_permissions);
 7385|      0|      }
 7386|      0|    }
 7387|      0|    { tmp___0 = chmod(file_name, mode); }
 7388|      0|    if (tmp___0 != 0) {
 7389|      0|      {
 7390|      0|        chmod_error_details(file_name, mode);
 7391|      0|      }
 7392|      0|    }
 7393|      0|    return;
 7394|      0|  }
 7395|      0|}
 7396|      0|static void check_time(char const *file_name, time_t t) {
 7397|      0|  time_t now;
 7398|      0|  char const *tmp;
 7399|      0|  char *tmp___0;
 7400|      0|  char const *tmp___1;
 7401|      0|  char *tmp___2;
 7402|      0|  char *__cil_tmp8;
 7403|      0|  char *__cil_tmp9;
 7404|       |
 7405|      0|  {
 7406|      0|    if (t <= 0L) {
 7407|      0|      {
 7408|      0|        tmp = tartime(t);
 7409|      0|        tmp___0 = gettext("%s: implausibly old time stamp %s");
 7410|      0|        error(0, 0, (char const *)tmp___0, file_name, tmp);
 7411|      0|      }
 7412|      0|    } else {
 7413|      0|      if (start_timespec.tv_sec < t) {
 7414|      0|        {
 7415|      0|          now = time((time_t *)0);
 7416|      0|        }
 7417|      0|        if (now < t) {
 7418|      0|          {
 7419|      0|            tmp___1 = tartime(t);
 7420|      0|            tmp___2 = gettext("%s: time stamp %s is %lu s in the future");
 7421|      0|            error(0, 0, (char const *)tmp___2, file_name, tmp___1,
 7422|      0|                  (unsigned long)(t - now));
 7423|      0|          }
 7424|      0|        }
 7425|      0|      }
 7426|      0|    }
 7427|      0|    return;
 7428|      0|  }
 7429|      0|}
 7430|       |static void set_stat(char const *file_name, struct stat const *stat_info,
 7431|       |                     struct stat const *cur_info, mode_t invert_permissions,
 7432|      0|                     enum permstatus permstatus, char typeflag) {
 7433|      0|  struct utimbuf utimbuf;
 7434|      0|  int tmp;
 7435|      0|  int tmp___0;
 7436|      0|  int tmp___1;
 7437|       |
 7438|      0|  {
 7439|      0|    if ((int)typeflag != 50) {
 7440|      0|      if (!touch_option) {
 7441|      0|        if ((unsigned int)permstatus != 2U) {
 7442|      0|          if (incremental_option) {
 7443|      0|            utimbuf.actime = (__time_t)stat_info->st_atim.tv_sec;
 7444|      0|          } else {
 7445|      0|            utimbuf.actime = start_timespec.tv_sec;
 7446|      0|          }
 7447|      0|          {
 7448|      0|            utimbuf.modtime = (__time_t)stat_info->st_mtim.tv_sec;
 7449|      0|            tmp = utime(file_name, (struct utimbuf const *)(&utimbuf));
 7450|      0|          }
 7451|      0|          if (tmp < 0) {
 7452|      0|            {
 7453|      0|              utime_error(file_name);
 7454|      0|            }
 7455|      0|          } else {
 7456|      0|            {
 7457|      0|              check_time(file_name, utimbuf.actime);
 7458|      0|              check_time(file_name, utimbuf.modtime);
 7459|      0|            }
 7460|      0|          }
 7461|      0|        }
 7462|      0|      }
 7463|      0|      {
 7464|      0|        set_mode(file_name, stat_info, cur_info, invert_permissions, permstatus,
 7465|      0|                 typeflag);
 7466|      0|      }
 7467|      0|    }
 7468|      0|    if (0 < same_owner_option) {
 7469|      0|      if ((unsigned int)permstatus != 2U) {
 7470|      0|        if ((int)typeflag == 50) {
 7471|      0|          {
 7472|      0|            tmp___0 = lchown(file_name, (__uid_t)stat_info->st_uid,
 7473|      0|                             (__gid_t)stat_info->st_gid);
 7474|      0|          }
 7475|      0|          if (tmp___0 < 0) {
 7476|      0|            {
 7477|      0|              chown_error_details(file_name, (uid_t)stat_info->st_uid,
 7478|      0|                                  (gid_t)stat_info->st_gid);
 7479|      0|            }
 7480|      0|          }
 7481|      0|        } else {
 7482|      0|          {
 7483|      0|            tmp___1 = chown(file_name, (__uid_t)stat_info->st_uid,
 7484|      0|                            (__gid_t)stat_info->st_gid);
 7485|      0|          }
 7486|      0|          if (tmp___1 < 0) {
 7487|      0|            {
 7488|      0|              chown_error_details(file_name, (uid_t)stat_info->st_uid,
 7489|      0|                                  (gid_t)stat_info->st_gid);
 7490|      0|            }
 7491|      0|          }
 7492|      0|          if (stat_info->st_mode & 3584U) {
 7493|      0|            {
 7494|      0|              set_mode(file_name, stat_info, (struct stat const *)0,
 7495|      0|                       invert_permissions, permstatus, typeflag);
 7496|      0|            }
 7497|      0|          }
 7498|      0|        }
 7499|      0|      }
 7500|      0|    }
 7501|      0|    return;
 7502|      0|  }
 7503|      0|}
 7504|       |static void delay_set_stat(char const *file_name, struct stat const *stat_info,
 7505|       |                           mode_t invert_permissions,
 7506|      0|                           enum permstatus permstatus) {
 7507|      0|  size_t file_name_len;
 7508|      0|  size_t tmp;
 7509|      0|  struct delayed_set_stat *data;
 7510|      0|  void *tmp___0;
 7511|       |
 7512|      0|  {
 7513|      0|    {
 7514|      0|      tmp = strlen(file_name);
 7515|      0|      file_name_len = tmp;
 7516|      0|      tmp___0 =
 7517|      0|          xmalloc(((unsigned long)(&((struct delayed_set_stat *)0)->file_name) +
 7518|      0|                   file_name_len) +
 7519|      0|                  1UL);
 7520|      0|      data = (struct delayed_set_stat *)tmp___0;
 7521|      0|      data->file_name_len = file_name_len;
 7522|      0|      strcpy((char * /* __restrict  */)(data->file_name),
 7523|      0|             (char const * /* __restrict  */)file_name);
 7524|      0|      data->invert_permissions = invert_permissions;
 7525|      0|      data->permstatus = permstatus;
 7526|      0|      data->after_symlinks = (_Bool)0;
 7527|      0|      data->stat_info = (struct stat) * stat_info;
 7528|      0|      data->next = delayed_set_stat_head;
 7529|      0|      delayed_set_stat_head = data;
 7530|      0|    }
 7531|      0|    return;
 7532|      0|  }
 7533|      0|}
 7534|       |static void repair_delayed_set_stat(char const *dir,
 7535|      0|                                    struct stat const *dir_stat_info) {
 7536|      0|  struct delayed_set_stat *data;
 7537|      0|  struct stat st;
 7538|      0|  int tmp;
 7539|      0|  char *tmp___0;
 7540|      0|  char *tmp___1;
 7541|      0|  void *__cil_tmp8;
 7542|      0|  char *__cil_tmp9;
 7543|       |
 7544|      0|  {
 7545|      0|    data = delayed_set_stat_head;
 7546|      0|    {
 7547|      0|      while (1) {
 7548|      0|      while_continue: /* CIL Label */;
 7549|      0|        if (!data) {
 7550|      0|          goto while_break;
 7551|      0|        }
 7552|      0|        {
 7553|      0|          tmp = stat((char const * /* __restrict  */)(data->file_name),
 7554|      0|                     (struct stat * /* __restrict  */)(&st));
 7555|      0|        }
 7556|      0|        if (tmp != 0) {
 7557|      0|          {
 7558|      0|            stat_error((char const *)(data->file_name));
 7559|      0|          }
 7560|      0|          return;
 7561|      0|        }
 7562|      0|        if (st.st_dev == (__dev_t)dir_stat_info->st_dev) {
 7563|      0|          if (st.st_ino == (__ino_t)dir_stat_info->st_ino) {
 7564|      0|            data->stat_info = current_stat_info.stat;
 7565|      0|            data->invert_permissions =
 7566|      0|                (unsigned int)(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 7567|      0|                               (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 7568|      0|                                ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))) &
 7569|      0|                (current_stat_info.stat.st_mode ^ st.st_mode);
 7570|      0|            data->permstatus = (enum permstatus)1;
 7571|      0|            return;
 7572|      0|          }
 7573|      0|        }
 7574|      0|        data = data->next;
 7575|      0|      }
 7576|      0|    while_break: /* CIL Label */;
 7577|      0|    }
 7578|      0|    {
 7579|      0|      tmp___0 = quotearg_colon(dir);
 7580|      0|      tmp___1 = gettext("%s: Unexpected inconsistency when making directory");
 7581|      0|      error(0, 0, (char const *)tmp___1, tmp___0);
 7582|      0|      exit_status = 2;
 7583|      0|    }
 7584|      0|    return;
 7585|      0|  }
 7586|      0|}
 7587|      0|static int make_directories(char *file_name) {
 7588|      0|  char *cursor0;
 7589|      0|  char *cursor;
 7590|      0|  int did_something;
 7591|      0|  int mode;
 7592|      0|  int invert_permissions;
 7593|      0|  int status;
 7594|      0|  int *tmp;
 7595|      0|  int tmp___0;
 7596|      0|  int *tmp___1;
 7597|       |
 7598|      0|  {
 7599|      0|    cursor0 = file_name + 0;
 7600|      0|    did_something = 0;
 7601|      0|    cursor = cursor0;
 7602|      0|    {
 7603|      0|      while (1) {
 7604|      0|      while_continue: /* CIL Label */;
 7605|      0|        if (!*cursor) {
 7606|      0|          goto while_break;
 7607|      0|        }
 7608|      0|        if (!((int)*cursor == 47)) {
 7609|      0|          goto __Cont;
 7610|      0|        }
 7611|      0|        if ((unsigned long)cursor == (unsigned long)cursor0) {
 7612|      0|          goto __Cont;
 7613|      0|        } else {
 7614|      0|          if ((int)*(cursor + -1) == 47) {
 7615|      0|            goto __Cont;
 7616|      0|          }
 7617|      0|        }
 7618|      0|        if ((int)*(cursor + -1) == 46) {
 7619|      0|          if ((unsigned long)cursor == (unsigned long)(cursor0 + 1)) {
 7620|      0|            goto __Cont;
 7621|      0|          } else {
 7622|      0|            if ((int)*(cursor + -2) == 47) {
 7623|      0|              goto __Cont;
 7624|      0|            } else {
 7625|      0|              if ((int)*(cursor + -2) == 46) {
 7626|      0|                if ((unsigned long)cursor == (unsigned long)(cursor0 + 2)) {
 7627|      0|                  goto __Cont;
 7628|      0|                } else {
 7629|      0|                  if ((int)*(cursor + -3) == 47) {
 7630|      0|                    goto __Cont;
 7631|      0|                  }
 7632|      0|                }
 7633|      0|              }
 7634|      0|            }
 7635|      0|          }
 7636|      0|        }
 7637|      0|        *cursor = (char)'\000';
 7638|      0|        mode =
 7639|      0|            (int)((unsigned int)(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 7640|      0|                                 (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 7641|      0|                                  ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))) &
 7642|      0|                  ~newdir_umask);
 7643|      0|        if (we_are_root) {
 7644|      0|          invert_permissions = 0;
 7645|      0|        } else {
 7646|      0|          invert_permissions = 192 & ~mode;
 7647|      0|        }
 7648|      0|        {
 7649|      0|          status = mkdir((char const *)file_name,
 7650|      0|                         (__mode_t)(mode ^ invert_permissions));
 7651|      0|        }
 7652|      0|        if (status == 0) {
 7653|      0|          {
 7654|      0|            delay_set_stat((char const *)file_name,
 7655|      0|                           (struct stat const *)(&current_stat_info.stat),
 7656|      0|                           (mode_t)invert_permissions, (enum permstatus)2);
 7657|      0|            print_for_mkdir(file_name, (int)(cursor - file_name), (mode_t)mode);
 7658|      0|            did_something = 1;
 7659|      0|            *cursor = (char)'/';
 7660|      0|          }
 7661|      0|          goto __Cont;
 7662|      0|        }
 7663|      0|        {
 7664|      0|          *cursor = (char)'/';
 7665|      0|          tmp___1 = __errno_location();
 7666|      0|        }
 7667|      0|        if (*tmp___1 == 17) {
 7668|      0|          goto __Cont;
 7669|      0|        } else {
 7670|      0|          { tmp = __errno_location(); }
 7671|      0|          if (*tmp == 38) {
 7672|      0|            goto _L___3;
 7673|      0|          } else {
 7674|      0|            if (0) {
 7675|      0|            _L___3 : /* CIL Label */
 7676|      0|            {
 7677|      0|              tmp___0 = access((char const *)file_name, 2);
 7678|      0|            }
 7679|      0|              if (tmp___0 == 0) {
 7680|      0|                goto __Cont;
 7681|      0|              }
 7682|      0|            }
 7683|      0|          }
 7684|      0|        }
 7685|      0|        goto while_break;
 7686|      0|      __Cont:
 7687|      0|        cursor++;
 7688|      0|      }
 7689|      0|    while_break: /* CIL Label */;
 7690|      0|    }
 7691|      0|    return (did_something);
 7692|      0|  }
 7693|      0|}
 7694|       |static _Bool file_newer_p(char const *file_name,
 7695|      0|                          struct tar_stat_info *tar_stat) {
 7696|      0|  struct stat st;
 7697|      0|  int tmp;
 7698|      0|  void *__cil_tmp5;
 7699|       |
 7700|      0|  {
 7701|      0|    {
 7702|      0|      tmp = stat((char const * /* __restrict  */)file_name,
 7703|      0|                 (struct stat * /* __restrict  */)(&st));
 7704|      0|    }
 7705|      0|    if (tmp) {
 7706|      0|      {
 7707|      0|        stat_warn(file_name);
 7708|      0|      }
 7709|      0|      return ((_Bool)1);
 7710|      0|    }
 7711|      0|    if (!((st.st_mode & 61440U) == 16384U)) {
 7712|      0|      if (st.st_mtim.tv_sec >= tar_stat->stat.st_mtim.tv_sec) {
 7713|      0|        return ((_Bool)1);
 7714|      0|      }
 7715|      0|    }
 7716|      0|    return ((_Bool)0);
 7717|      0|  }
 7718|      0|}
 7719|      0|static int prepare_to_extract(char const *file_name) {
 7720|      0|  int tmp;
 7721|      0|  int *tmp___0;
 7722|      0|  int *tmp___1;
 7723|      0|  char *tmp___2;
 7724|      0|  _Bool tmp___3;
 7725|      0|  char *__cil_tmp7;
 7726|       |
 7727|      0|  {
 7728|      0|    if (to_stdout_option) {
 7729|      0|      return (0);
 7730|      0|    }
 7731|      0|    {
 7732|      0|      if ((unsigned int)old_files_option == 3U) {
 7733|      0|        goto case_3;
 7734|      0|      }
 7735|      0|      if ((unsigned int)old_files_option == 5U) {
 7736|      0|        goto case_5;
 7737|      0|      }
 7738|      0|      goto switch_default;
 7739|      0|    case_3 : /* CIL Label */
 7740|      0|    {
 7741|      0|      tmp = remove_any_file(file_name,
 7742|      0|                            (enum remove_option)recursive_unlink_option);
 7743|      0|    }
 7744|      0|      if (!tmp) {
 7745|      0|        {
 7746|      0|          tmp___0 = __errno_location();
 7747|      0|        }
 7748|      0|        if (*tmp___0) {
 7749|      0|          {
 7750|      0|            tmp___1 = __errno_location();
 7751|      0|          }
 7752|      0|          if (*tmp___1 != 2) {
 7753|      0|            {
 7754|      0|              unlink_error(file_name);
 7755|      0|            }
 7756|      0|            return (0);
 7757|      0|          }
 7758|      0|        }
 7759|      0|      }
 7760|      0|      goto switch_break;
 7761|      0|    case_5 : /* CIL Label */
 7762|      0|    {
 7763|      0|      tmp___3 = file_newer_p(file_name, &current_stat_info);
 7764|      0|    }
 7765|      0|      if (tmp___3) {
 7766|      0|        {
 7767|      0|          tmp___2 = gettext("Current `%s\' is newer");
 7768|      0|          error(0, 0, (char const *)tmp___2, file_name);
 7769|      0|        }
 7770|      0|        return (0);
 7771|      0|      }
 7772|      0|      goto switch_break;
 7773|      0|    switch_default: /* CIL Label */
 7774|      0|      goto switch_break;
 7775|      0|    switch_break: /* CIL Label */;
 7776|      0|    }
 7777|      0|    return (1);
 7778|      0|  }
 7779|      0|}
 7780|      0|static int maybe_recoverable(char *file_name, int *interdir_made) {
 7781|      0|  int e;
 7782|      0|  int *tmp;
 7783|      0|  int *tmp___0;
 7784|      0|  int *tmp___1;
 7785|      0|  _Bool tmp___2;
 7786|      0|  int r;
 7787|      0|  int tmp___3;
 7788|      0|  int *tmp___4;
 7789|      0|  int *tmp___5;
 7790|      0|  int tmp___6;
 7791|       |
 7792|      0|  {
 7793|      0|    {
 7794|      0|      tmp = __errno_location();
 7795|      0|      e = *tmp;
 7796|      0|    }
 7797|      0|    if (*interdir_made) {
 7798|      0|      return (0);
 7799|      0|    }
 7800|      0|    { tmp___0 = __errno_location(); }
 7801|      0|    {
 7802|      0|      if (*tmp___0 == 17) {
 7803|      0|        goto case_17;
 7804|      0|      }
 7805|      0|      if (*tmp___0 == 2) {
 7806|      0|        goto case_2___0;
 7807|      0|      }
 7808|      0|      goto switch_default;
 7809|      0|    case_17 : /* CIL Label */
 7810|      0|    {
 7811|      0|      if ((unsigned int)old_files_option == 4U) {
 7812|      0|        goto case_4;
 7813|      0|      }
 7814|      0|      if ((unsigned int)old_files_option == 5U) {
 7815|      0|        goto case_5;
 7816|      0|      }
 7817|      0|      if ((unsigned int)old_files_option == 0U) {
 7818|      0|        goto case_0;
 7819|      0|      }
 7820|      0|      if ((unsigned int)old_files_option == 1U) {
 7821|      0|        goto case_0;
 7822|      0|      }
 7823|      0|      if ((unsigned int)old_files_option == 2U) {
 7824|      0|        goto case_0;
 7825|      0|      }
 7826|      0|      if ((unsigned int)old_files_option == 3U) {
 7827|      0|        goto case_3;
 7828|      0|      }
 7829|      0|      goto switch_break___0;
 7830|      0|    case_4: /* CIL Label */
 7831|      0|      return (0);
 7832|      0|    case_5 : /* CIL Label */
 7833|      0|    {
 7834|      0|      tmp___2 = file_newer_p((char const *)file_name, &current_stat_info);
 7835|      0|    }
 7836|      0|      if (tmp___2) {
 7837|      0|        {
 7838|      0|          tmp___1 = __errno_location();
 7839|      0|          *tmp___1 = e;
 7840|      0|        }
 7841|      0|        return (0);
 7842|      0|      }
 7843|      0|    case_0:  /* CIL Label */
 7844|      0|    case_1:  /* CIL Label */
 7845|      0|    case_2 : /* CIL Label */
 7846|      0|    {
 7847|      0|      tmp___3 = remove_any_file((char const *)file_name, (enum remove_option)0);
 7848|      0|      r = tmp___3;
 7849|      0|      tmp___4 = __errno_location();
 7850|      0|      *tmp___4 = 17;
 7851|      0|    }
 7852|      0|      return (r);
 7853|      0|    case_3: /* CIL Label */
 7854|      0|      goto switch_break___0;
 7855|      0|    switch_break___0: /* CIL Label */;
 7856|      0|    }
 7857|      0|    case_2___0 : /* CIL Label */
 7858|      0|    {
 7859|      0|      tmp___6 = make_directories(file_name);
 7860|      0|    }
 7861|      0|      if (!tmp___6) {
 7862|      0|        {
 7863|      0|          tmp___5 = __errno_location();
 7864|      0|          *tmp___5 = 2;
 7865|      0|        }
 7866|      0|        return (0);
 7867|      0|      }
 7868|      0|      *interdir_made = 1;
 7869|      0|      return (1);
 7870|      0|    switch_default: /* CIL Label */
 7871|      0|      return (0);
 7872|      0|    switch_break: /* CIL Label */;
 7873|      0|    }
 7874|      0|  }
 7875|      0|}
 7876|       |static void apply_nonancestor_delayed_set_stat(char const *file_name,
 7877|      0|                                               _Bool after_symlinks) {
 7878|      0|  size_t file_name_len;
 7879|      0|  size_t tmp;
 7880|      0|  _Bool check_for_renamed_directories;
 7881|      0|  struct delayed_set_stat *data;
 7882|      0|  _Bool skip_this_one;
 7883|      0|  struct stat st;
 7884|      0|  struct stat const *cur_info;
 7885|      0|  int tmp___0;
 7886|      0|  char *tmp___1;
 7887|      0|  char *tmp___2;
 7888|      0|  int tmp___3;
 7889|      0|  void *__cil_tmp14;
 7890|      0|  char *__cil_tmp15;
 7891|      0|  char *__cil_tmp16;
 7892|       |
 7893|      0|  {
 7894|      0|    {
 7895|      0|      tmp = strlen(file_name);
 7896|      0|      file_name_len = tmp;
 7897|      0|      check_for_renamed_directories = (_Bool)0;
 7898|      0|    }
 7899|      0|    {
 7900|      0|      while (1) {
 7901|      0|      while_continue: /* CIL Label */;
 7902|      0|        if (!delayed_set_stat_head) {
 7903|      0|          goto while_break;
 7904|      0|        }
 7905|      0|        data = delayed_set_stat_head;
 7906|      0|        skip_this_one = (_Bool)0;
 7907|      0|        cur_info = (struct stat const *)0;
 7908|      0|        check_for_renamed_directories = (_Bool)(
 7909|      0|            (int)check_for_renamed_directories | (int)data->after_symlinks);
 7910|      0|        if ((int)after_symlinks < (int)data->after_symlinks) {
 7911|      0|          goto while_break;
 7912|      0|        } else {
 7913|      0|          if (data->file_name_len < file_name_len) {
 7914|      0|            if (*(file_name + data->file_name_len)) {
 7915|      0|              if ((int const) * (file_name + data->file_name_len) == 47) {
 7916|      0|                goto _L___3;
 7917|      0|              } else {
 7918|      0|                if ((int const) * (file_name + (data->file_name_len - 1UL)) ==
 7919|      0|                    47) {
 7920|      0|                _L___3 : /* CIL Label */
 7921|      0|                {
 7922|      0|                  tmp___0 = memcmp((void const *)file_name,
 7923|      0|                                   (void const *)(data->file_name),
 7924|      0|                                   data->file_name_len);
 7925|      0|                }
 7926|      0|                  if (tmp___0 == 0) {
 7927|      0|                    goto while_break;
 7928|      0|                  }
 7929|      0|                }
 7930|      0|              }
 7931|      0|            }
 7932|      0|          }
 7933|      0|        }
 7934|      0|        if (check_for_renamed_directories) {
 7935|      0|          {
 7936|      0|            cur_info = (struct stat const *)(&st);
 7937|      0|            tmp___3 = stat((char const * /* __restrict  */)(data->file_name),
 7938|      0|                           (struct stat * /* __restrict  */)(&st));
 7939|      0|          }
 7940|      0|          if (tmp___3 != 0) {
 7941|      0|            {
 7942|      0|              stat_error((char const *)(data->file_name));
 7943|      0|              skip_this_one = (_Bool)1;
 7944|      0|            }
 7945|      0|          } else {
 7946|      0|            if (st.st_dev == data->stat_info.st_dev) {
 7947|      0|              if (!(st.st_ino == data->stat_info.st_ino)) {
 7948|      0|                {
 7949|      0|                  tmp___1 = quotearg_colon((char const *)(data->file_name));
 7950|      0|                  tmp___2 = gettext("%s: Directory renamed before its status "
 7951|      0|                                    "could be extracted");
 7952|      0|                  error(0, 0, (char const *)tmp___2, tmp___1);
 7953|      0|                  exit_status = 2;
 7954|      0|                  skip_this_one = (_Bool)1;
 7955|      0|                }
 7956|      0|              }
 7957|      0|            } else {
 7958|      0|              {
 7959|      0|                tmp___1 = quotearg_colon((char const *)(data->file_name));
 7960|      0|                tmp___2 = gettext("%s: Directory renamed before its status "
 7961|      0|                                  "could be extracted");
 7962|      0|                error(0, 0, (char const *)tmp___2, tmp___1);
 7963|      0|                exit_status = 2;
 7964|      0|                skip_this_one = (_Bool)1;
 7965|      0|              }
 7966|      0|            }
 7967|      0|          }
 7968|      0|        }
 7969|      0|        if (!skip_this_one) {
 7970|      0|          {
 7971|      0|            set_stat((char const *)(data->file_name),
 7972|      0|                     (struct stat const *)(&data->stat_info), cur_info,
 7973|      0|                     data->invert_permissions, data->permstatus, (char)'5');
 7974|      0|          }
 7975|      0|        }
 7976|      0|        {
 7977|      0|          delayed_set_stat_head = data->next;
 7978|      0|          free((void *)data);
 7979|      0|        }
 7980|      0|      }
 7981|      0|    while_break: /* CIL Label */;
 7982|      0|    }
 7983|      0|    return;
 7984|      0|  }
 7985|      0|}
 7986|       |static int conttype_diagnosed;
 7987|      0|void extract_archive(void) {
 7988|      0|  union block *data_block;
 7989|      0|  int fd;
 7990|      0|  int status;
 7991|      0|  size_t count;
 7992|      0|  size_t written;
 7993|      0|  int openflag;
 7994|      0|  mode_t mode;
 7995|      0|  off_t size;
 7996|      0|  int interdir_made;
 7997|      0|  char typeflag;
 7998|      0|  char *file_name;
 7999|      0|  int tmp;
 8000|      0|  size_t prefix_len;
 8001|      0|  size_t tmp___0;
 8002|      0|  int e;
 8003|      0|  int *tmp___1;
 8004|      0|  char *tmp___2;
 8005|      0|  char *tmp___3;
 8006|      0|  _Bool tmp___4;
 8007|      0|  _Bool tmp___5;
 8008|      0|  int tmp___6;
 8009|      0|  char *tmp___7;
 8010|      0|  int tmp___8;
 8011|      0|  char *tmp___9;
 8012|      0|  int *tmp___10;
 8013|      0|  int tmp___11;
 8014|      0|  int tmp___12;
 8015|      0|  struct stat st;
 8016|      0|  int tmp___13;
 8017|      0|  struct delayed_set_stat *h;
 8018|      0|  struct delayed_symlink *p;
 8019|      0|  size_t tmp___14;
 8020|      0|  void *tmp___15;
 8021|      0|  size_t tmp___16;
 8022|      0|  void *tmp___17;
 8023|      0|  int tmp___18;
 8024|      0|  int tmp___19;
 8025|      0|  char *tmp___20;
 8026|      0|  int tmp___21;
 8027|      0|  int tmp___22;
 8028|      0|  _Bool tmp___23;
 8029|      0|  int tmp___24;
 8030|      0|  char const *link_name;
 8031|      0|  char *tmp___25;
 8032|      0|  struct stat st1;
 8033|      0|  struct stat st2;
 8034|      0|  int e___0;
 8035|      0|  struct delayed_symlink *ds;
 8036|      0|  struct string_list *p___0;
 8037|      0|  size_t tmp___26;
 8038|      0|  void *tmp___27;
 8039|      0|  int tmp___28;
 8040|      0|  int tmp___29;
 8041|      0|  int *tmp___30;
 8042|      0|  int *tmp___31;
 8043|      0|  int tmp___32;
 8044|      0|  int tmp___33;
 8045|      0|  int tmp___34;
 8046|      0|  int tmp___35;
 8047|      0|  int tmp___36;
 8048|      0|  int tmp___37;
 8049|      0|  struct stat st___0;
 8050|      0|  int tmp___38;
 8051|      0|  int *tmp___39;
 8052|      0|  int *tmp___40;
 8053|      0|  int tmp___41;
 8054|      0|  int *tmp___42;
 8055|      0|  char const *tmp___43;
 8056|      0|  char *tmp___44;
 8057|      0|  char *tmp___45;
 8058|      0|  char *tmp___46;
 8059|      0|  char *tmp___47;
 8060|      0|  char *tmp___48;
 8061|      0|  char *tmp___49;
 8062|      0|  int tmp___50;
 8063|      0|  int tmp___51;
 8064|      0|  int tmp___52;
 8065|      0|  int tmp___53;
 8066|      0|  int tmp___54;
 8067|      0|  void *__cil_tmp80;
 8068|      0|  void *__cil_tmp81;
 8069|      0|  void *__cil_tmp82;
 8070|      0|  void *__cil_tmp83;
 8071|      0|  char *__cil_tmp84;
 8072|      0|  char *__cil_tmp85;
 8073|      0|  char *__cil_tmp86;
 8074|      0|  char *__cil_tmp87;
 8075|      0|  char *__cil_tmp88;
 8076|      0|  char *__cil_tmp89;
 8077|      0|  char *__cil_tmp90;
 8078|      0|  char *__cil_tmp91;
 8079|       |
 8080|      0|  {
 8081|      0|    {
 8082|      0|      interdir_made = 0;
 8083|      0|      set_next_block_after(current_header);
 8084|      0|      decode_header(current_header, &current_stat_info, &current_format, 1);
 8085|      0|    }
 8086|      0|    if (interactive_option) {
 8087|      0|      {
 8088|      0|        tmp = confirm("extract", (char const *)current_stat_info.file_name);
 8089|      0|      }
 8090|      0|      if (!tmp) {
 8091|      0|        {
 8092|      0|          skip_member();
 8093|      0|        }
 8094|      0|        return;
 8095|      0|      }
 8096|      0|    }
 8097|      0|    if (verbose_option) {
 8098|      0|      {
 8099|      0|        print_header(&current_stat_info, (off_t)-1);
 8100|      0|      }
 8101|      0|    }
 8102|      0|    {
 8103|      0|      file_name = safer_name_suffix((char const *)current_stat_info.file_name,
 8104|      0|                                    (_Bool)0);
 8105|      0|    }
 8106|      0|    if (strip_path_elements) {
 8107|      0|      {
 8108|      0|        tmp___0 =
 8109|      0|            stripped_prefix_len((char const *)file_name, strip_path_elements);
 8110|      0|        prefix_len = tmp___0;
 8111|      0|      }
 8112|      0|      if (prefix_len == 0xffffffffffffffffUL) {
 8113|      0|        {
 8114|      0|          skip_member();
 8115|      0|        }
 8116|      0|        return;
 8117|      0|      }
 8118|      0|      file_name += prefix_len;
 8119|      0|    }
 8120|      0|    { apply_nonancestor_delayed_set_stat((char const *)file_name, (_Bool)0); }
 8121|      0|    if (backup_option) {
 8122|      0|      if (!to_stdout_option) {
 8123|      0|        {
 8124|      0|          tmp___4 = maybe_backup_file((char const *)file_name, 0);
 8125|      0|        }
 8126|      0|        if (!tmp___4) {
 8127|      0|          {
 8128|      0|            tmp___1 = __errno_location();
 8129|      0|            e = *tmp___1;
 8130|      0|            tmp___2 = quotearg_colon((char const *)file_name);
 8131|      0|            tmp___3 = gettext("%s: Was unable to backup this file");
 8132|      0|            error(0, e, (char const *)tmp___3, tmp___2);
 8133|      0|            exit_status = 2;
 8134|      0|            skip_member();
 8135|      0|          }
 8136|      0|          return;
 8137|      0|        }
 8138|      0|      }
 8139|      0|    }
 8140|      0|    { tmp___5 = sparse_member_p(&current_stat_info); }
 8141|      0|    if (tmp___5) {
 8142|      0|      tmp___50 = 'S';
 8143|      0|    } else {
 8144|      0|      tmp___50 = (int)current_header->header.typeflag;
 8145|      0|    }
 8146|      0|    typeflag = (char)tmp___50;
 8147|      0|    {
 8148|      0|      if ((int)typeflag == 83) {
 8149|      0|        goto case_83;
 8150|      0|      }
 8151|      0|      if ((int)typeflag == 0) {
 8152|      0|        goto case_83;
 8153|      0|      }
 8154|      0|      if ((int)typeflag == 48) {
 8155|      0|        goto case_83;
 8156|      0|      }
 8157|      0|      if ((int)typeflag == 55) {
 8158|      0|        goto case_83;
 8159|      0|      }
 8160|      0|      if ((int)typeflag == 50) {
 8161|      0|        goto case_50;
 8162|      0|      }
 8163|      0|      if ((int)typeflag == 49) {
 8164|      0|        goto case_49;
 8165|      0|      }
 8166|      0|      if ((int)typeflag == 51) {
 8167|      0|        goto case_51;
 8168|      0|      }
 8169|      0|      if ((int)typeflag == 52) {
 8170|      0|        goto case_52;
 8171|      0|      }
 8172|      0|      if ((int)typeflag == 54) {
 8173|      0|        goto case_54;
 8174|      0|      }
 8175|      0|      if ((int)typeflag == 53) {
 8176|      0|        goto really_dir;
 8177|      0|      }
 8178|      0|      if ((int)typeflag == 68) {
 8179|      0|        goto really_dir;
 8180|      0|      }
 8181|      0|      if ((int)typeflag == 86) {
 8182|      0|        goto case_86;
 8183|      0|      }
 8184|      0|      if ((int)typeflag == 78) {
 8185|      0|        goto case_78;
 8186|      0|      }
 8187|      0|      if ((int)typeflag == 77) {
 8188|      0|        goto case_77;
 8189|      0|      }
 8190|      0|      if ((int)typeflag == 76) {
 8191|      0|        goto case_76;
 8192|      0|      }
 8193|      0|      if ((int)typeflag == 75) {
 8194|      0|        goto case_76;
 8195|      0|      }
 8196|      0|      goto switch_default;
 8197|      0|    case_83: /* CIL Label */
 8198|      0|    case_0:  /* CIL Label */
 8199|      0|    case_48: /* CIL Label */
 8200|      0|    case_55: /* CIL Label */
 8201|      0|      if (current_stat_info.had_trailing_slash) {
 8202|      0|        goto really_dir;
 8203|      0|      }
 8204|      0|    again_file:
 8205|      0|      if ((unsigned int)old_files_option == 2U) {
 8206|      0|        tmp___51 = 512;
 8207|      0|      } else {
 8208|      0|        tmp___51 = 128;
 8209|      0|      }
 8210|      0|      openflag = 65 | tmp___51;
 8211|      0|      mode = (current_stat_info.stat.st_mode &
 8212|      0|              (unsigned int)(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 8213|      0|                             (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 8214|      0|                              ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))) &
 8215|      0|             ~current_umask;
 8216|      0|      if (to_stdout_option) {
 8217|      0|        fd = 1;
 8218|      0|        goto extract_file;
 8219|      0|      }
 8220|      0|      { tmp___6 = prepare_to_extract((char const *)file_name); }
 8221|      0|      if (!tmp___6) {
 8222|      0|        {
 8223|      0|          skip_member();
 8224|      0|        }
 8225|      0|        if (backup_option) {
 8226|      0|          {
 8227|      0|            undo_last_backup();
 8228|      0|          }
 8229|      0|        }
 8230|      0|        goto switch_break;
 8231|      0|      }
 8232|      0|      if ((int)typeflag == 55) {
 8233|      0|        if (!conttype_diagnosed) {
 8234|      0|          {
 8235|      0|            conttype_diagnosed = 1;
 8236|      0|            tmp___7 = gettext("Extracting contiguous files as regular files");
 8237|      0|            error(0, 0, (char const *)tmp___7);
 8238|      0|          }
 8239|      0|        }
 8240|      0|      }
 8241|      0|      { fd = open((char const *)file_name, openflag, mode); }
 8242|      0|      if (fd < 0) {
 8243|      0|        {
 8244|      0|          tmp___8 = maybe_recoverable(file_name, &interdir_made);
 8245|      0|        }
 8246|      0|        if (tmp___8) {
 8247|      0|          goto again_file;
 8248|      0|        }
 8249|      0|        {
 8250|      0|          open_error((char const *)file_name);
 8251|      0|          skip_member();
 8252|      0|        }
 8253|      0|        if (backup_option) {
 8254|      0|          {
 8255|      0|            undo_last_backup();
 8256|      0|          }
 8257|      0|        }
 8258|      0|        goto switch_break;
 8259|      0|      }
 8260|      0|    extract_file:
 8261|      0|      if (current_stat_info.is_sparse) {
 8262|      0|        {
 8263|      0|          sparse_extract_file(fd, &current_stat_info, &size);
 8264|      0|        }
 8265|      0|      } else {
 8266|      0|        size = current_stat_info.stat.st_size;
 8267|      0|        {
 8268|      0|          while (1) {
 8269|      0|          while_continue: /* CIL Label */;
 8270|      0|            if (!(size > 0L)) {
 8271|      0|              goto while_break;
 8272|      0|            }
 8273|      0|            if (multi_volume_option) {
 8274|      0|              {
 8275|      0|                assign_string(&save_name,
 8276|      0|                              (char const *)current_stat_info.file_name);
 8277|      0|                save_totsize = current_stat_info.stat.st_size;
 8278|      0|                save_sizeleft = size;
 8279|      0|              }
 8280|      0|            }
 8281|      0|            { data_block = find_next_block(); }
 8282|      0|            if (!data_block) {
 8283|      0|              {
 8284|      0|                tmp___9 = gettext("Unexpected EOF in archive");
 8285|      0|                error(0, 0, (char const *)tmp___9);
 8286|      0|                exit_status = 2;
 8287|      0|              }
 8288|      0|              goto while_break;
 8289|      0|            }
 8290|      0|            { written = available_space_after(data_block); }
 8291|      0|            if (written > (size_t)size) {
 8292|      0|              written = (size_t)size;
 8293|      0|            }
 8294|      0|            {
 8295|      0|              tmp___10 = __errno_location();
 8296|      0|              *tmp___10 = 0;
 8297|      0|              count =
 8298|      0|                  full_write(fd, (void const *)(data_block->buffer), written);
 8299|      0|              size = (off_t)((size_t)size - count);
 8300|      0|              set_next_block_after(
 8301|      0|                  (union block *)((data_block->buffer + written) - 1));
 8302|      0|            }
 8303|      0|            if (count != written) {
 8304|      0|              {
 8305|      0|                write_error_details((char const *)file_name, count, written);
 8306|      0|              }
 8307|      0|              goto while_break;
 8308|      0|            }
 8309|      0|          }
 8310|      0|        while_break: /* CIL Label */;
 8311|      0|        }
 8312|      0|      }
 8313|      0|      { skip_file(size); }
 8314|      0|      if (multi_volume_option) {
 8315|      0|        {
 8316|      0|          assign_string(&save_name, (char const *)0);
 8317|      0|        }
 8318|      0|      }
 8319|      0|      if (to_stdout_option) {
 8320|      0|        goto switch_break;
 8321|      0|      }
 8322|      0|      { status = close(fd); }
 8323|      0|      if (status < 0) {
 8324|      0|        {
 8325|      0|          close_error((char const *)file_name);
 8326|      0|        }
 8327|      0|        if (backup_option) {
 8328|      0|          {
 8329|      0|            undo_last_backup();
 8330|      0|          }
 8331|      0|        }
 8332|      0|      }
 8333|      0|      if ((unsigned int)old_files_option == 2U) {
 8334|      0|        tmp___52 = 0;
 8335|      0|      } else {
 8336|      0|        tmp___52 = 1;
 8337|      0|      }
 8338|      0|      {
 8339|      0|        set_stat((char const *)file_name,
 8340|      0|                 (struct stat const *)(&current_stat_info.stat),
 8341|      0|                 (struct stat const *)0, (mode_t)0, (enum permstatus)tmp___52,
 8342|      0|                 typeflag);
 8343|      0|      }
 8344|      0|      goto switch_break;
 8345|      0|    case_50 : /* CIL Label */
 8346|      0|    {
 8347|      0|      tmp___11 = prepare_to_extract((char const *)file_name);
 8348|      0|    }
 8349|      0|      if (!tmp___11) {
 8350|      0|        goto switch_break;
 8351|      0|      }
 8352|      0|      if (absolute_names_option) {
 8353|      0|        goto _L;
 8354|      0|      } else {
 8355|      0|        if ((int)*(current_stat_info.link_name + 0) == 47) {
 8356|      0|          goto _L___0;
 8357|      0|        } else {
 8358|      0|          {
 8359|      0|            tmp___23 =
 8360|      0|                contains_dot_dot((char const *)current_stat_info.link_name);
 8361|      0|          }
 8362|      0|          if (tmp___23) {
 8363|      0|          _L___0 : {
 8364|      0|            while (1) {
 8365|      0|            while_continue___0: /* CIL Label */;
 8366|      0|              { fd = open((char const *)file_name, 193, 0); }
 8367|      0|              if (!(fd < 0)) {
 8368|      0|                goto while_break___0;
 8369|      0|              }
 8370|      0|              { tmp___13 = maybe_recoverable(file_name, &interdir_made); }
 8371|      0|              if (!tmp___13) {
 8372|      0|                goto while_break___0;
 8373|      0|              }
 8374|      0|            }
 8375|      0|          while_break___0: /* CIL Label */;
 8376|      0|          }
 8377|      0|            status = -1;
 8378|      0|            if (fd < 0) {
 8379|      0|              {
 8380|      0|                open_error((char const *)file_name);
 8381|      0|              }
 8382|      0|            } else {
 8383|      0|              { tmp___22 = fstat(fd, &st); }
 8384|      0|              if (tmp___22 != 0) {
 8385|      0|                {
 8386|      0|                  stat_error((char const *)file_name);
 8387|      0|                  close(fd);
 8388|      0|                }
 8389|      0|              } else {
 8390|      0|                { tmp___21 = close(fd); }
 8391|      0|                if (tmp___21 != 0) {
 8392|      0|                  {
 8393|      0|                    close_error((char const *)file_name);
 8394|      0|                  }
 8395|      0|                } else {
 8396|      0|                  {
 8397|      0|                    tmp___14 =
 8398|      0|                        strlen((char const *)current_stat_info.link_name);
 8399|      0|                    tmp___15 =
 8400|      0|                        xmalloc(((unsigned long)(&((struct delayed_symlink *)0)
 8401|      0|                                                      ->target) +
 8402|      0|                                 tmp___14) +
 8403|      0|                                1UL);
 8404|      0|                    p = (struct delayed_symlink *)tmp___15;
 8405|      0|                    p->next = delayed_symlink_head;
 8406|      0|                    delayed_symlink_head = p;
 8407|      0|                    p->dev = st.st_dev;
 8408|      0|                    p->ino = st.st_ino;
 8409|      0|                    p->mtime = st.st_mtim.tv_sec;
 8410|      0|                    p->uid = current_stat_info.stat.st_uid;
 8411|      0|                    p->gid = current_stat_info.stat.st_gid;
 8412|      0|                    tmp___16 = strlen((char const *)file_name);
 8413|      0|                    tmp___17 = xmalloc(
 8414|      0|                        ((unsigned long)(&((struct string_list *)0)->string) +
 8415|      0|                         tmp___16) +
 8416|      0|                        1UL);
 8417|      0|                    p->sources = (struct string_list *)tmp___17;
 8418|      0|                    (p->sources)->next = (struct string_list *)0;
 8419|      0|                    strcpy((char * /* __restrict  */)((p->sources)->string),
 8420|      0|                           (char const * /* __restrict  */)file_name);
 8421|      0|                    strcpy((char * /* __restrict  */)(p->target),
 8422|      0|                           (char const * /* __restrict  */)
 8423|      0|                               current_stat_info.link_name);
 8424|      0|                    h = delayed_set_stat_head;
 8425|      0|                  }
 8426|      0|                  if (h) {
 8427|      0|                    if (!h->after_symlinks) {
 8428|      0|                      {
 8429|      0|                        tmp___19 = strncmp((char const *)file_name,
 8430|      0|                                           (char const *)(h->file_name),
 8431|      0|                                           h->file_name_len);
 8432|      0|                      }
 8433|      0|                      if (tmp___19 == 0) {
 8434|      0|                        if ((int)*(file_name + h->file_name_len) == 47) {
 8435|      0|                          {
 8436|      0|                            tmp___20 = base_name((char const *)file_name);
 8437|      0|                          }
 8438|      0|                          if ((unsigned long)tmp___20 ==
 8439|      0|                              (unsigned long)((file_name + h->file_name_len) +
 8440|      0|                                              1)) {
 8441|      0|                            {
 8442|      0|                              while (1) {
 8443|      0|                              while_continue___1: /* CIL Label */;
 8444|      0|                                {
 8445|      0|                                  h->after_symlinks = (_Bool)1;
 8446|      0|                                  tmp___18 = stat(
 8447|      0|                                      (char const * /* __restrict  */)(
 8448|      0|                                          h->file_name),
 8449|      0|                                      (struct stat * /* __restrict  */)(&st));
 8450|      0|                                }
 8451|      0|                                if (tmp___18 != 0) {
 8452|      0|                                  {
 8453|      0|                                    stat_error((char const *)(h->file_name));
 8454|      0|                                  }
 8455|      0|                                } else {
 8456|      0|                                  h->stat_info.st_dev = st.st_dev;
 8457|      0|                                  h->stat_info.st_ino = st.st_ino;
 8458|      0|                                }
 8459|      0|                                h = h->next;
 8460|      0|                                if (h) {
 8461|      0|                                  if (!(!h->after_symlinks)) {
 8462|      0|                                    goto while_break___1;
 8463|      0|                                  }
 8464|      0|                                } else {
 8465|      0|                                  goto while_break___1;
 8466|      0|                                }
 8467|      0|                              }
 8468|      0|                            while_break___1: /* CIL Label */;
 8469|      0|                            }
 8470|      0|                          }
 8471|      0|                        }
 8472|      0|                      }
 8473|      0|                    }
 8474|      0|                  }
 8475|      0|                  status = 0;
 8476|      0|                }
 8477|      0|              }
 8478|      0|            }
 8479|      0|          } else {
 8480|      0|          _L : {
 8481|      0|            while (1) {
 8482|      0|            while_continue___2: /* CIL Label */;
 8483|      0|              {
 8484|      0|                status = symlink((char const *)current_stat_info.link_name,
 8485|      0|                                 (char const *)file_name);
 8486|      0|              }
 8487|      0|              if (!(status != 0)) {
 8488|      0|                goto while_break___2;
 8489|      0|              }
 8490|      0|              { tmp___12 = maybe_recoverable(file_name, &interdir_made); }
 8491|      0|              if (!tmp___12) {
 8492|      0|                goto while_break___2;
 8493|      0|              }
 8494|      0|            }
 8495|      0|          while_break___2: /* CIL Label */;
 8496|      0|          }
 8497|      0|            if (status == 0) {
 8498|      0|              {
 8499|      0|                set_stat((char const *)file_name,
 8500|      0|                         (struct stat const *)(&current_stat_info.stat),
 8501|      0|                         (struct stat const *)0, (mode_t)0, (enum permstatus)0,
 8502|      0|                         (char)'2');
 8503|      0|              }
 8504|      0|            } else {
 8505|      0|              {
 8506|      0|                symlink_error((char const *)current_stat_info.link_name,
 8507|      0|                              (char const *)file_name);
 8508|      0|              }
 8509|      0|            }
 8510|      0|          }
 8511|      0|        }
 8512|      0|      }
 8513|      0|      if (status != 0) {
 8514|      0|        if (backup_option) {
 8515|      0|          {
 8516|      0|            undo_last_backup();
 8517|      0|          }
 8518|      0|        }
 8519|      0|      }
 8520|      0|      goto switch_break;
 8521|      0|    case_49 : /* CIL Label */
 8522|      0|    {
 8523|      0|      tmp___24 = prepare_to_extract((char const *)file_name);
 8524|      0|    }
 8525|      0|      if (!tmp___24) {
 8526|      0|        goto switch_break;
 8527|      0|      }
 8528|      0|    again_link : {
 8529|      0|      tmp___25 = safer_name_suffix((char const *)current_stat_info.link_name,
 8530|      0|                                   (_Bool)1);
 8531|      0|      link_name = (char const *)tmp___25;
 8532|      0|      status = link(link_name, (char const *)file_name);
 8533|      0|    }
 8534|      0|      if (status == 0) {
 8535|      0|        ds = delayed_symlink_head;
 8536|      0|        if (ds) {
 8537|      0|          {
 8538|      0|            tmp___28 = stat((char const * /* __restrict  */)link_name,
 8539|      0|                            (struct stat * /* __restrict  */)(&st1));
 8540|      0|          }
 8541|      0|          if (tmp___28 == 0) {
 8542|      0|            {
 8543|      0|              while (1) {
 8544|      0|              while_continue___3: /* CIL Label */;
 8545|      0|                if (!ds) {
 8546|      0|                  goto while_break___3;
 8547|      0|                }
 8548|      0|                if (ds->dev == st1.st_dev) {
 8549|      0|                  if (ds->ino == st1.st_ino) {
 8550|      0|                    if (ds->mtime == st1.st_mtim.tv_sec) {
 8551|      0|                      {
 8552|      0|                        tmp___26 = strlen((char const *)file_name);
 8553|      0|                        tmp___27 =
 8554|      0|                            xmalloc(((unsigned long)(&((struct string_list *)0)
 8555|      0|                                                          ->string) +
 8556|      0|                                     tmp___26) +
 8557|      0|                                    1UL);
 8558|      0|                        p___0 = (struct string_list *)tmp___27;
 8559|      0|                        strcpy((char * /* __restrict  */)(p___0->string),
 8560|      0|                               (char const * /* __restrict  */)file_name);
 8561|      0|                        p___0->next = ds->sources;
 8562|      0|                        ds->sources = p___0;
 8563|      0|                      }
 8564|      0|                      goto while_break___3;
 8565|      0|                    }
 8566|      0|                  }
 8567|      0|                }
 8568|      0|                ds = ds->next;
 8569|      0|              }
 8570|      0|            while_break___3: /* CIL Label */;
 8571|      0|            }
 8572|      0|          }
 8573|      0|        }
 8574|      0|        goto switch_break;
 8575|      0|      }
 8576|      0|      { tmp___29 = maybe_recoverable(file_name, &interdir_made); }
 8577|      0|      if (tmp___29) {
 8578|      0|        goto again_link;
 8579|      0|      }
 8580|      0|      if (incremental_option) {
 8581|      0|        {
 8582|      0|          tmp___30 = __errno_location();
 8583|      0|        }
 8584|      0|        if (*tmp___30 == 17) {
 8585|      0|          goto switch_break;
 8586|      0|        }
 8587|      0|      }
 8588|      0|      {
 8589|      0|        tmp___31 = __errno_location();
 8590|      0|        e___0 = *tmp___31;
 8591|      0|        tmp___32 = stat((char const * /* __restrict  */)link_name,
 8592|      0|                        (struct stat * /* __restrict  */)(&st1));
 8593|      0|      }
 8594|      0|      if (tmp___32 == 0) {
 8595|      0|        {
 8596|      0|          tmp___33 = stat((char const * /* __restrict  */)file_name,
 8597|      0|                          (struct stat * /* __restrict  */)(&st2));
 8598|      0|        }
 8599|      0|        if (tmp___33 == 0) {
 8600|      0|          if (st1.st_dev == st2.st_dev) {
 8601|      0|            if (st1.st_ino == st2.st_ino) {
 8602|      0|              goto switch_break;
 8603|      0|            }
 8604|      0|          }
 8605|      0|        }
 8606|      0|      }
 8607|      0|      { link_error(link_name, (char const *)file_name); }
 8608|      0|      if (backup_option) {
 8609|      0|        {
 8610|      0|          undo_last_backup();
 8611|      0|        }
 8612|      0|      }
 8613|      0|      goto switch_break;
 8614|      0|    case_51: /* CIL Label */
 8615|      0|      current_stat_info.stat.st_mode |= 8192U;
 8616|      0|      goto make_node;
 8617|      0|    case_52: /* CIL Label */
 8618|      0|      current_stat_info.stat.st_mode |= 24576U;
 8619|      0|    make_node : { tmp___34 = prepare_to_extract((char const *)file_name); }
 8620|      0|      if (!tmp___34) {
 8621|      0|        goto switch_break;
 8622|      0|      }
 8623|      0|      {
 8624|      0|        status = mknod((char const *)file_name, current_stat_info.stat.st_mode,
 8625|      0|                       current_stat_info.stat.st_rdev);
 8626|      0|      }
 8627|      0|      if (status != 0) {
 8628|      0|        {
 8629|      0|          tmp___35 = maybe_recoverable(file_name, &interdir_made);
 8630|      0|        }
 8631|      0|        if (tmp___35) {
 8632|      0|          goto make_node;
 8633|      0|        }
 8634|      0|        { mknod_error((char const *)file_name); }
 8635|      0|        if (backup_option) {
 8636|      0|          {
 8637|      0|            undo_last_backup();
 8638|      0|          }
 8639|      0|        }
 8640|      0|        goto switch_break;
 8641|      0|      }
 8642|      0|      {
 8643|      0|        set_stat((char const *)file_name,
 8644|      0|                 (struct stat const *)(&current_stat_info.stat),
 8645|      0|                 (struct stat const *)0, (mode_t)0, (enum permstatus)1,
 8646|      0|                 typeflag);
 8647|      0|      }
 8648|      0|      goto switch_break;
 8649|      0|    case_54 : /* CIL Label */
 8650|      0|    {
 8651|      0|      tmp___36 = prepare_to_extract((char const *)file_name);
 8652|      0|    }
 8653|      0|      if (!tmp___36) {
 8654|      0|        goto switch_break;
 8655|      0|      }
 8656|      0|      {
 8657|      0|        while (1) {
 8658|      0|        while_continue___4: /* CIL Label */;
 8659|      0|          {
 8660|      0|            status =
 8661|      0|                mkfifo((char const *)file_name, current_stat_info.stat.st_mode);
 8662|      0|          }
 8663|      0|          if (!(status != 0)) {
 8664|      0|            goto while_break___4;
 8665|      0|          }
 8666|      0|          { tmp___37 = maybe_recoverable(file_name, &interdir_made); }
 8667|      0|          if (!tmp___37) {
 8668|      0|            goto while_break___4;
 8669|      0|          }
 8670|      0|        }
 8671|      0|      while_break___4: /* CIL Label */;
 8672|      0|      }
 8673|      0|      if (status == 0) {
 8674|      0|        {
 8675|      0|          set_stat((char const *)file_name,
 8676|      0|                   (struct stat const *)(&current_stat_info.stat),
 8677|      0|                   (struct stat const *)((void *)0), (mode_t)0,
 8678|      0|                   (enum permstatus)1, typeflag);
 8679|      0|        }
 8680|      0|      } else {
 8681|      0|        { mkfifo_error((char const *)file_name); }
 8682|      0|        if (backup_option) {
 8683|      0|          {
 8684|      0|            undo_last_backup();
 8685|      0|          }
 8686|      0|        }
 8687|      0|      }
 8688|      0|      goto switch_break;
 8689|      0|    really_dir:
 8690|      0|    case_53: /* CIL Label */
 8691|      0|    case_68: /* CIL Label */
 8692|      0|      if (incremental_option) {
 8693|      0|        {
 8694|      0|          gnu_restore((char const *)file_name);
 8695|      0|        }
 8696|      0|      } else {
 8697|      0|        if ((int)typeflag == 68) {
 8698|      0|          {
 8699|      0|            skip_member();
 8700|      0|          }
 8701|      0|        }
 8702|      0|      }
 8703|      0|      if (we_are_root) {
 8704|      0|        tmp___53 = 0;
 8705|      0|      } else {
 8706|      0|        tmp___53 = 192;
 8707|      0|      }
 8708|      0|      {
 8709|      0|        mode = (current_stat_info.stat.st_mode | (unsigned int)tmp___53) &
 8710|      0|               (unsigned int)(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 8711|      0|                              (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 8712|      0|                               ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
 8713|      0|        status = prepare_to_extract((char const *)file_name);
 8714|      0|      }
 8715|      0|      if (status == 0) {
 8716|      0|        goto switch_break;
 8717|      0|      }
 8718|      0|      if (status < 0) {
 8719|      0|        goto directory_exists;
 8720|      0|      }
 8721|      0|    again_dir : { status = mkdir((char const *)file_name, mode); }
 8722|      0|      if (status != 0) {
 8723|      0|        {
 8724|      0|          tmp___40 = __errno_location();
 8725|      0|        }
 8726|      0|        if (*tmp___40 == 17) {
 8727|      0|          if (interdir_made) {
 8728|      0|            goto _L___3;
 8729|      0|          } else {
 8730|      0|            if ((unsigned int)old_files_option == 0U) {
 8731|      0|              goto _L___3;
 8732|      0|            } else {
 8733|      0|              if ((unsigned int)old_files_option == 2U) {
 8734|      0|              _L___3 : /* CIL Label */
 8735|      0|              {
 8736|      0|                tmp___38 = stat((char const * /* __restrict  */)file_name,
 8737|      0|                                (struct stat * /* __restrict  */)(&st___0));
 8738|      0|              }
 8739|      0|                if (tmp___38 == 0) {
 8740|      0|                  if (interdir_made) {
 8741|      0|                    {
 8742|      0|                      repair_delayed_set_stat((char const *)file_name,
 8743|      0|                                              (struct stat const *)(&st___0));
 8744|      0|                    }
 8745|      0|                    goto switch_break;
 8746|      0|                  }
 8747|      0|                  if ((st___0.st_mode & 61440U) == 16384U) {
 8748|      0|                    mode = st___0.st_mode & ~current_umask;
 8749|      0|                    goto directory_exists;
 8750|      0|                  }
 8751|      0|                }
 8752|      0|                {
 8753|      0|                  tmp___39 = __errno_location();
 8754|      0|                  *tmp___39 = 17;
 8755|      0|                }
 8756|      0|              }
 8757|      0|            }
 8758|      0|          }
 8759|      0|        }
 8760|      0|        { tmp___41 = maybe_recoverable(file_name, &interdir_made); }
 8761|      0|        if (tmp___41) {
 8762|      0|          goto again_dir;
 8763|      0|        }
 8764|      0|        { tmp___42 = __errno_location(); }
 8765|      0|        if (*tmp___42 != 17) {
 8766|      0|          {
 8767|      0|            mkdir_error((char const *)file_name);
 8768|      0|          }
 8769|      0|          if (backup_option) {
 8770|      0|            {
 8771|      0|              undo_last_backup();
 8772|      0|            }
 8773|      0|          }
 8774|      0|          goto switch_break;
 8775|      0|        }
 8776|      0|      }
 8777|      0|    directory_exists:
 8778|      0|      if (status == 0) {
 8779|      0|        goto _L___4;
 8780|      0|      } else {
 8781|      0|        if ((unsigned int)old_files_option == 0U) {
 8782|      0|          goto _L___4;
 8783|      0|        } else {
 8784|      0|          if ((unsigned int)old_files_option == 2U) {
 8785|      0|          _L___4: /* CIL Label */
 8786|      0|            if (status == 0) {
 8787|      0|              tmp___54 = 1;
 8788|      0|            } else {
 8789|      0|              tmp___54 = 0;
 8790|      0|            }
 8791|      0|            {
 8792|      0|              delay_set_stat(
 8793|      0|                  (char const *)file_name,
 8794|      0|                  (struct stat const *)(&current_stat_info.stat),
 8795|      0|                  (unsigned int)(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) |
 8796|      0|                                 (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
 8797|      0|                                  ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))) &
 8798|      0|                      (mode ^ current_stat_info.stat.st_mode),
 8799|      0|                  (enum permstatus)tmp___54);
 8800|      0|            }
 8801|      0|          }
 8802|      0|        }
 8803|      0|      }
 8804|      0|      goto switch_break;
 8805|      0|    case_86: /* CIL Label */
 8806|      0|      if (verbose_option) {
 8807|      0|        {
 8808|      0|          tmp___43 = quote((char const *)current_stat_info.file_name);
 8809|      0|          tmp___44 = gettext("Reading %s\n");
 8810|      0|          fprintf((FILE * /* __restrict  */) stdlis,
 8811|      0|                  (char const * /* __restrict  */)tmp___44, tmp___43);
 8812|      0|        }
 8813|      0|      }
 8814|      0|      goto switch_break;
 8815|      0|    case_78 : /* CIL Label */
 8816|      0|    {
 8817|      0|      extract_mangle();
 8818|      0|    }
 8819|      0|      goto switch_break;
 8820|      0|    case_77 : /* CIL Label */
 8821|      0|    {
 8822|      0|      tmp___45 = quotearg_colon((char const *)current_stat_info.file_name);
 8823|      0|      tmp___46 = gettext(
 8824|      0|          "%s: Cannot extract -- file is continued from another volume");
 8825|      0|      error(0, 0, (char const *)tmp___46, tmp___45);
 8826|      0|      exit_status = 2;
 8827|      0|      skip_member();
 8828|      0|    }
 8829|      0|      if (backup_option) {
 8830|      0|        {
 8831|      0|          undo_last_backup();
 8832|      0|        }
 8833|      0|      }
 8834|      0|      goto switch_break;
 8835|      0|    case_76:  /* CIL Label */
 8836|      0|    case_75 : /* CIL Label */
 8837|      0|    {
 8838|      0|      tmp___47 = gettext("Visible long name error");
 8839|      0|      error(0, 0, (char const *)tmp___47);
 8840|      0|      exit_status = 2;
 8841|      0|      skip_member();
 8842|      0|    }
 8843|      0|      if (backup_option) {
 8844|      0|        {
 8845|      0|          undo_last_backup();
 8846|      0|        }
 8847|      0|      }
 8848|      0|      goto switch_break;
 8849|      0|    switch_default : /* CIL Label */
 8850|      0|    {
 8851|      0|      tmp___48 = quotearg_colon((char const *)file_name);
 8852|      0|      tmp___49 =
 8853|      0|          gettext("%s: Unknown file type \'%c\', extracted as normal file");
 8854|      0|      error(0, 0, (char const *)tmp___49, tmp___48, (int)typeflag);
 8855|      0|    }
 8856|      0|      goto again_file;
 8857|      0|    switch_break: /* CIL Label */;
 8858|      0|    }
 8859|      0|    return;
 8860|      0|  }
 8861|      0|}
 8862|      0|static void apply_delayed_symlinks(void) {
 8863|      0|  struct delayed_symlink *ds;
 8864|      0|  struct string_list *sources;
 8865|      0|  char const *valid_source;
 8866|      0|  char const *source;
 8867|      0|  struct stat st;
 8868|      0|  int tmp;
 8869|      0|  int tmp___0;
 8870|      0|  int tmp___1;
 8871|      0|  int tmp___2;
 8872|      0|  struct string_list *next;
 8873|      0|  struct delayed_symlink *next___0;
 8874|      0|  void *__cil_tmp12;
 8875|       |
 8876|      0|  {
 8877|      0|    ds = delayed_symlink_head;
 8878|      0|    {
 8879|      0|      while (1) {
 8880|      0|      while_continue: /* CIL Label */;
 8881|      0|        if (!ds) {
 8882|      0|          goto while_break;
 8883|      0|        }
 8884|      0|        sources = ds->sources;
 8885|      0|        valid_source = (char const *)0;
 8886|      0|        sources = ds->sources;
 8887|      0|        {
 8888|      0|          while (1) {
 8889|      0|          while_continue___0: /* CIL Label */;
 8890|      0|            if (!sources) {
 8891|      0|              goto while_break___0;
 8892|      0|            }
 8893|      0|            {
 8894|      0|              source = (char const *)(sources->string);
 8895|      0|              tmp___2 = lstat((char const * /* __restrict  */)source,
 8896|      0|                              (struct stat * /* __restrict  */)(&st));
 8897|      0|            }
 8898|      0|            if (tmp___2 == 0) {
 8899|      0|              if (st.st_dev == ds->dev) {
 8900|      0|                if (st.st_ino == ds->ino) {
 8901|      0|                  if (st.st_mtim.tv_sec == ds->mtime) {
 8902|      0|                    {
 8903|      0|                      tmp___1 = unlink(source);
 8904|      0|                    }
 8905|      0|                    if (tmp___1 != 0) {
 8906|      0|                      {
 8907|      0|                        unlink_error(source);
 8908|      0|                      }
 8909|      0|                    } else {
 8910|      0|                      if (valid_source) {
 8911|      0|                        {
 8912|      0|                          tmp___0 = link(valid_source, source);
 8913|      0|                        }
 8914|      0|                        if (!(tmp___0 == 0)) {
 8915|      0|                          goto _L;
 8916|      0|                        }
 8917|      0|                      } else {
 8918|      0|                      _L : {
 8919|      0|                        tmp = symlink((char const *)(ds->target), source);
 8920|      0|                      }
 8921|      0|                        if (tmp != 0) {
 8922|      0|                          {
 8923|      0|                            symlink_error((char const *)(ds->target), source);
 8924|      0|                          }
 8925|      0|                        } else {
 8926|      0|                          {
 8927|      0|                            valid_source = source;
 8928|      0|                            st.st_uid = ds->uid;
 8929|      0|                            st.st_gid = ds->gid;
 8930|      0|                            set_stat(source, (struct stat const *)(&st),
 8931|      0|                                     (struct stat const *)0, (mode_t)0,
 8932|      0|                                     (enum permstatus)0, (char)'2');
 8933|      0|                          }
 8934|      0|                        }
 8935|      0|                      }
 8936|      0|                    }
 8937|      0|                  }
 8938|      0|                }
 8939|      0|              }
 8940|      0|            }
 8941|      0|            sources = sources->next;
 8942|      0|          }
 8943|      0|        while_break___0: /* CIL Label */;
 8944|      0|        }
 8945|      0|        sources = ds->sources;
 8946|      0|        {
 8947|      0|          while (1) {
 8948|      0|          while_continue___1: /* CIL Label */;
 8949|      0|            if (!sources) {
 8950|      0|              goto while_break___1;
 8951|      0|            }
 8952|      0|            {
 8953|      0|              next = sources->next;
 8954|      0|              free((void *)sources);
 8955|      0|              sources = next;
 8956|      0|            }
 8957|      0|          }
 8958|      0|        while_break___1: /* CIL Label */;
 8959|      0|        }
 8960|      0|        {
 8961|      0|          next___0 = ds->next;
 8962|      0|          free((void *)ds);
 8963|      0|          ds = next___0;
 8964|      0|        }
 8965|      0|      }
 8966|      0|    while_break: /* CIL Label */;
 8967|      0|    }
 8968|      0|    delayed_symlink_head = (struct delayed_symlink *)0;
 8969|      0|    return;
 8970|      0|  }
 8971|      0|}
 8972|      0|void extract_finish(void) {
 8973|      0|  char *__cil_tmp1;
 8974|      0|  char *__cil_tmp2;
 8975|       |
 8976|      0|  {
 8977|      0|    {
 8978|      0|      apply_nonancestor_delayed_set_stat("", (_Bool)0);
 8979|      0|      apply_delayed_symlinks();
 8980|      0|      apply_nonancestor_delayed_set_stat("", (_Bool)1);
 8981|      0|    }
 8982|      0|    return;
 8983|      0|  }
 8984|      0|}
 8985|       |__attribute__((__noreturn__)) void fatal_exit(void);
 8986|      0|void fatal_exit(void) {
 8987|      0|  char *tmp;
 8988|      0|  char *__cil_tmp2;
 8989|       |
 8990|      0|  {
 8991|      0|    {
 8992|      0|      extract_finish();
 8993|      0|      tmp = gettext("Error is not recoverable: exiting now");
 8994|      0|      error(2, 0, (char const *)tmp);
 8995|      0|      abort();
 8996|      0|    }
 8997|      0|  }
 8998|      0|}
 8999|       |/* #pragma merger("0","005.xheader.o.i","") */
 9000|       |extern __attribute__((__nothrow__)) unsigned short const **(
 9001|       |    __attribute__((__leaf__)) __ctype_b_loc)(void)__attribute__((__const__));
 9002|       |extern __attribute__((__nothrow__)) char *(
 9003|       |    __attribute__((__nonnull__(2), __leaf__))
 9004|       |    strtok)(char *__restrict __s, char const *__restrict __delim);
 9005|       |extern __attribute__((__nothrow__)) char *(
 9006|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 9007|       |    stpcpy)(char *__restrict __dest, char const *__restrict __src);
 9008|       |extern __attribute__((__nothrow__))
 9009|       |__pid_t(__attribute__((__leaf__)) getpid)(void);
 9010|       |extern __attribute__((__nothrow__)) unsigned long(__attribute__((
 9011|       |    __nonnull__(1), __leaf__)) strtoul)(char const *__restrict __nptr,
 9012|       |                                        char **__restrict __endptr, int __base);
 9013|       |extern
 9014|       |    __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
 9015|       |                                        calloc)(size_t __nmemb, size_t __size)
 9016|       |        __attribute__((__malloc__));
 9017|       |extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1),
 9018|       |                                                          __leaf__))
 9019|       |                                           getenv)(char const *__name);
 9020|       |char *dir_name(char const *path);
 9021|       |strtol_error xstrtoumax(char const *s, char **ptr, int strtol_base,
 9022|       |                        uintmax_t *val, char const *valid_suffixes);
 9023|       |__attribute__((__noreturn__)) void usage(int status);
 9024|       |void xheader_decode_global(void);
 9025|       |void xheader_read(union block *p, size_t size);
 9026|       |void xheader_destroy(struct xheader *xhdr);
 9027|       |char *xheader_ghdr_name(void);
 9028|       |void xheader_set_option(char *string);
 9029|       |_Bool utf8_convert(_Bool to_utf, char const *input, char **output);
 9030|       |extern void _obstack_newchunk(struct obstack *, int);
 9031|       |extern int _obstack_begin(struct obstack *, int, int, void *(*)(long),
 9032|       |                          void (*)(void *));
 9033|       |extern void obstack_free(struct obstack *obstack, void *block);
 9034|       |static _Bool xheader_protected_pattern_p(char const *pattern);
 9035|       |static _Bool xheader_protected_keyword_p(char const *keyword);
 9036|       |static __attribute__((__noreturn__)) void xheader_set_single_keyword(char *kw);
 9037|       |static void code_string(char const *string, char const *keyword,
 9038|       |                        struct xheader *xhdr);
 9039|       |static void extended_header_init(void);
 9040|       |static size_t global_header_count;
 9041|       |static struct keyword_list *keyword_pattern_list;
 9042|       |static struct keyword_list *keyword_global_override_list;
 9043|       |static struct keyword_list *keyword_override_list;
 9044|       |static struct keyword_list *global_header_override_list;
 9045|       |static char *exthdr_name;
 9046|       |static char *globexthdr_name;
 9047|      0|static _Bool xheader_keyword_deleted_p(char const *kw) {
 9048|      0|  struct keyword_list *kp;
 9049|      0|  int tmp;
 9050|       |
 9051|      0|  {
 9052|      0|    kp = keyword_pattern_list;
 9053|      0|    {
 9054|      0|      while (1) {
 9055|      0|      while_continue: /* CIL Label */;
 9056|      0|        if (!kp) {
 9057|      0|          goto while_break;
 9058|      0|        }
 9059|      0|        { tmp = fnmatch((char const *)kp->pattern, kw, 0); }
 9060|      0|        if (tmp == 0) {
 9061|      0|          return ((_Bool)1);
 9062|      0|        }
 9063|      0|        kp = kp->next;
 9064|      0|      }
 9065|      0|    while_break: /* CIL Label */;
 9066|      0|    }
 9067|      0|    return ((_Bool)0);
 9068|      0|  }
 9069|      0|}
 9070|      0|static _Bool xheader_keyword_override_p(char const *keyword) {
 9071|      0|  struct keyword_list *kp;
 9072|      0|  int tmp;
 9073|       |
 9074|      0|  {
 9075|      0|    kp = keyword_override_list;
 9076|      0|    {
 9077|      0|      while (1) {
 9078|      0|      while_continue: /* CIL Label */;
 9079|      0|        if (!kp) {
 9080|      0|          goto while_break;
 9081|      0|        }
 9082|      0|        { tmp = strcmp((char const *)kp->pattern, keyword); }
 9083|      0|        if (tmp == 0) {
 9084|      0|          return ((_Bool)1);
 9085|      0|        }
 9086|      0|        kp = kp->next;
 9087|      0|      }
 9088|      0|    while_break: /* CIL Label */;
 9089|      0|    }
 9090|      0|    return ((_Bool)0);
 9091|      0|  }
 9092|      0|}
 9093|       |static void xheader_list_append(struct keyword_list **root, char const *kw,
 9094|      0|                                char const *value) {
 9095|      0|  struct keyword_list *kp;
 9096|      0|  void *tmp;
 9097|      0|  char *tmp___0;
 9098|       |
 9099|      0|  {
 9100|      0|    {
 9101|      0|      tmp = xmalloc(sizeof(*kp));
 9102|      0|      kp = (struct keyword_list *)tmp;
 9103|      0|      kp->pattern = xstrdup(kw);
 9104|      0|    }
 9105|      0|    if (value) {
 9106|      0|      {
 9107|      0|        tmp___0 = xstrdup(value);
 9108|      0|        kp->value = tmp___0;
 9109|      0|      }
 9110|      0|    } else {
 9111|      0|      kp->value = (char *)((void *)0);
 9112|      0|    }
 9113|      0|    kp->next = *root;
 9114|      0|    *root = kp;
 9115|      0|    return;
 9116|      0|  }
 9117|      0|}
 9118|      0|static void xheader_list_destroy(struct keyword_list **root) {
 9119|      0|  struct keyword_list *kw;
 9120|      0|  struct keyword_list *next;
 9121|       |
 9122|      0|  {
 9123|      0|    if (root) {
 9124|      0|      kw = *root;
 9125|      0|      {
 9126|      0|        while (1) {
 9127|      0|        while_continue: /* CIL Label */;
 9128|      0|          if (!kw) {
 9129|      0|            goto while_break;
 9130|      0|          }
 9131|      0|          {
 9132|      0|            next = kw->next;
 9133|      0|            free((void *)kw->pattern);
 9134|      0|            free((void *)kw->value);
 9135|      0|            free((void *)kw);
 9136|      0|            kw = next;
 9137|      0|          }
 9138|      0|        }
 9139|      0|      while_break: /* CIL Label */;
 9140|      0|      }
 9141|      0|      *root = (struct keyword_list *)((void *)0);
 9142|      0|    }
 9143|      0|    return;
 9144|      0|  }
 9145|      0|}
 9146|       |static __attribute__((__noreturn__)) void xheader_set_single_keyword(char *kw);
 9147|      0|static void xheader_set_single_keyword(char *kw) {
 9148|      0|  char *tmp;
 9149|      0|  char *__cil_tmp3;
 9150|       |
 9151|      0|  {
 9152|      0|    {
 9153|      0|      tmp = gettext("Keyword %s is unknown or not yet imlemented");
 9154|      0|      error(0, 0, (char const *)tmp, kw);
 9155|      0|      usage(2);
 9156|      0|    }
 9157|      0|  }
 9158|      0|}
 9159|      0|static void xheader_set_keyword_equal(char *kw, char *eq) {
 9160|      0|  _Bool global;
 9161|      0|  char *p;
 9162|      0|  unsigned short const **tmp;
 9163|      0|  unsigned short const **tmp___0;
 9164|      0|  char *tmp___1;
 9165|      0|  _Bool tmp___2;
 9166|      0|  char *tmp___3;
 9167|      0|  _Bool tmp___4;
 9168|      0|  int tmp___5;
 9169|      0|  int tmp___6;
 9170|      0|  int tmp___7;
 9171|      0|  char *__cil_tmp14;
 9172|      0|  char *__cil_tmp15;
 9173|       |
 9174|      0|  {
 9175|      0|    global = (_Bool)1;
 9176|      0|    p = eq;
 9177|      0|    if ((int)*(eq + -1) == 58) {
 9178|      0|      p--;
 9179|      0|      global = (_Bool)0;
 9180|      0|    }
 9181|      0|    {
 9182|      0|      while (1) {
 9183|      0|      while_continue: /* CIL Label */;
 9184|      0|        if ((unsigned long)p > (unsigned long)kw) {
 9185|      0|          {
 9186|      0|            tmp = __ctype_b_loc();
 9187|      0|          }
 9188|      0|          if (!((int const) * (*tmp + (int)*p) & 8192)) {
 9189|      0|            goto while_break;
 9190|      0|          }
 9191|      0|        } else {
 9192|      0|          goto while_break;
 9193|      0|        }
 9194|      0|        p--;
 9195|      0|      }
 9196|      0|    while_break: /* CIL Label */;
 9197|      0|    }
 9198|      0|    *p = (char)0;
 9199|      0|    p = eq + 1;
 9200|      0|    {
 9201|      0|      while (1) {
 9202|      0|      while_continue___0: /* CIL Label */;
 9203|      0|        if (*p) {
 9204|      0|          {
 9205|      0|            tmp___0 = __ctype_b_loc();
 9206|      0|          }
 9207|      0|          if (!((int const) * (*tmp___0 + (int)*p) & 8192)) {
 9208|      0|            goto while_break___0;
 9209|      0|          }
 9210|      0|        } else {
 9211|      0|          goto while_break___0;
 9212|      0|        }
 9213|      0|        p++;
 9214|      0|      }
 9215|      0|    while_break___0: /* CIL Label */;
 9216|      0|    }
 9217|      0|    { tmp___7 = strcmp((char const *)kw, "delete"); }
 9218|      0|    if (tmp___7 == 0) {
 9219|      0|      {
 9220|      0|        tmp___2 = xheader_protected_pattern_p((char const *)p);
 9221|      0|      }
 9222|      0|      if (tmp___2) {
 9223|      0|        {
 9224|      0|          tmp___1 = gettext("Pattern %s cannot be used");
 9225|      0|          error(0, 0, (char const *)tmp___1, p);
 9226|      0|          usage(2);
 9227|      0|        }
 9228|      0|      }
 9229|      0|      {
 9230|      0|        xheader_list_append(&keyword_pattern_list, (char const *)p,
 9231|      0|                            (char const *)((void *)0));
 9232|      0|      }
 9233|      0|    } else {
 9234|      0|      { tmp___6 = strcmp((char const *)kw, "exthdr.name"); }
 9235|      0|      if (tmp___6 == 0) {
 9236|      0|        {
 9237|      0|          assign_string(&exthdr_name, (char const *)p);
 9238|      0|        }
 9239|      0|      } else {
 9240|      0|        { tmp___5 = strcmp((char const *)kw, "globexthdr.name"); }
 9241|      0|        if (tmp___5 == 0) {
 9242|      0|          {
 9243|      0|            assign_string(&globexthdr_name, (char const *)p);
 9244|      0|          }
 9245|      0|        } else {
 9246|      0|          { tmp___4 = xheader_protected_keyword_p((char const *)kw); }
 9247|      0|          if (tmp___4) {
 9248|      0|            {
 9249|      0|              tmp___3 = gettext("Keyword %s cannot be overridden");
 9250|      0|              error(0, 0, (char const *)tmp___3, kw);
 9251|      0|              usage(2);
 9252|      0|            }
 9253|      0|          }
 9254|      0|          if (global) {
 9255|      0|            {
 9256|      0|              xheader_list_append(&keyword_global_override_list,
 9257|      0|                                  (char const *)kw, (char const *)p);
 9258|      0|            }
 9259|      0|          } else {
 9260|      0|            {
 9261|      0|              xheader_list_append(&keyword_override_list, (char const *)kw,
 9262|      0|                                  (char const *)p);
 9263|      0|            }
 9264|      0|          }
 9265|      0|        }
 9266|      0|      }
 9267|      0|    }
 9268|      0|    return;
 9269|      0|  }
 9270|      0|}
 9271|      0|void xheader_set_option(char *string) {
 9272|      0|  char *token;
 9273|      0|  char *p;
 9274|      0|  char *tmp;
 9275|       |
 9276|      0|  {
 9277|      0|    {
 9278|      0|      token = strtok((char * /* __restrict  */)string,
 9279|      0|                     (char const * /* __restrict  */) ",");
 9280|      0|    }
 9281|      0|    {
 9282|      0|      while (1) {
 9283|      0|      while_continue: /* CIL Label */;
 9284|      0|        if (!token) {
 9285|      0|          goto while_break;
 9286|      0|        }
 9287|      0|        {
 9288|      0|          tmp = strchr((char const *)token, '=');
 9289|      0|          p = tmp;
 9290|      0|        }
 9291|      0|        if (!p) {
 9292|      0|          {
 9293|      0|            xheader_set_single_keyword(token);
 9294|      0|          }
 9295|      0|        } else {
 9296|      0|          { xheader_set_keyword_equal(token, p); }
 9297|      0|        }
 9298|      0|        {
 9299|      0|          token = strtok((char * /* __restrict  */)((void *)0),
 9300|      0|                         (char const * /* __restrict  */) ",");
 9301|      0|        }
 9302|      0|      }
 9303|      0|    while_break: /* CIL Label */;
 9304|      0|    }
 9305|      0|    return;
 9306|      0|  }
 9307|      0|}
 9308|      0|static void to_decimal(uintmax_t value, char *where, size_t size) {
 9309|      0|  size_t i;
 9310|      0|  size_t j;
 9311|      0|  size_t tmp;
 9312|      0|  size_t tmp___0;
 9313|      0|  char c;
 9314|       |
 9315|      0|  {
 9316|      0|    i = (size_t)0;
 9317|      0|    tmp = i;
 9318|      0|    i++;
 9319|      0|    *(where + tmp) = (char)0;
 9320|      0|    {
 9321|      0|      while (1) {
 9322|      0|      while_continue: /* CIL Label */;
 9323|      0|        tmp___0 = i;
 9324|      0|        i++;
 9325|      0|        *(where + tmp___0) = (char)(48UL + value % 10UL);
 9326|      0|        value /= 10UL;
 9327|      0|        if (i < size) {
 9328|      0|          if (!value) {
 9329|      0|            goto while_break;
 9330|      0|          }
 9331|      0|        } else {
 9332|      0|          goto while_break;
 9333|      0|        }
 9334|      0|      }
 9335|      0|    while_break: /* CIL Label */;
 9336|      0|    }
 9337|      0|    j = (size_t)0;
 9338|      0|    i--;
 9339|      0|    {
 9340|      0|      while (1) {
 9341|      0|      while_continue___0: /* CIL Label */;
 9342|      0|        if (!(j < i)) {
 9343|      0|          goto while_break___0;
 9344|      0|        }
 9345|      0|        c = *(where + j);
 9346|      0|        *(where + j) = *(where + i);
 9347|      0|        *(where + i) = c;
 9348|      0|        j++;
 9349|      0|        i--;
 9350|      0|      }
 9351|      0|    while_break___0: /* CIL Label */;
 9352|      0|    }
 9353|      0|    return;
 9354|      0|  }
 9355|      0|}
 9356|       |static char *xheader_format_name(struct tar_stat_info *st, char const *fmt,
 9357|      0|                                 _Bool allow_n) {
 9358|      0|  char *buf;
 9359|      0|  size_t len;
 9360|      0|  size_t tmp;
 9361|      0|  char *q;
 9362|      0|  char const *p;
 9363|      0|  char *dir;
 9364|      0|  char *base;
 9365|      0|  char pidbuf[64];
 9366|      0|  char nbuf[64];
 9367|      0|  char *tmp___0;
 9368|      0|  size_t tmp___1;
 9369|      0|  size_t tmp___2;
 9370|      0|  __pid_t tmp___3;
 9371|      0|  size_t tmp___4;
 9372|      0|  size_t tmp___5;
 9373|      0|  char *tmp___6;
 9374|      0|  void *tmp___7;
 9375|      0|  char *tmp___8;
 9376|      0|  char const *tmp___9;
 9377|      0|  char *tmp___10;
 9378|      0|  char const *tmp___11;
 9379|      0|  char *tmp___12;
 9380|      0|  char const *tmp___13;
 9381|      0|  char *tmp___14;
 9382|      0|  char const *tmp___15;
 9383|      0|  void *__cil_tmp29;
 9384|      0|  void *__cil_tmp30;
 9385|       |
 9386|      0|  {
 9387|      0|    {
 9388|      0|      tmp = strlen(fmt);
 9389|      0|      len = tmp;
 9390|      0|      dir = (char *)((void *)0);
 9391|      0|      base = (char *)((void *)0);
 9392|      0|      p = fmt;
 9393|      0|    }
 9394|      0|    {
 9395|      0|      while (1) {
 9396|      0|      while_continue: /* CIL Label */;
 9397|      0|        if (*p) {
 9398|      0|          {
 9399|      0|            tmp___6 = strchr(p, '%');
 9400|      0|            p = (char const *)tmp___6;
 9401|      0|          }
 9402|      0|          if (!p) {
 9403|      0|            goto while_break;
 9404|      0|          }
 9405|      0|        } else {
 9406|      0|          goto while_break;
 9407|      0|        }
 9408|      0|        {
 9409|      0|          if ((int const) * (p + 1) == 37) {
 9410|      0|            goto case_37;
 9411|      0|          }
 9412|      0|          if ((int const) * (p + 1) == 100) {
 9413|      0|            goto case_100;
 9414|      0|          }
 9415|      0|          if ((int const) * (p + 1) == 102) {
 9416|      0|            goto case_102;
 9417|      0|          }
 9418|      0|          if ((int const) * (p + 1) == 112) {
 9419|      0|            goto case_112;
 9420|      0|          }
 9421|      0|          if ((int const) * (p + 1) == 110) {
 9422|      0|            goto case_110;
 9423|      0|          }
 9424|      0|          goto switch_break;
 9425|      0|        case_37: /* CIL Label */
 9426|      0|          len--;
 9427|      0|          goto switch_break;
 9428|      0|        case_100: /* CIL Label */
 9429|      0|          if (st) {
 9430|      0|            {
 9431|      0|              tmp___0 = dir_name((char const *)st->orig_file_name);
 9432|      0|              dir = safer_name_suffix((char const *)tmp___0, (_Bool)0);
 9433|      0|              tmp___1 = strlen((char const *)dir);
 9434|      0|              len += tmp___1 - 1UL;
 9435|      0|            }
 9436|      0|          }
 9437|      0|          goto switch_break;
 9438|      0|        case_102: /* CIL Label */
 9439|      0|          if (st) {
 9440|      0|            {
 9441|      0|              base = base_name((char const *)st->orig_file_name);
 9442|      0|              tmp___2 = strlen((char const *)base);
 9443|      0|              len += tmp___2 - 1UL;
 9444|      0|            }
 9445|      0|          }
 9446|      0|          goto switch_break;
 9447|      0|        case_112 : /* CIL Label */
 9448|      0|        {
 9449|      0|          tmp___3 = getpid();
 9450|      0|          to_decimal((uintmax_t)tmp___3, pidbuf, sizeof(pidbuf));
 9451|      0|          tmp___4 = strlen((char const *)(pidbuf));
 9452|      0|          len += tmp___4 - 1UL;
 9453|      0|        }
 9454|      0|          goto switch_break;
 9455|      0|        case_110: /* CIL Label */
 9456|      0|          if (allow_n) {
 9457|      0|            {
 9458|      0|              to_decimal(global_header_count + 1UL, pidbuf, sizeof(pidbuf));
 9459|      0|              tmp___5 = strlen((char const *)(nbuf));
 9460|      0|              len += tmp___5 - 1UL;
 9461|      0|            }
 9462|      0|          }
 9463|      0|          goto switch_break;
 9464|      0|        switch_break: /* CIL Label */;
 9465|      0|        }
 9466|      0|        p++;
 9467|      0|      }
 9468|      0|    while_break: /* CIL Label */;
 9469|      0|    }
 9470|      0|    {
 9471|      0|      tmp___7 = xmalloc(len + 1UL);
 9472|      0|      buf = (char *)tmp___7;
 9473|      0|      q = buf;
 9474|      0|      p = fmt;
 9475|      0|    }
 9476|      0|    {
 9477|      0|      while (1) {
 9478|      0|      while_continue___0: /* CIL Label */;
 9479|      0|        if (!*p) {
 9480|      0|          goto while_break___0;
 9481|      0|        }
 9482|      0|        if ((int const) * p == 37) {
 9483|      0|          {
 9484|      0|            if ((int const) * (p + 1) == 37) {
 9485|      0|              goto case_37___0;
 9486|      0|            }
 9487|      0|            if ((int const) * (p + 1) == 100) {
 9488|      0|              goto case_100___0;
 9489|      0|            }
 9490|      0|            if ((int const) * (p + 1) == 102) {
 9491|      0|              goto case_102___0;
 9492|      0|            }
 9493|      0|            if ((int const) * (p + 1) == 112) {
 9494|      0|              goto case_112___0;
 9495|      0|            }
 9496|      0|            if ((int const) * (p + 1) == 110) {
 9497|      0|              goto case_110___0;
 9498|      0|            }
 9499|      0|            goto switch_default;
 9500|      0|          case_37___0: /* CIL Label */
 9501|      0|            tmp___8 = q;
 9502|      0|            q++;
 9503|      0|            tmp___9 = p;
 9504|      0|            p++;
 9505|      0|            *tmp___8 = (char)*tmp___9;
 9506|      0|            p++;
 9507|      0|            goto switch_break___0;
 9508|      0|          case_100___0: /* CIL Label */
 9509|      0|            if (dir) {
 9510|      0|              {
 9511|      0|                q = stpcpy((char * /* __restrict  */)q,
 9512|      0|                           (char const * /* __restrict  */)dir);
 9513|      0|              }
 9514|      0|            }
 9515|      0|            p += 2;
 9516|      0|            goto switch_break___0;
 9517|      0|          case_102___0: /* CIL Label */
 9518|      0|            if (base) {
 9519|      0|              {
 9520|      0|                q = stpcpy((char * /* __restrict  */)q,
 9521|      0|                           (char const * /* __restrict  */)base);
 9522|      0|              }
 9523|      0|            }
 9524|      0|            p += 2;
 9525|      0|            goto switch_break___0;
 9526|      0|          case_112___0 : /* CIL Label */
 9527|      0|          {
 9528|      0|            q = stpcpy((char * /* __restrict  */)q,
 9529|      0|                       (char const * /* __restrict  */)(pidbuf));
 9530|      0|            p += 2;
 9531|      0|          }
 9532|      0|            goto switch_break___0;
 9533|      0|          case_110___0: /* CIL Label */
 9534|      0|            if (allow_n) {
 9535|      0|              {
 9536|      0|                q = stpcpy((char * /* __restrict  */)q,
 9537|      0|                           (char const * /* __restrict  */)(nbuf));
 9538|      0|                p += 2;
 9539|      0|              }
 9540|      0|            }
 9541|      0|          switch_default: /* CIL Label */
 9542|      0|            tmp___10 = q;
 9543|      0|            q++;
 9544|      0|            tmp___11 = p;
 9545|      0|            p++;
 9546|      0|            *tmp___10 = (char)*tmp___11;
 9547|      0|            if (*p) {
 9548|      0|              tmp___12 = q;
 9549|      0|              q++;
 9550|      0|              tmp___13 = p;
 9551|      0|              p++;
 9552|      0|              *tmp___12 = (char)*tmp___13;
 9553|      0|            }
 9554|      0|          switch_break___0: /* CIL Label */;
 9555|      0|          }
 9556|      0|        } else {
 9557|      0|          tmp___14 = q;
 9558|      0|          q++;
 9559|      0|          tmp___15 = p;
 9560|      0|          p++;
 9561|      0|          *tmp___14 = (char)*tmp___15;
 9562|      0|        }
 9563|      0|      }
 9564|      0|    while_break___0: /* CIL Label */;
 9565|      0|    }
 9566|      0|    {
 9567|      0|      while (1) {
 9568|      0|      while_continue___1: /* CIL Label */;
 9569|      0|        if ((unsigned long)q > (unsigned long)buf) {
 9570|      0|          if (!((int)*(q + -1) == 47)) {
 9571|      0|            goto while_break___1;
 9572|      0|          }
 9573|      0|        } else {
 9574|      0|          goto while_break___1;
 9575|      0|        }
 9576|      0|        q--;
 9577|      0|      }
 9578|      0|    while_break___1: /* CIL Label */;
 9579|      0|    }
 9580|      0|    *q = (char)0;
 9581|      0|    return (buf);
 9582|      0|  }
 9583|      0|}
 9584|      0|char *xheader_xhdr_name(struct tar_stat_info *st) {
 9585|      0|  char *tmp;
 9586|      0|  char *__cil_tmp3;
 9587|       |
 9588|      0|  {
 9589|      0|    if (!exthdr_name) {
 9590|      0|      {
 9591|      0|        assign_string(&exthdr_name, "%d/PaxHeaders.%p/%f");
 9592|      0|      }
 9593|      0|    }
 9594|      0|    { tmp = xheader_format_name(st, (char const *)exthdr_name, (_Bool)0); }
 9595|      0|    return (tmp);
 9596|      0|  }
 9597|      0|}
 9598|      0|char *xheader_ghdr_name(void) {
 9599|      0|  size_t len;
 9600|      0|  char const *tmp;
 9601|      0|  char *tmp___0;
 9602|      0|  size_t tmp___1;
 9603|      0|  void *tmp___2;
 9604|      0|  char *tmp___3;
 9605|      0|  char *__cil_tmp7;
 9606|      0|  char *__cil_tmp8;
 9607|      0|  char *__cil_tmp9;
 9608|      0|  char *__cil_tmp10;
 9609|       |
 9610|      0|  {
 9611|      0|    if (!globexthdr_name) {
 9612|      0|      {
 9613|      0|        tmp___0 = getenv("TMPDIR");
 9614|      0|        tmp = (char const *)tmp___0;
 9615|      0|      }
 9616|      0|      if (!tmp) {
 9617|      0|        tmp = "/tmp";
 9618|      0|      }
 9619|      0|      {
 9620|      0|        tmp___1 = strlen(tmp);
 9621|      0|        len = tmp___1 + sizeof("/GlobalHead.%p.%n");
 9622|      0|        tmp___2 = xmalloc(len);
 9623|      0|        globexthdr_name = (char *)tmp___2;
 9624|      0|        strcpy((char * /* __restrict  */)globexthdr_name,
 9625|      0|               (char const * /* __restrict  */)tmp);
 9626|      0|        strcat((char * /* __restrict  */)globexthdr_name,
 9627|      0|               (char const * /* __restrict  */) "/GlobalHead.%p.%n");
 9628|      0|      }
 9629|      0|    }
 9630|      0|    {
 9631|      0|      tmp___3 = xheader_format_name((struct tar_stat_info *)((void *)0),
 9632|      0|                                    (char const *)globexthdr_name, (_Bool)1);
 9633|      0|    }
 9634|      0|    return (tmp___3);
 9635|      0|  }
 9636|      0|}
 9637|      0|void xheader_write(char type, char *name, struct xheader *xhdr) {
 9638|      0|  union block *header;
 9639|      0|  size_t size;
 9640|      0|  char *p;
 9641|      0|  size_t len;
 9642|       |
 9643|      0|  {
 9644|      0|    {
 9645|      0|      size = xhdr->size;
 9646|      0|      header = start_private_header((char const *)name, size);
 9647|      0|      header->header.typeflag = type;
 9648|      0|      simple_finish_header(header);
 9649|      0|      p = xhdr->buffer;
 9650|      0|    }
 9651|      0|    {
 9652|      0|      while (1) {
 9653|      0|      while_continue: /* CIL Label */;
 9654|      0|        {
 9655|      0|          header = find_next_block();
 9656|      0|          len = (size_t)512;
 9657|      0|        }
 9658|      0|        if (len > size) {
 9659|      0|          len = size;
 9660|      0|        }
 9661|      0|        {
 9662|      0|          memcpy((void * /* __restrict  */)(header->buffer),
 9663|      0|                 (void const * /* __restrict  */)p, len);
 9664|      0|        }
 9665|      0|        if (len < 512UL) {
 9666|      0|          {
 9667|      0|            memset((void *)(header->buffer + len), 0, 512UL - len);
 9668|      0|          }
 9669|      0|        }
 9670|      0|        {
 9671|      0|          p += len;
 9672|      0|          size -= len;
 9673|      0|          set_next_block_after(header);
 9674|      0|        }
 9675|      0|        if (!(size > 0UL)) {
 9676|      0|          goto while_break;
 9677|      0|        }
 9678|      0|      }
 9679|      0|    while_break: /* CIL Label */;
 9680|      0|    }
 9681|      0|    { xheader_destroy(xhdr); }
 9682|      0|    return;
 9683|      0|  }
 9684|      0|}
 9685|      0|void xheader_write_global(void) {
 9686|      0|  char *name;
 9687|      0|  struct keyword_list *kp;
 9688|       |
 9689|      0|  {
 9690|      0|    if (!keyword_global_override_list) {
 9691|      0|      return;
 9692|      0|    }
 9693|      0|    {
 9694|      0|      extended_header_init();
 9695|      0|      kp = keyword_global_override_list;
 9696|      0|    }
 9697|      0|    {
 9698|      0|      while (1) {
 9699|      0|      while_continue: /* CIL Label */;
 9700|      0|        if (!kp) {
 9701|      0|          goto while_break;
 9702|      0|        }
 9703|      0|        {
 9704|      0|          code_string((char const *)kp->value, (char const *)kp->pattern,
 9705|      0|                      &extended_header);
 9706|      0|          kp = kp->next;
 9707|      0|        }
 9708|      0|      }
 9709|      0|    while_break: /* CIL Label */;
 9710|      0|    }
 9711|      0|    {
 9712|      0|      xheader_finish(&extended_header);
 9713|      0|      name = xheader_ghdr_name();
 9714|      0|      xheader_write((char)'g', name, &extended_header);
 9715|      0|      free((void *)name);
 9716|      0|      global_header_count++;
 9717|      0|    }
 9718|      0|    return;
 9719|      0|  }
 9720|      0|}
 9721|       |struct xhdr_tab const xhdr_tab[17];
 9722|      0|static struct xhdr_tab const *locate_handler(char const *keyword) {
 9723|      0|  struct xhdr_tab const *p;
 9724|      0|  int tmp;
 9725|       |
 9726|      0|  {
 9727|      0|    p = xhdr_tab;
 9728|      0|    {
 9729|      0|      while (1) {
 9730|      0|      while_continue: /* CIL Label */;
 9731|      0|        if (!p->keyword) {
 9732|      0|          goto while_break;
 9733|      0|        }
 9734|      0|        { tmp = strcmp((char const *)p->keyword, keyword); }
 9735|      0|        if (tmp == 0) {
 9736|      0|          return (p);
 9737|      0|        }
 9738|      0|        p++;
 9739|      0|      }
 9740|      0|    while_break: /* CIL Label */;
 9741|      0|    }
 9742|      0|    return ((struct xhdr_tab const *)((void *)0));
 9743|      0|  }
 9744|      0|}
 9745|      0|static _Bool xheader_protected_pattern_p(char const *pattern) {
 9746|      0|  struct xhdr_tab const *p;
 9747|      0|  int tmp;
 9748|       |
 9749|      0|  {
 9750|      0|    p = xhdr_tab;
 9751|      0|    {
 9752|      0|      while (1) {
 9753|      0|      while_continue: /* CIL Label */;
 9754|      0|        if (!p->keyword) {
 9755|      0|          goto while_break;
 9756|      0|        }
 9757|      0|        if (p->protect) {
 9758|      0|          {
 9759|      0|            tmp = fnmatch(pattern, (char const *)p->keyword, 0);
 9760|      0|          }
 9761|      0|          if (tmp == 0) {
 9762|      0|            return ((_Bool)1);
 9763|      0|          }
 9764|      0|        }
 9765|      0|        p++;
 9766|      0|      }
 9767|      0|    while_break: /* CIL Label */;
 9768|      0|    }
 9769|      0|    return ((_Bool)0);
 9770|      0|  }
 9771|      0|}
 9772|      0|static _Bool xheader_protected_keyword_p(char const *keyword) {
 9773|      0|  struct xhdr_tab const *p;
 9774|      0|  int tmp;
 9775|       |
 9776|      0|  {
 9777|      0|    p = xhdr_tab;
 9778|      0|    {
 9779|      0|      while (1) {
 9780|      0|      while_continue: /* CIL Label */;
 9781|      0|        if (!p->keyword) {
 9782|      0|          goto while_break;
 9783|      0|        }
 9784|      0|        if (p->protect) {
 9785|      0|          {
 9786|      0|            tmp = strcmp((char const *)p->keyword, keyword);
 9787|      0|          }
 9788|      0|          if (tmp == 0) {
 9789|      0|            return ((_Bool)1);
 9790|      0|          }
 9791|      0|        }
 9792|      0|        p++;
 9793|      0|      }
 9794|      0|    while_break: /* CIL Label */;
 9795|      0|    }
 9796|      0|    return ((_Bool)0);
 9797|      0|  }
 9798|      0|}
 9799|       |static _Bool decode_record(char **p,
 9800|       |                           void (*handler)(void *, char const *, char const *),
 9801|      0|                           void *data) {
 9802|      0|  size_t len;
 9803|      0|  char const *keyword;
 9804|      0|  char *start;
 9805|      0|  char endc;
 9806|      0|  char *tmp;
 9807|      0|  char *tmp___0;
 9808|      0|  char *__cil_tmp10;
 9809|      0|  char *__cil_tmp11;
 9810|       |
 9811|      0|  {
 9812|      0|    start = *p;
 9813|      0|    if ((int)*(*p) == 0) {
 9814|      0|      return ((_Bool)0);
 9815|      0|    }
 9816|      0|    {
 9817|      0|      len = strtoul((char const * /* __restrict  */) * p,
 9818|      0|                    (char ** /* __restrict  */)p, 10);
 9819|      0|    }
 9820|      0|    if ((int)*(*p) != 32) {
 9821|      0|      {
 9822|      0|        tmp = gettext(
 9823|      0|            "Malformed extended header: missing whitespace after the length");
 9824|      0|        error(0, 0, (char const *)tmp);
 9825|      0|        exit_status = 2;
 9826|      0|      }
 9827|      0|      return ((_Bool)0);
 9828|      0|    }
 9829|      0|    (*p)++;
 9830|      0|    keyword = (char const *)*p;
 9831|      0|    {
 9832|      0|      while (1) {
 9833|      0|      while_continue: /* CIL Label */;
 9834|      0|        if (!((unsigned long)*p < (unsigned long)(start + len))) {
 9835|      0|          goto while_break;
 9836|      0|        }
 9837|      0|        if ((int)*(*p) == 61) {
 9838|      0|          goto while_break;
 9839|      0|        }
 9840|      0|        (*p)++;
 9841|      0|      }
 9842|      0|    while_break: /* CIL Label */;
 9843|      0|    }
 9844|      0|    if ((int)*(*p) != 61) {
 9845|      0|      {
 9846|      0|        tmp___0 = gettext("Malformed extended header: missing equal sign");
 9847|      0|        error(0, 0, (char const *)tmp___0);
 9848|      0|        exit_status = 2;
 9849|      0|      }
 9850|      0|      return ((_Bool)0);
 9851|      0|    }
 9852|      0|    {
 9853|      0|      *(*p) = (char)0;
 9854|      0|      endc = *(start + (len - 1UL));
 9855|      0|      *(start + (len - 1UL)) = (char)0;
 9856|      0|      (*handler)(data, keyword, (char const *)(*p + 1));
 9857|      0|      *(start + (len - 1UL)) = endc;
 9858|      0|      *(*p) = (char)'=';
 9859|      0|      *p = start + len;
 9860|      0|    }
 9861|      0|    return ((_Bool)1);
 9862|      0|  }
 9863|      0|}
 9864|       |static void run_override_list(struct keyword_list *kp,
 9865|      0|                              struct tar_stat_info *st) {
 9866|      0|  struct xhdr_tab const *t;
 9867|      0|  struct xhdr_tab const *tmp;
 9868|       |
 9869|      0|  {
 9870|      0|    {
 9871|      0|      while (1) {
 9872|      0|      while_continue: /* CIL Label */;
 9873|      0|        if (!kp) {
 9874|      0|          goto while_break;
 9875|      0|        }
 9876|      0|        {
 9877|      0|          tmp = locate_handler((char const *)kp->pattern);
 9878|      0|          t = tmp;
 9879|      0|        }
 9880|      0|        if (t) {
 9881|      0|          {
 9882|      0|            (*(t->decoder))(st, (char const *)kp->value);
 9883|      0|          }
 9884|      0|        }
 9885|      0|        kp = kp->next;
 9886|      0|      }
 9887|      0|    while_break: /* CIL Label */;
 9888|      0|    }
 9889|      0|    return;
 9890|      0|  }
 9891|      0|}
 9892|      0|static void decx(void *data, char const *keyword, char const *value) {
 9893|      0|  struct xhdr_tab const *t;
 9894|      0|  struct tar_stat_info *st;
 9895|      0|  _Bool tmp;
 9896|      0|  _Bool tmp___0;
 9897|       |
 9898|      0|  {
 9899|      0|    {
 9900|      0|      st = (struct tar_stat_info *)data;
 9901|      0|      tmp = xheader_keyword_deleted_p(keyword);
 9902|      0|    }
 9903|      0|    if (tmp) {
 9904|      0|      return;
 9905|      0|    } else {
 9906|      0|      { tmp___0 = xheader_keyword_override_p(keyword); }
 9907|      0|      if (tmp___0) {
 9908|      0|        return;
 9909|      0|      }
 9910|      0|    }
 9911|      0|    { t = locate_handler(keyword); }
 9912|      0|    if (t) {
 9913|      0|      {
 9914|      0|        (*(t->decoder))(st, value);
 9915|      0|      }
 9916|      0|    }
 9917|      0|    return;
 9918|      0|  }
 9919|      0|}
 9920|      0|void xheader_decode(struct tar_stat_info *st) {
 9921|      0|  char *p;
 9922|      0|  char *endp;
 9923|      0|  _Bool tmp;
 9924|       |
 9925|      0|  {
 9926|      0|    {
 9927|      0|      run_override_list(keyword_global_override_list, st);
 9928|      0|      run_override_list(global_header_override_list, st);
 9929|      0|    }
 9930|      0|    if (extended_header.size) {
 9931|      0|      p = extended_header.buffer + 512;
 9932|      0|      endp = extended_header.buffer + (extended_header.size - 1UL);
 9933|      0|      {
 9934|      0|        while (1) {
 9935|      0|        while_continue: /* CIL Label */;
 9936|      0|          if (!((unsigned long)p < (unsigned long)endp)) {
 9937|      0|            goto while_break;
 9938|      0|          }
 9939|      0|          { tmp = decode_record(&p, &decx, (void *)st); }
 9940|      0|          if (!tmp) {
 9941|      0|            goto while_break;
 9942|      0|          }
 9943|      0|        }
 9944|      0|      while_break: /* CIL Label */;
 9945|      0|      }
 9946|      0|    }
 9947|      0|    { run_override_list(keyword_override_list, st); }
 9948|      0|    return;
 9949|      0|  }
 9950|      0|}
 9951|      0|static void decg(void *data, char const *keyword, char const *value) {
 9952|      0|  struct keyword_list **kwl;
 9953|       |
 9954|      0|  {
 9955|      0|    {
 9956|      0|      kwl = (struct keyword_list **)data;
 9957|      0|      xheader_list_append(kwl, keyword, value);
 9958|      0|    }
 9959|      0|    return;
 9960|      0|  }
 9961|      0|}
 9962|      0|void xheader_decode_global(void) {
 9963|      0|  char *p;
 9964|      0|  char *endp;
 9965|      0|  _Bool tmp;
 9966|       |
 9967|      0|  {
 9968|      0|    if (extended_header.size) {
 9969|      0|      {
 9970|      0|        p = extended_header.buffer + 512;
 9971|      0|        endp = extended_header.buffer + (extended_header.size - 1UL);
 9972|      0|        xheader_list_destroy(&global_header_override_list);
 9973|      0|      }
 9974|      0|      {
 9975|      0|        while (1) {
 9976|      0|        while_continue: /* CIL Label */;
 9977|      0|          if (!((unsigned long)p < (unsigned long)endp)) {
 9978|      0|            goto while_break;
 9979|      0|          }
 9980|      0|          {
 9981|      0|            tmp = decode_record(&p, &decg,
 9982|      0|                                (void *)(&global_header_override_list));
 9983|      0|          }
 9984|      0|          if (!tmp) {
 9985|      0|            goto while_break;
 9986|      0|          }
 9987|      0|        }
 9988|      0|      while_break: /* CIL Label */;
 9989|      0|      }
 9990|      0|    }
 9991|      0|    return;
 9992|      0|  }
 9993|      0|}
 9994|      0|static void extended_header_init(void) {
 9995|      0|  void *tmp;
 9996|       |
 9997|      0|  {
 9998|      0|    if (!extended_header.stk) {
 9999|      0|      {
10000|      0|        tmp = xmalloc(sizeof(*(extended_header.stk)));
10001|      0|        extended_header.stk = (struct obstack *)tmp;
10002|      0|        _obstack_begin(extended_header.stk, 0, 0, (void *(*)(long))(&xmalloc),
10003|      0|                       (void (*)(void *))(&free));
10004|      0|      }
10005|      0|    }
10006|      0|    return;
10007|      0|  }
10008|      0|}
10009|       |void xheader_store(char const *keyword, struct tar_stat_info const *st,
10010|      0|                   void *data) {
10011|      0|  struct xhdr_tab const *t;
10012|      0|  _Bool tmp;
10013|      0|  _Bool tmp___0;
10014|       |
10015|      0|  {
10016|      0|    if (extended_header.buffer) {
10017|      0|      return;
10018|      0|    }
10019|      0|    { t = locate_handler(keyword); }
10020|      0|    if (!t) {
10021|      0|      return;
10022|      0|    }
10023|      0|    { tmp = xheader_keyword_deleted_p(keyword); }
10024|      0|    if (tmp) {
10025|      0|      return;
10026|      0|    } else {
10027|      0|      { tmp___0 = xheader_keyword_override_p(keyword); }
10028|      0|      if (tmp___0) {
10029|      0|        return;
10030|      0|      }
10031|      0|    }
10032|      0|    {
10033|      0|      extended_header_init();
10034|      0|      (*(t->coder))(st, keyword, &extended_header, data);
10035|      0|    }
10036|      0|    return;
10037|      0|  }
10038|      0|}
10039|      0|void xheader_read(union block *p, size_t size) {
10040|      0|  size_t j;
10041|      0|  size_t nblocks;
10042|      0|  void *tmp;
10043|      0|  size_t len;
10044|       |
10045|      0|  {
10046|      0|    {
10047|      0|      j = (size_t)0;
10048|      0|      free((void *)extended_header.buffer);
10049|      0|      size += 512UL;
10050|      0|      extended_header.size = size;
10051|      0|      nblocks = ((size + 512UL) - 1UL) / 512UL;
10052|      0|      tmp = xmalloc(size + 1UL);
10053|      0|      extended_header.buffer = (char *)tmp;
10054|      0|    }
10055|      0|    {
10056|      0|      while (1) {
10057|      0|      while_continue: /* CIL Label */;
10058|      0|        len = size;
10059|      0|        if (len > 512UL) {
10060|      0|          len = (size_t)512;
10061|      0|        }
10062|      0|        {
10063|      0|          memcpy((void * /* __restrict  */)(extended_header.buffer + j),
10064|      0|                 (void const * /* __restrict  */)(p->buffer), len);
10065|      0|          set_next_block_after(p);
10066|      0|          p = find_next_block();
10067|      0|          j += len;
10068|      0|          size -= len;
10069|      0|        }
10070|      0|        if (!(size > 0UL)) {
10071|      0|          goto while_break;
10072|      0|        }
10073|      0|      }
10074|      0|    while_break: /* CIL Label */;
10075|      0|    }
10076|      0|    return;
10077|      0|  }
10078|      0|}
10079|      0|static size_t format_uintmax(uintmax_t val, char *buf, size_t s) {
10080|      0|  char *p;
10081|      0|  char *tmp;
10082|      0|  char *tmp___0;
10083|       |
10084|      0|  {
10085|      0|    if (!buf) {
10086|      0|      s = (size_t)0;
10087|      0|      {
10088|      0|        while (1) {
10089|      0|        while_continue: /* CIL Label */;
10090|      0|          s++;
10091|      0|          val /= 10UL;
10092|      0|          if (!(val != 0UL)) {
10093|      0|            goto while_break;
10094|      0|          }
10095|      0|        }
10096|      0|      while_break: /* CIL Label */;
10097|      0|      }
10098|      0|    } else {
10099|      0|      p = (buf + s) - 1;
10100|      0|      {
10101|      0|        while (1) {
10102|      0|        while_continue___0: /* CIL Label */;
10103|      0|          tmp = p;
10104|      0|          p--;
10105|      0|          *tmp = (char)(val % 10UL + 48UL);
10106|      0|          val /= 10UL;
10107|      0|          if (!(val != 0UL)) {
10108|      0|            goto while_break___0;
10109|      0|          }
10110|      0|        }
10111|      0|      while_break___0: /* CIL Label */;
10112|      0|      }
10113|      0|      {
10114|      0|        while (1) {
10115|      0|        while_continue___1: /* CIL Label */;
10116|      0|          if (!((unsigned long)p >= (unsigned long)buf)) {
10117|      0|            goto while_break___1;
10118|      0|          }
10119|      0|          tmp___0 = p;
10120|      0|          p--;
10121|      0|          *tmp___0 = (char)'0';
10122|      0|        }
10123|      0|      while_break___1: /* CIL Label */;
10124|      0|      }
10125|      0|    }
10126|      0|    return (s);
10127|      0|  }
10128|      0|}
10129|       |static void xheader_print(struct xheader *xhdr, char const *keyword,
10130|      0|                          char const *value) {
10131|      0|  size_t len;
10132|      0|  size_t tmp;
10133|      0|  size_t tmp___0;
10134|      0|  size_t p;
10135|      0|  size_t n;
10136|      0|  char nbuf[100];
10137|      0|  struct obstack *__o;
10138|      0|  int __len;
10139|      0|  struct obstack *__o___0;
10140|      0|  char *tmp___1;
10141|      0|  struct obstack *__o___1;
10142|      0|  int __len___0;
10143|      0|  size_t tmp___2;
10144|      0|  struct obstack *__o___2;
10145|      0|  char *tmp___3;
10146|      0|  struct obstack *__o___3;
10147|      0|  int __len___1;
10148|      0|  size_t tmp___4;
10149|      0|  struct obstack *__o___4;
10150|      0|  char *tmp___5;
10151|      0|  void *__cil_tmp24;
10152|       |
10153|      0|  {
10154|      0|    {
10155|      0|      tmp = strlen(keyword);
10156|      0|      tmp___0 = strlen(value);
10157|      0|      len = (tmp + tmp___0) + 3UL;
10158|      0|      n = (size_t)0;
10159|      0|    }
10160|      0|    {
10161|      0|      while (1) {
10162|      0|      while_continue: /* CIL Label */;
10163|      0|        {
10164|      0|          p = n;
10165|      0|          n = format_uintmax(len + p, (char *)((void *)0), (size_t)0);
10166|      0|        }
10167|      0|        if (!(n != p)) {
10168|      0|          goto while_break;
10169|      0|        }
10170|      0|      }
10171|      0|    while_break: /* CIL Label */;
10172|      0|    }
10173|      0|    {
10174|      0|      format_uintmax(len + n, nbuf, n);
10175|      0|      __o = xhdr->stk;
10176|      0|      __len = (int)n;
10177|      0|    }
10178|      0|    if ((unsigned long)(__o->next_free + __len) >
10179|      0|        (unsigned long)__o->chunk_limit) {
10180|      0|      {
10181|      0|        _obstack_newchunk(__o, __len);
10182|      0|      }
10183|      0|    }
10184|      0|    {
10185|      0|      memcpy((void * /* __restrict  */)__o->next_free,
10186|      0|             (void const * /* __restrict  */)(nbuf), (size_t)__len);
10187|      0|      __o->next_free += __len;
10188|      0|      __o___0 = xhdr->stk;
10189|      0|    }
10190|      0|    if ((unsigned long)(__o___0->next_free + 1) >
10191|      0|        (unsigned long)__o___0->chunk_limit) {
10192|      0|      {
10193|      0|        _obstack_newchunk(__o___0, 1);
10194|      0|      }
10195|      0|    }
10196|      0|    {
10197|      0|      tmp___1 = __o___0->next_free;
10198|      0|      (__o___0->next_free)++;
10199|      0|      *tmp___1 = (char)' ';
10200|      0|      __o___1 = xhdr->stk;
10201|      0|      tmp___2 = strlen(keyword);
10202|      0|      __len___0 = (int)tmp___2;
10203|      0|    }
10204|      0|    if ((unsigned long)(__o___1->next_free + __len___0) >
10205|      0|        (unsigned long)__o___1->chunk_limit) {
10206|      0|      {
10207|      0|        _obstack_newchunk(__o___1, __len___0);
10208|      0|      }
10209|      0|    }
10210|      0|    {
10211|      0|      memcpy((void * /* __restrict  */)__o___1->next_free,
10212|      0|             (void const * /* __restrict  */)keyword, (size_t)__len___0);
10213|      0|      __o___1->next_free += __len___0;
10214|      0|      __o___2 = xhdr->stk;
10215|      0|    }
10216|      0|    if ((unsigned long)(__o___2->next_free + 1) >
10217|      0|        (unsigned long)__o___2->chunk_limit) {
10218|      0|      {
10219|      0|        _obstack_newchunk(__o___2, 1);
10220|      0|      }
10221|      0|    }
10222|      0|    {
10223|      0|      tmp___3 = __o___2->next_free;
10224|      0|      (__o___2->next_free)++;
10225|      0|      *tmp___3 = (char)'=';
10226|      0|      __o___3 = xhdr->stk;
10227|      0|      tmp___4 = strlen(value);
10228|      0|      __len___1 = (int)tmp___4;
10229|      0|    }
10230|      0|    if ((unsigned long)(__o___3->next_free + __len___1) >
10231|      0|        (unsigned long)__o___3->chunk_limit) {
10232|      0|      {
10233|      0|        _obstack_newchunk(__o___3, __len___1);
10234|      0|      }
10235|      0|    }
10236|      0|    {
10237|      0|      memcpy((void * /* __restrict  */)__o___3->next_free,
10238|      0|             (void const * /* __restrict  */)value, (size_t)__len___1);
10239|      0|      __o___3->next_free += __len___1;
10240|      0|      __o___4 = xhdr->stk;
10241|      0|    }
10242|      0|    if ((unsigned long)(__o___4->next_free + 1) >
10243|      0|        (unsigned long)__o___4->chunk_limit) {
10244|      0|      {
10245|      0|        _obstack_newchunk(__o___4, 1);
10246|      0|      }
10247|      0|    }
10248|      0|    tmp___5 = __o___4->next_free;
10249|      0|    (__o___4->next_free)++;
10250|      0|    *tmp___5 = (char)'\n';
10251|      0|    return;
10252|      0|  }
10253|      0|}
10254|      0|void xheader_finish(struct xheader *xhdr) {
10255|      0|  struct keyword_list *kp;
10256|      0|  struct obstack *__o;
10257|      0|  char *tmp;
10258|      0|  struct obstack *__o1;
10259|      0|  void *value;
10260|       |
10261|      0|  {
10262|      0|    kp = keyword_override_list;
10263|      0|    {
10264|      0|      while (1) {
10265|      0|      while_continue: /* CIL Label */;
10266|      0|        if (!kp) {
10267|      0|          goto while_break;
10268|      0|        }
10269|      0|        {
10270|      0|          code_string((char const *)kp->value, (char const *)kp->pattern, xhdr);
10271|      0|          kp = kp->next;
10272|      0|        }
10273|      0|      }
10274|      0|    while_break: /* CIL Label */;
10275|      0|    }
10276|      0|    __o = xhdr->stk;
10277|      0|    if ((unsigned long)(__o->next_free + 1) > (unsigned long)__o->chunk_limit) {
10278|      0|      {
10279|      0|        _obstack_newchunk(__o, 1);
10280|      0|      }
10281|      0|    }
10282|      0|    tmp = __o->next_free;
10283|      0|    (__o->next_free)++;
10284|      0|    *tmp = (char)0;
10285|      0|    __o1 = xhdr->stk;
10286|      0|    value = (void *)__o1->object_base;
10287|      0|    if ((unsigned long)__o1->next_free == (unsigned long)value) {
10288|      0|      __o1->maybe_empty_object = 1U;
10289|      0|    }
10290|      0|    __o1->next_free =
10291|      0|        (char *)0 +
10292|      0|        (((__o1->next_free - (char *)0) + (long)__o1->alignment_mask) &
10293|      0|         (long)(~__o1->alignment_mask));
10294|      0|    if (__o1->next_free - (char *)__o1->chunk >
10295|      0|        __o1->chunk_limit - (char *)__o1->chunk) {
10296|      0|      __o1->next_free = __o1->chunk_limit;
10297|      0|    }
10298|      0|    {
10299|      0|      __o1->object_base = __o1->next_free;
10300|      0|      xhdr->buffer = (char *)value;
10301|      0|      xhdr->size = strlen((char const *)xhdr->buffer);
10302|      0|    }
10303|      0|    return;
10304|      0|  }
10305|      0|}
10306|      0|void xheader_destroy(struct xheader *xhdr) {
10307|      0|  struct obstack *__o;
10308|      0|  void *__obj;
10309|      0|  char *tmp;
10310|       |
10311|      0|  {
10312|      0|    if (xhdr->stk) {
10313|      0|      __o = xhdr->stk;
10314|      0|      __obj = (void *)0;
10315|      0|      if ((unsigned long)__obj > (unsigned long)((void *)__o->chunk)) {
10316|      0|        if ((unsigned long)__obj < (unsigned long)((void *)__o->chunk_limit)) {
10317|      0|          tmp = (char *)__obj;
10318|      0|          __o->object_base = tmp;
10319|      0|          __o->next_free = tmp;
10320|      0|        } else {
10321|      0|          { obstack_free(__o, __obj); }
10322|      0|        }
10323|      0|      } else {
10324|      0|        { obstack_free(__o, __obj); }
10325|      0|      }
10326|      0|      {
10327|      0|        free((void *)xhdr->stk);
10328|      0|        xhdr->stk = (struct obstack *)((void *)0);
10329|      0|      }
10330|      0|    } else {
10331|      0|      { free((void *)xhdr->buffer); }
10332|      0|    }
10333|      0|    xhdr->buffer = (char *)0;
10334|      0|    xhdr->size = (size_t)0;
10335|      0|    return;
10336|      0|  }
10337|      0|}
10338|       |static void code_string(char const *string, char const *keyword,
10339|      0|                        struct xheader *xhdr) {
10340|      0|  char *outstr;
10341|      0|  _Bool tmp;
10342|       |
10343|      0|  {
10344|      0|    { tmp = utf8_convert((_Bool)1, string, &outstr); }
10345|      0|    if (!tmp) {
10346|      0|      {
10347|      0|        outstr = xstrdup(string);
10348|      0|      }
10349|      0|    }
10350|      0|    {
10351|      0|      xheader_print(xhdr, keyword, (char const *)outstr);
10352|      0|      free((void *)outstr);
10353|      0|    }
10354|      0|    return;
10355|      0|  }
10356|      0|}
10357|      0|static void decode_string(char **string, char const *arg) {
10358|      0|  _Bool tmp;
10359|       |
10360|      0|  {
10361|      0|    if (*string) {
10362|      0|      {
10363|      0|        free((void *)*string);
10364|      0|        *string = (char *)((void *)0);
10365|      0|      }
10366|      0|    }
10367|      0|    { tmp = utf8_convert((_Bool)0, arg, string); }
10368|      0|    if (!tmp) {
10369|      0|      {
10370|      0|        assign_string(string, arg);
10371|      0|      }
10372|      0|    }
10373|      0|    return;
10374|      0|  }
10375|      0|}
10376|       |static void code_time(time_t t, unsigned long nano, char const *keyword,
10377|      0|                      struct xheader *xhdr) {
10378|      0|  char sbuf[200];
10379|      0|  size_t s;
10380|      0|  size_t tmp;
10381|      0|  size_t tmp___0;
10382|      0|  size_t tmp___1;
10383|      0|  void *__cil_tmp10;
10384|       |
10385|      0|  {
10386|      0|    {
10387|      0|      tmp = format_uintmax((uintmax_t)t, (char *)((void *)0), (size_t)0);
10388|      0|      s = tmp;
10389|      0|    }
10390|      0|    if (s + 11UL >= sizeof(sbuf)) {
10391|      0|      return;
10392|      0|    }
10393|      0|    {
10394|      0|      format_uintmax((uintmax_t)t, sbuf, s);
10395|      0|      tmp___0 = s;
10396|      0|      s++;
10397|      0|      sbuf[tmp___0] = (char)'.';
10398|      0|      tmp___1 = format_uintmax(nano, sbuf + s, (size_t)9);
10399|      0|      s += tmp___1;
10400|      0|      sbuf[s] = (char)0;
10401|      0|      xheader_print(xhdr, keyword, (char const *)(sbuf));
10402|      0|    }
10403|      0|    return;
10404|      0|  }
10405|      0|}
10406|      0|static void decode_time(char const *arg, time_t *secs, unsigned long *nsecs) {
10407|      0|  uintmax_t u;
10408|      0|  char *p;
10409|      0|  strtol_error tmp;
10410|      0|  strtol_error tmp___0;
10411|      0|  char *__cil_tmp8;
10412|      0|  char *__cil_tmp9;
10413|       |
10414|      0|  {
10415|      0|    { tmp___0 = xstrtoumax(arg, &p, 10, &u, ""); }
10416|      0|    if ((unsigned int)tmp___0 == 0U) {
10417|      0|      *secs = (time_t)u;
10418|      0|      if ((int)*p == 46) {
10419|      0|        {
10420|      0|          tmp = xstrtoumax((char const *)(p + 1), (char **)((void *)0), 10, &u,
10421|      0|                           "");
10422|      0|        }
10423|      0|        if ((unsigned int)tmp == 0U) {
10424|      0|          *nsecs = u;
10425|      0|        }
10426|      0|      }
10427|      0|    }
10428|      0|    return;
10429|      0|  }
10430|      0|}
10431|       |static void code_num(uintmax_t value, char const *keyword,
10432|      0|                     struct xheader *xhdr) {
10433|      0|  char sbuf[100];
10434|      0|  size_t s;
10435|      0|  size_t tmp;
10436|      0|  void *__cil_tmp7;
10437|       |
10438|      0|  {
10439|      0|    {
10440|      0|      tmp = format_uintmax(value, (char *)((void *)0), (size_t)0);
10441|      0|      s = tmp;
10442|      0|      format_uintmax(value, sbuf, s);
10443|      0|      sbuf[s] = (char)0;
10444|      0|      xheader_print(xhdr, keyword, (char const *)(sbuf));
10445|      0|    }
10446|      0|    return;
10447|      0|  }
10448|      0|}
10449|       |static void dummy_coder(struct tar_stat_info const *st
10450|       |                        __attribute__((__unused__)),
10451|       |                        char const *keyword __attribute__((__unused__)),
10452|       |                        struct xheader *xhdr __attribute__((__unused__)),
10453|      0|                        void *data __attribute__((__unused__))) {
10454|       |
10455|      0|  { return; }
10456|      0|}
10457|       |static void dummy_decoder(struct tar_stat_info *st __attribute__((__unused__)),
10458|      0|                          char const *arg __attribute__((__unused__))) {
10459|       |
10460|      0|  { return; }
10461|      0|}
10462|       |static void atime_coder(struct tar_stat_info const *st, char const *keyword,
10463|       |                        struct xheader *xhdr,
10464|      0|                        void *data __attribute__((__unused__))) {
10465|       |
10466|      0|  {
10467|      0|    {
10468|      0|      code_time((time_t)st->stat.st_atim.tv_sec, (unsigned long)st->atime_nsec,
10469|      0|                keyword, xhdr);
10470|      0|    }
10471|      0|    return;
10472|      0|  }
10473|      0|}
10474|      0|static void atime_decoder(struct tar_stat_info *st, char const *arg) {
10475|       |
10476|      0|  {
10477|      0|    { decode_time(arg, &st->stat.st_atim.tv_sec, &st->atime_nsec); }
10478|      0|    return;
10479|      0|  }
10480|      0|}
10481|       |static void gid_coder(struct tar_stat_info const *st, char const *keyword,
10482|       |                      struct xheader *xhdr,
10483|      0|                      void *data __attribute__((__unused__))) {
10484|       |
10485|      0|  {
10486|      0|    { code_num((uintmax_t)st->stat.st_gid, keyword, xhdr); }
10487|      0|    return;
10488|      0|  }
10489|      0|}
10490|      0|static void gid_decoder(struct tar_stat_info *st, char const *arg) {
10491|      0|  uintmax_t u;
10492|      0|  strtol_error tmp;
10493|      0|  char *__cil_tmp5;
10494|       |
10495|      0|  {
10496|      0|    { tmp = xstrtoumax(arg, (char **)((void *)0), 10, &u, ""); }
10497|      0|    if ((unsigned int)tmp == 0U) {
10498|      0|      st->stat.st_gid = (__gid_t)u;
10499|      0|    }
10500|      0|    return;
10501|      0|  }
10502|      0|}
10503|       |static void gname_coder(struct tar_stat_info const *st, char const *keyword,
10504|       |                        struct xheader *xhdr,
10505|      0|                        void *data __attribute__((__unused__))) {
10506|       |
10507|      0|  {
10508|      0|    { code_string((char const *)st->gname, keyword, xhdr); }
10509|      0|    return;
10510|      0|  }
10511|      0|}
10512|      0|static void gname_decoder(struct tar_stat_info *st, char const *arg) {
10513|       |
10514|      0|  {
10515|      0|    { decode_string(&st->gname, arg); }
10516|      0|    return;
10517|      0|  }
10518|      0|}
10519|       |static void linkpath_coder(struct tar_stat_info const *st, char const *keyword,
10520|       |                           struct xheader *xhdr,
10521|      0|                           void *data __attribute__((__unused__))) {
10522|       |
10523|      0|  {
10524|      0|    { code_string((char const *)st->link_name, keyword, xhdr); }
10525|      0|    return;
10526|      0|  }
10527|      0|}
10528|      0|static void linkpath_decoder(struct tar_stat_info *st, char const *arg) {
10529|       |
10530|      0|  {
10531|      0|    { decode_string(&st->link_name, arg); }
10532|      0|    return;
10533|      0|  }
10534|      0|}
10535|       |static void ctime_coder(struct tar_stat_info const *st, char const *keyword,
10536|       |                        struct xheader *xhdr,
10537|      0|                        void *data __attribute__((__unused__))) {
10538|       |
10539|      0|  {
10540|      0|    {
10541|      0|      code_time((time_t)st->stat.st_ctim.tv_sec, (unsigned long)st->ctime_nsec,
10542|      0|                keyword, xhdr);
10543|      0|    }
10544|      0|    return;
10545|      0|  }
10546|      0|}
10547|      0|static void ctime_decoder(struct tar_stat_info *st, char const *arg) {
10548|       |
10549|      0|  {
10550|      0|    { decode_time(arg, &st->stat.st_ctim.tv_sec, &st->ctime_nsec); }
10551|      0|    return;
10552|      0|  }
10553|      0|}
10554|       |static void mtime_coder(struct tar_stat_info const *st, char const *keyword,
10555|       |                        struct xheader *xhdr,
10556|      0|                        void *data __attribute__((__unused__))) {
10557|       |
10558|      0|  {
10559|      0|    {
10560|      0|      code_time((time_t)st->stat.st_mtim.tv_sec, (unsigned long)st->mtime_nsec,
10561|      0|                keyword, xhdr);
10562|      0|    }
10563|      0|    return;
10564|      0|  }
10565|      0|}
10566|      0|static void mtime_decoder(struct tar_stat_info *st, char const *arg) {
10567|       |
10568|      0|  {
10569|      0|    { decode_time(arg, &st->stat.st_mtim.tv_sec, &st->mtime_nsec); }
10570|      0|    return;
10571|      0|  }
10572|      0|}
10573|       |static void path_coder(struct tar_stat_info const *st, char const *keyword,
10574|       |                       struct xheader *xhdr,
10575|      0|                       void *data __attribute__((__unused__))) {
10576|       |
10577|      0|  {
10578|      0|    { code_string((char const *)st->file_name, keyword, xhdr); }
10579|      0|    return;
10580|      0|  }
10581|      0|}
10582|      0|static void path_decoder(struct tar_stat_info *st, char const *arg) {
10583|       |
10584|      0|  {
10585|      0|    {
10586|      0|      decode_string(&st->orig_file_name, arg);
10587|      0|      decode_string(&st->file_name, arg);
10588|      0|      st->had_trailing_slash = strip_trailing_slashes(st->file_name);
10589|      0|    }
10590|      0|    return;
10591|      0|  }
10592|      0|}
10593|       |static void size_coder(struct tar_stat_info const *st, char const *keyword,
10594|       |                       struct xheader *xhdr,
10595|      0|                       void *data __attribute__((__unused__))) {
10596|       |
10597|      0|  {
10598|      0|    { code_num((uintmax_t)st->stat.st_size, keyword, xhdr); }
10599|      0|    return;
10600|      0|  }
10601|      0|}
10602|      0|static void size_decoder(struct tar_stat_info *st, char const *arg) {
10603|      0|  uintmax_t u;
10604|      0|  __off_t tmp;
10605|      0|  strtol_error tmp___0;
10606|      0|  char *__cil_tmp6;
10607|       |
10608|      0|  {
10609|      0|    { tmp___0 = xstrtoumax(arg, (char **)((void *)0), 10, &u, ""); }
10610|      0|    if ((unsigned int)tmp___0 == 0U) {
10611|      0|      tmp = (__off_t)u;
10612|      0|      st->stat.st_size = tmp;
10613|      0|      st->archive_file_size = tmp;
10614|      0|    }
10615|      0|    return;
10616|      0|  }
10617|      0|}
10618|       |static void uid_coder(struct tar_stat_info const *st, char const *keyword,
10619|       |                      struct xheader *xhdr,
10620|      0|                      void *data __attribute__((__unused__))) {
10621|       |
10622|      0|  {
10623|      0|    { code_num((uintmax_t)st->stat.st_uid, keyword, xhdr); }
10624|      0|    return;
10625|      0|  }
10626|      0|}
10627|      0|static void uid_decoder(struct tar_stat_info *st, char const *arg) {
10628|      0|  uintmax_t u;
10629|      0|  strtol_error tmp;
10630|      0|  char *__cil_tmp5;
10631|       |
10632|      0|  {
10633|      0|    { tmp = xstrtoumax(arg, (char **)((void *)0), 10, &u, ""); }
10634|      0|    if ((unsigned int)tmp == 0U) {
10635|      0|      st->stat.st_uid = (__uid_t)u;
10636|      0|    }
10637|      0|    return;
10638|      0|  }
10639|      0|}
10640|       |static void uname_coder(struct tar_stat_info const *st, char const *keyword,
10641|       |                        struct xheader *xhdr,
10642|      0|                        void *data __attribute__((__unused__))) {
10643|       |
10644|      0|  {
10645|      0|    { code_string((char const *)st->uname, keyword, xhdr); }
10646|      0|    return;
10647|      0|  }
10648|      0|}
10649|      0|static void uname_decoder(struct tar_stat_info *st, char const *arg) {
10650|       |
10651|      0|  {
10652|      0|    { decode_string(&st->uname, arg); }
10653|      0|    return;
10654|      0|  }
10655|      0|}
10656|       |static void sparse_size_coder(struct tar_stat_info const *st,
10657|       |                              char const *keyword, struct xheader *xhdr,
10658|      0|                              void *data) {
10659|       |
10660|      0|  {
10661|      0|    { size_coder(st, keyword, xhdr, data); }
10662|      0|    return;
10663|      0|  }
10664|      0|}
10665|      0|static void sparse_size_decoder(struct tar_stat_info *st, char const *arg) {
10666|      0|  uintmax_t u;
10667|      0|  strtol_error tmp;
10668|      0|  char *__cil_tmp5;
10669|       |
10670|      0|  {
10671|      0|    { tmp = xstrtoumax(arg, (char **)((void *)0), 10, &u, ""); }
10672|      0|    if ((unsigned int)tmp == 0U) {
10673|      0|      st->stat.st_size = (__off_t)u;
10674|      0|    }
10675|      0|    return;
10676|      0|  }
10677|      0|}
10678|       |static void sparse_numblocks_coder(struct tar_stat_info const *st,
10679|       |                                   char const *keyword, struct xheader *xhdr,
10680|      0|                                   void *data __attribute__((__unused__))) {
10681|       |
10682|      0|  {
10683|      0|    { code_num((uintmax_t)st->sparse_map_avail, keyword, xhdr); }
10684|      0|    return;
10685|      0|  }
10686|      0|}
10687|       |static void sparse_numblocks_decoder(struct tar_stat_info *st,
10688|      0|                                     char const *arg) {
10689|      0|  uintmax_t u;
10690|      0|  void *tmp;
10691|      0|  strtol_error tmp___0;
10692|      0|  char *__cil_tmp6;
10693|       |
10694|      0|  {
10695|      0|    { tmp___0 = xstrtoumax(arg, (char **)((void *)0), 10, &u, ""); }
10696|      0|    if ((unsigned int)tmp___0 == 0U) {
10697|      0|      {
10698|      0|        st->sparse_map_size = u;
10699|      0|        tmp = calloc(st->sparse_map_size, sizeof(*(st->sparse_map + 0)));
10700|      0|        st->sparse_map = (struct sp_array *)tmp;
10701|      0|        st->sparse_map_avail = (size_t)0;
10702|      0|      }
10703|      0|    }
10704|      0|    return;
10705|      0|  }
10706|      0|}
10707|       |static void sparse_offset_coder(struct tar_stat_info const *st,
10708|       |                                char const *keyword, struct xheader *xhdr,
10709|      0|                                void *data) {
10710|      0|  size_t i;
10711|       |
10712|      0|  {
10713|      0|    {
10714|      0|      i = *((size_t *)data);
10715|      0|      code_num((uintmax_t)(st->sparse_map + i)->offset, keyword, xhdr);
10716|      0|    }
10717|      0|    return;
10718|      0|  }
10719|      0|}
10720|      0|static void sparse_offset_decoder(struct tar_stat_info *st, char const *arg) {
10721|      0|  uintmax_t u;
10722|      0|  strtol_error tmp;
10723|      0|  char *__cil_tmp5;
10724|       |
10725|      0|  {
10726|      0|    { tmp = xstrtoumax(arg, (char **)((void *)0), 10, &u, ""); }
10727|      0|    if ((unsigned int)tmp == 0U) {
10728|      0|      (st->sparse_map + st->sparse_map_avail)->offset = (off_t)u;
10729|      0|    }
10730|      0|    return;
10731|      0|  }
10732|      0|}
10733|       |static void sparse_numbytes_coder(struct tar_stat_info const *st,
10734|       |                                  char const *keyword, struct xheader *xhdr,
10735|      0|                                  void *data) {
10736|      0|  size_t i;
10737|       |
10738|      0|  {
10739|      0|    {
10740|      0|      i = *((size_t *)data);
10741|      0|      code_num((st->sparse_map + i)->numbytes, keyword, xhdr);
10742|      0|    }
10743|      0|    return;
10744|      0|  }
10745|      0|}
10746|      0|static void sparse_numbytes_decoder(struct tar_stat_info *st, char const *arg) {
10747|      0|  uintmax_t u;
10748|      0|  void *tmp;
10749|      0|  size_t tmp___0;
10750|      0|  strtol_error tmp___1;
10751|      0|  char *__cil_tmp7;
10752|       |
10753|      0|  {
10754|      0|    { tmp___1 = xstrtoumax(arg, (char **)((void *)0), 10, &u, ""); }
10755|      0|    if ((unsigned int)tmp___1 == 0U) {
10756|      0|      if (st->sparse_map_avail == st->sparse_map_size) {
10757|      0|        {
10758|      0|          st->sparse_map_size *= 2UL;
10759|      0|          tmp = xrealloc((void *)st->sparse_map,
10760|      0|                         st->sparse_map_size * sizeof(*(st->sparse_map + 0)));
10761|      0|          st->sparse_map = (struct sp_array *)tmp;
10762|      0|        }
10763|      0|      }
10764|      0|      tmp___0 = st->sparse_map_avail;
10765|      0|      (st->sparse_map_avail)++;
10766|      0|      (st->sparse_map + tmp___0)->numbytes = u;
10767|      0|    }
10768|      0|    return;
10769|      0|  }
10770|      0|}
10771|       |struct xhdr_tab const xhdr_tab[17] = {
10772|       |    {"atime", &atime_coder, &atime_decoder, (_Bool)0},
10773|       |    {"comment", &dummy_coder, &dummy_decoder, (_Bool)0},
10774|       |    {"charset", &dummy_coder, &dummy_decoder, (_Bool)0},
10775|       |    {"ctime", &ctime_coder, &ctime_decoder, (_Bool)0},
10776|       |    {"gid", &gid_coder, &gid_decoder, (_Bool)0},
10777|       |    {"gname", &gname_coder, &gname_decoder, (_Bool)0},
10778|       |    {"linkpath", &linkpath_coder, &linkpath_decoder, (_Bool)0},
10779|       |    {"mtime", &mtime_coder, &mtime_decoder, (_Bool)0},
10780|       |    {"path", &path_coder, &path_decoder, (_Bool)0},
10781|       |    {"size", &size_coder, &size_decoder, (_Bool)0},
10782|       |    {"uid", &uid_coder, &uid_decoder, (_Bool)0},
10783|       |    {"uname", &uname_coder, &uname_decoder, (_Bool)0},
10784|       |    {"GNU.sparse.size", &sparse_size_coder, &sparse_size_decoder, (_Bool)1},
10785|       |    {"GNU.sparse.numblocks", &sparse_numblocks_coder, &sparse_numblocks_decoder,
10786|       |     (_Bool)1},
10787|       |    {"GNU.sparse.offset", &sparse_offset_coder, &sparse_offset_decoder,
10788|       |     (_Bool)1},
10789|       |    {"GNU.sparse.numbytes", &sparse_numbytes_coder, &sparse_numbytes_decoder,
10790|       |     (_Bool)1},
10791|       |    {(char const *)((void *)0),
10792|       |     (void (*)(struct tar_stat_info const *, char const *, struct xheader *,
10793|       |               void *data))((void *)0),
10794|       |     (void (*)(struct tar_stat_info *, char const *))((void *)0), (_Bool)0}};
10795|       |/* #pragma merger("0","006.incremen.o.i","") */
10796|       |extern void(__attribute__((__nonnull__(1, 4)))
10797|       |            qsort)(void *__base, size_t __nmemb, size_t __size,
10798|       |                   int (*__compar)(void const *, void const *));
10799|       |extern __attribute__((__nothrow__))
10800|       |FILE *(__attribute__((__leaf__)) fdopen)(int __fd, char const *__modes);
10801|       |extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n,
10802|       |                         FILE *__restrict __stream);
10803|       |extern int fseek(FILE *__stream, long __off, int __whence);
10804|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
10805|       |                                        fileno)(FILE *__stream);
10806|       |size_t hash_do_for_each(Hash_table const *table___0,
10807|       |                        _Bool (*processor)(void *, void *),
10808|       |                        void *processor_data);
10809|       |size_t hash_string(char const *string, size_t n_buckets);
10810|       |char const *program_name;
10811|       |void read_directory_file(void);
10812|       |char *quote_copy_string(char const *string);
10813|       |int unquote_string(char *string);
10814|       |void savedir_error(char const *name);
10815|       |void seek_error(char const *name);
10816|       |void truncate_error(char const *name);
10817|       |char *new_name(char const *path, char const *name);
10818|       |static Hash_table *directory_table;
10819|      0|static unsigned int hash_directory(void const *entry, unsigned int n_buckets) {
10820|      0|  struct directory const *directory;
10821|      0|  size_t tmp;
10822|       |
10823|      0|  {
10824|      0|    {
10825|      0|      directory = (struct directory const *)entry;
10826|      0|      tmp = hash_string((char const *)(directory->name), (size_t)n_buckets);
10827|      0|    }
10828|      0|    return ((unsigned int)tmp);
10829|      0|  }
10830|      0|}
10831|      0|static _Bool compare_directories(void const *entry1, void const *entry2) {
10832|      0|  struct directory const *directory1;
10833|      0|  struct directory const *directory2;
10834|      0|  int tmp;
10835|       |
10836|      0|  {
10837|      0|    {
10838|      0|      directory1 = (struct directory const *)entry1;
10839|      0|      directory2 = (struct directory const *)entry2;
10840|      0|      tmp = strcmp((char const *)(directory1->name),
10841|      0|                   (char const *)(directory2->name));
10842|      0|    }
10843|      0|    return ((_Bool)(tmp == 0));
10844|      0|  }
10845|      0|}
10846|       |static struct directory *note_directory(char const *name, dev_t dev, ino_t ino,
10847|      0|                                        _Bool nfs, _Bool found) {
10848|      0|  size_t size;
10849|      0|  size_t tmp;
10850|      0|  struct directory *directory;
10851|      0|  void *tmp___0;
10852|      0|  void *tmp___1;
10853|       |
10854|      0|  {
10855|      0|    {
10856|      0|      tmp = strlen(name);
10857|      0|      size = ((unsigned long)(&((struct directory *)0)->name) + tmp) + 1UL;
10858|      0|      tmp___0 = xmalloc(size);
10859|      0|      directory = (struct directory *)tmp___0;
10860|      0|      directory->device_number = dev;
10861|      0|      directory->inode_number = ino;
10862|      0|      directory->children = (enum children)1;
10863|      0|      directory->nfs = nfs;
10864|      0|      directory->found = found;
10865|      0|      strcpy((char * /* __restrict  */)(directory->name),
10866|      0|             (char const * /* __restrict  */)name);
10867|      0|    }
10868|      0|    if (directory_table) {
10869|      0|      goto _L;
10870|      0|    } else {
10871|      0|      {
10872|      0|        directory_table =
10873|      0|            hash_initialize((size_t)0, (Hash_tuning const *)0,
10874|      0|                            (size_t(*)(void const *, size_t))(&hash_directory),
10875|      0|                            &compare_directories, (void (*)(void *))0);
10876|      0|      }
10877|      0|      if (directory_table) {
10878|      0|      _L : { tmp___1 = hash_insert(directory_table, (void const *)directory); }
10879|      0|        if (!tmp___1) {
10880|      0|          {
10881|      0|            xalloc_die();
10882|      0|          }
10883|      0|        }
10884|      0|      } else {
10885|      0|        { xalloc_die(); }
10886|      0|      }
10887|      0|    }
10888|      0|    return (directory);
10889|      0|  }
10890|      0|}
10891|      0|static struct directory *find_directory(char *name) {
10892|      0|  size_t size;
10893|      0|  size_t tmp;
10894|      0|  struct directory *dir;
10895|      0|  void *tmp___0;
10896|      0|  void *tmp___1;
10897|       |
10898|      0|  {
10899|      0|    if (!directory_table) {
10900|      0|      return ((struct directory *)0);
10901|      0|    } else {
10902|      0|      {
10903|      0|        tmp = strlen((char const *)name);
10904|      0|        size = ((unsigned long)(&((struct directory *)0)->name) + tmp) + 1UL;
10905|      0|        tmp___0 = __builtin_alloca(size);
10906|      0|        dir = (struct directory *)tmp___0;
10907|      0|        strcpy((char * /* __restrict  */)(dir->name),
10908|      0|               (char const * /* __restrict  */)name);
10909|      0|        tmp___1 =
10910|      0|            hash_lookup((Hash_table const *)directory_table, (void const *)dir);
10911|      0|      }
10912|      0|      return ((struct directory *)tmp___1);
10913|      0|    }
10914|      0|  }
10915|      0|}
10916|      0|static int compare_dirents(void const *first, void const *second) {
10917|      0|  int tmp;
10918|       |
10919|      0|  {
10920|      0|    {
10921|      0|      tmp = strcmp((char const *)(*((char *const *)first) + 1),
10922|      0|                   (char const *)(*((char *const *)second) + 1));
10923|      0|    }
10924|      0|    return (tmp);
10925|      0|  }
10926|      0|}
10927|      0|static void scan_path(struct obstack *stk, char *path, dev_t device) {
10928|      0|  char *dirp;
10929|      0|  char *tmp;
10930|      0|  char const *entry;
10931|      0|  size_t entrylen;
10932|      0|  char *name_buffer___0;
10933|      0|  size_t name_buffer_size;
10934|      0|  size_t name_length;
10935|      0|  struct directory *directory;
10936|      0|  enum children children;
10937|      0|  int *tmp___0;
10938|      0|  size_t tmp___1;
10939|      0|  void *tmp___2;
10940|      0|  size_t tmp___3;
10941|      0|  void *tmp___4;
10942|      0|  struct obstack *__o;
10943|      0|  char *tmp___5;
10944|      0|  struct stat stat_data;
10945|      0|  int tmp___6;
10946|      0|  _Bool nfs;
10947|      0|  char *tmp___7;
10948|      0|  char *tmp___8;
10949|      0|  char *tmp___9;
10950|      0|  char *tmp___10;
10951|      0|  struct obstack *__o___0;
10952|      0|  char *tmp___11;
10953|      0|  struct obstack *__o___1;
10954|      0|  char *tmp___12;
10955|      0|  struct obstack *__o___2;
10956|      0|  char *tmp___13;
10957|      0|  struct obstack *__o___3;
10958|      0|  char *tmp___14;
10959|      0|  _Bool tmp___15;
10960|      0|  struct obstack *__o___4;
10961|      0|  int __len;
10962|      0|  struct obstack *__o___5;
10963|      0|  int __len___0;
10964|      0|  unsigned int tmp___16;
10965|      0|  int tmp___17;
10966|      0|  void *__cil_tmp42;
10967|      0|  char *__cil_tmp43;
10968|      0|  char *__cil_tmp44;
10969|      0|  char *__cil_tmp45;
10970|      0|  char *__cil_tmp46;
10971|       |
10972|      0|  {
10973|      0|    {
10974|      0|      tmp = savedir((char const *)path);
10975|      0|      dirp = tmp;
10976|      0|    }
10977|      0|    if (!dirp) {
10978|      0|      {
10979|      0|        savedir_error((char const *)path);
10980|      0|      }
10981|      0|    }
10982|      0|    {
10983|      0|      tmp___0 = __errno_location();
10984|      0|      *tmp___0 = 0;
10985|      0|      tmp___1 = strlen((char const *)path);
10986|      0|      name_buffer_size = tmp___1 + 100UL;
10987|      0|      tmp___2 = xmalloc(name_buffer_size + 2UL);
10988|      0|      name_buffer___0 = (char *)tmp___2;
10989|      0|      strcpy((char * /* __restrict  */)name_buffer___0,
10990|      0|             (char const * /* __restrict  */)path);
10991|      0|      tmp___3 = strlen((char const *)path);
10992|      0|    }
10993|      0|    if (!((int)*(path + (tmp___3 - 1UL)) == 47)) {
10994|      0|      {
10995|      0|        strcat((char * /* __restrict  */)name_buffer___0,
10996|      0|               (char const * /* __restrict  */) "/");
10997|      0|      }
10998|      0|    }
10999|      0|    {
11000|      0|      name_length = strlen((char const *)name_buffer___0);
11001|      0|      directory = find_directory(path);
11002|      0|    }
11003|      0|    if (directory) {
11004|      0|      tmp___16 = (unsigned int)directory->children;
11005|      0|    } else {
11006|      0|      tmp___16 = 1U;
11007|      0|    }
11008|      0|    children = (enum children)tmp___16;
11009|      0|    if (dirp) {
11010|      0|      if ((unsigned int)children != 0U) {
11011|      0|        entry = (char const *)dirp;
11012|      0|        {
11013|      0|          while (1) {
11014|      0|          while_continue: /* CIL Label */;
11015|      0|            { entrylen = strlen(entry); }
11016|      0|            if (!(entrylen != 0UL)) {
11017|      0|              goto while_break;
11018|      0|            }
11019|      0|            if (name_buffer_size <= entrylen + name_length) {
11020|      0|              {
11021|      0|                while (1) {
11022|      0|                while_continue___0: /* CIL Label */;
11023|      0|                  name_buffer_size += 100UL;
11024|      0|                  if (!(name_buffer_size <= entrylen + name_length)) {
11025|      0|                    goto while_break___0;
11026|      0|                  }
11027|      0|                }
11028|      0|              while_break___0: /* CIL Label */;
11029|      0|              }
11030|      0|              {
11031|      0|                tmp___4 =
11032|      0|                    xrealloc((void *)name_buffer___0, name_buffer_size + 2UL);
11033|      0|                name_buffer___0 = (char *)tmp___4;
11034|      0|              }
11035|      0|            }
11036|      0|            {
11037|      0|              strcpy((char * /* __restrict  */)(name_buffer___0 + name_length),
11038|      0|                     (char const * /* __restrict  */)entry);
11039|      0|              tmp___15 = excluded_name((char const *)name_buffer___0);
11040|      0|            }
11041|      0|            if (tmp___15) {
11042|      0|              __o = stk;
11043|      0|              if ((unsigned long)(__o->next_free + 1) >
11044|      0|                  (unsigned long)__o->chunk_limit) {
11045|      0|                {
11046|      0|                  _obstack_newchunk(__o, 1);
11047|      0|                }
11048|      0|              }
11049|      0|              tmp___5 = __o->next_free;
11050|      0|              (__o->next_free)++;
11051|      0|              *tmp___5 = (char)'N';
11052|      0|            } else {
11053|      0|              {
11054|      0|                tmp___6 = deref_stat(dereference_option,
11055|      0|                                     (char const *)name_buffer___0, &stat_data);
11056|      0|              }
11057|      0|              if (tmp___6) {
11058|      0|                {
11059|      0|                  stat_diag((char const *)name_buffer___0);
11060|      0|                }
11061|      0|                goto __Cont;
11062|      0|              }
11063|      0|              if ((stat_data.st_mode & 61440U) == 16384U) {
11064|      0|                {
11065|      0|                  nfs = (_Bool)((stat_data.st_dev &
11066|      0|                                 (0xffffffffffffffffUL
11067|      0|                                  << (sizeof(stat_data.st_dev) * 8UL - 1UL))) !=
11068|      0|                                0UL);
11069|      0|                  directory = find_directory(name_buffer___0);
11070|      0|                }
11071|      0|                if ((unsigned long)directory != (unsigned long)((void *)0)) {
11072|      0|                  if ((int)directory->nfs & (int)nfs) {
11073|      0|                    goto _L___4;
11074|      0|                  } else {
11075|      0|                    if (directory->device_number == stat_data.st_dev) {
11076|      0|                    _L___4: /* CIL Label */
11077|      0|                      if (!(directory->inode_number == stat_data.st_ino)) {
11078|      0|                        goto _L___3;
11079|      0|                      }
11080|      0|                    } else {
11081|      0|                    _L___3: /* CIL Label */
11082|      0|                      if (verbose_option) {
11083|      0|                        {
11084|      0|                          tmp___7 =
11085|      0|                              quotearg_colon((char const *)name_buffer___0);
11086|      0|                          tmp___8 = gettext("%s: Directory has been renamed");
11087|      0|                          error(0, 0, (char const *)tmp___8, tmp___7);
11088|      0|                        }
11089|      0|                      }
11090|      0|                      directory->children = (enum children)2;
11091|      0|                      directory->nfs = nfs;
11092|      0|                      directory->device_number = stat_data.st_dev;
11093|      0|                      directory->inode_number = stat_data.st_ino;
11094|      0|                    }
11095|      0|                  }
11096|      0|                  directory->found = (_Bool)1;
11097|      0|                } else {
11098|      0|                  if (verbose_option) {
11099|      0|                    {
11100|      0|                      tmp___9 = quotearg_colon((char const *)name_buffer___0);
11101|      0|                      tmp___10 = gettext("%s: Directory is new");
11102|      0|                      error(0, 0, (char const *)tmp___10, tmp___9);
11103|      0|                    }
11104|      0|                  }
11105|      0|                  {
11106|      0|                    directory = note_directory((char const *)name_buffer___0,
11107|      0|                                               stat_data.st_dev,
11108|      0|                                               stat_data.st_ino, nfs, (_Bool)1);
11109|      0|                  }
11110|      0|                  if (listed_incremental_option) {
11111|      0|                    tmp___17 = 2;
11112|      0|                  } else {
11113|      0|                    if (stat_data.st_mtim.tv_sec < newer_mtime_option.tv_sec) {
11114|      0|                      tmp___17 = 2;
11115|      0|                    } else {
11116|      0|                      if (stat_data.st_mtim.tv_sec ==
11117|      0|                          newer_mtime_option.tv_sec) {
11118|      0|                        if (stat_data.st_mtim.tv_nsec <
11119|      0|                            newer_mtime_option.tv_nsec) {
11120|      0|                          tmp___17 = 2;
11121|      0|                        } else {
11122|      0|                          goto _L___5;
11123|      0|                        }
11124|      0|                      } else {
11125|      0|                      _L___5: /* CIL Label */
11126|      0|                        if (after_date_option) {
11127|      0|                          if (stat_data.st_ctim.tv_sec <
11128|      0|                              newer_mtime_option.tv_sec) {
11129|      0|                            tmp___17 = 2;
11130|      0|                          } else {
11131|      0|                            if (stat_data.st_ctim.tv_sec ==
11132|      0|                                newer_mtime_option.tv_sec) {
11133|      0|                              if (stat_data.st_ctim.tv_nsec <
11134|      0|                                  newer_mtime_option.tv_nsec) {
11135|      0|                                tmp___17 = 2;
11136|      0|                              } else {
11137|      0|                                tmp___17 = 1;
11138|      0|                              }
11139|      0|                            } else {
11140|      0|                              tmp___17 = 1;
11141|      0|                            }
11142|      0|                          }
11143|      0|                        } else {
11144|      0|                          tmp___17 = 1;
11145|      0|                        }
11146|      0|                      }
11147|      0|                    }
11148|      0|                  }
11149|      0|                  directory->children = (enum children)tmp___17;
11150|      0|                }
11151|      0|                if (one_file_system_option) {
11152|      0|                  if (device != stat_data.st_dev) {
11153|      0|                    directory->children = (enum children)0;
11154|      0|                  } else {
11155|      0|                    goto _L___6;
11156|      0|                  }
11157|      0|                } else {
11158|      0|                _L___6: /* CIL Label */
11159|      0|                  if ((unsigned int)children == 2U) {
11160|      0|                    directory->children = (enum children)2;
11161|      0|                  }
11162|      0|                }
11163|      0|                __o___0 = stk;
11164|      0|                if ((unsigned long)(__o___0->next_free + 1) >
11165|      0|                    (unsigned long)__o___0->chunk_limit) {
11166|      0|                  {
11167|      0|                    _obstack_newchunk(__o___0, 1);
11168|      0|                  }
11169|      0|                }
11170|      0|                tmp___11 = __o___0->next_free;
11171|      0|                (__o___0->next_free)++;
11172|      0|                *tmp___11 = (char)'D';
11173|      0|              } else {
11174|      0|                if (one_file_system_option) {
11175|      0|                  if (device != stat_data.st_dev) {
11176|      0|                    __o___1 = stk;
11177|      0|                    if ((unsigned long)(__o___1->next_free + 1) >
11178|      0|                        (unsigned long)__o___1->chunk_limit) {
11179|      0|                      {
11180|      0|                        _obstack_newchunk(__o___1, 1);
11181|      0|                      }
11182|      0|                    }
11183|      0|                    tmp___12 = __o___1->next_free;
11184|      0|                    (__o___1->next_free)++;
11185|      0|                    *tmp___12 = (char)'N';
11186|      0|                  } else {
11187|      0|                    goto _L___12;
11188|      0|                  }
11189|      0|                } else {
11190|      0|                _L___12: /* CIL Label */
11191|      0|                  if ((unsigned int)children == 1U) {
11192|      0|                    if (stat_data.st_mtim.tv_sec < newer_mtime_option.tv_sec) {
11193|      0|                      goto _L___11;
11194|      0|                    } else {
11195|      0|                      if (stat_data.st_mtim.tv_sec ==
11196|      0|                          newer_mtime_option.tv_sec) {
11197|      0|                        if (stat_data.st_mtim.tv_nsec <
11198|      0|                            newer_mtime_option.tv_nsec) {
11199|      0|                        _L___11: /* CIL Label */
11200|      0|                          if (!after_date_option) {
11201|      0|                            goto _L___9;
11202|      0|                          } else {
11203|      0|                            if (stat_data.st_ctim.tv_sec <
11204|      0|                                newer_mtime_option.tv_sec) {
11205|      0|                              goto _L___9;
11206|      0|                            } else {
11207|      0|                              if (stat_data.st_ctim.tv_sec ==
11208|      0|                                  newer_mtime_option.tv_sec) {
11209|      0|                                if (stat_data.st_ctim.tv_nsec <
11210|      0|                                    newer_mtime_option.tv_nsec) {
11211|      0|                                _L___9: /* CIL Label */
11212|      0|                                  __o___2 = stk;
11213|      0|                                  if ((unsigned long)(__o___2->next_free + 1) >
11214|      0|                                      (unsigned long)__o___2->chunk_limit) {
11215|      0|                                    {
11216|      0|                                      _obstack_newchunk(__o___2, 1);
11217|      0|                                    }
11218|      0|                                  }
11219|      0|                                  tmp___13 = __o___2->next_free;
11220|      0|                                  (__o___2->next_free)++;
11221|      0|                                  *tmp___13 = (char)'N';
11222|      0|                                } else {
11223|      0|                                  goto _L___10;
11224|      0|                                }
11225|      0|                              } else {
11226|      0|                                goto _L___10;
11227|      0|                              }
11228|      0|                            }
11229|      0|                          }
11230|      0|                        } else {
11231|      0|                          goto _L___10;
11232|      0|                        }
11233|      0|                      } else {
11234|      0|                        goto _L___10;
11235|      0|                      }
11236|      0|                    }
11237|      0|                  } else {
11238|      0|                  _L___10: /* CIL Label */
11239|      0|                    __o___3 = stk;
11240|      0|                    if ((unsigned long)(__o___3->next_free + 1) >
11241|      0|                        (unsigned long)__o___3->chunk_limit) {
11242|      0|                      {
11243|      0|                        _obstack_newchunk(__o___3, 1);
11244|      0|                      }
11245|      0|                    }
11246|      0|                    tmp___14 = __o___3->next_free;
11247|      0|                    (__o___3->next_free)++;
11248|      0|                    *tmp___14 = (char)'Y';
11249|      0|                  }
11250|      0|                }
11251|      0|              }
11252|      0|            }
11253|      0|            __o___4 = stk;
11254|      0|            __len = (int)(entrylen + 1UL);
11255|      0|            if ((unsigned long)(__o___4->next_free + __len) >
11256|      0|                (unsigned long)__o___4->chunk_limit) {
11257|      0|              {
11258|      0|                _obstack_newchunk(__o___4, __len);
11259|      0|              }
11260|      0|            }
11261|      0|            {
11262|      0|              memcpy((void * /* __restrict  */)__o___4->next_free,
11263|      0|                     (void const * /* __restrict  */)entry, (size_t)__len);
11264|      0|              __o___4->next_free += __len;
11265|      0|            }
11266|      0|          __Cont:
11267|      0|            entry += entrylen + 1UL;
11268|      0|          }
11269|      0|        while_break: /* CIL Label */;
11270|      0|        }
11271|      0|      }
11272|      0|    }
11273|      0|    __o___5 = stk;
11274|      0|    __len___0 = 2;
11275|      0|    if ((unsigned long)(__o___5->next_free + __len___0) >
11276|      0|        (unsigned long)__o___5->chunk_limit) {
11277|      0|      {
11278|      0|        _obstack_newchunk(__o___5, __len___0);
11279|      0|      }
11280|      0|    }
11281|      0|    {
11282|      0|      memcpy((void * /* __restrict  */)__o___5->next_free,
11283|      0|             (void const * /* __restrict  */) "\000\000", (size_t)__len___0);
11284|      0|      __o___5->next_free += __len___0;
11285|      0|      free((void *)name_buffer___0);
11286|      0|    }
11287|      0|    if (dirp) {
11288|      0|      {
11289|      0|        free((void *)dirp);
11290|      0|      }
11291|      0|    }
11292|      0|    return;
11293|      0|  }
11294|      0|}
11295|      0|static char *sort_obstack(struct obstack *stk) {
11296|      0|  char *pointer;
11297|      0|  struct obstack *__o1;
11298|      0|  void *value;
11299|      0|  size_t counter;
11300|      0|  char *cursor;
11301|      0|  char *buffer___2;
11302|      0|  char **array;
11303|      0|  char **array_cursor;
11304|      0|  size_t tmp;
11305|      0|  struct obstack *__h;
11306|      0|  struct obstack *__o;
11307|      0|  int __len;
11308|      0|  struct obstack *__o1___0;
11309|      0|  void *value___0;
11310|      0|  size_t tmp___0;
11311|      0|  char **tmp___1;
11312|      0|  void *tmp___2;
11313|      0|  char *string;
11314|      0|  char *tmp___3;
11315|      0|  char tmp___4;
11316|      0|  char *tmp___5;
11317|       |
11318|      0|  {
11319|      0|    __o1 = stk;
11320|      0|    value = (void *)__o1->object_base;
11321|      0|    if ((unsigned long)__o1->next_free == (unsigned long)value) {
11322|      0|      __o1->maybe_empty_object = 1U;
11323|      0|    }
11324|      0|    __o1->next_free =
11325|      0|        (char *)0 +
11326|      0|        (((__o1->next_free - (char *)0) + (long)__o1->alignment_mask) &
11327|      0|         (long)(~__o1->alignment_mask));
11328|      0|    if (__o1->next_free - (char *)__o1->chunk >
11329|      0|        __o1->chunk_limit - (char *)__o1->chunk) {
11330|      0|      __o1->next_free = __o1->chunk_limit;
11331|      0|    }
11332|      0|    __o1->object_base = __o1->next_free;
11333|      0|    pointer = (char *)value;
11334|      0|    counter = (size_t)0;
11335|      0|    cursor = pointer;
11336|      0|    {
11337|      0|      while (1) {
11338|      0|      while_continue: /* CIL Label */;
11339|      0|        if (!*cursor) {
11340|      0|          goto while_break;
11341|      0|        }
11342|      0|        {
11343|      0|          counter++;
11344|      0|          tmp = strlen((char const *)cursor);
11345|      0|          cursor += tmp + 1UL;
11346|      0|        }
11347|      0|      }
11348|      0|    while_break: /* CIL Label */;
11349|      0|    }
11350|      0|    if (!counter) {
11351|      0|      return ((char *)((void *)0));
11352|      0|    }
11353|      0|    __h = stk;
11354|      0|    __o = __h;
11355|      0|    __len = (int)(sizeof(char *) * (counter + 1UL));
11356|      0|    if (__o->chunk_limit - __o->next_free < (long)__len) {
11357|      0|      {
11358|      0|        _obstack_newchunk(__o, __len);
11359|      0|      }
11360|      0|    }
11361|      0|    __o->next_free += __len;
11362|      0|    __o1___0 = __h;
11363|      0|    value___0 = (void *)__o1___0->object_base;
11364|      0|    if ((unsigned long)__o1___0->next_free == (unsigned long)value___0) {
11365|      0|      __o1___0->maybe_empty_object = 1U;
11366|      0|    }
11367|      0|    __o1___0->next_free =
11368|      0|        (char *)0 +
11369|      0|        (((__o1___0->next_free - (char *)0) + (long)__o1___0->alignment_mask) &
11370|      0|         (long)(~__o1___0->alignment_mask));
11371|      0|    if (__o1___0->next_free - (char *)__o1___0->chunk >
11372|      0|        __o1___0->chunk_limit - (char *)__o1___0->chunk) {
11373|      0|      __o1___0->next_free = __o1___0->chunk_limit;
11374|      0|    }
11375|      0|    __o1___0->object_base = __o1___0->next_free;
11376|      0|    array = (char **)value___0;
11377|      0|    array_cursor = array;
11378|      0|    cursor = pointer;
11379|      0|    {
11380|      0|      while (1) {
11381|      0|      while_continue___0: /* CIL Label */;
11382|      0|        if (!*cursor) {
11383|      0|          goto while_break___0;
11384|      0|        }
11385|      0|        {
11386|      0|          tmp___1 = array_cursor;
11387|      0|          array_cursor++;
11388|      0|          *tmp___1 = cursor;
11389|      0|          tmp___0 = strlen((char const *)cursor);
11390|      0|          cursor += tmp___0 + 1UL;
11391|      0|        }
11392|      0|      }
11393|      0|    while_break___0: /* CIL Label */;
11394|      0|    }
11395|      0|    {
11396|      0|      *array_cursor = (char *)0;
11397|      0|      qsort((void *)array, counter, sizeof(char *), &compare_dirents);
11398|      0|      tmp___2 = xmalloc((size_t)((cursor - pointer) + 2L));
11399|      0|      buffer___2 = (char *)tmp___2;
11400|      0|      cursor = buffer___2;
11401|      0|      array_cursor = array;
11402|      0|    }
11403|      0|    {
11404|      0|      while (1) {
11405|      0|      while_continue___1: /* CIL Label */;
11406|      0|        if (!*array_cursor) {
11407|      0|          goto while_break___1;
11408|      0|        }
11409|      0|        string = *array_cursor;
11410|      0|        {
11411|      0|          while (1) {
11412|      0|          while_continue___2: /* CIL Label */;
11413|      0|            tmp___3 = cursor;
11414|      0|            cursor++;
11415|      0|            tmp___5 = string;
11416|      0|            string++;
11417|      0|            tmp___4 = *tmp___5;
11418|      0|            *tmp___3 = tmp___4;
11419|      0|            if (!tmp___4) {
11420|      0|              goto while_break___2;
11421|      0|            }
11422|      0|            goto while_continue___2;
11423|      0|          }
11424|      0|        while_break___2: /* CIL Label */;
11425|      0|        }
11426|      0|        array_cursor++;
11427|      0|      }
11428|      0|    while_break___1: /* CIL Label */;
11429|      0|    }
11430|      0|    *cursor = (char)'\000';
11431|      0|    return (buffer___2);
11432|      0|  }
11433|      0|}
11434|      0|char *get_directory_contents(char *path, dev_t device) {
11435|      0|  struct obstack stk;
11436|      0|  char *buffer___2;
11437|      0|  struct obstack *__o;
11438|      0|  void *__obj;
11439|      0|  char *tmp;
11440|       |
11441|      0|  {
11442|      0|    {
11443|      0|      _obstack_begin(&stk, 0, 0, (void *(*)(long))(&xmalloc),
11444|      0|                     (void (*)(void *))(&free));
11445|      0|      scan_path(&stk, path, device);
11446|      0|      buffer___2 = sort_obstack(&stk);
11447|      0|      __o = &stk;
11448|      0|      __obj = (void *)0;
11449|      0|    }
11450|      0|    if ((unsigned long)__obj > (unsigned long)((void *)__o->chunk)) {
11451|      0|      if ((unsigned long)__obj < (unsigned long)((void *)__o->chunk_limit)) {
11452|      0|        tmp = (char *)__obj;
11453|      0|        __o->object_base = tmp;
11454|      0|        __o->next_free = tmp;
11455|      0|      } else {
11456|      0|        { obstack_free(__o, __obj); }
11457|      0|      }
11458|      0|    } else {
11459|      0|      { obstack_free(__o, __obj); }
11460|      0|    }
11461|      0|    return (buffer___2);
11462|      0|  }
11463|      0|}
11464|       |static FILE *listed_incremental_stream;
11465|      0|void read_directory_file(void) {
11466|      0|  int fd;
11467|      0|  FILE *fp;
11468|      0|  char *buf;
11469|      0|  size_t bufsize;
11470|      0|  char *ebuf;
11471|      0|  int n;
11472|      0|  long lineno;
11473|      0|  unsigned long u;
11474|      0|  int *tmp;
11475|      0|  unsigned long tmp___0;
11476|      0|  time_t t;
11477|      0|  char *tmp___1;
11478|      0|  char *tmp___2;
11479|      0|  char *tmp___3;
11480|      0|  char *tmp___4;
11481|      0|  int *tmp___5;
11482|      0|  int *tmp___6;
11483|      0|  dev_t dev;
11484|      0|  ino_t ino;
11485|      0|  _Bool nfs;
11486|      0|  char *strp;
11487|      0|  int *tmp___7;
11488|      0|  char *tmp___8;
11489|      0|  char *tmp___9;
11490|      0|  char *tmp___10;
11491|      0|  char *tmp___11;
11492|      0|  int *tmp___12;
11493|      0|  int *tmp___13;
11494|      0|  int *tmp___14;
11495|      0|  char *tmp___15;
11496|      0|  char *tmp___16;
11497|      0|  char *tmp___17;
11498|      0|  char *tmp___18;
11499|      0|  int *tmp___19;
11500|      0|  int *tmp___20;
11501|      0|  __ssize_t tmp___21;
11502|      0|  __ssize_t tmp___22;
11503|      0|  int tmp___23;
11504|      0|  char *__cil_tmp39;
11505|      0|  char *__cil_tmp40;
11506|      0|  char *__cil_tmp41;
11507|      0|  char *__cil_tmp42;
11508|      0|  char *__cil_tmp43;
11509|      0|  char *__cil_tmp44;
11510|      0|  char *__cil_tmp45;
11511|      0|  char *__cil_tmp46;
11512|      0|  char *__cil_tmp47;
11513|      0|  char *__cil_tmp48;
11514|      0|  char *__cil_tmp49;
11515|      0|  char *__cil_tmp50;
11516|       |
11517|      0|  {
11518|      0|    {
11519|      0|      buf = (char *)0;
11520|      0|      fd = open(listed_incremental_option, 66,
11521|      0|                ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
11522|      0|                    ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
11523|      0|    }
11524|      0|    if (fd < 0) {
11525|      0|      {
11526|      0|        open_error(listed_incremental_option);
11527|      0|      }
11528|      0|      return;
11529|      0|    }
11530|      0|    { fp = fdopen(fd, "r+"); }
11531|      0|    if (!fp) {
11532|      0|      {
11533|      0|        open_error(listed_incremental_option);
11534|      0|        close(fd);
11535|      0|      }
11536|      0|      return;
11537|      0|    }
11538|      0|    {
11539|      0|      listed_incremental_stream = fp;
11540|      0|      tmp___22 = getline((char ** /* __restrict  */)(&buf),
11541|      0|                         (size_t * /* __restrict  */)(&bufsize),
11542|      0|                         (FILE * /* __restrict  */) fp);
11543|      0|    }
11544|      0|    if (0L < tmp___22) {
11545|      0|      {
11546|      0|        lineno = 1L;
11547|      0|        tmp = __errno_location();
11548|      0|        *tmp = 0;
11549|      0|        tmp___0 = strtoul((char const * /* __restrict  */)buf,
11550|      0|                          (char ** /* __restrict  */)(&ebuf), 10);
11551|      0|        u = tmp___0;
11552|      0|        t = (time_t)u;
11553|      0|      }
11554|      0|      if ((unsigned long)buf == (unsigned long)ebuf) {
11555|      0|        {
11556|      0|          tmp___1 = gettext("Invalid time stamp");
11557|      0|          tmp___2 = quotearg_colon(listed_incremental_option);
11558|      0|          error(0, 0, "%s:1: %s", tmp___2, tmp___1);
11559|      0|          exit_status = 2;
11560|      0|        }
11561|      0|      } else {
11562|      0|        if (u == 0UL) {
11563|      0|          {
11564|      0|            tmp___6 = __errno_location();
11565|      0|          }
11566|      0|          if (*tmp___6 == 22) {
11567|      0|            {
11568|      0|              tmp___1 = gettext("Invalid time stamp");
11569|      0|              tmp___2 = quotearg_colon(listed_incremental_option);
11570|      0|              error(0, 0, "%s:1: %s", tmp___2, tmp___1);
11571|      0|              exit_status = 2;
11572|      0|            }
11573|      0|          } else {
11574|      0|            goto _L;
11575|      0|          }
11576|      0|        } else {
11577|      0|        _L:
11578|      0|          if ((unsigned long)t != u) {
11579|      0|            {
11580|      0|              tmp___3 = gettext("Time stamp out of range");
11581|      0|              tmp___4 = quotearg_colon(listed_incremental_option);
11582|      0|              error(0, 0, "%s:1: %s", tmp___4, tmp___3);
11583|      0|              exit_status = 2;
11584|      0|            }
11585|      0|          } else {
11586|      0|            if (u == 0xffffffffffffffffUL) {
11587|      0|              {
11588|      0|                tmp___5 = __errno_location();
11589|      0|              }
11590|      0|              if (*tmp___5 == 34) {
11591|      0|                {
11592|      0|                  tmp___3 = gettext("Time stamp out of range");
11593|      0|                  tmp___4 = quotearg_colon(listed_incremental_option);
11594|      0|                  error(0, 0, "%s:1: %s", tmp___4, tmp___3);
11595|      0|                  exit_status = 2;
11596|      0|                }
11597|      0|              } else {
11598|      0|                newer_mtime_option.tv_sec = t;
11599|      0|                newer_mtime_option.tv_nsec = (__syscall_slong_t)0;
11600|      0|              }
11601|      0|            } else {
11602|      0|              newer_mtime_option.tv_sec = t;
11603|      0|              newer_mtime_option.tv_nsec = (__syscall_slong_t)0;
11604|      0|            }
11605|      0|          }
11606|      0|        }
11607|      0|      }
11608|      0|      {
11609|      0|        while (1) {
11610|      0|        while_continue: /* CIL Label */;
11611|      0|          {
11612|      0|            tmp___21 = getline((char ** /* __restrict  */)(&buf),
11613|      0|                               (size_t * /* __restrict  */)(&bufsize),
11614|      0|                               (FILE * /* __restrict  */) fp);
11615|      0|            n = (int)tmp___21;
11616|      0|          }
11617|      0|          if (!(0 < n)) {
11618|      0|            goto while_break;
11619|      0|          }
11620|      0|          nfs = (_Bool)((int)*(buf + 0) == 43);
11621|      0|          strp = buf + (int)nfs;
11622|      0|          lineno++;
11623|      0|          if ((int)*(buf + (n - 1)) == 10) {
11624|      0|            *(buf + (n - 1)) = (char)'\000';
11625|      0|          }
11626|      0|          {
11627|      0|            tmp___7 = __errno_location();
11628|      0|            *tmp___7 = 0;
11629|      0|            u = strtoul((char const * /* __restrict  */)strp,
11630|      0|                        (char ** /* __restrict  */)(&ebuf), 10);
11631|      0|            dev = u;
11632|      0|          }
11633|      0|          if ((unsigned long)strp == (unsigned long)ebuf) {
11634|      0|            {
11635|      0|              tmp___8 = gettext("Invalid device number");
11636|      0|              tmp___9 = quotearg_colon(listed_incremental_option);
11637|      0|              error(0, 0, "%s:%ld: %s", tmp___9, lineno, tmp___8);
11638|      0|              exit_status = 2;
11639|      0|            }
11640|      0|          } else {
11641|      0|            if (u == 0UL) {
11642|      0|              {
11643|      0|                tmp___13 = __errno_location();
11644|      0|              }
11645|      0|              if (*tmp___13 == 22) {
11646|      0|                {
11647|      0|                  tmp___8 = gettext("Invalid device number");
11648|      0|                  tmp___9 = quotearg_colon(listed_incremental_option);
11649|      0|                  error(0, 0, "%s:%ld: %s", tmp___9, lineno, tmp___8);
11650|      0|                  exit_status = 2;
11651|      0|                }
11652|      0|              } else {
11653|      0|                goto _L___0;
11654|      0|              }
11655|      0|            } else {
11656|      0|            _L___0:
11657|      0|              if (dev != u) {
11658|      0|                {
11659|      0|                  tmp___10 = gettext("Device number out of range");
11660|      0|                  tmp___11 = quotearg_colon(listed_incremental_option);
11661|      0|                  error(0, 0, "%s:%ld: %s", tmp___11, lineno, tmp___10);
11662|      0|                  exit_status = 2;
11663|      0|                }
11664|      0|              } else {
11665|      0|                if (u == 0xffffffffffffffffUL) {
11666|      0|                  {
11667|      0|                    tmp___12 = __errno_location();
11668|      0|                  }
11669|      0|                  if (*tmp___12 == 34) {
11670|      0|                    {
11671|      0|                      tmp___10 = gettext("Device number out of range");
11672|      0|                      tmp___11 = quotearg_colon(listed_incremental_option);
11673|      0|                      error(0, 0, "%s:%ld: %s", tmp___11, lineno, tmp___10);
11674|      0|                      exit_status = 2;
11675|      0|                    }
11676|      0|                  }
11677|      0|                }
11678|      0|              }
11679|      0|            }
11680|      0|          }
11681|      0|          {
11682|      0|            strp = ebuf;
11683|      0|            tmp___14 = __errno_location();
11684|      0|            *tmp___14 = 0;
11685|      0|            u = strtoul((char const * /* __restrict  */)strp,
11686|      0|                        (char ** /* __restrict  */)(&ebuf), 10);
11687|      0|            ino = u;
11688|      0|          }
11689|      0|          if ((unsigned long)strp == (unsigned long)ebuf) {
11690|      0|            {
11691|      0|              tmp___15 = gettext("Invalid inode number");
11692|      0|              tmp___16 = quotearg_colon(listed_incremental_option);
11693|      0|              error(0, 0, "%s:%ld: %s", tmp___16, lineno, tmp___15);
11694|      0|              exit_status = 2;
11695|      0|            }
11696|      0|          } else {
11697|      0|            if (u == 0UL) {
11698|      0|              {
11699|      0|                tmp___20 = __errno_location();
11700|      0|              }
11701|      0|              if (*tmp___20 == 22) {
11702|      0|                {
11703|      0|                  tmp___15 = gettext("Invalid inode number");
11704|      0|                  tmp___16 = quotearg_colon(listed_incremental_option);
11705|      0|                  error(0, 0, "%s:%ld: %s", tmp___16, lineno, tmp___15);
11706|      0|                  exit_status = 2;
11707|      0|                }
11708|      0|              } else {
11709|      0|                goto _L___1;
11710|      0|              }
11711|      0|            } else {
11712|      0|            _L___1:
11713|      0|              if (ino != u) {
11714|      0|                {
11715|      0|                  tmp___17 = gettext("Inode number out of range");
11716|      0|                  tmp___18 = quotearg_colon(listed_incremental_option);
11717|      0|                  error(0, 0, "%s:%ld: %s", tmp___18, lineno, tmp___17);
11718|      0|                  exit_status = 2;
11719|      0|                }
11720|      0|              } else {
11721|      0|                if (u == 0xffffffffffffffffUL) {
11722|      0|                  {
11723|      0|                    tmp___19 = __errno_location();
11724|      0|                  }
11725|      0|                  if (*tmp___19 == 34) {
11726|      0|                    {
11727|      0|                      tmp___17 = gettext("Inode number out of range");
11728|      0|                      tmp___18 = quotearg_colon(listed_incremental_option);
11729|      0|                      error(0, 0, "%s:%ld: %s", tmp___18, lineno, tmp___17);
11730|      0|                      exit_status = 2;
11731|      0|                    }
11732|      0|                  }
11733|      0|                }
11734|      0|              }
11735|      0|            }
11736|      0|          }
11737|      0|          {
11738|      0|            strp = ebuf;
11739|      0|            strp++;
11740|      0|            unquote_string(strp);
11741|      0|            note_directory((char const *)strp, dev, ino, nfs, (_Bool)0);
11742|      0|          }
11743|      0|        }
11744|      0|      while_break: /* CIL Label */;
11745|      0|      }
11746|      0|    }
11747|      0|    { tmp___23 = ferror_unlocked(fp); }
11748|      0|    if (tmp___23) {
11749|      0|      {
11750|      0|        read_error(listed_incremental_option);
11751|      0|      }
11752|      0|    }
11753|      0|    if (buf) {
11754|      0|      {
11755|      0|        free((void *)buf);
11756|      0|      }
11757|      0|    }
11758|      0|    return;
11759|      0|  }
11760|      0|}
11761|      0|static _Bool write_directory_file_entry(void *entry, void *data) {
11762|      0|  struct directory const *directory;
11763|      0|  FILE *fp;
11764|      0|  int e;
11765|      0|  char *str;
11766|      0|  char *tmp;
11767|      0|  int *tmp___0;
11768|      0|  int *tmp___1;
11769|      0|  int tmp___2;
11770|      0|  int tmp___3;
11771|      0|  char *tmp___4;
11772|       |
11773|      0|  {
11774|      0|    directory = (struct directory const *)entry;
11775|      0|    fp = (FILE *)data;
11776|      0|    if (directory->found) {
11777|      0|      {
11778|      0|        tmp = quote_copy_string((char const *)(directory->name));
11779|      0|        str = tmp;
11780|      0|      }
11781|      0|      if (str) {
11782|      0|        tmp___4 = (char * /* const  */)str;
11783|      0|      } else {
11784|      0|        tmp___4 = directory->name;
11785|      0|      }
11786|      0|      {
11787|      0|        fprintf(
11788|      0|            (FILE * /* __restrict  */) fp,
11789|      0|            (char const * /* __restrict  */)("+%lu %lu %s\n" + !directory->nfs),
11790|      0|            (unsigned long)directory->device_number,
11791|      0|            (unsigned long)directory->inode_number, tmp___4);
11792|      0|        tmp___0 = __errno_location();
11793|      0|        e = *tmp___0;
11794|      0|      }
11795|      0|      if (str) {
11796|      0|        {
11797|      0|          free((void *)str);
11798|      0|        }
11799|      0|      }
11800|      0|      {
11801|      0|        tmp___1 = __errno_location();
11802|      0|        *tmp___1 = e;
11803|      0|      }
11804|      0|    }
11805|      0|    { tmp___2 = ferror_unlocked(fp); }
11806|      0|    if (tmp___2) {
11807|      0|      tmp___3 = 0;
11808|      0|    } else {
11809|      0|      tmp___3 = 1;
11810|      0|    }
11811|      0|    return ((_Bool)tmp___3);
11812|      0|  }
11813|      0|}
11814|      0|void write_directory_file(void) {
11815|      0|  FILE *fp;
11816|      0|  int tmp;
11817|      0|  int tmp___0;
11818|      0|  int tmp___1;
11819|      0|  int tmp___2;
11820|      0|  int tmp___3;
11821|      0|  int tmp___4;
11822|       |
11823|      0|  {
11824|      0|    fp = listed_incremental_stream;
11825|      0|    if (!fp) {
11826|      0|      return;
11827|      0|    }
11828|      0|    { tmp = fseek(fp, 0L, 0); }
11829|      0|    if (tmp != 0) {
11830|      0|      {
11831|      0|        seek_error(listed_incremental_option);
11832|      0|      }
11833|      0|    }
11834|      0|    {
11835|      0|      tmp___0 = fileno(fp);
11836|      0|      tmp___1 = sys_truncate(tmp___0);
11837|      0|    }
11838|      0|    if (tmp___1 != 0) {
11839|      0|      {
11840|      0|        truncate_error(listed_incremental_option);
11841|      0|      }
11842|      0|    }
11843|      0|    {
11844|      0|      fprintf((FILE * /* __restrict  */) fp,
11845|      0|              (char const * /* __restrict  */) "%lu\n",
11846|      0|              (unsigned long)start_timespec.tv_sec);
11847|      0|      tmp___2 = ferror_unlocked(fp);
11848|      0|    }
11849|      0|    if (!tmp___2) {
11850|      0|      if (directory_table) {
11851|      0|        {
11852|      0|          hash_do_for_each((Hash_table const *)directory_table,
11853|      0|                           &write_directory_file_entry, (void *)fp);
11854|      0|        }
11855|      0|      }
11856|      0|    }
11857|      0|    { tmp___3 = ferror_unlocked(fp); }
11858|      0|    if (tmp___3) {
11859|      0|      {
11860|      0|        write_error(listed_incremental_option);
11861|      0|      }
11862|      0|    }
11863|      0|    { tmp___4 = fclose(fp); }
11864|      0|    if (tmp___4 != 0) {
11865|      0|      {
11866|      0|        close_error(listed_incremental_option);
11867|      0|      }
11868|      0|    }
11869|      0|    return;
11870|      0|  }
11871|      0|}
11872|      0|void gnu_restore(char const *directory_name) {
11873|      0|  char *archive_dir;
11874|      0|  char *current_dir;
11875|      0|  char *cur;
11876|      0|  char *arc;
11877|      0|  size_t size;
11878|      0|  size_t copied;
11879|      0|  union block *data_block;
11880|      0|  char *to;
11881|      0|  void *tmp;
11882|      0|  char *tmp___0;
11883|      0|  size_t tmp___1;
11884|      0|  size_t tmp___2;
11885|      0|  int tmp___3;
11886|      0|  char *p;
11887|      0|  char *tmp___4;
11888|      0|  char const *tmp___5;
11889|      0|  char *tmp___6;
11890|      0|  int e;
11891|      0|  int *tmp___7;
11892|      0|  char *tmp___8;
11893|      0|  char *tmp___9;
11894|      0|  int tmp___10;
11895|      0|  int tmp___11;
11896|      0|  char *__cil_tmp25;
11897|      0|  char *__cil_tmp26;
11898|      0|  char *__cil_tmp27;
11899|      0|  char *__cil_tmp28;
11900|       |
11901|      0|  {
11902|      0|    { current_dir = savedir(directory_name); }
11903|      0|    if (!current_dir) {
11904|      0|      {
11905|      0|        skip_member();
11906|      0|      }
11907|      0|      return;
11908|      0|    }
11909|      0|    size = (size_t)current_stat_info.stat.st_size;
11910|      0|    if (size != (size_t)current_stat_info.stat.st_size) {
11911|      0|      {
11912|      0|        xalloc_die();
11913|      0|      }
11914|      0|    }
11915|      0|    {
11916|      0|      tmp = xmalloc(size);
11917|      0|      archive_dir = (char *)tmp;
11918|      0|      to = archive_dir;
11919|      0|    }
11920|      0|    {
11921|      0|      while (1) {
11922|      0|      while_continue: /* CIL Label */;
11923|      0|        if (!(size > 0UL)) {
11924|      0|          goto while_break;
11925|      0|        }
11926|      0|        { data_block = find_next_block(); }
11927|      0|        if (!data_block) {
11928|      0|          {
11929|      0|            tmp___0 = gettext("Unexpected EOF in archive");
11930|      0|            error(0, 0, (char const *)tmp___0);
11931|      0|            exit_status = 2;
11932|      0|          }
11933|      0|          goto while_break;
11934|      0|        }
11935|      0|        { copied = available_space_after(data_block); }
11936|      0|        if (copied > size) {
11937|      0|          copied = size;
11938|      0|        }
11939|      0|        {
11940|      0|          memcpy((void * /* __restrict  */)to,
11941|      0|                 (void const * /* __restrict  */)(data_block->buffer), copied);
11942|      0|          to += copied;
11943|      0|          set_next_block_after(
11944|      0|              (union block *)((data_block->buffer + copied) - 1));
11945|      0|          size -= copied;
11946|      0|        }
11947|      0|      }
11948|      0|    while_break: /* CIL Label */;
11949|      0|    }
11950|      0|    cur = current_dir;
11951|      0|    {
11952|      0|      while (1) {
11953|      0|      while_continue___0: /* CIL Label */;
11954|      0|        if (!*cur) {
11955|      0|          goto while_break___0;
11956|      0|        }
11957|      0|        arc = archive_dir;
11958|      0|        {
11959|      0|          while (1) {
11960|      0|          while_continue___1: /* CIL Label */;
11961|      0|            if (!*arc) {
11962|      0|              goto while_break___1;
11963|      0|            }
11964|      0|            {
11965|      0|              arc++;
11966|      0|              tmp___3 = strcmp((char const *)arc, (char const *)cur);
11967|      0|            }
11968|      0|            if (!tmp___3) {
11969|      0|              goto while_break___1;
11970|      0|            }
11971|      0|            {
11972|      0|              tmp___2 = strlen((char const *)arc);
11973|      0|              arc += tmp___2 + 1UL;
11974|      0|            }
11975|      0|          }
11976|      0|        while_break___1: /* CIL Label */;
11977|      0|        }
11978|      0|        if ((int)*arc == 0) {
11979|      0|          {
11980|      0|            tmp___4 = new_name(directory_name, (char const *)cur);
11981|      0|            p = tmp___4;
11982|      0|          }
11983|      0|          if (!interactive_option) {
11984|      0|            goto _L;
11985|      0|          } else {
11986|      0|            { tmp___11 = confirm("delete", (char const *)p); }
11987|      0|            if (tmp___11) {
11988|      0|            _L:
11989|      0|              if (verbose_option) {
11990|      0|                {
11991|      0|                  tmp___5 = quote((char const *)p);
11992|      0|                  tmp___6 = gettext("%s: Deleting %s\n");
11993|      0|                  fprintf((FILE * /* __restrict  */) stdlis,
11994|      0|                          (char const * /* __restrict  */)tmp___6, program_name,
11995|      0|                          tmp___5);
11996|      0|                }
11997|      0|              }
11998|      0|              {
11999|      0|                tmp___10 =
12000|      0|                    remove_any_file((char const *)p, (enum remove_option)1);
12001|      0|              }
12002|      0|              if (!tmp___10) {
12003|      0|                {
12004|      0|                  tmp___7 = __errno_location();
12005|      0|                  e = *tmp___7;
12006|      0|                  tmp___8 = quotearg_colon((char const *)p);
12007|      0|                  tmp___9 = gettext("%s: Cannot remove");
12008|      0|                  error(0, e, (char const *)tmp___9, tmp___8);
12009|      0|                  exit_status = 2;
12010|      0|                }
12011|      0|              }
12012|      0|            }
12013|      0|          }
12014|      0|          { free((void *)p); }
12015|      0|        }
12016|      0|        {
12017|      0|          tmp___1 = strlen((char const *)cur);
12018|      0|          cur += tmp___1 + 1UL;
12019|      0|        }
12020|      0|      }
12021|      0|    while_break___0: /* CIL Label */;
12022|      0|    }
12023|      0|    {
12024|      0|      free((void *)current_dir);
12025|      0|      free((void *)archive_dir);
12026|      0|    }
12027|      0|    return;
12028|      0|  }
12029|      0|}
12030|       |/* #pragma merger("0","007.list.o.i","") */
12031|       |extern __attribute__((__nothrow__)) unsigned long long(__attribute__((__leaf__))
12032|       |                                                       gnu_dev_makedev)(
12033|       |    unsigned int __major, unsigned int __minor) __attribute__((__const__));
12034|       |extern int putc_unlocked(int __c, FILE *__stream);
12035|       |extern size_t fwrite_unlocked(void const *__restrict __ptr, size_t __size,
12036|       |                              size_t __n, FILE *__restrict __stream);
12037|       |extern __attribute__((__nothrow__)) struct tm *(__attribute__((__leaf__))
12038|       |                                                gmtime)(time_t const *__timer);
12039|       |extern
12040|       |    __attribute__((__nothrow__)) struct tm *(__attribute__((__leaf__))
12041|       |                                             localtime)(time_t const *__timer);
12042|       |struct quoting_options *clone_quoting_options(struct quoting_options *o___0);
12043|       |void set_quoting_style(struct quoting_options *o___0, enum quoting_style s);
12044|       |size_t quotearg_buffer(char *buffer___2, size_t buffersize, char const *arg,
12045|       |                       size_t argsize, struct quoting_options const *o___0);
12046|       |char *quotearg(char const *arg);
12047|       |_Bool utc_option;
12048|       |_Bool block_number_option;
12049|       |_Bool show_omitted_dirs_option;
12050|       |gid_t gid_from_header(char const *p, size_t s);
12051|       |int major_from_header(char const *p, size_t s);
12052|       |int minor_from_header(char const *p, size_t s);
12053|       |mode_t mode_from_header(char const *p, size_t s);
12054|       |size_t size_from_header(char const *p, size_t s);
12055|       |time_t time_from_header(char const *p, size_t s);
12056|       |uid_t uid_from_header(char const *p, size_t s);
12057|       |void list_archive(void);
12058|       |void read_and(void (*do_something)(void));
12059|       |void decode_mode(mode_t mode, char *string);
12060|       |int name_match(char const *path);
12061|       |_Bool all_names_found(struct tar_stat_info *p);
12062|       |_Bool sparse_fixup_header(struct tar_stat_info *st);
12063|       |enum dump_status sparse_skip_file(struct tar_stat_info *st);
12064|       |static uintmax_t from_header(char const *where0, size_t digs, char const *type,
12065|       |                             uintmax_t minus_minval, uintmax_t maxval);
12066|       |static char const base_64_digits[64] = {
12067|       |    (char const)'A', (char const)'B', (char const)'C', (char const)'D',
12068|       |    (char const)'E', (char const)'F', (char const)'G', (char const)'H',
12069|       |    (char const)'I', (char const)'J', (char const)'K', (char const)'L',
12070|       |    (char const)'M', (char const)'N', (char const)'O', (char const)'P',
12071|       |    (char const)'Q', (char const)'R', (char const)'S', (char const)'T',
12072|       |    (char const)'U', (char const)'V', (char const)'W', (char const)'X',
12073|       |    (char const)'Y', (char const)'Z', (char const)'a', (char const)'b',
12074|       |    (char const)'c', (char const)'d', (char const)'e', (char const)'f',
12075|       |    (char const)'g', (char const)'h', (char const)'i', (char const)'j',
12076|       |    (char const)'k', (char const)'l', (char const)'m', (char const)'n',
12077|       |    (char const)'o', (char const)'p', (char const)'q', (char const)'r',
12078|       |    (char const)'s', (char const)'t', (char const)'u', (char const)'v',
12079|       |    (char const)'w', (char const)'x', (char const)'y', (char const)'z',
12080|       |    (char const)'0', (char const)'1', (char const)'2', (char const)'3',
12081|       |    (char const)'4', (char const)'5', (char const)'6', (char const)'7',
12082|       |    (char const)'8', (char const)'9', (char const)'+', (char const)'/'};
12083|       |static char base64_map[256];
12084|      0|static void base64_init(void) {
12085|      0|  int i;
12086|       |
12087|      0|  {
12088|      0|    {
12089|      0|      memset((void *)(base64_map), 64, sizeof(base64_map));
12090|      0|      i = 0;
12091|      0|    }
12092|      0|    {
12093|      0|      while (1) {
12094|      0|      while_continue: /* CIL Label */;
12095|      0|        if (!(i < 64)) {
12096|      0|          goto while_break;
12097|      0|        }
12098|      0|        base64_map[(int)base_64_digits[i]] = (char)i;
12099|      0|        i++;
12100|      0|      }
12101|      0|    while_break: /* CIL Label */;
12102|      0|    }
12103|      0|    return;
12104|      0|  }
12105|      0|}
12106|      0|void read_and(void (*do_something)(void)) {
12107|      0|  enum read_header status;
12108|      0|  enum read_header prev_status;
12109|      0|  char *tmp;
12110|      0|  char *tmp___0;
12111|      0|  int tmp___1;
12112|      0|  _Bool tmp___2;
12113|      0|  char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
12114|      0|  off_t tmp___3;
12115|      0|  char *tmp___4;
12116|      0|  char *tmp___5;
12117|      0|  char buf___0[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
12118|      0|  off_t tmp___6;
12119|      0|  char *tmp___7;
12120|      0|  char *tmp___8;
12121|      0|  char buf___1[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
12122|      0|  off_t tmp___9;
12123|      0|  char *tmp___10;
12124|      0|  char *tmp___11;
12125|      0|  char *tmp___12;
12126|      0|  char buf___2[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
12127|      0|  off_t block_ordinal;
12128|      0|  off_t tmp___13;
12129|      0|  char *tmp___14;
12130|      0|  char *tmp___15;
12131|      0|  char *tmp___16;
12132|      0|  _Bool tmp___17;
12133|      0|  void *__cil_tmp28;
12134|      0|  void *__cil_tmp29;
12135|      0|  void *__cil_tmp30;
12136|      0|  void *__cil_tmp31;
12137|      0|  char *__cil_tmp32;
12138|      0|  char *__cil_tmp33;
12139|      0|  char *__cil_tmp34;
12140|      0|  char *__cil_tmp35;
12141|      0|  char *__cil_tmp36;
12142|      0|  char *__cil_tmp37;
12143|      0|  char *__cil_tmp38;
12144|       |
12145|      0|  {
12146|      0|    {
12147|      0|      status = (enum read_header)0;
12148|      0|      base64_init();
12149|      0|      name_gather();
12150|      0|      open_archive((enum access_mode)0);
12151|      0|    }
12152|      0|    {
12153|      0|      while (1) {
12154|      0|      while_continue: /* CIL Label */;
12155|      0|        {
12156|      0|          prev_status = status;
12157|      0|          tar_stat_destroy(&current_stat_info);
12158|      0|          xheader_destroy(&extended_header);
12159|      0|          status = read_header((_Bool)0);
12160|      0|        }
12161|      0|        {
12162|      0|          if ((unsigned int)status == 0U) {
12163|      0|            goto case_0;
12164|      0|          }
12165|      0|          if ((unsigned int)status == 2U) {
12166|      0|            goto case_0;
12167|      0|          }
12168|      0|          if ((unsigned int)status == 1U) {
12169|      0|            goto case_1;
12170|      0|          }
12171|      0|          if ((unsigned int)status == 3U) {
12172|      0|            goto case_3;
12173|      0|          }
12174|      0|          if ((unsigned int)status == 4U) {
12175|      0|            goto case_4;
12176|      0|          }
12177|      0|          if ((unsigned int)status == 5U) {
12178|      0|            goto case_5;
12179|      0|          }
12180|      0|          goto switch_break;
12181|      0|        case_0:  /* CIL Label */
12182|      0|        case_2 : /* CIL Label */
12183|      0|        {
12184|      0|          abort();
12185|      0|        }
12186|      0|        case_1 : /* CIL Label */
12187|      0|        {
12188|      0|          tmp___1 = name_match((char const *)current_stat_info.file_name);
12189|      0|        }
12190|      0|          if (tmp___1) {
12191|      0|            if (0L <= newer_mtime_option.tv_nsec) {
12192|      0|              {
12193|      0|                current_stat_info.stat.st_mtim.tv_sec = time_from_header(
12194|      0|                    (char const *)(current_header->header.mtime),
12195|      0|                    sizeof(current_header->header.mtime));
12196|      0|                current_stat_info.stat.st_mtim.tv_nsec = (__syscall_slong_t)0;
12197|      0|              }
12198|      0|              if (current_stat_info.stat.st_mtim.tv_sec <
12199|      0|                  newer_mtime_option.tv_sec) {
12200|      0|                goto _L;
12201|      0|              } else {
12202|      0|                if (current_stat_info.stat.st_mtim.tv_sec ==
12203|      0|                    newer_mtime_option.tv_sec) {
12204|      0|                  if (current_stat_info.stat.st_mtim.tv_nsec <
12205|      0|                      newer_mtime_option.tv_nsec) {
12206|      0|                    goto _L;
12207|      0|                  } else {
12208|      0|                    goto _L___0;
12209|      0|                  }
12210|      0|                } else {
12211|      0|                  goto _L___0;
12212|      0|                }
12213|      0|              }
12214|      0|            } else {
12215|      0|            _L___0 : {
12216|      0|              tmp___2 =
12217|      0|                  excluded_name((char const *)current_stat_info.file_name);
12218|      0|            }
12219|      0|              if (tmp___2) {
12220|      0|              _L : {
12221|      0|                if ((int)current_header->header.typeflag == 86) {
12222|      0|                  goto case_86;
12223|      0|                }
12224|      0|                if ((int)current_header->header.typeflag == 77) {
12225|      0|                  goto case_86;
12226|      0|                }
12227|      0|                if ((int)current_header->header.typeflag == 78) {
12228|      0|                  goto case_86;
12229|      0|                }
12230|      0|                if ((int)current_header->header.typeflag == 53) {
12231|      0|                  goto case_53;
12232|      0|                }
12233|      0|                goto switch_default;
12234|      0|              case_86: /* CIL Label */
12235|      0|              case_77: /* CIL Label */
12236|      0|              case_78: /* CIL Label */
12237|      0|                goto switch_break___0;
12238|      0|              case_53: /* CIL Label */
12239|      0|                if (show_omitted_dirs_option) {
12240|      0|                  {
12241|      0|                    tmp = quotearg_colon(
12242|      0|                        (char const *)current_stat_info.file_name);
12243|      0|                    tmp___0 = gettext("%s: Omitting");
12244|      0|                    error(0, 0, (char const *)tmp___0, tmp);
12245|      0|                  }
12246|      0|                }
12247|      0|              switch_default : /* CIL Label */
12248|      0|              {
12249|      0|                skip_member();
12250|      0|              }
12251|      0|                goto __Cont;
12252|      0|              switch_break___0: /* CIL Label */;
12253|      0|              }
12254|      0|              }
12255|      0|            }
12256|      0|          } else {
12257|      0|            goto _L;
12258|      0|          }
12259|      0|          { (*do_something)(); }
12260|      0|          goto __Cont;
12261|      0|        case_3: /* CIL Label */
12262|      0|          if (block_number_option) {
12263|      0|            {
12264|      0|              tmp___3 = current_block_ordinal();
12265|      0|              tmp___4 = stringify_uintmax_t_backwards(
12266|      0|                  (uintmax_t)tmp___3,
12267|      0|                  buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
12268|      0|                         1UL));
12269|      0|              tmp___5 = gettext("block %s: ** Block of NULs **\n");
12270|      0|              fprintf((FILE * /* __restrict  */) stdlis,
12271|      0|                      (char const * /* __restrict  */)tmp___5, tmp___4);
12272|      0|            }
12273|      0|          }
12274|      0|          { set_next_block_after(current_header); }
12275|      0|          if (!ignore_zeros_option) {
12276|      0|            {
12277|      0|              status = read_header((_Bool)0);
12278|      0|            }
12279|      0|            if ((unsigned int)status == 3U) {
12280|      0|              goto switch_break;
12281|      0|            }
12282|      0|            {
12283|      0|              tmp___6 = current_block_ordinal();
12284|      0|              tmp___7 = stringify_uintmax_t_backwards(
12285|      0|                  (uintmax_t)tmp___6,
12286|      0|                  buf___0 +
12287|      0|                      ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
12288|      0|                       1UL));
12289|      0|              tmp___8 = gettext("A lone zero block at %s");
12290|      0|              error(0, 0, (char const *)tmp___8, tmp___7);
12291|      0|            }
12292|      0|            goto switch_break;
12293|      0|          }
12294|      0|          status = prev_status;
12295|      0|          goto __Cont;
12296|      0|        case_4: /* CIL Label */
12297|      0|          if (block_number_option) {
12298|      0|            {
12299|      0|              tmp___9 = current_block_ordinal();
12300|      0|              tmp___10 = stringify_uintmax_t_backwards(
12301|      0|                  (uintmax_t)tmp___9,
12302|      0|                  buf___1 +
12303|      0|                      ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
12304|      0|                       1UL));
12305|      0|              tmp___11 = gettext("block %s: ** End of File **\n");
12306|      0|              fprintf((FILE * /* __restrict  */) stdlis,
12307|      0|                      (char const * /* __restrict  */)tmp___11, tmp___10);
12308|      0|            }
12309|      0|          }
12310|      0|          goto switch_break;
12311|      0|        case_5 : /* CIL Label */
12312|      0|        {
12313|      0|          set_next_block_after(current_header);
12314|      0|        }
12315|      0|          {
12316|      0|            if ((unsigned int)prev_status == 0U) {
12317|      0|              goto case_0___0;
12318|      0|            }
12319|      0|            if ((unsigned int)prev_status == 3U) {
12320|      0|              goto case_3___0;
12321|      0|            }
12322|      0|            if ((unsigned int)prev_status == 1U) {
12323|      0|              goto case_3___0;
12324|      0|            }
12325|      0|            if ((unsigned int)prev_status == 4U) {
12326|      0|              goto case_4___0;
12327|      0|            }
12328|      0|            if ((unsigned int)prev_status == 5U) {
12329|      0|              goto case_4___0;
12330|      0|            }
12331|      0|            if ((unsigned int)prev_status == 2U) {
12332|      0|              goto case_2___0;
12333|      0|            }
12334|      0|            goto switch_break___1;
12335|      0|          case_0___0 : /* CIL Label */
12336|      0|          {
12337|      0|            tmp___12 = gettext("This does not look like a tar archive");
12338|      0|            error(0, 0, (char const *)tmp___12);
12339|      0|            exit_status = 2;
12340|      0|          }
12341|      0|          case_3___0: /* CIL Label */
12342|      0|          case_1___0: /* CIL Label */
12343|      0|            if (block_number_option) {
12344|      0|              {
12345|      0|                tmp___13 = current_block_ordinal();
12346|      0|                block_ordinal = tmp___13;
12347|      0|                block_ordinal =
12348|      0|                    (off_t)((size_t)block_ordinal - recent_long_name_blocks);
12349|      0|                block_ordinal =
12350|      0|                    (off_t)((size_t)block_ordinal - recent_long_link_blocks);
12351|      0|                tmp___14 = stringify_uintmax_t_backwards(
12352|      0|                    (uintmax_t)block_ordinal,
12353|      0|                    buf___2 +
12354|      0|                        ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
12355|      0|                         1UL));
12356|      0|                tmp___15 = gettext("block %s: ");
12357|      0|                fprintf((FILE * /* __restrict  */) stdlis,
12358|      0|                        (char const * /* __restrict  */)tmp___15, tmp___14);
12359|      0|              }
12360|      0|            }
12361|      0|            {
12362|      0|              tmp___16 = gettext("Skipping to next header");
12363|      0|              error(0, 0, (char const *)tmp___16);
12364|      0|              exit_status = 2;
12365|      0|            }
12366|      0|            goto switch_break___1;
12367|      0|          case_4___0: /* CIL Label */
12368|      0|          case_5___0: /* CIL Label */
12369|      0|            goto switch_break___1;
12370|      0|          case_2___0 : /* CIL Label */
12371|      0|          {
12372|      0|            abort();
12373|      0|          }
12374|      0|          switch_break___1: /* CIL Label */;
12375|      0|          }
12376|      0|          goto __Cont;
12377|      0|        switch_break: /* CIL Label */;
12378|      0|        }
12379|      0|        goto while_break;
12380|      0|      __Cont : { tmp___17 = all_names_found(&current_stat_info); }
12381|      0|        if (tmp___17) {
12382|      0|          goto while_break;
12383|      0|        }
12384|      0|      }
12385|      0|    while_break: /* CIL Label */;
12386|      0|    }
12387|      0|    {
12388|      0|      close_archive();
12389|      0|      names_notfound();
12390|      0|    }
12391|      0|    return;
12392|      0|  }
12393|      0|}
12394|      0|void list_archive(void) {
12395|      0|  off_t size;
12396|      0|  size_t written;
12397|      0|  size_t check;
12398|      0|  union block *data_block;
12399|      0|  char *tmp;
12400|      0|  int *tmp___0;
12401|      0|  char *__cil_tmp7;
12402|       |
12403|      0|  {
12404|      0|    { decode_header(current_header, &current_stat_info, &current_format, 0); }
12405|      0|    if (verbose_option) {
12406|      0|      {
12407|      0|        print_header(&current_stat_info, (off_t)-1);
12408|      0|      }
12409|      0|    }
12410|      0|    if (incremental_option) {
12411|      0|      if ((int)current_header->header.typeflag == 68) {
12412|      0|        {
12413|      0|          set_next_block_after(current_header);
12414|      0|        }
12415|      0|        if (multi_volume_option) {
12416|      0|          {
12417|      0|            assign_string(&save_name,
12418|      0|                          (char const *)current_stat_info.file_name);
12419|      0|            save_totsize = current_stat_info.stat.st_size;
12420|      0|          }
12421|      0|        }
12422|      0|        size = current_stat_info.stat.st_size;
12423|      0|        {
12424|      0|          while (1) {
12425|      0|          while_continue: /* CIL Label */;
12426|      0|            if (!(size > 0L)) {
12427|      0|              goto while_break;
12428|      0|            }
12429|      0|            if (multi_volume_option) {
12430|      0|              save_sizeleft = size;
12431|      0|            }
12432|      0|            { data_block = find_next_block(); }
12433|      0|            if (!data_block) {
12434|      0|              {
12435|      0|                tmp = gettext("Unexpected EOF in archive");
12436|      0|                error(0, 0, (char const *)tmp);
12437|      0|                exit_status = 2;
12438|      0|              }
12439|      0|              goto while_break;
12440|      0|            }
12441|      0|            { written = available_space_after(data_block); }
12442|      0|            if (written > (size_t)size) {
12443|      0|              written = (size_t)size;
12444|      0|            }
12445|      0|            {
12446|      0|              tmp___0 = __errno_location();
12447|      0|              *tmp___0 = 0;
12448|      0|              check = fwrite_unlocked(
12449|      0|                  (void const * /* __restrict  */)(data_block->buffer),
12450|      0|                  sizeof(char), written, (FILE * /* __restrict  */) stdlis);
12451|      0|              set_next_block_after(
12452|      0|                  (union block *)((data_block->buffer + written) - 1));
12453|      0|            }
12454|      0|            if (check != written) {
12455|      0|              {
12456|      0|                write_error_details((char const *)current_stat_info.file_name,
12457|      0|                                    check, written);
12458|      0|                skip_file((off_t)((size_t)size - written));
12459|      0|              }
12460|      0|              goto while_break;
12461|      0|            }
12462|      0|            size = (off_t)((size_t)size - written);
12463|      0|          }
12464|      0|        while_break: /* CIL Label */;
12465|      0|        }
12466|      0|        if (multi_volume_option) {
12467|      0|          {
12468|      0|            assign_string(&save_name, (char const *)0);
12469|      0|          }
12470|      0|        }
12471|      0|        {
12472|      0|          fputc_unlocked('\n', stdlis);
12473|      0|          fflush_unlocked(stdlis);
12474|      0|        }
12475|      0|        return;
12476|      0|      }
12477|      0|    }
12478|      0|    if (multi_volume_option) {
12479|      0|      {
12480|      0|        assign_string(&save_name, (char const *)current_stat_info.file_name);
12481|      0|      }
12482|      0|    }
12483|      0|    { skip_member(); }
12484|      0|    if (multi_volume_option) {
12485|      0|      {
12486|      0|        assign_string(&save_name, (char const *)0);
12487|      0|      }
12488|      0|    }
12489|      0|    return;
12490|      0|  }
12491|      0|}
12492|      0|enum read_header read_header(_Bool raw_extended_headers) {
12493|      0|  size_t i;
12494|      0|  int unsigned_sum;
12495|      0|  int signed_sum;
12496|      0|  int recorded_sum;
12497|      0|  uintmax_t parsed_sum;
12498|      0|  char *p;
12499|      0|  union block *header;
12500|      0|  union block *header_copy;
12501|      0|  char *bp;
12502|      0|  union block *data_block;
12503|      0|  size_t size;
12504|      0|  size_t written;
12505|      0|  union block *next_long_name;
12506|      0|  union block *next_long_link;
12507|      0|  size_t next_long_name_blocks;
12508|      0|  size_t next_long_link_blocks;
12509|      0|  char *tmp;
12510|      0|  size_t tmp___0;
12511|      0|  size_t tmp___1;
12512|      0|  size_t name_size;
12513|      0|  void *tmp___2;
12514|      0|  char *tmp___3;
12515|      0|  off_t tmp___4;
12516|      0|  off_t tmp___5;
12517|      0|  char const *name;
12518|      0|  struct posix_header const *h;
12519|      0|  char namebuf[((sizeof(h->prefix) + 1UL) + 100UL) + 1UL];
12520|      0|  char *np;
12521|      0|  size_t tmp___6;
12522|      0|  char *tmp___7;
12523|      0|  int tmp___8;
12524|      0|  void *__cil_tmp33;
12525|      0|  char *__cil_tmp34;
12526|       |
12527|      0|  {
12528|      0|    next_long_name = (union block *)0;
12529|      0|    next_long_link = (union block *)0;
12530|      0|    {
12531|      0|      while (1) {
12532|      0|      while_continue: /* CIL Label */;
12533|      0|        {
12534|      0|          header = find_next_block();
12535|      0|          current_header = header;
12536|      0|        }
12537|      0|        if (!header) {
12538|      0|          return ((enum read_header)4);
12539|      0|        }
12540|      0|        unsigned_sum = 0;
12541|      0|        signed_sum = 0;
12542|      0|        p = header->buffer;
12543|      0|        i = sizeof(*header);
12544|      0|        {
12545|      0|          while (1) {
12546|      0|          while_continue___0: /* CIL Label */;
12547|      0|            tmp___0 = i;
12548|      0|            i--;
12549|      0|            if (!(tmp___0 != 0UL)) {
12550|      0|              goto while_break___0;
12551|      0|            }
12552|      0|            unsigned_sum += (int)((unsigned char)*p);
12553|      0|            tmp = p;
12554|      0|            p++;
12555|      0|            signed_sum += (int)((signed char)*tmp);
12556|      0|          }
12557|      0|        while_break___0: /* CIL Label */;
12558|      0|        }
12559|      0|        if (unsigned_sum == 0) {
12560|      0|          return ((enum read_header)3);
12561|      0|        }
12562|      0|        i = sizeof(header->header.chksum);
12563|      0|        {
12564|      0|          while (1) {
12565|      0|          while_continue___1: /* CIL Label */;
12566|      0|            tmp___1 = i;
12567|      0|            i--;
12568|      0|            if (!(tmp___1 != 0UL)) {
12569|      0|              goto while_break___1;
12570|      0|            }
12571|      0|            unsigned_sum -= (int)((unsigned char)header->header.chksum[i]);
12572|      0|            signed_sum -= (int)((signed char)header->header.chksum[i]);
12573|      0|          }
12574|      0|        while_break___1: /* CIL Label */;
12575|      0|        }
12576|      0|        {
12577|      0|          unsigned_sum = (int)((unsigned long)unsigned_sum +
12578|      0|                               32UL * sizeof(header->header.chksum));
12579|      0|          signed_sum = (int)((unsigned long)signed_sum +
12580|      0|                             32UL * sizeof(header->header.chksum));
12581|      0|          parsed_sum = from_header(
12582|      0|              (char const *)(header->header.chksum),
12583|      0|              sizeof(header->header.chksum), (char const *)0, (uintmax_t)0,
12584|      0|              (uintmax_t)(-1 - (-1 << (sizeof(int) * 8UL - 1UL))));
12585|      0|        }
12586|      0|        if (parsed_sum == 0xffffffffffffffffUL) {
12587|      0|          return ((enum read_header)5);
12588|      0|        }
12589|      0|        recorded_sum = (int)parsed_sum;
12590|      0|        if (unsigned_sum != recorded_sum) {
12591|      0|          if (signed_sum != recorded_sum) {
12592|      0|            return ((enum read_header)5);
12593|      0|          }
12594|      0|        }
12595|      0|        if ((int)header->header.typeflag == 49) {
12596|      0|          current_stat_info.stat.st_size = (__off_t)0;
12597|      0|        } else {
12598|      0|          {
12599|      0|            current_stat_info.stat.st_size =
12600|      0|                off_from_header((char const *)(header->header.size),
12601|      0|                                sizeof(header->header.size));
12602|      0|          }
12603|      0|        }
12604|      0|        if ((int)header->header.typeflag == 76) {
12605|      0|          goto _L___4;
12606|      0|        } else {
12607|      0|          if ((int)header->header.typeflag == 75) {
12608|      0|            goto _L___4;
12609|      0|          } else {
12610|      0|            if ((int)header->header.typeflag == 120) {
12611|      0|              goto _L___4;
12612|      0|            } else {
12613|      0|              if ((int)header->header.typeflag == 103) {
12614|      0|              _L___4: /* CIL Label */
12615|      0|                if (raw_extended_headers) {
12616|      0|                  return ((enum read_header)2);
12617|      0|                } else {
12618|      0|                  if ((int)header->header.typeflag == 76) {
12619|      0|                    goto _L___3;
12620|      0|                  } else {
12621|      0|                    if ((int)header->header.typeflag == 75) {
12622|      0|                    _L___3: /* CIL Label */
12623|      0|                      name_size = (size_t)current_stat_info.stat.st_size;
12624|      0|                      size = (name_size - name_size % 512UL) + 1024UL;
12625|      0|                      if (name_size != (size_t)current_stat_info.stat.st_size) {
12626|      0|                        {
12627|      0|                          xalloc_die();
12628|      0|                        }
12629|      0|                      } else {
12630|      0|                        if (size < name_size) {
12631|      0|                          {
12632|      0|                            xalloc_die();
12633|      0|                          }
12634|      0|                        }
12635|      0|                      }
12636|      0|                      {
12637|      0|                        tmp___2 = xmalloc(size + 1UL);
12638|      0|                        header_copy = (union block *)tmp___2;
12639|      0|                      }
12640|      0|                      if ((int)header->header.typeflag == 76) {
12641|      0|                        if (next_long_name) {
12642|      0|                          {
12643|      0|                            free((void *)next_long_name);
12644|      0|                          }
12645|      0|                        }
12646|      0|                        next_long_name = header_copy;
12647|      0|                        next_long_name_blocks = size / 512UL;
12648|      0|                      } else {
12649|      0|                        if (next_long_link) {
12650|      0|                          {
12651|      0|                            free((void *)next_long_link);
12652|      0|                          }
12653|      0|                        }
12654|      0|                        next_long_link = header_copy;
12655|      0|                        next_long_link_blocks = size / 512UL;
12656|      0|                      }
12657|      0|                      {
12658|      0|                        set_next_block_after(header);
12659|      0|                        *header_copy = *header;
12660|      0|                        bp = header_copy->buffer + 512;
12661|      0|                        size -= 512UL;
12662|      0|                      }
12663|      0|                      {
12664|      0|                        while (1) {
12665|      0|                        while_continue___2: /* CIL Label */;
12666|      0|                          if (!(size > 0UL)) {
12667|      0|                            goto while_break___2;
12668|      0|                          }
12669|      0|                          { data_block = find_next_block(); }
12670|      0|                          if (!data_block) {
12671|      0|                            {
12672|      0|                              tmp___3 = gettext("Unexpected EOF in archive");
12673|      0|                              error(0, 0, (char const *)tmp___3);
12674|      0|                              exit_status = 2;
12675|      0|                            }
12676|      0|                            goto while_break___2;
12677|      0|                          }
12678|      0|                          { written = available_space_after(data_block); }
12679|      0|                          if (written > size) {
12680|      0|                            written = size;
12681|      0|                          }
12682|      0|                          {
12683|      0|                            memcpy((void * /* __restrict  */)bp,
12684|      0|                                   (void const * /* __restrict  */)(
12685|      0|                                       data_block->buffer),
12686|      0|                                   written);
12687|      0|                            bp += written;
12688|      0|                            set_next_block_after(
12689|      0|                                (union block *)((data_block->buffer + written) -
12690|      0|                                                1));
12691|      0|                            size -= written;
12692|      0|                          }
12693|      0|                        }
12694|      0|                      while_break___2: /* CIL Label */;
12695|      0|                      }
12696|      0|                      *bp = (char)'\000';
12697|      0|                    } else {
12698|      0|                      if ((int)header->header.typeflag == 120) {
12699|      0|                        {
12700|      0|                          tmp___4 = off_from_header(
12701|      0|                              (char const *)(header->header.size),
12702|      0|                              sizeof(header->header.size));
12703|      0|                          xheader_read(header, (size_t)tmp___4);
12704|      0|                        }
12705|      0|                      } else {
12706|      0|                        if ((int)header->header.typeflag == 103) {
12707|      0|                          {
12708|      0|                            tmp___5 = off_from_header(
12709|      0|                                (char const *)(header->header.size),
12710|      0|                                sizeof(header->header.size));
12711|      0|                            xheader_read(header, (size_t)tmp___5);
12712|      0|                            xheader_decode_global();
12713|      0|                          }
12714|      0|                        }
12715|      0|                      }
12716|      0|                    }
12717|      0|                  }
12718|      0|                }
12719|      0|              } else {
12720|      0|                h = (struct posix_header const *)(&current_header->header);
12721|      0|                if (recent_long_name) {
12722|      0|                  {
12723|      0|                    free((void *)recent_long_name);
12724|      0|                  }
12725|      0|                }
12726|      0|                if (next_long_name) {
12727|      0|                  name = (char const *)(next_long_name->buffer + 512);
12728|      0|                  recent_long_name = next_long_name;
12729|      0|                  recent_long_name_blocks = next_long_name_blocks;
12730|      0|                } else {
12731|      0|                  np = namebuf;
12732|      0|                  if (h->prefix[0]) {
12733|      0|                    {
12734|      0|                      tmp___8 = strcmp((char const *)(h->magic), "ustar");
12735|      0|                    }
12736|      0|                    if (tmp___8 == 0) {
12737|      0|                      {
12738|      0|                        memcpy((void * /* __restrict  */)np,
12739|      0|                               (void const * /* __restrict  */)(h->prefix),
12740|      0|                               sizeof(h->prefix));
12741|      0|                        *(np + sizeof(h->prefix)) = (char)'\000';
12742|      0|                        tmp___6 = strlen((char const *)np);
12743|      0|                        np += tmp___6;
12744|      0|                        tmp___7 = np;
12745|      0|                        np++;
12746|      0|                        *tmp___7 = (char)'/';
12747|      0|                        current_header->oldgnu_header.isextended = (char)0;
12748|      0|                      }
12749|      0|                    }
12750|      0|                  }
12751|      0|                  {
12752|      0|                    memcpy((void * /* __restrict  */)np,
12753|      0|                           (void const * /* __restrict  */)(h->name),
12754|      0|                           sizeof(h->name));
12755|      0|                    *(np + sizeof(h->name)) = (char)'\000';
12756|      0|                    name = (char const *)(namebuf);
12757|      0|                    recent_long_name = (union block *)0;
12758|      0|                    recent_long_name_blocks = (size_t)0;
12759|      0|                  }
12760|      0|                }
12761|      0|                {
12762|      0|                  assign_string(&current_stat_info.orig_file_name, name);
12763|      0|                  assign_string(&current_stat_info.file_name, name);
12764|      0|                  current_stat_info.had_trailing_slash =
12765|      0|                      strip_trailing_slashes(current_stat_info.file_name);
12766|      0|                }
12767|      0|                if (recent_long_link) {
12768|      0|                  {
12769|      0|                    free((void *)recent_long_link);
12770|      0|                  }
12771|      0|                }
12772|      0|                if (next_long_link) {
12773|      0|                  name = (char const *)(next_long_link->buffer + 512);
12774|      0|                  recent_long_link = next_long_link;
12775|      0|                  recent_long_link_blocks = next_long_link_blocks;
12776|      0|                } else {
12777|      0|                  {
12778|      0|                    memcpy((void * /* __restrict  */)(namebuf),
12779|      0|                           (void const * /* __restrict  */)(h->linkname),
12780|      0|                           sizeof(h->linkname));
12781|      0|                    namebuf[sizeof(h->linkname)] = (char)'\000';
12782|      0|                    name = (char const *)(namebuf);
12783|      0|                    recent_long_link = (union block *)0;
12784|      0|                    recent_long_link_blocks = (size_t)0;
12785|      0|                  }
12786|      0|                }
12787|      0|                { assign_string(&current_stat_info.link_name, name); }
12788|      0|                return ((enum read_header)1);
12789|      0|              }
12790|      0|            }
12791|      0|          }
12792|      0|        }
12793|      0|      }
12794|      0|    while_break: /* CIL Label */;
12795|      0|    }
12796|      0|  }
12797|      0|}
12798|       |void decode_header(union block *header, struct tar_stat_info *stat_info,
12799|      0|                   enum archive_format *format_pointer, int do_user_group) {
12800|      0|  enum archive_format format;
12801|      0|  int tmp;
12802|      0|  int tmp___0;
12803|      0|  int tmp___1;
12804|      0|  int tmp___2;
12805|      0|  int tmp___3;
12806|      0|  int tmp___4;
12807|      0|  unsigned long long tmp___5;
12808|      0|  _Bool tmp___6;
12809|       |
12810|      0|  {
12811|      0|    { tmp___0 = strcmp((char const *)(header->header.magic), "ustar"); }
12812|      0|    if (tmp___0 == 0) {
12813|      0|      if ((int)header->star_header.prefix[130] == 0) {
12814|      0|        if ((int)header->star_header.atime[0] >= 48) {
12815|      0|          if ((int)header->star_header.atime[0] <= 55) {
12816|      0|            if ((int)header->star_header.atime[11] == 32) {
12817|      0|              if ((int)header->star_header.ctime[0] >= 48) {
12818|      0|                if ((int)header->star_header.ctime[0] <= 55) {
12819|      0|                  if ((int)header->star_header.ctime[11] == 32) {
12820|      0|                    format = (enum archive_format)5;
12821|      0|                  } else {
12822|      0|                    goto _L___6;
12823|      0|                  }
12824|      0|                } else {
12825|      0|                  goto _L___6;
12826|      0|                }
12827|      0|              } else {
12828|      0|                goto _L___6;
12829|      0|              }
12830|      0|            } else {
12831|      0|              goto _L___6;
12832|      0|            }
12833|      0|          } else {
12834|      0|            goto _L___6;
12835|      0|          }
12836|      0|        } else {
12837|      0|          goto _L___6;
12838|      0|        }
12839|      0|      } else {
12840|      0|      _L___6: /* CIL Label */
12841|      0|        if (extended_header.size) {
12842|      0|          format = (enum archive_format)4;
12843|      0|        } else {
12844|      0|          format = (enum archive_format)3;
12845|      0|        }
12846|      0|      }
12847|      0|    } else {
12848|      0|      { tmp = strcmp((char const *)(header->header.magic), "ustar  "); }
12849|      0|      if (tmp == 0) {
12850|      0|        format = (enum archive_format)2;
12851|      0|      } else {
12852|      0|        format = (enum archive_format)1;
12853|      0|      }
12854|      0|    }
12855|      0|    {
12856|      0|      *format_pointer = format;
12857|      0|      stat_info->stat.st_mode = mode_from_header(
12858|      0|          (char const *)(header->header.mode), sizeof(header->header.mode));
12859|      0|      stat_info->stat.st_mtim.tv_sec = time_from_header(
12860|      0|          (char const *)(header->header.mtime), sizeof(header->header.mtime));
12861|      0|      assign_string(&stat_info->uname, (char const *)(header->header.uname));
12862|      0|      assign_string(&stat_info->gname, (char const *)(header->header.gname));
12863|      0|      tmp___1 = major_from_header((char const *)(header->header.devmajor),
12864|      0|                                  sizeof(header->header.devmajor));
12865|      0|      stat_info->devmajor = (unsigned int)tmp___1;
12866|      0|      tmp___2 = minor_from_header((char const *)(header->header.devminor),
12867|      0|                                  sizeof(header->header.devminor));
12868|      0|      stat_info->devminor = (unsigned int)tmp___2;
12869|      0|      stat_info->stat.st_atim.tv_sec = start_timespec.tv_sec;
12870|      0|      stat_info->stat.st_ctim.tv_sec = start_timespec.tv_sec;
12871|      0|    }
12872|      0|    if ((unsigned int)format == 2U) {
12873|      0|      if (incremental_option) {
12874|      0|        {
12875|      0|          stat_info->stat.st_atim.tv_sec =
12876|      0|              time_from_header((char const *)(header->oldgnu_header.atime),
12877|      0|                               sizeof(header->oldgnu_header.atime));
12878|      0|          stat_info->stat.st_ctim.tv_sec =
12879|      0|              time_from_header((char const *)(header->oldgnu_header.ctime),
12880|      0|                               sizeof(header->oldgnu_header.ctime));
12881|      0|        }
12882|      0|      }
12883|      0|    }
12884|      0|    if ((unsigned int)format == 1U) {
12885|      0|      {
12886|      0|        stat_info->stat.st_uid = uid_from_header(
12887|      0|            (char const *)(header->header.uid), sizeof(header->header.uid));
12888|      0|        stat_info->stat.st_gid = gid_from_header(
12889|      0|            (char const *)(header->header.gid), sizeof(header->header.gid));
12890|      0|        stat_info->stat.st_rdev = (__dev_t)0;
12891|      0|      }
12892|      0|    } else {
12893|      0|      if ((unsigned int)format == 5U) {
12894|      0|        {
12895|      0|          stat_info->stat.st_atim.tv_sec =
12896|      0|              time_from_header((char const *)(header->star_header.atime),
12897|      0|                               sizeof(header->star_header.atime));
12898|      0|          stat_info->stat.st_ctim.tv_sec =
12899|      0|              time_from_header((char const *)(header->star_header.ctime),
12900|      0|                               sizeof(header->star_header.ctime));
12901|      0|        }
12902|      0|      }
12903|      0|      if (do_user_group) {
12904|      0|        if (numeric_owner_option) {
12905|      0|          {
12906|      0|            stat_info->stat.st_uid = uid_from_header(
12907|      0|                (char const *)(header->header.uid), sizeof(header->header.uid));
12908|      0|          }
12909|      0|        } else {
12910|      0|          if (!header->header.uname[0]) {
12911|      0|            {
12912|      0|              stat_info->stat.st_uid =
12913|      0|                  uid_from_header((char const *)(header->header.uid),
12914|      0|                                  sizeof(header->header.uid));
12915|      0|            }
12916|      0|          } else {
12917|      0|            {
12918|      0|              tmp___3 = uname_to_uid((char const *)(header->header.uname),
12919|      0|                                     &stat_info->stat.st_uid);
12920|      0|            }
12921|      0|            if (!tmp___3) {
12922|      0|              {
12923|      0|                stat_info->stat.st_uid =
12924|      0|                    uid_from_header((char const *)(header->header.uid),
12925|      0|                                    sizeof(header->header.uid));
12926|      0|              }
12927|      0|            }
12928|      0|          }
12929|      0|        }
12930|      0|        if (numeric_owner_option) {
12931|      0|          {
12932|      0|            stat_info->stat.st_gid = gid_from_header(
12933|      0|                (char const *)(header->header.gid), sizeof(header->header.gid));
12934|      0|          }
12935|      0|        } else {
12936|      0|          if (!header->header.gname[0]) {
12937|      0|            {
12938|      0|              stat_info->stat.st_gid =
12939|      0|                  gid_from_header((char const *)(header->header.gid),
12940|      0|                                  sizeof(header->header.gid));
12941|      0|            }
12942|      0|          } else {
12943|      0|            {
12944|      0|              tmp___4 = gname_to_gid((char const *)(header->header.gname),
12945|      0|                                     &stat_info->stat.st_gid);
12946|      0|            }
12947|      0|            if (!tmp___4) {
12948|      0|              {
12949|      0|                stat_info->stat.st_gid =
12950|      0|                    gid_from_header((char const *)(header->header.gid),
12951|      0|                                    sizeof(header->header.gid));
12952|      0|              }
12953|      0|            }
12954|      0|          }
12955|      0|        }
12956|      0|      }
12957|      0|      {
12958|      0|        if ((int)header->header.typeflag == 52) {
12959|      0|          goto case_52;
12960|      0|        }
12961|      0|        if ((int)header->header.typeflag == 51) {
12962|      0|          goto case_52;
12963|      0|        }
12964|      0|        goto switch_default;
12965|      0|      case_52:  /* CIL Label */
12966|      0|      case_51 : /* CIL Label */
12967|      0|      {
12968|      0|        tmp___5 = gnu_dev_makedev(stat_info->devmajor, stat_info->devminor);
12969|      0|        stat_info->stat.st_rdev = (__dev_t)tmp___5;
12970|      0|      }
12971|      0|        goto switch_break;
12972|      0|      switch_default: /* CIL Label */
12973|      0|        stat_info->stat.st_rdev = (__dev_t)0;
12974|      0|      switch_break: /* CIL Label */;
12975|      0|      }
12976|      0|    }
12977|      0|    {
12978|      0|      stat_info->archive_file_size = stat_info->stat.st_size;
12979|      0|      xheader_decode(stat_info);
12980|      0|      tmp___6 = sparse_member_p(stat_info);
12981|      0|    }
12982|      0|    if (tmp___6) {
12983|      0|      {
12984|      0|        sparse_fixup_header(stat_info);
12985|      0|        stat_info->is_sparse = (_Bool)1;
12986|      0|      }
12987|      0|    }
12988|      0|    return;
12989|      0|  }
12990|      0|}
12991|       |static int warned_once___0;
12992|       |static struct quoting_options *o;
12993|       |static uintmax_t from_header(char const *where0, size_t digs, char const *type,
12994|      0|                             uintmax_t minus_minval, uintmax_t maxval) {
12995|      0|  uintmax_t value;
12996|      0|  char const *where;
12997|      0|  char const *lim;
12998|      0|  int negative;
12999|      0|  char *tmp;
13000|      0|  unsigned short const **tmp___0;
13001|      0|  char const *where1;
13002|      0|  uintmax_t overflow;
13003|      0|  char const *tmp___1;
13004|      0|  int digit;
13005|      0|  char *tmp___2;
13006|      0|  char *tmp___3;
13007|      0|  int dig;
13008|      0|  char *tmp___4;
13009|      0|  char const *tmp___5;
13010|      0|  char *string;
13011|      0|  void *tmp___6;
13012|      0|  char const *tmp___7;
13013|      0|  char *tmp___8;
13014|      0|  int signbit;
13015|      0|  uintmax_t topbits;
13016|      0|  char const *tmp___9;
13017|      0|  char const *tmp___10;
13018|      0|  char *tmp___11;
13019|      0|  char buf[1000];
13020|      0|  char *tmp___12;
13021|      0|  unsigned short const **tmp___13;
13022|      0|  char minval_buf[((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL) +
13023|      0|                  1UL];
13024|      0|  char maxval_buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
13025|      0|  char value_buf[((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL) +
13026|      0|                 1UL];
13027|      0|  char *minval_string;
13028|      0|  char *tmp___14;
13029|      0|  char *value_string;
13030|      0|  char *tmp___15;
13031|      0|  char *tmp___16;
13032|      0|  char *tmp___17;
13033|      0|  uintmax_t tmp___18;
13034|      0|  uintmax_t tmp___19;
13035|      0|  void *__cil_tmp44;
13036|      0|  void *__cil_tmp45;
13037|      0|  void *__cil_tmp46;
13038|      0|  void *__cil_tmp47;
13039|      0|  char *__cil_tmp48;
13040|      0|  char *__cil_tmp49;
13041|      0|  char *__cil_tmp50;
13042|      0|  char *__cil_tmp51;
13043|      0|  char *__cil_tmp52;
13044|      0|  char *__cil_tmp53;
13045|      0|  char *__cil_tmp54;
13046|      0|  char *__cil_tmp55;
13047|       |
13048|      0|  {
13049|      0|    where = where0;
13050|      0|    lim = where + digs;
13051|      0|    negative = 0;
13052|      0|    where += !*where;
13053|      0|    {
13054|      0|      while (1) {
13055|      0|      while_continue: /* CIL Label */;
13056|      0|        if ((unsigned long)where == (unsigned long)lim) {
13057|      0|          if (type) {
13058|      0|            {
13059|      0|              tmp = gettext("Blanks in header where numeric %s value expected");
13060|      0|              error(0, 0, (char const *)tmp, type);
13061|      0|              exit_status = 2;
13062|      0|            }
13063|      0|          }
13064|      0|          return ((uintmax_t)-1);
13065|      0|        }
13066|      0|        { tmp___0 = __ctype_b_loc(); }
13067|      0|        if (!((int const) * (*tmp___0 + (int)((unsigned char)*where)) & 8192)) {
13068|      0|          goto while_break;
13069|      0|        }
13070|      0|        where++;
13071|      0|      }
13072|      0|    while_break: /* CIL Label */;
13073|      0|    }
13074|      0|    value = (uintmax_t)0;
13075|      0|    if ((unsigned int)*where - 48U <= 7U) {
13076|      0|      where1 = where;
13077|      0|      overflow = (uintmax_t)0;
13078|      0|      {
13079|      0|        while (1) {
13080|      0|        while_continue___0: /* CIL Label */;
13081|      0|          tmp___1 = where;
13082|      0|          where++;
13083|      0|          value += (uintmax_t)((int const) * tmp___1 - 48);
13084|      0|          if ((unsigned long)where == (unsigned long)lim) {
13085|      0|            goto while_break___0;
13086|      0|          } else {
13087|      0|            if (!((unsigned int)*where - 48U <= 7U)) {
13088|      0|              goto while_break___0;
13089|      0|            }
13090|      0|          }
13091|      0|          overflow |= value ^ ((value << 3) >> 3);
13092|      0|          value <<= 3;
13093|      0|        }
13094|      0|      while_break___0: /* CIL Label */;
13095|      0|      }
13096|      0|      if (overflow) {
13097|      0|        goto _L___3;
13098|      0|      } else {
13099|      0|        if (maxval < value) {
13100|      0|        _L___3: /* CIL Label */
13101|      0|          if (50 <= (int)*where1) {
13102|      0|            if (type) {
13103|      0|              digit = (int)(((int const) * where1 - 48) | 4);
13104|      0|              overflow = (uintmax_t)0;
13105|      0|              value = (uintmax_t)0;
13106|      0|              where = where1;
13107|      0|              {
13108|      0|                while (1) {
13109|      0|                while_continue___1: /* CIL Label */;
13110|      0|                  value += (uintmax_t)(7 - digit);
13111|      0|                  where++;
13112|      0|                  if ((unsigned long)where == (unsigned long)lim) {
13113|      0|                    goto while_break___1;
13114|      0|                  } else {
13115|      0|                    if (!((unsigned int)*where - 48U <= 7U)) {
13116|      0|                      goto while_break___1;
13117|      0|                    }
13118|      0|                  }
13119|      0|                  digit = (int)((int const) * where - 48);
13120|      0|                  overflow |= value ^ ((value << 3) >> 3);
13121|      0|                  value <<= 3;
13122|      0|                }
13123|      0|              while_break___1: /* CIL Label */;
13124|      0|              }
13125|      0|              value++;
13126|      0|              overflow |= (unsigned long)(!value);
13127|      0|              if (!overflow) {
13128|      0|                if (value <= minus_minval) {
13129|      0|                  {
13130|      0|                    tmp___2 = gettext("Archive octal value %.*s is out of %s "
13131|      0|                                      "range; assuming two\'s complement");
13132|      0|                    error(0, 0, (char const *)tmp___2, (int)(where - where1),
13133|      0|                          where1, type);
13134|      0|                    negative = 1;
13135|      0|                  }
13136|      0|                }
13137|      0|              }
13138|      0|            }
13139|      0|          }
13140|      0|        }
13141|      0|      }
13142|      0|      if (overflow) {
13143|      0|        if (type) {
13144|      0|          {
13145|      0|            tmp___3 = gettext("Archive octal value %.*s is out of %s range");
13146|      0|            error(0, 0, (char const *)tmp___3, (int)(where - where1), where1,
13147|      0|                  type);
13148|      0|            exit_status = 2;
13149|      0|          }
13150|      0|        }
13151|      0|        return ((uintmax_t)-1);
13152|      0|      }
13153|      0|    } else {
13154|      0|      if ((int const) * where == 45) {
13155|      0|        goto _L___5;
13156|      0|      } else {
13157|      0|        if ((int const) * where == 43) {
13158|      0|        _L___5: /* CIL Label */
13159|      0|          if (!warned_once___0) {
13160|      0|            {
13161|      0|              warned_once___0 = 1;
13162|      0|              tmp___4 = gettext("Archive contains obsolescent base-64 headers");
13163|      0|              error(0, 0, (char const *)tmp___4);
13164|      0|            }
13165|      0|          }
13166|      0|          tmp___5 = where;
13167|      0|          where++;
13168|      0|          negative = (int const) * tmp___5 == 45;
13169|      0|          {
13170|      0|            while (1) {
13171|      0|            while_continue___2: /* CIL Label */;
13172|      0|              if ((unsigned long)where != (unsigned long)lim) {
13173|      0|                dig = (int)base64_map[(unsigned char)*where];
13174|      0|                if (!(dig < 64)) {
13175|      0|                  goto while_break___2;
13176|      0|                }
13177|      0|              } else {
13178|      0|                goto while_break___2;
13179|      0|              }
13180|      0|              if ((value << 6) >> 6 != value) {
13181|      0|                {
13182|      0|                  tmp___6 = __builtin_alloca(digs + 1UL);
13183|      0|                  string = (char *)tmp___6;
13184|      0|                  memcpy((void * /* __restrict  */)string,
13185|      0|                         (void const * /* __restrict  */)where0, digs);
13186|      0|                  *(string + digs) = (char)'\000';
13187|      0|                }
13188|      0|                if (type) {
13189|      0|                  {
13190|      0|                    tmp___7 = quote((char const *)string);
13191|      0|                    tmp___8 = gettext(
13192|      0|                        "Archive signed base-64 string %s is out of %s range");
13193|      0|                    error(0, 0, (char const *)tmp___8, tmp___7, type);
13194|      0|                    exit_status = 2;
13195|      0|                  }
13196|      0|                }
13197|      0|                return ((uintmax_t)-1);
13198|      0|              }
13199|      0|              value = (value << 6) | (unsigned long)dig;
13200|      0|              where++;
13201|      0|            }
13202|      0|          while_break___2: /* CIL Label */;
13203|      0|          }
13204|      0|        } else {
13205|      0|          if ((int const) * where == -128) {
13206|      0|            goto _L___4;
13207|      0|          } else {
13208|      0|            if ((int const) * where == -1) {
13209|      0|            _L___4: /* CIL Label */
13210|      0|              signbit = (int)((int const) * where & (int const)(1 << 6));
13211|      0|              topbits = (uintmax_t)(-signbit)
13212|      0|                        << ((8UL * sizeof(uintmax_t) - 8UL) - 6UL);
13213|      0|              tmp___9 = where;
13214|      0|              where++;
13215|      0|              value = (uintmax_t)(
13216|      0|                  ((int const) * tmp___9 & (int const)((1 << 6) - 1)) -
13217|      0|                  (int const)signbit);
13218|      0|              {
13219|      0|                while (1) {
13220|      0|                while_continue___3: /* CIL Label */;
13221|      0|                  tmp___10 = where;
13222|      0|                  where++;
13223|      0|                  value = (value << 8) + (uintmax_t)((unsigned char)*tmp___10);
13224|      0|                  if ((unsigned long)where == (unsigned long)lim) {
13225|      0|                    goto while_break___3;
13226|      0|                  }
13227|      0|                  if ((((value << 8) >> 8) | topbits) != value) {
13228|      0|                    if (type) {
13229|      0|                      {
13230|      0|                        tmp___11 = gettext(
13231|      0|                            "Archive base-256 value is out of %s range");
13232|      0|                        error(0, 0, (char const *)tmp___11, type);
13233|      0|                        exit_status = 2;
13234|      0|                      }
13235|      0|                    }
13236|      0|                    return ((uintmax_t)-1);
13237|      0|                  }
13238|      0|                }
13239|      0|              while_break___3: /* CIL Label */;
13240|      0|              }
13241|      0|              negative = signbit;
13242|      0|              if (negative) {
13243|      0|                value = -value;
13244|      0|              }
13245|      0|            }
13246|      0|          }
13247|      0|        }
13248|      0|      }
13249|      0|    }
13250|      0|    if ((unsigned long)where != (unsigned long)lim) {
13251|      0|      if (*where) {
13252|      0|        {
13253|      0|          tmp___13 = __ctype_b_loc();
13254|      0|        }
13255|      0|        if (!((int const) * (*tmp___13 + (int)((unsigned char)*where)) &
13256|      0|              8192)) {
13257|      0|          if (type) {
13258|      0|            if (!o) {
13259|      0|              {
13260|      0|                o = clone_quoting_options((struct quoting_options *)0);
13261|      0|                set_quoting_style(o, (enum quoting_style)5);
13262|      0|              }
13263|      0|            }
13264|      0|            {
13265|      0|              while (1) {
13266|      0|              while_continue___4: /* CIL Label */;
13267|      0|                if ((unsigned long)where0 != (unsigned long)lim) {
13268|      0|                  if (!(!*(lim + -1))) {
13269|      0|                    goto while_break___4;
13270|      0|                  }
13271|      0|                } else {
13272|      0|                  goto while_break___4;
13273|      0|                }
13274|      0|                lim--;
13275|      0|              }
13276|      0|            while_break___4: /* CIL Label */;
13277|      0|            }
13278|      0|            {
13279|      0|              quotearg_buffer(buf, sizeof(buf), where0, (size_t)(lim - where),
13280|      0|                              (struct quoting_options const *)o);
13281|      0|              tmp___12 = gettext(
13282|      0|                  "Archive contains %.*s where numeric %s value expected");
13283|      0|              error(0, 0, (char const *)tmp___12, (int)sizeof(buf), buf, type);
13284|      0|              exit_status = 2;
13285|      0|            }
13286|      0|          }
13287|      0|          return ((uintmax_t)-1);
13288|      0|        }
13289|      0|      }
13290|      0|    }
13291|      0|    if (negative) {
13292|      0|      tmp___19 = minus_minval;
13293|      0|    } else {
13294|      0|      tmp___19 = maxval;
13295|      0|    }
13296|      0|    if (value <= tmp___19) {
13297|      0|      if (negative) {
13298|      0|        tmp___18 = -value;
13299|      0|      } else {
13300|      0|        tmp___18 = value;
13301|      0|      }
13302|      0|      return (tmp___18);
13303|      0|    }
13304|      0|    if (type) {
13305|      0|      {
13306|      0|        tmp___14 = stringify_uintmax_t_backwards(
13307|      0|            minus_minval,
13308|      0|            (minval_buf + 1) +
13309|      0|                ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
13310|      0|        minval_string = tmp___14;
13311|      0|        tmp___15 = stringify_uintmax_t_backwards(
13312|      0|            value,
13313|      0|            (value_buf + 1) +
13314|      0|                ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
13315|      0|        value_string = tmp___15;
13316|      0|      }
13317|      0|      if (negative) {
13318|      0|        value_string--;
13319|      0|        *value_string = (char)'-';
13320|      0|      }
13321|      0|      if (minus_minval) {
13322|      0|        minval_string--;
13323|      0|        *minval_string = (char)'-';
13324|      0|      }
13325|      0|      {
13326|      0|        tmp___16 = stringify_uintmax_t_backwards(
13327|      0|            maxval,
13328|      0|            maxval_buf +
13329|      0|                ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
13330|      0|        tmp___17 = gettext("Archive value %s is out of %s range %s.%s");
13331|      0|        error(0, 0, (char const *)tmp___17, value_string, type, minval_string,
13332|      0|              tmp___16);
13333|      0|        exit_status = 2;
13334|      0|      }
13335|      0|    }
13336|      0|    return ((uintmax_t)-1);
13337|      0|  }
13338|      0|}
13339|      0|gid_t gid_from_header(char const *p, size_t s) {
13340|      0|  uintmax_t tmp;
13341|      0|  char *__cil_tmp4;
13342|       |
13343|      0|  {
13344|      0|    {
13345|      0|      tmp = from_header(p, s, "gid_t", -((uintmax_t)((gid_t)0)),
13346|      0|                        (uintmax_t)4294967295U);
13347|      0|    }
13348|      0|    return ((gid_t)tmp);
13349|      0|  }
13350|      0|}
13351|      0|int major_from_header(char const *p, size_t s) {
13352|      0|  uintmax_t tmp;
13353|      0|  char *__cil_tmp4;
13354|       |
13355|      0|  {
13356|      0|    {
13357|      0|      tmp = from_header(p, s, "major_t",
13358|      0|                        -((uintmax_t)(-1 << (sizeof(int) * 8UL - 1UL))),
13359|      0|                        (uintmax_t)(-1 - (-1 << (sizeof(int) * 8UL - 1UL))));
13360|      0|    }
13361|      0|    return ((int)tmp);
13362|      0|  }
13363|      0|}
13364|      0|int minor_from_header(char const *p, size_t s) {
13365|      0|  uintmax_t tmp;
13366|      0|  char *__cil_tmp4;
13367|       |
13368|      0|  {
13369|      0|    {
13370|      0|      tmp = from_header(p, s, "minor_t",
13371|      0|                        -((uintmax_t)(-1 << (sizeof(int) * 8UL - 1UL))),
13372|      0|                        (uintmax_t)(-1 - (-1 << (sizeof(int) * 8UL - 1UL))));
13373|      0|    }
13374|      0|    return ((int)tmp);
13375|      0|  }
13376|      0|}
13377|      0|mode_t mode_from_header(char const *p, size_t s) {
13378|      0|  unsigned int u;
13379|      0|  uintmax_t tmp;
13380|      0|  int tmp___0;
13381|      0|  int tmp___1;
13382|      0|  int tmp___2;
13383|      0|  int tmp___3;
13384|      0|  int tmp___4;
13385|      0|  int tmp___5;
13386|      0|  int tmp___6;
13387|      0|  int tmp___7;
13388|      0|  int tmp___8;
13389|      0|  int tmp___9;
13390|      0|  int tmp___10;
13391|      0|  int tmp___11;
13392|      0|  char *__cil_tmp17;
13393|       |
13394|      0|  {
13395|      0|    {
13396|      0|      tmp = from_header(p, s, "mode_t", -((uintmax_t)((mode_t)0)),
13397|      0|                        0xffffffffffffffffUL);
13398|      0|      u = (unsigned int)tmp;
13399|      0|    }
13400|      0|    if (u & 2048U) {
13401|      0|      tmp___0 = 2048;
13402|      0|    } else {
13403|      0|      tmp___0 = 0;
13404|      0|    }
13405|      0|    if (u & 1024U) {
13406|      0|      tmp___1 = 1024;
13407|      0|    } else {
13408|      0|      tmp___1 = 0;
13409|      0|    }
13410|      0|    if (u & 512U) {
13411|      0|      tmp___2 = 512;
13412|      0|    } else {
13413|      0|      tmp___2 = 0;
13414|      0|    }
13415|      0|    if (u & 256U) {
13416|      0|      tmp___3 = 256;
13417|      0|    } else {
13418|      0|      tmp___3 = 0;
13419|      0|    }
13420|      0|    if (u & 128U) {
13421|      0|      tmp___4 = 128;
13422|      0|    } else {
13423|      0|      tmp___4 = 0;
13424|      0|    }
13425|      0|    if (u & 64U) {
13426|      0|      tmp___5 = 64;
13427|      0|    } else {
13428|      0|      tmp___5 = 0;
13429|      0|    }
13430|      0|    if (u & 32U) {
13431|      0|      tmp___6 = 256 >> 3;
13432|      0|    } else {
13433|      0|      tmp___6 = 0;
13434|      0|    }
13435|      0|    if (u & 16U) {
13436|      0|      tmp___7 = 128 >> 3;
13437|      0|    } else {
13438|      0|      tmp___7 = 0;
13439|      0|    }
13440|      0|    if (u & 8U) {
13441|      0|      tmp___8 = 64 >> 3;
13442|      0|    } else {
13443|      0|      tmp___8 = 0;
13444|      0|    }
13445|      0|    if (u & 4U) {
13446|      0|      tmp___9 = (256 >> 3) >> 3;
13447|      0|    } else {
13448|      0|      tmp___9 = 0;
13449|      0|    }
13450|      0|    if (u & 2U) {
13451|      0|      tmp___10 = (128 >> 3) >> 3;
13452|      0|    } else {
13453|      0|      tmp___10 = 0;
13454|      0|    }
13455|      0|    if (u & 1U) {
13456|      0|      tmp___11 = (64 >> 3) >> 3;
13457|      0|    } else {
13458|      0|      tmp___11 = 0;
13459|      0|    }
13460|      0|    return (
13461|      0|        (mode_t)(((((((((((tmp___0 | tmp___1) | tmp___2) | tmp___3) | tmp___4) |
13462|      0|                       tmp___5) |
13463|      0|                      tmp___6) |
13464|      0|                     tmp___7) |
13465|      0|                    tmp___8) |
13466|      0|                   tmp___9) |
13467|      0|                  tmp___10) |
13468|      0|                 tmp___11));
13469|      0|  }
13470|      0|}
13471|      0|off_t off_from_header(char const *p, size_t s) {
13472|      0|  uintmax_t tmp;
13473|      0|  char *__cil_tmp4;
13474|       |
13475|      0|  {
13476|      0|    {
13477|      0|      tmp =
13478|      0|          from_header(p, s, "off_t", (uintmax_t)0,
13479|      0|                      (uintmax_t)(-1L - (-1L << (sizeof(off_t) * 8UL - 1UL))));
13480|      0|    }
13481|      0|    return ((off_t)tmp);
13482|      0|  }
13483|      0|}
13484|      0|size_t size_from_header(char const *p, size_t s) {
13485|      0|  uintmax_t tmp;
13486|      0|  char *__cil_tmp4;
13487|       |
13488|      0|  {
13489|      0|    { tmp = from_header(p, s, "size_t", (uintmax_t)0, 0xffffffffffffffffUL); }
13490|      0|    return (tmp);
13491|      0|  }
13492|      0|}
13493|      0|time_t time_from_header(char const *p, size_t s) {
13494|      0|  uintmax_t tmp;
13495|      0|  char *__cil_tmp4;
13496|       |
13497|      0|  {
13498|      0|    {
13499|      0|      tmp = from_header(
13500|      0|          p, s, "time_t", -((uintmax_t)(-1L << (sizeof(time_t) * 8UL - 1UL))),
13501|      0|          (uintmax_t)(-1L - (-1L << (sizeof(time_t) * 8UL - 1UL))));
13502|      0|    }
13503|      0|    return ((time_t)tmp);
13504|      0|  }
13505|      0|}
13506|      0|uid_t uid_from_header(char const *p, size_t s) {
13507|      0|  uintmax_t tmp;
13508|      0|  char *__cil_tmp4;
13509|       |
13510|      0|  {
13511|      0|    {
13512|      0|      tmp = from_header(p, s, "uid_t", -((uintmax_t)((uid_t)0)),
13513|      0|                        (uintmax_t)4294967295U);
13514|      0|    }
13515|      0|    return ((uid_t)tmp);
13516|      0|  }
13517|      0|}
13518|      0|uintmax_t uintmax_from_header(char const *p, size_t s) {
13519|      0|  uintmax_t tmp;
13520|      0|  char *__cil_tmp4;
13521|       |
13522|      0|  {
13523|      0|    {
13524|      0|      tmp = from_header(p, s, "uintmax_t", (uintmax_t)0, 0xffffffffffffffffUL);
13525|      0|    }
13526|      0|    return (tmp);
13527|      0|  }
13528|      0|}
13529|      0|char *stringify_uintmax_t_backwards(uintmax_t o___0, char *buf) {
13530|       |
13531|      0|  {
13532|      0|    buf--;
13533|      0|    *buf = (char)'\000';
13534|      0|    {
13535|      0|      while (1) {
13536|      0|      while_continue: /* CIL Label */;
13537|      0|        buf--;
13538|      0|        *buf = (char)(48 + (int)(o___0 % 10UL));
13539|      0|        o___0 /= 10UL;
13540|      0|        if (!(o___0 != 0UL)) {
13541|      0|          goto while_break;
13542|      0|        }
13543|      0|      }
13544|      0|    while_break: /* CIL Label */;
13545|      0|    }
13546|      0|    return (buf);
13547|      0|  }
13548|      0|}
13549|       |static char buffer[27UL];
13550|      0|char const *tartime(time_t t) {
13551|      0|  char *p;
13552|      0|  struct tm *tm;
13553|      0|  struct tm *tmp;
13554|      0|  struct tm *tmp___0;
13555|      0|  struct tm *tmp___1;
13556|      0|  uintmax_t tmp___2;
13557|      0|  char *__cil_tmp8;
13558|       |
13559|      0|  {
13560|      0|    if (utc_option) {
13561|      0|      {
13562|      0|        tmp = gmtime((time_t const *)(&t));
13563|      0|        tmp___1 = tmp;
13564|      0|      }
13565|      0|    } else {
13566|      0|      {
13567|      0|        tmp___0 = localtime((time_t const *)(&t));
13568|      0|        tmp___1 = tmp___0;
13569|      0|      }
13570|      0|    }
13571|      0|    tm = tmp___1;
13572|      0|    if (tm) {
13573|      0|      {
13574|      0|        sprintf(
13575|      0|            (char * /* __restrict  */)(buffer),
13576|      0|            (char const * /* __restrict  */) "%04ld-%02d-%02d %02d:%02d:%02d",
13577|      0|            (long)tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour,
13578|      0|            tm->tm_min, tm->tm_sec);
13579|      0|      }
13580|      0|      return ((char const *)(buffer));
13581|      0|    }
13582|      0|    if (t < 0L) {
13583|      0|      tmp___2 = -((uintmax_t)t);
13584|      0|    } else {
13585|      0|      tmp___2 = (uintmax_t)t;
13586|      0|    }
13587|      0|    { p = stringify_uintmax_t_backwards(tmp___2, buffer + sizeof(buffer)); }
13588|      0|    if (t < 0L) {
13589|      0|      p--;
13590|      0|      *p = (char)'-';
13591|      0|    }
13592|      0|    {
13593|      0|      while (1) {
13594|      0|      while_continue: /* CIL Label */;
13595|      0|        if (!((unsigned long)(((buffer + sizeof(buffer)) - 19) - 1) <
13596|      0|              (unsigned long)p)) {
13597|      0|          goto while_break;
13598|      0|        }
13599|      0|        p--;
13600|      0|        *p = (char)' ';
13601|      0|      }
13602|      0|    while_break: /* CIL Label */;
13603|      0|    }
13604|      0|    return ((char const *)p);
13605|      0|  }
13606|      0|}
13607|       |static int ugswidth = 18;
13608|      0|void print_header(struct tar_stat_info *st, off_t block_ordinal) {
13609|      0|  char modes[11];
13610|      0|  char const *time_stamp;
13611|      0|  char *temp_name;
13612|      0|  char uform[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
13613|      0|  char gform[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
13614|      0|  char *user;
13615|      0|  char *group;
13616|      0|  char size[2UL * ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL)];
13617|      0|  char uintbuf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
13618|      0|  int pad;
13619|      0|  char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
13620|      0|  char *tmp;
13621|      0|  char *tmp___0;
13622|      0|  char *tmp___1;
13623|      0|  char *tmp___2;
13624|      0|  size_t tmp___3;
13625|      0|  uintmax_t u;
13626|      0|  uintmax_t tmp___4;
13627|      0|  uid_t tmp___5;
13628|      0|  uintmax_t g;
13629|      0|  uintmax_t tmp___6;
13630|      0|  gid_t tmp___7;
13631|      0|  unsigned int tmp___8;
13632|      0|  char *tmp___9;
13633|      0|  unsigned int tmp___10;
13634|      0|  char *tmp___11;
13635|      0|  char *tmp___12;
13636|      0|  size_t tmp___13;
13637|      0|  size_t tmp___14;
13638|      0|  size_t tmp___15;
13639|      0|  char *tmp___16;
13640|      0|  char *tmp___17;
13641|      0|  char *tmp___18;
13642|      0|  char *tmp___19;
13643|      0|  char type_string[2];
13644|      0|  char const *tmp___20;
13645|      0|  char *tmp___21;
13646|      0|  char *tmp___22;
13647|      0|  char *tmp___23;
13648|      0|  char *tmp___24;
13649|      0|  uintmax_t tmp___25;
13650|      0|  char *tmp___26;
13651|      0|  char *tmp___27;
13652|      0|  char *tmp___28;
13653|      0|  void *__cil_tmp47;
13654|      0|  void *__cil_tmp48;
13655|      0|  void *__cil_tmp49;
13656|      0|  void *__cil_tmp50;
13657|      0|  void *__cil_tmp51;
13658|      0|  void *__cil_tmp52;
13659|      0|  void *__cil_tmp53;
13660|      0|  char *__cil_tmp54;
13661|      0|  char *__cil_tmp55;
13662|      0|  char *__cil_tmp56;
13663|      0|  char *__cil_tmp57;
13664|      0|  char *__cil_tmp58;
13665|      0|  char *__cil_tmp59;
13666|      0|  char *__cil_tmp60;
13667|      0|  char *__cil_tmp61;
13668|      0|  char *__cil_tmp62;
13669|      0|  char *__cil_tmp63;
13670|      0|  char *__cil_tmp64;
13671|      0|  char *__cil_tmp65;
13672|       |
13673|      0|  {
13674|      0|    if (st->orig_file_name) {
13675|      0|      temp_name = st->orig_file_name;
13676|      0|    } else {
13677|      0|      temp_name = st->file_name;
13678|      0|    }
13679|      0|    if (block_number_option) {
13680|      0|      if (block_ordinal < 0L) {
13681|      0|        {
13682|      0|          block_ordinal = current_block_ordinal();
13683|      0|        }
13684|      0|      }
13685|      0|      {
13686|      0|        block_ordinal =
13687|      0|            (off_t)((size_t)block_ordinal - recent_long_name_blocks);
13688|      0|        block_ordinal =
13689|      0|            (off_t)((size_t)block_ordinal - recent_long_link_blocks);
13690|      0|        tmp = stringify_uintmax_t_backwards(
13691|      0|            (uintmax_t)block_ordinal,
13692|      0|            buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
13693|      0|        tmp___0 = gettext("block %s: ");
13694|      0|        fprintf((FILE * /* __restrict  */) stdlis,
13695|      0|                (char const * /* __restrict  */)tmp___0, tmp);
13696|      0|      }
13697|      0|    }
13698|      0|    if (verbose_option <= 1) {
13699|      0|      {
13700|      0|        tmp___1 = quotearg((char const *)temp_name);
13701|      0|        fprintf((FILE * /* __restrict  */) stdlis,
13702|      0|                (char const * /* __restrict  */) "%s\n", tmp___1);
13703|      0|      }
13704|      0|    } else {
13705|      0|      modes[0] = (char)'?';
13706|      0|      {
13707|      0|        if ((int)current_header->header.typeflag == 86) {
13708|      0|          goto case_86;
13709|      0|        }
13710|      0|        if ((int)current_header->header.typeflag == 77) {
13711|      0|          goto case_77;
13712|      0|        }
13713|      0|        if ((int)current_header->header.typeflag == 78) {
13714|      0|          goto case_78;
13715|      0|        }
13716|      0|        if ((int)current_header->header.typeflag == 76) {
13717|      0|          goto case_76;
13718|      0|        }
13719|      0|        if ((int)current_header->header.typeflag == 75) {
13720|      0|          goto case_76;
13721|      0|        }
13722|      0|        if ((int)current_header->header.typeflag == 83) {
13723|      0|          goto case_83;
13724|      0|        }
13725|      0|        if ((int)current_header->header.typeflag == 48) {
13726|      0|          goto case_83;
13727|      0|        }
13728|      0|        if ((int)current_header->header.typeflag == 0) {
13729|      0|          goto case_83;
13730|      0|        }
13731|      0|        if ((int)current_header->header.typeflag == 49) {
13732|      0|          goto case_49;
13733|      0|        }
13734|      0|        if ((int)current_header->header.typeflag == 68) {
13735|      0|          goto case_68;
13736|      0|        }
13737|      0|        if ((int)current_header->header.typeflag == 53) {
13738|      0|          goto case_53;
13739|      0|        }
13740|      0|        if ((int)current_header->header.typeflag == 50) {
13741|      0|          goto case_50;
13742|      0|        }
13743|      0|        if ((int)current_header->header.typeflag == 52) {
13744|      0|          goto case_52;
13745|      0|        }
13746|      0|        if ((int)current_header->header.typeflag == 51) {
13747|      0|          goto case_51;
13748|      0|        }
13749|      0|        if ((int)current_header->header.typeflag == 54) {
13750|      0|          goto case_54;
13751|      0|        }
13752|      0|        if ((int)current_header->header.typeflag == 55) {
13753|      0|          goto case_55;
13754|      0|        }
13755|      0|        goto switch_break;
13756|      0|      case_86: /* CIL Label */
13757|      0|        modes[0] = (char)'V';
13758|      0|        goto switch_break;
13759|      0|      case_77: /* CIL Label */
13760|      0|        modes[0] = (char)'M';
13761|      0|        goto switch_break;
13762|      0|      case_78: /* CIL Label */
13763|      0|        modes[0] = (char)'N';
13764|      0|        goto switch_break;
13765|      0|      case_76:  /* CIL Label */
13766|      0|      case_75 : /* CIL Label */
13767|      0|      {
13768|      0|        modes[0] = (char)'L';
13769|      0|        tmp___2 = gettext("Visible longname error");
13770|      0|        error(0, 0, (char const *)tmp___2);
13771|      0|        exit_status = 2;
13772|      0|      }
13773|      0|        goto switch_break;
13774|      0|      case_83: /* CIL Label */
13775|      0|      case_48: /* CIL Label */
13776|      0|      case_0 : /* CIL Label */
13777|      0|      {
13778|      0|        modes[0] = (char)'-';
13779|      0|        tmp___3 = strlen((char const *)temp_name);
13780|      0|      }
13781|      0|        if ((int)*(temp_name + (tmp___3 - 1UL)) == 47) {
13782|      0|          modes[0] = (char)'d';
13783|      0|        }
13784|      0|        goto switch_break;
13785|      0|      case_49: /* CIL Label */
13786|      0|        modes[0] = (char)'h';
13787|      0|        goto switch_break;
13788|      0|      case_68: /* CIL Label */
13789|      0|        modes[0] = (char)'d';
13790|      0|        goto switch_break;
13791|      0|      case_53: /* CIL Label */
13792|      0|        modes[0] = (char)'d';
13793|      0|        goto switch_break;
13794|      0|      case_50: /* CIL Label */
13795|      0|        modes[0] = (char)'l';
13796|      0|        goto switch_break;
13797|      0|      case_52: /* CIL Label */
13798|      0|        modes[0] = (char)'b';
13799|      0|        goto switch_break;
13800|      0|      case_51: /* CIL Label */
13801|      0|        modes[0] = (char)'c';
13802|      0|        goto switch_break;
13803|      0|      case_54: /* CIL Label */
13804|      0|        modes[0] = (char)'p';
13805|      0|        goto switch_break;
13806|      0|      case_55: /* CIL Label */
13807|      0|        modes[0] = (char)'C';
13808|      0|        goto switch_break;
13809|      0|      switch_break: /* CIL Label */;
13810|      0|      }
13811|      0|      {
13812|      0|        decode_mode(st->stat.st_mode, modes + 1);
13813|      0|        time_stamp = tartime(st->stat.st_mtim.tv_sec);
13814|      0|      }
13815|      0|      if (st->uname) {
13816|      0|        if ((unsigned int)current_format != 1U) {
13817|      0|          if (!numeric_owner_option) {
13818|      0|            user = st->uname;
13819|      0|          } else {
13820|      0|            goto _L___4;
13821|      0|          }
13822|      0|        } else {
13823|      0|          goto _L___4;
13824|      0|        }
13825|      0|      } else {
13826|      0|      _L___4 : /* CIL Label */
13827|      0|      {
13828|      0|        tmp___4 =
13829|      0|            from_header((char const *)(current_header->header.uid),
13830|      0|                        sizeof(current_header->header.uid), (char const *)0,
13831|      0|                        (uintmax_t)0, 0xffffffffffffffffUL);
13832|      0|        u = tmp___4;
13833|      0|      }
13834|      0|        if (u != 0xffffffffffffffffUL) {
13835|      0|          {
13836|      0|            user = stringify_uintmax_t_backwards(
13837|      0|                u,
13838|      0|                uform + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
13839|      0|                         1UL));
13840|      0|          }
13841|      0|        } else {
13842|      0|          {
13843|      0|            tmp___5 =
13844|      0|                uid_from_header((char const *)(current_header->header.uid),
13845|      0|                                sizeof(current_header->header.uid));
13846|      0|            sprintf((char * /* __restrict  */)(uform),
13847|      0|                    (char const * /* __restrict  */) "%ld", (long)tmp___5);
13848|      0|            user = uform;
13849|      0|          }
13850|      0|        }
13851|      0|      }
13852|      0|      if (st->gname) {
13853|      0|        if ((unsigned int)current_format != 1U) {
13854|      0|          if (!numeric_owner_option) {
13855|      0|            group = st->gname;
13856|      0|          } else {
13857|      0|            goto _L___6;
13858|      0|          }
13859|      0|        } else {
13860|      0|          goto _L___6;
13861|      0|        }
13862|      0|      } else {
13863|      0|      _L___6 : /* CIL Label */
13864|      0|      {
13865|      0|        tmp___6 =
13866|      0|            from_header((char const *)(current_header->header.gid),
13867|      0|                        sizeof(current_header->header.gid), (char const *)0,
13868|      0|                        (uintmax_t)0, 0xffffffffffffffffUL);
13869|      0|        g = tmp___6;
13870|      0|      }
13871|      0|        if (g != 0xffffffffffffffffUL) {
13872|      0|          {
13873|      0|            group = stringify_uintmax_t_backwards(
13874|      0|                g,
13875|      0|                gform + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
13876|      0|                         1UL));
13877|      0|          }
13878|      0|        } else {
13879|      0|          {
13880|      0|            tmp___7 =
13881|      0|                gid_from_header((char const *)(current_header->header.gid),
13882|      0|                                sizeof(current_header->header.gid));
13883|      0|            sprintf((char * /* __restrict  */)(gform),
13884|      0|                    (char const * /* __restrict  */) "%ld", (long)tmp___7);
13885|      0|            group = gform;
13886|      0|          }
13887|      0|        }
13888|      0|      }
13889|      0|      {
13890|      0|        if ((int)current_header->header.typeflag == 51) {
13891|      0|          goto case_51___0;
13892|      0|        }
13893|      0|        if ((int)current_header->header.typeflag == 52) {
13894|      0|          goto case_51___0;
13895|      0|        }
13896|      0|        goto switch_default;
13897|      0|      case_51___0:  /* CIL Label */
13898|      0|      case_52___0 : /* CIL Label */
13899|      0|      {
13900|      0|        tmp___8 = gnu_dev_major((unsigned long long)st->stat.st_rdev);
13901|      0|        tmp___9 = stringify_uintmax_t_backwards(
13902|      0|            (uintmax_t)tmp___8,
13903|      0|            uintbuf +
13904|      0|                ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
13905|      0|        strcpy((char * /* __restrict  */)(size),
13906|      0|               (char const * /* __restrict  */)tmp___9);
13907|      0|        strcat((char * /* __restrict  */)(size),
13908|      0|               (char const * /* __restrict  */) ",");
13909|      0|        tmp___10 = gnu_dev_minor((unsigned long long)st->stat.st_rdev);
13910|      0|        tmp___11 = stringify_uintmax_t_backwards(
13911|      0|            (uintmax_t)tmp___10,
13912|      0|            uintbuf +
13913|      0|                ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
13914|      0|        strcat((char * /* __restrict  */)(size),
13915|      0|               (char const * /* __restrict  */)tmp___11);
13916|      0|      }
13917|      0|        goto switch_break___0;
13918|      0|      switch_default : /* CIL Label */
13919|      0|      {
13920|      0|        tmp___12 = stringify_uintmax_t_backwards(
13921|      0|            (uintmax_t)st->stat.st_size,
13922|      0|            uintbuf +
13923|      0|                ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
13924|      0|        strcpy((char * /* __restrict  */)(size),
13925|      0|               (char const * /* __restrict  */)tmp___12);
13926|      0|      }
13927|      0|        goto switch_break___0;
13928|      0|      switch_break___0: /* CIL Label */;
13929|      0|      }
13930|      0|      {
13931|      0|        tmp___13 = strlen((char const *)user);
13932|      0|        tmp___14 = strlen((char const *)group);
13933|      0|        tmp___15 = strlen((char const *)(size));
13934|      0|        pad = (int)(((tmp___13 + tmp___14) + tmp___15) + 1UL);
13935|      0|      }
13936|      0|      if (pad > ugswidth) {
13937|      0|        ugswidth = pad;
13938|      0|      }
13939|      0|      {
13940|      0|        fprintf((FILE * /* __restrict  */) stdlis,
13941|      0|                (char const * /* __restrict  */) "%s %s/%s %*s%s %s", modes,
13942|      0|                user, group, ugswidth - pad, "", size, time_stamp);
13943|      0|        tmp___16 = quotearg((char const *)temp_name);
13944|      0|        fprintf((FILE * /* __restrict  */) stdlis,
13945|      0|                (char const * /* __restrict  */) " %s", tmp___16);
13946|      0|      }
13947|      0|      {
13948|      0|        if ((int)current_header->header.typeflag == 50) {
13949|      0|          goto case_50___0;
13950|      0|        }
13951|      0|        if ((int)current_header->header.typeflag == 49) {
13952|      0|          goto case_49___0;
13953|      0|        }
13954|      0|        if ((int)current_header->header.typeflag == 0) {
13955|      0|          goto case_0___0;
13956|      0|        }
13957|      0|        if ((int)current_header->header.typeflag == 48) {
13958|      0|          goto case_0___0;
13959|      0|        }
13960|      0|        if ((int)current_header->header.typeflag == 83) {
13961|      0|          goto case_0___0;
13962|      0|        }
13963|      0|        if ((int)current_header->header.typeflag == 51) {
13964|      0|          goto case_0___0;
13965|      0|        }
13966|      0|        if ((int)current_header->header.typeflag == 52) {
13967|      0|          goto case_0___0;
13968|      0|        }
13969|      0|        if ((int)current_header->header.typeflag == 53) {
13970|      0|          goto case_0___0;
13971|      0|        }
13972|      0|        if ((int)current_header->header.typeflag == 54) {
13973|      0|          goto case_0___0;
13974|      0|        }
13975|      0|        if ((int)current_header->header.typeflag == 55) {
13976|      0|          goto case_0___0;
13977|      0|        }
13978|      0|        if ((int)current_header->header.typeflag == 68) {
13979|      0|          goto case_0___0;
13980|      0|        }
13981|      0|        if ((int)current_header->header.typeflag == 75) {
13982|      0|          goto case_75___0;
13983|      0|        }
13984|      0|        if ((int)current_header->header.typeflag == 76) {
13985|      0|          goto case_76___0;
13986|      0|        }
13987|      0|        if ((int)current_header->header.typeflag == 86) {
13988|      0|          goto case_86___0;
13989|      0|        }
13990|      0|        if ((int)current_header->header.typeflag == 77) {
13991|      0|          goto case_77___0;
13992|      0|        }
13993|      0|        if ((int)current_header->header.typeflag == 78) {
13994|      0|          goto case_78___0;
13995|      0|        }
13996|      0|        goto switch_default___0;
13997|      0|      case_50___0 : /* CIL Label */
13998|      0|      {
13999|      0|        tmp___17 = quotearg((char const *)st->link_name);
14000|      0|        fprintf((FILE * /* __restrict  */) stdlis,
14001|      0|                (char const * /* __restrict  */) " -> %s\n", tmp___17);
14002|      0|      }
14003|      0|        goto switch_break___1;
14004|      0|      case_49___0 : /* CIL Label */
14005|      0|      {
14006|      0|        tmp___18 = quotearg((char const *)st->link_name);
14007|      0|        tmp___19 = gettext(" link to %s\n");
14008|      0|        fprintf((FILE * /* __restrict  */) stdlis,
14009|      0|                (char const * /* __restrict  */)tmp___19, tmp___18);
14010|      0|      }
14011|      0|        goto switch_break___1;
14012|      0|      switch_default___0 : /* CIL Label */
14013|      0|      {
14014|      0|        type_string[0] = current_header->header.typeflag;
14015|      0|        type_string[1] = (char)'\000';
14016|      0|        tmp___20 = quote((char const *)(type_string));
14017|      0|        tmp___21 = gettext(" unknown file type %s\n");
14018|      0|        fprintf((FILE * /* __restrict  */) stdlis,
14019|      0|                (char const * /* __restrict  */)tmp___21, tmp___20);
14020|      0|      }
14021|      0|        goto switch_break___1;
14022|      0|      case_0___0:   /* CIL Label */
14023|      0|      case_48___0:  /* CIL Label */
14024|      0|      case_83___0:  /* CIL Label */
14025|      0|      case_51___1:  /* CIL Label */
14026|      0|      case_52___1:  /* CIL Label */
14027|      0|      case_53___0:  /* CIL Label */
14028|      0|      case_54___0:  /* CIL Label */
14029|      0|      case_55___0:  /* CIL Label */
14030|      0|      case_68___0 : /* CIL Label */
14031|      0|      {
14032|      0|        putc_unlocked('\n', stdlis);
14033|      0|      }
14034|      0|        goto switch_break___1;
14035|      0|      case_75___0 : /* CIL Label */
14036|      0|      {
14037|      0|        tmp___22 = gettext("--Long Link--\n");
14038|      0|        fprintf((FILE * /* __restrict  */) stdlis,
14039|      0|                (char const * /* __restrict  */)tmp___22);
14040|      0|      }
14041|      0|        goto switch_break___1;
14042|      0|      case_76___0 : /* CIL Label */
14043|      0|      {
14044|      0|        tmp___23 = gettext("--Long Name--\n");
14045|      0|        fprintf((FILE * /* __restrict  */) stdlis,
14046|      0|                (char const * /* __restrict  */)tmp___23);
14047|      0|      }
14048|      0|        goto switch_break___1;
14049|      0|      case_86___0 : /* CIL Label */
14050|      0|      {
14051|      0|        tmp___24 = gettext("--Volume Header--\n");
14052|      0|        fprintf((FILE * /* __restrict  */) stdlis,
14053|      0|                (char const * /* __restrict  */)tmp___24);
14054|      0|      }
14055|      0|        goto switch_break___1;
14056|      0|      case_77___0 : /* CIL Label */
14057|      0|      {
14058|      0|        tmp___25 = uintmax_from_header(
14059|      0|            (char const *)(current_header->oldgnu_header.offset),
14060|      0|            sizeof(current_header->oldgnu_header.offset));
14061|      0|        tmp___26 = stringify_uintmax_t_backwards(
14062|      0|            tmp___25,
14063|      0|            uintbuf +
14064|      0|                ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
14065|      0|        strcpy((char * /* __restrict  */)(size),
14066|      0|               (char const * /* __restrict  */)tmp___26);
14067|      0|        tmp___27 = gettext("--Continued at byte %s--\n");
14068|      0|        fprintf((FILE * /* __restrict  */) stdlis,
14069|      0|                (char const * /* __restrict  */)tmp___27, size);
14070|      0|      }
14071|      0|        goto switch_break___1;
14072|      0|      case_78___0 : /* CIL Label */
14073|      0|      {
14074|      0|        tmp___28 = gettext("--Mangled file names--\n");
14075|      0|        fprintf((FILE * /* __restrict  */) stdlis,
14076|      0|                (char const * /* __restrict  */)tmp___28);
14077|      0|      }
14078|      0|        goto switch_break___1;
14079|      0|      switch_break___1: /* CIL Label */;
14080|      0|      }
14081|      0|    }
14082|      0|    { fflush_unlocked(stdlis); }
14083|      0|    return;
14084|      0|  }
14085|      0|}
14086|      0|void print_for_mkdir(char *pathname, int length, mode_t mode) {
14087|      0|  char modes[11];
14088|      0|  char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
14089|      0|  off_t tmp;
14090|      0|  char *tmp___0;
14091|      0|  char *tmp___1;
14092|      0|  char *tmp___2;
14093|      0|  char *tmp___3;
14094|      0|  void *__cil_tmp11;
14095|      0|  void *__cil_tmp12;
14096|      0|  char *__cil_tmp13;
14097|      0|  char *__cil_tmp14;
14098|       |
14099|      0|  {
14100|      0|    if (verbose_option > 1) {
14101|      0|      {
14102|      0|        modes[0] = (char)'d';
14103|      0|        decode_mode(mode, modes + 1);
14104|      0|      }
14105|      0|      if (block_number_option) {
14106|      0|        {
14107|      0|          tmp = current_block_ordinal();
14108|      0|          tmp___0 = stringify_uintmax_t_backwards(
14109|      0|              (uintmax_t)tmp,
14110|      0|              buf +
14111|      0|                  ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
14112|      0|          tmp___1 = gettext("block %s: ");
14113|      0|          fprintf((FILE * /* __restrict  */) stdlis,
14114|      0|                  (char const * /* __restrict  */)tmp___1, tmp___0);
14115|      0|        }
14116|      0|      }
14117|      0|      {
14118|      0|        tmp___2 = quotearg((char const *)pathname);
14119|      0|        tmp___3 = gettext("Creating directory:");
14120|      0|        fprintf((FILE * /* __restrict  */) stdlis,
14121|      0|                (char const * /* __restrict  */) "%s %*s %.*s\n", modes,
14122|      0|                ugswidth + 18, tmp___3, length, tmp___2);
14123|      0|      }
14124|      0|    }
14125|      0|    return;
14126|      0|  }
14127|      0|}
14128|      0|void skip_file(off_t size) {
14129|      0|  union block *x;
14130|      0|  char *tmp;
14131|      0|  char *__cil_tmp4;
14132|       |
14133|      0|  {
14134|      0|    if (multi_volume_option) {
14135|      0|      save_totsize = size;
14136|      0|      save_sizeleft = size;
14137|      0|    }
14138|      0|    {
14139|      0|      while (1) {
14140|      0|      while_continue: /* CIL Label */;
14141|      0|        if (!(size > 0L)) {
14142|      0|          goto while_break;
14143|      0|        }
14144|      0|        { x = find_next_block(); }
14145|      0|        if (!x) {
14146|      0|          {
14147|      0|            tmp = gettext("Unexpected EOF in archive");
14148|      0|            error(0, 0, (char const *)tmp);
14149|      0|            fatal_exit();
14150|      0|          }
14151|      0|        }
14152|      0|        {
14153|      0|          set_next_block_after(x);
14154|      0|          size -= 512L;
14155|      0|        }
14156|      0|        if (multi_volume_option) {
14157|      0|          save_sizeleft -= 512L;
14158|      0|        }
14159|      0|      }
14160|      0|    while_break: /* CIL Label */;
14161|      0|    }
14162|      0|    return;
14163|      0|  }
14164|      0|}
14165|      0|void skip_member(void) {
14166|      0|  char save_typeflag;
14167|      0|  _Bool tmp;
14168|       |
14169|      0|  {
14170|      0|    {
14171|      0|      save_typeflag = current_header->header.typeflag;
14172|      0|      set_next_block_after(current_header);
14173|      0|      assign_string(&save_name, (char const *)current_stat_info.file_name);
14174|      0|      tmp = sparse_member_p(&current_stat_info);
14175|      0|    }
14176|      0|    if (tmp) {
14177|      0|      {
14178|      0|        sparse_skip_file(&current_stat_info);
14179|      0|      }
14180|      0|    } else {
14181|      0|      if ((int)save_typeflag != 53) {
14182|      0|        {
14183|      0|          skip_file(current_stat_info.stat.st_size);
14184|      0|        }
14185|      0|      }
14186|      0|    }
14187|      0|    return;
14188|      0|  }
14189|      0|}
14190|       |/* #pragma merger("0","008.mangle.o.i","") */
14191|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
14192|       |                                        rename)(char const *__old,
14193|       |                                                char const *__new);
14194|      0|void extract_mangle(void) {
14195|      0|  off_t size;
14196|      0|  char *buffer___2;
14197|      0|  void *tmp;
14198|      0|  char *copy;
14199|      0|  char *cursor;
14200|      0|  union block *block;
14201|      0|  union block *tmp___0;
14202|      0|  size_t available;
14203|      0|  char *tmp___1;
14204|      0|  char *next_cursor;
14205|      0|  char *name;
14206|      0|  char *name_end;
14207|      0|  char *tmp___2;
14208|      0|  int tmp___3;
14209|      0|  char const *tmp___4;
14210|      0|  char *tmp___5;
14211|      0|  char *tmp___6;
14212|      0|  int *tmp___7;
14213|      0|  char *tmp___8;
14214|      0|  int tmp___9;
14215|      0|  int tmp___10;
14216|      0|  char const *tmp___11;
14217|      0|  char *tmp___12;
14218|      0|  char *tmp___13;
14219|      0|  int *tmp___14;
14220|      0|  char *tmp___15;
14221|      0|  int tmp___16;
14222|      0|  int tmp___17;
14223|      0|  int tmp___18;
14224|      0|  char *tmp___19;
14225|      0|  int tmp___20;
14226|      0|  int tmp___21;
14227|      0|  char *__cil_tmp33;
14228|      0|  char *__cil_tmp34;
14229|      0|  char *__cil_tmp35;
14230|      0|  char *__cil_tmp36;
14231|      0|  char *__cil_tmp37;
14232|      0|  char *__cil_tmp38;
14233|       |
14234|      0|  {
14235|      0|    {
14236|      0|      size = current_stat_info.stat.st_size;
14237|      0|      tmp = xmalloc((size_t)(size + 1L));
14238|      0|      buffer___2 = (char *)tmp;
14239|      0|      copy = buffer___2;
14240|      0|      cursor = buffer___2;
14241|      0|    }
14242|      0|    if ((size_t)size != (size_t)size) {
14243|      0|      {
14244|      0|        xalloc_die();
14245|      0|      }
14246|      0|    } else {
14247|      0|      if ((size_t)size == 0xffffffffffffffffUL) {
14248|      0|        {
14249|      0|          xalloc_die();
14250|      0|        }
14251|      0|      }
14252|      0|    }
14253|      0|    *(buffer___2 + size) = (char)'\000';
14254|      0|    {
14255|      0|      while (1) {
14256|      0|      while_continue: /* CIL Label */;
14257|      0|        if (!(size > 0L)) {
14258|      0|          goto while_break;
14259|      0|        }
14260|      0|        {
14261|      0|          tmp___0 = find_next_block();
14262|      0|          block = tmp___0;
14263|      0|        }
14264|      0|        if (!block) {
14265|      0|          {
14266|      0|            tmp___1 = gettext("Unexpected EOF in mangled names");
14267|      0|            error(0, 0, (char const *)tmp___1);
14268|      0|            exit_status = 2;
14269|      0|          }
14270|      0|          return;
14271|      0|        }
14272|      0|        { available = available_space_after(block); }
14273|      0|        if (available > (size_t)size) {
14274|      0|          available = (size_t)size;
14275|      0|        }
14276|      0|        {
14277|      0|          memcpy((void * /* __restrict  */)copy,
14278|      0|                 (void const * /* __restrict  */)(block->buffer), available);
14279|      0|          copy += available;
14280|      0|          size = (off_t)((size_t)size - available);
14281|      0|          set_next_block_after(
14282|      0|              (union block *)((block->buffer + available) - 1));
14283|      0|        }
14284|      0|      }
14285|      0|    while_break: /* CIL Label */;
14286|      0|    }
14287|      0|    {
14288|      0|      while (1) {
14289|      0|      while_continue___0: /* CIL Label */;
14290|      0|        if (!*cursor) {
14291|      0|          goto while_break___0;
14292|      0|        }
14293|      0|        {
14294|      0|          next_cursor = strchr((char const *)cursor, '\n');
14295|      0|          tmp___2 = next_cursor;
14296|      0|          next_cursor++;
14297|      0|          *tmp___2 = (char)'\000';
14298|      0|          tmp___21 = strncmp((char const *)cursor, "Rename ", (size_t)7);
14299|      0|        }
14300|      0|        if (tmp___21) {
14301|      0|          {
14302|      0|            tmp___20 = strncmp((char const *)cursor, "Symlink ", (size_t)8);
14303|      0|          }
14304|      0|          if (tmp___20) {
14305|      0|            {
14306|      0|              tmp___19 = gettext("Unknown demangling command %s");
14307|      0|              error(0, 0, (char const *)tmp___19, cursor);
14308|      0|              exit_status = 2;
14309|      0|            }
14310|      0|          } else {
14311|      0|            {
14312|      0|              name = cursor + 8;
14313|      0|              name_end = strchr((char const *)name, ' ');
14314|      0|            }
14315|      0|            {
14316|      0|              while (1) {
14317|      0|              while_continue___1: /* CIL Label */;
14318|      0|                {
14319|      0|                  tmp___10 = strncmp((char const *)name_end, " to ", (size_t)4);
14320|      0|                }
14321|      0|                if (!tmp___10) {
14322|      0|                  goto while_break___1;
14323|      0|                }
14324|      0|                {
14325|      0|                  name_end++;
14326|      0|                  name_end = strchr((char const *)name_end, ' ');
14327|      0|                }
14328|      0|              }
14329|      0|            while_break___1: /* CIL Label */;
14330|      0|            }
14331|      0|            {
14332|      0|              *name_end = (char)'\000';
14333|      0|              unquote_string(name);
14334|      0|              unquote_string(name_end + 4);
14335|      0|              tmp___16 =
14336|      0|                  symlink((char const *)name, (char const *)(name_end + 4));
14337|      0|            }
14338|      0|            if (tmp___16) {
14339|      0|              {
14340|      0|                tmp___17 = unlink((char const *)(name_end + 4));
14341|      0|              }
14342|      0|              if (tmp___17) {
14343|      0|                goto _L___0;
14344|      0|              } else {
14345|      0|                {
14346|      0|                  tmp___18 =
14347|      0|                      symlink((char const *)name, (char const *)(name_end + 4));
14348|      0|                }
14349|      0|                if (tmp___18) {
14350|      0|                _L___0 : {
14351|      0|                  tmp___11 = quote_n(1, (char const *)(name_end + 4));
14352|      0|                  tmp___12 = quotearg_colon((char const *)name);
14353|      0|                  tmp___13 = gettext("%s: Cannot symlink to %s");
14354|      0|                  tmp___14 = __errno_location();
14355|      0|                  error(0, *tmp___14, (char const *)tmp___13, tmp___12,
14356|      0|                        tmp___11);
14357|      0|                  exit_status = 2;
14358|      0|                }
14359|      0|                } else {
14360|      0|                  goto _L;
14361|      0|                }
14362|      0|              }
14363|      0|            } else {
14364|      0|            _L:
14365|      0|              if (verbose_option) {
14366|      0|                {
14367|      0|                  tmp___15 = gettext("Symlinked %s to %s");
14368|      0|                  error(0, 0, (char const *)tmp___15, name, name_end + 4);
14369|      0|                }
14370|      0|              }
14371|      0|            }
14372|      0|          }
14373|      0|        } else {
14374|      0|          {
14375|      0|            name = cursor + 7;
14376|      0|            name_end = strchr((char const *)name, ' ');
14377|      0|          }
14378|      0|          {
14379|      0|            while (1) {
14380|      0|            while_continue___2: /* CIL Label */;
14381|      0|              { tmp___3 = strncmp((char const *)name_end, " to ", (size_t)4); }
14382|      0|              if (!tmp___3) {
14383|      0|                goto while_break___2;
14384|      0|              }
14385|      0|              {
14386|      0|                name_end++;
14387|      0|                name_end = strchr((char const *)name_end, ' ');
14388|      0|              }
14389|      0|            }
14390|      0|          while_break___2: /* CIL Label */;
14391|      0|          }
14392|      0|          *name_end = (char)'\000';
14393|      0|          if ((int)*(next_cursor + -2) == 47) {
14394|      0|            *(next_cursor + -2) = (char)'\000';
14395|      0|          }
14396|      0|          {
14397|      0|            unquote_string(name_end + 4);
14398|      0|            tmp___9 = rename((char const *)name, (char const *)(name_end + 4));
14399|      0|          }
14400|      0|          if (tmp___9) {
14401|      0|            {
14402|      0|              tmp___4 = quote_n(1, (char const *)(name_end + 4));
14403|      0|              tmp___5 = quotearg_colon((char const *)name);
14404|      0|              tmp___6 = gettext("%s: Cannot rename to %s");
14405|      0|              tmp___7 = __errno_location();
14406|      0|              error(0, *tmp___7, (char const *)tmp___6, tmp___5, tmp___4);
14407|      0|              exit_status = 2;
14408|      0|            }
14409|      0|          } else {
14410|      0|            if (verbose_option) {
14411|      0|              {
14412|      0|                tmp___8 = gettext("Renamed %s to %s");
14413|      0|                error(0, 0, (char const *)tmp___8, name, name_end + 4);
14414|      0|              }
14415|      0|            }
14416|      0|          }
14417|      0|        }
14418|      0|        cursor = next_cursor;
14419|      0|      }
14420|      0|    while_break___0: /* CIL Label */;
14421|      0|    }
14422|      0|    return;
14423|      0|  }
14424|      0|}
14425|       |/* #pragma merger("0","009.misc.o.i","") */
14426|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
14427|       |                                        pipe)(int *__pipedes);
14428|       |extern
14429|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
14430|       |                                     chdir)(char const *__path);
14431|       |extern __attribute__((__nothrow__)) __pid_t fork(void);
14432|       |extern
14433|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
14434|       |                                     rmdir)(char const *__path);
14435|       |char *find_backup_file_name(char const *file, enum backup_type backup_type___0);
14436|       |enum backup_type backup_type;
14437|       |int chdir_arg(char const *dir);
14438|       |void chdir_do(int i);
14439|       |__attribute__((__noreturn__)) void chdir_fatal(char const *name);
14440|       |__attribute__((__noreturn__)) void exec_fatal(char const *name);
14441|       |void read_error_details(char const *name, off_t offset, size_t size);
14442|       |__attribute__((__noreturn__)) void read_fatal(char const *name);
14443|       |__attribute__((__noreturn__)) void
14444|       |read_fatal_details(char const *name, off_t offset, size_t size);
14445|       |void read_warn_details(char const *name, off_t offset, size_t size);
14446|       |void savedir_warn(char const *name);
14447|       |void seek_warn_details(char const *name, off_t offset);
14448|       |void seek_diag_details(char const *name, off_t offset);
14449|       |void waitpid_error(char const *name);
14450|       |pid_t xfork(void);
14451|       |void xpipe(int *fd);
14452|       |char *quotearg_n_style(int n, enum quoting_style s, char const *arg);
14453|       |int save_cwd(struct saved_cwd *cwd);
14454|       |int restore_cwd(struct saved_cwd const *cwd);
14455|       |static __attribute__((__noreturn__)) void call_arg_fatal(char const *call,
14456|       |                                                         char const *name);
14457|      0|void assign_string(char **string, char const *value) {
14458|      0|  char *tmp;
14459|       |
14460|      0|  {
14461|      0|    if (*string) {
14462|      0|      {
14463|      0|        free((void *)*string);
14464|      0|      }
14465|      0|    }
14466|      0|    if (value) {
14467|      0|      {
14468|      0|        tmp = xstrdup(value);
14469|      0|        *string = tmp;
14470|      0|      }
14471|      0|    } else {
14472|      0|      *string = (char *)0;
14473|      0|    }
14474|      0|    return;
14475|      0|  }
14476|      0|}
14477|      0|char *quote_copy_string(char const *string) {
14478|      0|  char const *source;
14479|      0|  char *destination;
14480|      0|  char *buffer___2;
14481|      0|  int copying;
14482|      0|  int character;
14483|      0|  char const *tmp;
14484|      0|  size_t length;
14485|      0|  size_t tmp___0;
14486|      0|  void *tmp___1;
14487|      0|  char *tmp___2;
14488|      0|  char *tmp___3;
14489|      0|  char *tmp___4;
14490|      0|  int tmp___5;
14491|       |
14492|      0|  {
14493|      0|    source = string;
14494|      0|    destination = (char *)0;
14495|      0|    buffer___2 = (char *)0;
14496|      0|    copying = 0;
14497|      0|    {
14498|      0|      while (1) {
14499|      0|      while_continue: /* CIL Label */;
14500|      0|        if (!*source) {
14501|      0|          goto while_break;
14502|      0|        }
14503|      0|        tmp = source;
14504|      0|        source++;
14505|      0|        character = (int)*tmp;
14506|      0|        {
14507|      0|          if (character == 10) {
14508|      0|            goto case_10;
14509|      0|          }
14510|      0|          if (character == 92) {
14511|      0|            goto case_10;
14512|      0|          }
14513|      0|          goto switch_default;
14514|      0|        case_10: /* CIL Label */
14515|      0|        case_92: /* CIL Label */
14516|      0|          if (!copying) {
14517|      0|            {
14518|      0|              length = (size_t)((source - string) - 1L);
14519|      0|              copying = 1;
14520|      0|              tmp___0 = strlen(source);
14521|      0|              tmp___1 = xmalloc(((length + 2UL) + 2UL * tmp___0) + 1UL);
14522|      0|              buffer___2 = (char *)tmp___1;
14523|      0|              memcpy((void * /* __restrict  */)buffer___2,
14524|      0|                     (void const * /* __restrict  */)string, length);
14525|      0|              destination = buffer___2 + length;
14526|      0|            }
14527|      0|          }
14528|      0|          tmp___2 = destination;
14529|      0|          destination++;
14530|      0|          *tmp___2 = (char)'\\';
14531|      0|          tmp___3 = destination;
14532|      0|          destination++;
14533|      0|          if (character == 92) {
14534|      0|            tmp___5 = '\\';
14535|      0|          } else {
14536|      0|            tmp___5 = 'n';
14537|      0|          }
14538|      0|          *tmp___3 = (char)tmp___5;
14539|      0|          goto switch_break;
14540|      0|        switch_default: /* CIL Label */
14541|      0|          if (copying) {
14542|      0|            tmp___4 = destination;
14543|      0|            destination++;
14544|      0|            *tmp___4 = (char)character;
14545|      0|          }
14546|      0|          goto switch_break;
14547|      0|        switch_break: /* CIL Label */;
14548|      0|        }
14549|      0|      }
14550|      0|    while_break: /* CIL Label */;
14551|      0|    }
14552|      0|    if (copying) {
14553|      0|      *destination = (char)'\000';
14554|      0|      return (buffer___2);
14555|      0|    }
14556|      0|    return ((char *)0);
14557|      0|  }
14558|      0|}
14559|      0|int unquote_string(char *string) {
14560|      0|  int result;
14561|      0|  char *source;
14562|      0|  char *destination;
14563|      0|  char *tmp;
14564|      0|  char *tmp___0;
14565|      0|  char *tmp___1;
14566|      0|  char *tmp___2;
14567|      0|  char *tmp___3;
14568|      0|  char *tmp___4;
14569|      0|  char *tmp___5;
14570|      0|  int value;
14571|      0|  char *tmp___6;
14572|      0|  char *tmp___7;
14573|      0|  char *tmp___8;
14574|      0|  char *tmp___9;
14575|      0|  char *tmp___10;
14576|      0|  char *tmp___11;
14577|      0|  char *tmp___12;
14578|      0|  char *tmp___13;
14579|      0|  char *tmp___14;
14580|      0|  char *tmp___15;
14581|      0|  char *tmp___16;
14582|       |
14583|      0|  {
14584|      0|    result = 1;
14585|      0|    source = string;
14586|      0|    destination = string;
14587|      0|    {
14588|      0|      while (1) {
14589|      0|      while_continue: /* CIL Label */;
14590|      0|        if (!*source) {
14591|      0|          goto while_break;
14592|      0|        }
14593|      0|        if ((int)*source == 92) {
14594|      0|          source++;
14595|      0|          {
14596|      0|            if ((int)*source == 92) {
14597|      0|              goto case_92;
14598|      0|            }
14599|      0|            if ((int)*source == 110) {
14600|      0|              goto case_110;
14601|      0|            }
14602|      0|            if ((int)*source == 116) {
14603|      0|              goto case_116;
14604|      0|            }
14605|      0|            if ((int)*source == 102) {
14606|      0|              goto case_102;
14607|      0|            }
14608|      0|            if ((int)*source == 98) {
14609|      0|              goto case_98;
14610|      0|            }
14611|      0|            if ((int)*source == 114) {
14612|      0|              goto case_114;
14613|      0|            }
14614|      0|            if ((int)*source == 63) {
14615|      0|              goto case_63;
14616|      0|            }
14617|      0|            if ((int)*source == 48) {
14618|      0|              goto case_48;
14619|      0|            }
14620|      0|            if ((int)*source == 49) {
14621|      0|              goto case_48;
14622|      0|            }
14623|      0|            if ((int)*source == 50) {
14624|      0|              goto case_48;
14625|      0|            }
14626|      0|            if ((int)*source == 51) {
14627|      0|              goto case_48;
14628|      0|            }
14629|      0|            if ((int)*source == 52) {
14630|      0|              goto case_48;
14631|      0|            }
14632|      0|            if ((int)*source == 53) {
14633|      0|              goto case_48;
14634|      0|            }
14635|      0|            if ((int)*source == 54) {
14636|      0|              goto case_48;
14637|      0|            }
14638|      0|            if ((int)*source == 55) {
14639|      0|              goto case_48;
14640|      0|            }
14641|      0|            goto switch_default;
14642|      0|          case_92: /* CIL Label */
14643|      0|            tmp = destination;
14644|      0|            destination++;
14645|      0|            *tmp = (char)'\\';
14646|      0|            source++;
14647|      0|            goto switch_break;
14648|      0|          case_110: /* CIL Label */
14649|      0|            tmp___0 = destination;
14650|      0|            destination++;
14651|      0|            *tmp___0 = (char)'\n';
14652|      0|            source++;
14653|      0|            goto switch_break;
14654|      0|          case_116: /* CIL Label */
14655|      0|            tmp___1 = destination;
14656|      0|            destination++;
14657|      0|            *tmp___1 = (char)'\t';
14658|      0|            source++;
14659|      0|            goto switch_break;
14660|      0|          case_102: /* CIL Label */
14661|      0|            tmp___2 = destination;
14662|      0|            destination++;
14663|      0|            *tmp___2 = (char)'\f';
14664|      0|            source++;
14665|      0|            goto switch_break;
14666|      0|          case_98: /* CIL Label */
14667|      0|            tmp___3 = destination;
14668|      0|            destination++;
14669|      0|            *tmp___3 = (char)'\b';
14670|      0|            source++;
14671|      0|            goto switch_break;
14672|      0|          case_114: /* CIL Label */
14673|      0|            tmp___4 = destination;
14674|      0|            destination++;
14675|      0|            *tmp___4 = (char)'\r';
14676|      0|            source++;
14677|      0|            goto switch_break;
14678|      0|          case_63: /* CIL Label */
14679|      0|            tmp___5 = destination;
14680|      0|            destination++;
14681|      0|            *tmp___5 = (char)127;
14682|      0|            source++;
14683|      0|            goto switch_break;
14684|      0|          case_48: /* CIL Label */
14685|      0|          case_49: /* CIL Label */
14686|      0|          case_50: /* CIL Label */
14687|      0|          case_51: /* CIL Label */
14688|      0|          case_52: /* CIL Label */
14689|      0|          case_53: /* CIL Label */
14690|      0|          case_54: /* CIL Label */
14691|      0|          case_55: /* CIL Label */
14692|      0|            tmp___6 = source;
14693|      0|            source++;
14694|      0|            value = (int)*tmp___6 - 48;
14695|      0|            if ((int)*source < 48) {
14696|      0|              tmp___7 = destination;
14697|      0|              destination++;
14698|      0|              *tmp___7 = (char)value;
14699|      0|              goto switch_break;
14700|      0|            } else {
14701|      0|              if ((int)*source > 55) {
14702|      0|                tmp___7 = destination;
14703|      0|                destination++;
14704|      0|                *tmp___7 = (char)value;
14705|      0|                goto switch_break;
14706|      0|              }
14707|      0|            }
14708|      0|            tmp___8 = source;
14709|      0|            source++;
14710|      0|            value = (value * 8 + (int)*tmp___8) - 48;
14711|      0|            if ((int)*source < 48) {
14712|      0|              tmp___9 = destination;
14713|      0|              destination++;
14714|      0|              *tmp___9 = (char)value;
14715|      0|              goto switch_break;
14716|      0|            } else {
14717|      0|              if ((int)*source > 55) {
14718|      0|                tmp___9 = destination;
14719|      0|                destination++;
14720|      0|                *tmp___9 = (char)value;
14721|      0|                goto switch_break;
14722|      0|              }
14723|      0|            }
14724|      0|            tmp___10 = source;
14725|      0|            source++;
14726|      0|            value = (value * 8 + (int)*tmp___10) - 48;
14727|      0|            tmp___11 = destination;
14728|      0|            destination++;
14729|      0|            *tmp___11 = (char)value;
14730|      0|            goto switch_break;
14731|      0|          switch_default: /* CIL Label */
14732|      0|            result = 0;
14733|      0|            tmp___12 = destination;
14734|      0|            destination++;
14735|      0|            *tmp___12 = (char)'\\';
14736|      0|            if (*source) {
14737|      0|              tmp___13 = destination;
14738|      0|              destination++;
14739|      0|              tmp___14 = source;
14740|      0|              source++;
14741|      0|              *tmp___13 = *tmp___14;
14742|      0|            }
14743|      0|            goto switch_break;
14744|      0|          switch_break: /* CIL Label */;
14745|      0|          }
14746|      0|        } else {
14747|      0|          if ((unsigned long)source != (unsigned long)destination) {
14748|      0|            tmp___15 = destination;
14749|      0|            destination++;
14750|      0|            tmp___16 = source;
14751|      0|            source++;
14752|      0|            *tmp___15 = *tmp___16;
14753|      0|          } else {
14754|      0|            source++;
14755|      0|            destination++;
14756|      0|          }
14757|      0|        }
14758|      0|      }
14759|      0|    while_break: /* CIL Label */;
14760|      0|    }
14761|      0|    if ((unsigned long)source != (unsigned long)destination) {
14762|      0|      *destination = (char)'\000';
14763|      0|    }
14764|      0|    return (result);
14765|      0|  }
14766|      0|}
14767|       |static char *before_backup_name;
14768|       |static char *after_backup_name;
14769|      0|static _Bool must_be_dot_or_slash(char const *path) {
14770|      0|  int tmp;
14771|       |
14772|      0|  {
14773|      0|    path += 0;
14774|      0|    if ((int const) * (path + 0) == 47) {
14775|      0|      {
14776|      0|        while (1) {
14777|      0|        while_continue: /* CIL Label */;
14778|      0|          if ((int const) * (path + 1) == 47) {
14779|      0|            path++;
14780|      0|          } else {
14781|      0|            if ((int const) * (path + 1) == 46) {
14782|      0|              if ((int const) *
14783|      0|                      (path + (2 + ((int const) * (path + 2) == 46))) ==
14784|      0|                  47) {
14785|      0|                path += 2 + ((int const) * (path + 2) == 46);
14786|      0|              } else {
14787|      0|                return ((_Bool)(!*(path + 1)));
14788|      0|              }
14789|      0|            } else {
14790|      0|              return ((_Bool)(!*(path + 1)));
14791|      0|            }
14792|      0|          }
14793|      0|        }
14794|      0|      while_break: /* CIL Label */;
14795|      0|      }
14796|      0|    } else {
14797|      0|      {
14798|      0|        while (1) {
14799|      0|        while_continue___0: /* CIL Label */;
14800|      0|          if ((int const) * (path + 0) == 46) {
14801|      0|            if (!((int const) * (path + 1) == 47)) {
14802|      0|              goto while_break___0;
14803|      0|            }
14804|      0|          } else {
14805|      0|            goto while_break___0;
14806|      0|          }
14807|      0|          path += 2;
14808|      0|          {
14809|      0|            while (1) {
14810|      0|            while_continue___1: /* CIL Label */;
14811|      0|              if (!((int const) * path == 47)) {
14812|      0|                goto while_break___1;
14813|      0|              }
14814|      0|              path++;
14815|      0|            }
14816|      0|          while_break___1: /* CIL Label */;
14817|      0|          }
14818|      0|        }
14819|      0|      while_break___0: /* CIL Label */;
14820|      0|      }
14821|      0|      if (!*(path + 0)) {
14822|      0|        tmp = 1;
14823|      0|      } else {
14824|      0|        if ((int const) * (path + 0) == 46) {
14825|      0|          if (!*(path + 1)) {
14826|      0|            tmp = 1;
14827|      0|          } else {
14828|      0|            tmp = 0;
14829|      0|          }
14830|      0|        } else {
14831|      0|          tmp = 0;
14832|      0|        }
14833|      0|      }
14834|      0|      return ((_Bool)tmp);
14835|      0|    }
14836|      0|  }
14837|      0|}
14838|      0|static int safer_rmdir(char const *path) {
14839|      0|  int *tmp;
14840|      0|  _Bool tmp___0;
14841|      0|  int tmp___1;
14842|       |
14843|      0|  {
14844|      0|    { tmp___0 = must_be_dot_or_slash(path); }
14845|      0|    if (tmp___0) {
14846|      0|      {
14847|      0|        tmp = __errno_location();
14848|      0|        *tmp = 0;
14849|      0|      }
14850|      0|      return (-1);
14851|      0|    }
14852|      0|    { tmp___1 = rmdir(path); }
14853|      0|    return (tmp___1);
14854|      0|  }
14855|      0|}
14856|      0|int remove_any_file(char const *path, enum remove_option option) {
14857|      0|  int tmp;
14858|      0|  int *tmp___0;
14859|      0|  int *tmp___1;
14860|      0|  int tmp___2;
14861|      0|  int *tmp___3;
14862|      0|  int tmp___4;
14863|      0|  int tmp___5;
14864|      0|  char *directory;
14865|      0|  char *tmp___6;
14866|      0|  char const *entry;
14867|      0|  size_t entrylen;
14868|      0|  char *path_buffer;
14869|      0|  char *tmp___7;
14870|      0|  int r;
14871|      0|  int tmp___8;
14872|      0|  int e;
14873|      0|  int *tmp___9;
14874|      0|  int *tmp___10;
14875|      0|  int tmp___11;
14876|       |
14877|      0|  {
14878|      0|    if (!we_are_root) {
14879|      0|      {
14880|      0|        tmp = unlink(path);
14881|      0|      }
14882|      0|      if (tmp == 0) {
14883|      0|        return (1);
14884|      0|      }
14885|      0|      { tmp___0 = __errno_location(); }
14886|      0|      if (*tmp___0 != 1) {
14887|      0|        {
14888|      0|          tmp___1 = __errno_location();
14889|      0|        }
14890|      0|        if (*tmp___1 != 21) {
14891|      0|          return (0);
14892|      0|        }
14893|      0|      }
14894|      0|    }
14895|      0|    { tmp___2 = safer_rmdir(path); }
14896|      0|    if (tmp___2 == 0) {
14897|      0|      return (1);
14898|      0|    }
14899|      0|    { tmp___3 = __errno_location(); }
14900|      0|    {
14901|      0|      if (*tmp___3 == 20) {
14902|      0|        goto case_20;
14903|      0|      }
14904|      0|      if (*tmp___3 == 0) {
14905|      0|        goto case_0;
14906|      0|      }
14907|      0|      if (*tmp___3 == 17) {
14908|      0|        goto case_0;
14909|      0|      }
14910|      0|      if (*tmp___3 == 39) {
14911|      0|        goto case_0;
14912|      0|      }
14913|      0|      goto switch_break;
14914|      0|    case_20: /* CIL Label */
14915|      0|      if (we_are_root) {
14916|      0|        {
14917|      0|          tmp___4 = unlink(path);
14918|      0|        }
14919|      0|        if (tmp___4 == 0) {
14920|      0|          tmp___5 = 1;
14921|      0|        } else {
14922|      0|          tmp___5 = 0;
14923|      0|        }
14924|      0|      } else {
14925|      0|        tmp___5 = 0;
14926|      0|      }
14927|      0|      return (tmp___5);
14928|      0|    case_0:   /* CIL Label */
14929|      0|    case_17:  /* CIL Label */
14930|      0|    case_39 : /* CIL Label */
14931|      0|    {
14932|      0|      if ((unsigned int)option == 0U) {
14933|      0|        goto case_0___0;
14934|      0|      }
14935|      0|      if ((unsigned int)option == 2U) {
14936|      0|        goto case_2;
14937|      0|      }
14938|      0|      if ((unsigned int)option == 1U) {
14939|      0|        goto case_1;
14940|      0|      }
14941|      0|      goto switch_break___0;
14942|      0|    case_0___0: /* CIL Label */
14943|      0|      goto switch_break___0;
14944|      0|    case_2: /* CIL Label */
14945|      0|      return (-1);
14946|      0|    case_1 : /* CIL Label */
14947|      0|    {
14948|      0|      tmp___6 = savedir(path);
14949|      0|      directory = tmp___6;
14950|      0|    }
14951|      0|      if (!directory) {
14952|      0|        return (0);
14953|      0|      }
14954|      0|      entry = (char const *)directory;
14955|      0|      {
14956|      0|        while (1) {
14957|      0|        while_continue: /* CIL Label */;
14958|      0|          { entrylen = strlen(entry); }
14959|      0|          if (!(entrylen != 0UL)) {
14960|      0|            goto while_break;
14961|      0|          }
14962|      0|          {
14963|      0|            tmp___7 = new_name(path, entry);
14964|      0|            path_buffer = tmp___7;
14965|      0|            tmp___8 = remove_any_file((char const *)path_buffer,
14966|      0|                                      (enum remove_option)1);
14967|      0|            r = tmp___8;
14968|      0|            tmp___9 = __errno_location();
14969|      0|            e = *tmp___9;
14970|      0|            free((void *)path_buffer);
14971|      0|          }
14972|      0|          if (!r) {
14973|      0|            {
14974|      0|              free((void *)directory);
14975|      0|              tmp___10 = __errno_location();
14976|      0|              *tmp___10 = e;
14977|      0|            }
14978|      0|            return (0);
14979|      0|          }
14980|      0|          entry += entrylen + 1UL;
14981|      0|        }
14982|      0|      while_break: /* CIL Label */;
14983|      0|      }
14984|      0|      {
14985|      0|        free((void *)directory);
14986|      0|        tmp___11 = safer_rmdir(path);
14987|      0|      }
14988|      0|      return (tmp___11 == 0);
14989|      0|    switch_break___0: /* CIL Label */;
14990|      0|    }
14991|      0|      goto switch_break;
14992|      0|    switch_break: /* CIL Label */;
14993|      0|    }
14994|      0|    return (0);
14995|      0|  }
14996|      0|}
14997|      0|_Bool maybe_backup_file(char const *path, int this_is_the_archive) {
14998|      0|  struct stat file_stat;
14999|      0|  void *tmp;
15000|      0|  int *tmp___0;
15001|      0|  int tmp___1;
15002|      0|  char const *tmp___2;
15003|      0|  char const *tmp___3;
15004|      0|  char *tmp___4;
15005|      0|  int e;
15006|      0|  int *tmp___5;
15007|      0|  char const *tmp___6;
15008|      0|  char *tmp___7;
15009|      0|  char *tmp___8;
15010|      0|  int tmp___9;
15011|      0|  void *__cil_tmp16;
15012|      0|  char *__cil_tmp17;
15013|      0|  char *__cil_tmp18;
15014|       |
15015|      0|  {
15016|      0|    if (this_is_the_archive) {
15017|      0|      if (!force_local_option) {
15018|      0|        {
15019|      0|          rmt_path__ = strchr(path, ':');
15020|      0|        }
15021|      0|        if (rmt_path__) {
15022|      0|          if ((unsigned long)rmt_path__ > (unsigned long)path) {
15023|      0|            {
15024|      0|              tmp = memchr((void const *)path, '/',
15025|      0|                           (size_t)(rmt_path__ - (char *)path));
15026|      0|            }
15027|      0|            if (!tmp) {
15028|      0|              return ((_Bool)1);
15029|      0|            }
15030|      0|          }
15031|      0|        }
15032|      0|      }
15033|      0|    }
15034|      0|    {
15035|      0|      tmp___1 = stat((char const * /* __restrict  */)path,
15036|      0|                     (struct stat * /* __restrict  */)(&file_stat));
15037|      0|    }
15038|      0|    if (tmp___1) {
15039|      0|      {
15040|      0|        tmp___0 = __errno_location();
15041|      0|      }
15042|      0|      if (*tmp___0 == 2) {
15043|      0|        return ((_Bool)1);
15044|      0|      }
15045|      0|      { stat_error(path); }
15046|      0|      return ((_Bool)0);
15047|      0|    }
15048|      0|    if ((file_stat.st_mode & 61440U) == 16384U) {
15049|      0|      return ((_Bool)1);
15050|      0|    }
15051|      0|    if (this_is_the_archive) {
15052|      0|      if ((file_stat.st_mode & 61440U) == 24576U) {
15053|      0|        return ((_Bool)1);
15054|      0|      } else {
15055|      0|        if ((file_stat.st_mode & 61440U) == 8192U) {
15056|      0|          return ((_Bool)1);
15057|      0|        }
15058|      0|      }
15059|      0|    }
15060|      0|    {
15061|      0|      assign_string(&before_backup_name, path);
15062|      0|      assign_string(&after_backup_name, (char const *)0);
15063|      0|      after_backup_name = find_backup_file_name(path, backup_type);
15064|      0|    }
15065|      0|    if (!after_backup_name) {
15066|      0|      {
15067|      0|        xalloc_die();
15068|      0|      }
15069|      0|    }
15070|      0|    {
15071|      0|      tmp___9 = rename((char const *)before_backup_name,
15072|      0|                       (char const *)after_backup_name);
15073|      0|    }
15074|      0|    if (tmp___9 == 0) {
15075|      0|      if (verbose_option) {
15076|      0|        {
15077|      0|          tmp___2 = quote_n(1, (char const *)after_backup_name);
15078|      0|          tmp___3 = quote_n(0, (char const *)before_backup_name);
15079|      0|          tmp___4 = gettext("Renaming %s to %s\n");
15080|      0|          fprintf((FILE * /* __restrict  */) stdlis,
15081|      0|                  (char const * /* __restrict  */)tmp___4, tmp___3, tmp___2);
15082|      0|        }
15083|      0|      }
15084|      0|      return ((_Bool)1);
15085|      0|    } else {
15086|      0|      {
15087|      0|        tmp___5 = __errno_location();
15088|      0|        e = *tmp___5;
15089|      0|        tmp___6 = quote_n(1, (char const *)after_backup_name);
15090|      0|        tmp___7 = quotearg_colon((char const *)before_backup_name);
15091|      0|        tmp___8 = gettext("%s: Cannot rename to %s");
15092|      0|        error(0, e, (char const *)tmp___8, tmp___7, tmp___6);
15093|      0|        exit_status = 2;
15094|      0|        assign_string(&after_backup_name, (char const *)0);
15095|      0|      }
15096|      0|      return ((_Bool)0);
15097|      0|    }
15098|      0|  }
15099|      0|}
15100|      0|void undo_last_backup(void) {
15101|      0|  int e;
15102|      0|  int *tmp;
15103|      0|  char const *tmp___0;
15104|      0|  char *tmp___1;
15105|      0|  char *tmp___2;
15106|      0|  int tmp___3;
15107|      0|  char const *tmp___4;
15108|      0|  char const *tmp___5;
15109|      0|  char *tmp___6;
15110|      0|  char *__cil_tmp10;
15111|      0|  char *__cil_tmp11;
15112|       |
15113|      0|  {
15114|      0|    if (after_backup_name) {
15115|      0|      {
15116|      0|        tmp___3 = rename((char const *)after_backup_name,
15117|      0|                         (char const *)before_backup_name);
15118|      0|      }
15119|      0|      if (tmp___3 != 0) {
15120|      0|        {
15121|      0|          tmp = __errno_location();
15122|      0|          e = *tmp;
15123|      0|          tmp___0 = quote_n(1, (char const *)before_backup_name);
15124|      0|          tmp___1 = quotearg_colon((char const *)after_backup_name);
15125|      0|          tmp___2 = gettext("%s: Cannot rename to %s");
15126|      0|          error(0, e, (char const *)tmp___2, tmp___1, tmp___0);
15127|      0|          exit_status = 2;
15128|      0|        }
15129|      0|      }
15130|      0|      if (verbose_option) {
15131|      0|        {
15132|      0|          tmp___4 = quote_n(1, (char const *)before_backup_name);
15133|      0|          tmp___5 = quote_n(0, (char const *)after_backup_name);
15134|      0|          tmp___6 = gettext("Renaming %s back to %s\n");
15135|      0|          fprintf((FILE * /* __restrict  */) stdlis,
15136|      0|                  (char const * /* __restrict  */)tmp___6, tmp___5, tmp___4);
15137|      0|        }
15138|      0|      }
15139|      0|      { assign_string(&after_backup_name, (char const *)0); }
15140|      0|    }
15141|      0|    return;
15142|      0|  }
15143|      0|}
15144|      0|int deref_stat(_Bool deref, char const *name, struct stat *buf) {
15145|      0|  int tmp;
15146|      0|  int tmp___0;
15147|      0|  int tmp___1;
15148|       |
15149|      0|  {
15150|      0|    if (deref) {
15151|      0|      {
15152|      0|        tmp = stat((char const * /* __restrict  */)name,
15153|      0|                   (struct stat * /* __restrict  */) buf);
15154|      0|        tmp___1 = tmp;
15155|      0|      }
15156|      0|    } else {
15157|      0|      {
15158|      0|        tmp___0 = lstat((char const * /* __restrict  */)name,
15159|      0|                        (struct stat * /* __restrict  */) buf);
15160|      0|        tmp___1 = tmp___0;
15161|      0|      }
15162|      0|    }
15163|      0|    return (tmp___1);
15164|      0|  }
15165|      0|}
15166|       |static struct wd *wd;
15167|       |static size_t wds;
15168|       |static size_t wd_alloc;
15169|      0|int chdir_arg(char const *dir) {
15170|      0|  void *tmp;
15171|      0|  size_t tmp___0;
15172|      0|  char *__cil_tmp4;
15173|       |
15174|      0|  {
15175|      0|    if (wds == wd_alloc) {
15176|      0|      {
15177|      0|        wd_alloc = 2UL * (wd_alloc + 1UL);
15178|      0|        tmp = xrealloc((void *)wd, sizeof(*wd) * wd_alloc);
15179|      0|        wd = (struct wd *)tmp;
15180|      0|      }
15181|      0|      if (!wds) {
15182|      0|        (wd + wds)->name = ".";
15183|      0|        (wd + wds)->saved = 0;
15184|      0|        wds++;
15185|      0|      }
15186|      0|    }
15187|      0|    if (*(dir + 0)) {
15188|      0|      {
15189|      0|        while (1) {
15190|      0|        while_continue: /* CIL Label */;
15191|      0|          if ((int const) * (dir + 0) == 46) {
15192|      0|            if (!((int const) * (dir + 1) == 47)) {
15193|      0|              goto while_break;
15194|      0|            }
15195|      0|          } else {
15196|      0|            goto while_break;
15197|      0|          }
15198|      0|          dir += 2;
15199|      0|          {
15200|      0|            while (1) {
15201|      0|            while_continue___0: /* CIL Label */;
15202|      0|              if (!((int const) * dir == 47)) {
15203|      0|                goto while_break___0;
15204|      0|              }
15205|      0|              goto __Cont;
15206|      0|            __Cont:
15207|      0|              dir++;
15208|      0|            }
15209|      0|          while_break___0: /* CIL Label */;
15210|      0|          }
15211|      0|        }
15212|      0|      while_break: /* CIL Label */;
15213|      0|      }
15214|      0|      if (!*(dir + ((int const) * (dir + 0) == 46))) {
15215|      0|        return ((int)(wds - 1UL));
15216|      0|      }
15217|      0|    }
15218|      0|    (wd + wds)->name = dir;
15219|      0|    (wd + wds)->saved = 0;
15220|      0|    tmp___0 = wds;
15221|      0|    wds++;
15222|      0|    return ((int)tmp___0);
15223|      0|  }
15224|      0|}
15225|       |static int previous;
15226|      0|void chdir_do(int i) {
15227|      0|  struct wd *prev;
15228|      0|  struct wd *curr;
15229|      0|  char *tmp;
15230|      0|  int tmp___0;
15231|      0|  char *tmp___1;
15232|      0|  int tmp___2;
15233|      0|  int tmp___3;
15234|      0|  char *__cil_tmp9;
15235|      0|  char *__cil_tmp10;
15236|       |
15237|      0|  {
15238|      0|    if (previous != i) {
15239|      0|      prev = wd + previous;
15240|      0|      curr = wd + i;
15241|      0|      if (!prev->saved) {
15242|      0|        {
15243|      0|          prev->saved = 1;
15244|      0|          tmp___0 = save_cwd(&prev->saved_cwd);
15245|      0|        }
15246|      0|        if (tmp___0 != 0) {
15247|      0|          {
15248|      0|            tmp = gettext("Cannot save working directory");
15249|      0|            error(0, 0, (char const *)tmp);
15250|      0|            fatal_exit();
15251|      0|          }
15252|      0|        }
15253|      0|      }
15254|      0|      if (curr->saved) {
15255|      0|        {
15256|      0|          tmp___2 = restore_cwd((struct saved_cwd const *)(&curr->saved_cwd));
15257|      0|        }
15258|      0|        if (tmp___2) {
15259|      0|          {
15260|      0|            tmp___1 = gettext("Cannot change working directory");
15261|      0|            error(0, 0, (char const *)tmp___1);
15262|      0|            fatal_exit();
15263|      0|          }
15264|      0|        }
15265|      0|      } else {
15266|      0|        if (i) {
15267|      0|          if (!((int const) * (curr->name + 0) == 47)) {
15268|      0|            {
15269|      0|              chdir_do(i - 1);
15270|      0|            }
15271|      0|          }
15272|      0|        }
15273|      0|        { tmp___3 = chdir(curr->name); }
15274|      0|        if (tmp___3 != 0) {
15275|      0|          {
15276|      0|            chdir_fatal(curr->name);
15277|      0|          }
15278|      0|        }
15279|      0|      }
15280|      0|      previous = i;
15281|      0|    }
15282|      0|    return;
15283|      0|  }
15284|      0|}
15285|      0|void decode_mode(mode_t mode, char *string) {
15286|      0|  char *tmp;
15287|      0|  char *tmp___0;
15288|      0|  char *tmp___1;
15289|      0|  char *tmp___2;
15290|      0|  char *tmp___3;
15291|      0|  char *tmp___4;
15292|      0|  char *tmp___5;
15293|      0|  char *tmp___6;
15294|      0|  char *tmp___7;
15295|      0|  int tmp___8;
15296|      0|  int tmp___9;
15297|      0|  int tmp___10;
15298|      0|  int tmp___11;
15299|      0|  int tmp___12;
15300|      0|  int tmp___13;
15301|      0|  int tmp___14;
15302|      0|  int tmp___15;
15303|      0|  int tmp___16;
15304|      0|  int tmp___17;
15305|      0|  int tmp___18;
15306|      0|  int tmp___19;
15307|      0|  int tmp___20;
15308|      0|  int tmp___21;
15309|      0|  int tmp___22;
15310|       |
15311|      0|  {
15312|      0|    tmp = string;
15313|      0|    string++;
15314|      0|    if (mode & 256U) {
15315|      0|      tmp___8 = 'r';
15316|      0|    } else {
15317|      0|      tmp___8 = '-';
15318|      0|    }
15319|      0|    *tmp = (char)tmp___8;
15320|      0|    tmp___0 = string;
15321|      0|    string++;
15322|      0|    if (mode & 128U) {
15323|      0|      tmp___9 = 'w';
15324|      0|    } else {
15325|      0|      tmp___9 = '-';
15326|      0|    }
15327|      0|    *tmp___0 = (char)tmp___9;
15328|      0|    tmp___1 = string;
15329|      0|    string++;
15330|      0|    if (mode & 2048U) {
15331|      0|      if (mode & 64U) {
15332|      0|        tmp___10 = 's';
15333|      0|      } else {
15334|      0|        tmp___10 = 'S';
15335|      0|      }
15336|      0|      tmp___12 = tmp___10;
15337|      0|    } else {
15338|      0|      if (mode & 64U) {
15339|      0|        tmp___11 = 'x';
15340|      0|      } else {
15341|      0|        tmp___11 = '-';
15342|      0|      }
15343|      0|      tmp___12 = tmp___11;
15344|      0|    }
15345|      0|    *tmp___1 = (char)tmp___12;
15346|      0|    tmp___2 = string;
15347|      0|    string++;
15348|      0|    if (mode & (unsigned int)(256 >> 3)) {
15349|      0|      tmp___13 = 'r';
15350|      0|    } else {
15351|      0|      tmp___13 = '-';
15352|      0|    }
15353|      0|    *tmp___2 = (char)tmp___13;
15354|      0|    tmp___3 = string;
15355|      0|    string++;
15356|      0|    if (mode & (unsigned int)(128 >> 3)) {
15357|      0|      tmp___14 = 'w';
15358|      0|    } else {
15359|      0|      tmp___14 = '-';
15360|      0|    }
15361|      0|    *tmp___3 = (char)tmp___14;
15362|      0|    tmp___4 = string;
15363|      0|    string++;
15364|      0|    if (mode & 1024U) {
15365|      0|      if (mode & (unsigned int)(64 >> 3)) {
15366|      0|        tmp___15 = 's';
15367|      0|      } else {
15368|      0|        tmp___15 = 'S';
15369|      0|      }
15370|      0|      tmp___17 = tmp___15;
15371|      0|    } else {
15372|      0|      if (mode & (unsigned int)(64 >> 3)) {
15373|      0|        tmp___16 = 'x';
15374|      0|      } else {
15375|      0|        tmp___16 = '-';
15376|      0|      }
15377|      0|      tmp___17 = tmp___16;
15378|      0|    }
15379|      0|    *tmp___4 = (char)tmp___17;
15380|      0|    tmp___5 = string;
15381|      0|    string++;
15382|      0|    if (mode & (unsigned int)((256 >> 3) >> 3)) {
15383|      0|      tmp___18 = 'r';
15384|      0|    } else {
15385|      0|      tmp___18 = '-';
15386|      0|    }
15387|      0|    *tmp___5 = (char)tmp___18;
15388|      0|    tmp___6 = string;
15389|      0|    string++;
15390|      0|    if (mode & (unsigned int)((128 >> 3) >> 3)) {
15391|      0|      tmp___19 = 'w';
15392|      0|    } else {
15393|      0|      tmp___19 = '-';
15394|      0|    }
15395|      0|    *tmp___6 = (char)tmp___19;
15396|      0|    tmp___7 = string;
15397|      0|    string++;
15398|      0|    if (mode & 512U) {
15399|      0|      if (mode & (unsigned int)((64 >> 3) >> 3)) {
15400|      0|        tmp___20 = 't';
15401|      0|      } else {
15402|      0|        tmp___20 = 'T';
15403|      0|      }
15404|      0|      tmp___22 = tmp___20;
15405|      0|    } else {
15406|      0|      if (mode & (unsigned int)((64 >> 3) >> 3)) {
15407|      0|        tmp___21 = 'x';
15408|      0|      } else {
15409|      0|        tmp___21 = '-';
15410|      0|      }
15411|      0|      tmp___22 = tmp___21;
15412|      0|    }
15413|      0|    *tmp___7 = (char)tmp___22;
15414|      0|    *string = (char)'\000';
15415|      0|    return;
15416|      0|  }
15417|      0|}
15418|      0|static void call_arg_error(char const *call, char const *name) {
15419|      0|  int e;
15420|      0|  int *tmp;
15421|      0|  char *tmp___0;
15422|      0|  char *tmp___1;
15423|      0|  char *__cil_tmp7;
15424|       |
15425|      0|  {
15426|      0|    {
15427|      0|      tmp = __errno_location();
15428|      0|      e = *tmp;
15429|      0|      tmp___0 = quotearg_colon(name);
15430|      0|      tmp___1 = gettext("%s: Cannot %s");
15431|      0|      error(0, e, (char const *)tmp___1, tmp___0, call);
15432|      0|      exit_status = 2;
15433|      0|    }
15434|      0|    return;
15435|      0|  }
15436|      0|}
15437|       |static __attribute__((__noreturn__)) void call_arg_fatal(char const *call,
15438|       |                                                         char const *name);
15439|      0|static void call_arg_fatal(char const *call, char const *name) {
15440|      0|  int e;
15441|      0|  int *tmp;
15442|      0|  char *tmp___0;
15443|      0|  char *tmp___1;
15444|      0|  char *__cil_tmp7;
15445|       |
15446|      0|  {
15447|      0|    {
15448|      0|      tmp = __errno_location();
15449|      0|      e = *tmp;
15450|      0|      tmp___0 = quotearg_colon(name);
15451|      0|      tmp___1 = gettext("%s: Cannot %s");
15452|      0|      error(0, e, (char const *)tmp___1, tmp___0, call);
15453|      0|      fatal_exit();
15454|      0|    }
15455|      0|  }
15456|      0|}
15457|      0|static void call_arg_warn(char const *call, char const *name) {
15458|      0|  int e;
15459|      0|  int *tmp;
15460|      0|  char *tmp___0;
15461|      0|  char *tmp___1;
15462|      0|  char *__cil_tmp7;
15463|       |
15464|      0|  {
15465|      0|    {
15466|      0|      tmp = __errno_location();
15467|      0|      e = *tmp;
15468|      0|      tmp___0 = quotearg_colon(name);
15469|      0|      tmp___1 = gettext("%s: Warning: Cannot %s");
15470|      0|      error(0, e, (char const *)tmp___1, tmp___0, call);
15471|      0|    }
15472|      0|    return;
15473|      0|  }
15474|      0|}
15475|       |__attribute__((__noreturn__)) void chdir_fatal(char const *name);
15476|      0|void chdir_fatal(char const *name) {
15477|      0|  char *__cil_tmp2;
15478|       |
15479|      0|  {
15480|      0|    { call_arg_fatal("chdir", name); }
15481|      0|  }
15482|      0|}
15483|      0|void chmod_error_details(char const *name, mode_t mode) {
15484|      0|  int e;
15485|      0|  int *tmp;
15486|      0|  char buf[10];
15487|      0|  char *tmp___0;
15488|      0|  char *tmp___1;
15489|      0|  void *__cil_tmp8;
15490|      0|  char *__cil_tmp9;
15491|       |
15492|      0|  {
15493|      0|    {
15494|      0|      tmp = __errno_location();
15495|      0|      e = *tmp;
15496|      0|      decode_mode(mode, buf);
15497|      0|      tmp___0 = quotearg_colon(name);
15498|      0|      tmp___1 = gettext("%s: Cannot change mode to %s");
15499|      0|      error(0, e, (char const *)tmp___1, tmp___0, buf);
15500|      0|      exit_status = 2;
15501|      0|    }
15502|      0|    return;
15503|      0|  }
15504|      0|}
15505|      0|void chown_error_details(char const *name, uid_t uid, gid_t gid) {
15506|      0|  int e;
15507|      0|  int *tmp;
15508|      0|  char *tmp___0;
15509|      0|  char *tmp___1;
15510|      0|  char *__cil_tmp8;
15511|       |
15512|      0|  {
15513|      0|    {
15514|      0|      tmp = __errno_location();
15515|      0|      e = *tmp;
15516|      0|      tmp___0 = quotearg_colon(name);
15517|      0|      tmp___1 = gettext("%s: Cannot change ownership to uid %lu, gid %lu");
15518|      0|      error(0, e, (char const *)tmp___1, tmp___0, (unsigned long)uid,
15519|      0|            (unsigned long)gid);
15520|      0|      exit_status = 2;
15521|      0|    }
15522|      0|    return;
15523|      0|  }
15524|      0|}
15525|      0|void close_error(char const *name) {
15526|      0|  char *__cil_tmp2;
15527|       |
15528|      0|  {
15529|      0|    { call_arg_error("close", name); }
15530|      0|    return;
15531|      0|  }
15532|      0|}
15533|      0|void close_warn(char const *name) {
15534|      0|  char *__cil_tmp2;
15535|       |
15536|      0|  {
15537|      0|    { call_arg_warn("close", name); }
15538|      0|    return;
15539|      0|  }
15540|      0|}
15541|      0|void close_diag(char const *name) {
15542|       |
15543|      0|  {
15544|      0|    if (ignore_failed_read_option) {
15545|      0|      {
15546|      0|        close_warn(name);
15547|      0|      }
15548|      0|    } else {
15549|      0|      { close_error(name); }
15550|      0|    }
15551|      0|    return;
15552|      0|  }
15553|      0|}
15554|       |__attribute__((__noreturn__)) void exec_fatal(char const *name);
15555|      0|void exec_fatal(char const *name) {
15556|      0|  char *__cil_tmp2;
15557|       |
15558|      0|  {
15559|      0|    { call_arg_fatal("exec", name); }
15560|      0|  }
15561|      0|}
15562|      0|void link_error(char const *target, char const *source) {
15563|      0|  int e;
15564|      0|  int *tmp;
15565|      0|  char const *tmp___0;
15566|      0|  char *tmp___1;
15567|      0|  char *tmp___2;
15568|      0|  char *__cil_tmp8;
15569|       |
15570|      0|  {
15571|      0|    {
15572|      0|      tmp = __errno_location();
15573|      0|      e = *tmp;
15574|      0|      tmp___0 = quote_n(1, target);
15575|      0|      tmp___1 = quotearg_colon(source);
15576|      0|      tmp___2 = gettext("%s: Cannot hard link to %s");
15577|      0|      error(0, e, (char const *)tmp___2, tmp___1, tmp___0);
15578|      0|      exit_status = 2;
15579|      0|    }
15580|      0|    return;
15581|      0|  }
15582|      0|}
15583|      0|void mkdir_error(char const *name) {
15584|      0|  char *__cil_tmp2;
15585|       |
15586|      0|  {
15587|      0|    { call_arg_error("mkdir", name); }
15588|      0|    return;
15589|      0|  }
15590|      0|}
15591|      0|void mkfifo_error(char const *name) {
15592|      0|  char *__cil_tmp2;
15593|       |
15594|      0|  {
15595|      0|    { call_arg_error("mkfifo", name); }
15596|      0|    return;
15597|      0|  }
15598|      0|}
15599|      0|void mknod_error(char const *name) {
15600|      0|  char *__cil_tmp2;
15601|       |
15602|      0|  {
15603|      0|    { call_arg_error("mknod", name); }
15604|      0|    return;
15605|      0|  }
15606|      0|}
15607|      0|void open_error(char const *name) {
15608|      0|  char *__cil_tmp2;
15609|       |
15610|      0|  {
15611|      0|    { call_arg_error("open", name); }
15612|      0|    return;
15613|      0|  }
15614|      0|}
15615|       |__attribute__((__noreturn__)) void open_fatal(char const *name);
15616|      0|void open_fatal(char const *name) {
15617|      0|  char *__cil_tmp2;
15618|       |
15619|      0|  {
15620|      0|    { call_arg_fatal("open", name); }
15621|      0|  }
15622|      0|}
15623|      0|void open_warn(char const *name) {
15624|      0|  char *__cil_tmp2;
15625|       |
15626|      0|  {
15627|      0|    { call_arg_warn("open", name); }
15628|      0|    return;
15629|      0|  }
15630|      0|}
15631|      0|void open_diag(char const *name) {
15632|       |
15633|      0|  {
15634|      0|    if (ignore_failed_read_option) {
15635|      0|      {
15636|      0|        open_warn(name);
15637|      0|      }
15638|      0|    } else {
15639|      0|      { open_error(name); }
15640|      0|    }
15641|      0|    return;
15642|      0|  }
15643|      0|}
15644|      0|void read_error(char const *name) {
15645|      0|  char *__cil_tmp2;
15646|       |
15647|      0|  {
15648|      0|    { call_arg_error("read", name); }
15649|      0|    return;
15650|      0|  }
15651|      0|}
15652|      0|void read_error_details(char const *name, off_t offset, size_t size) {
15653|      0|  char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
15654|      0|  int e;
15655|      0|  int *tmp;
15656|      0|  char *tmp___0;
15657|      0|  char *tmp___1;
15658|      0|  char *tmp___2;
15659|      0|  void *__cil_tmp10;
15660|       |
15661|      0|  {
15662|      0|    {
15663|      0|      tmp = __errno_location();
15664|      0|      e = *tmp;
15665|      0|      tmp___0 = stringify_uintmax_t_backwards(
15666|      0|          (uintmax_t)offset,
15667|      0|          buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
15668|      0|      tmp___1 = quotearg_colon(name);
15669|      0|      tmp___2 = ngettext("%s: Read error at byte %s, reading %lu byte",
15670|      0|                         "%s: Read error at byte %s, reading %lu bytes", size);
15671|      0|      error(0, e, (char const *)tmp___2, tmp___1, tmp___0, size);
15672|      0|      exit_status = 2;
15673|      0|    }
15674|      0|    return;
15675|      0|  }
15676|      0|}
15677|      0|void read_warn_details(char const *name, off_t offset, size_t size) {
15678|      0|  char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
15679|      0|  int e;
15680|      0|  int *tmp;
15681|      0|  char *tmp___0;
15682|      0|  char *tmp___1;
15683|      0|  char *tmp___2;
15684|      0|  void *__cil_tmp10;
15685|       |
15686|      0|  {
15687|      0|    {
15688|      0|      tmp = __errno_location();
15689|      0|      e = *tmp;
15690|      0|      tmp___0 = stringify_uintmax_t_backwards(
15691|      0|          (uintmax_t)offset,
15692|      0|          buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
15693|      0|      tmp___1 = quotearg_colon(name);
15694|      0|      tmp___2 = ngettext(
15695|      0|          "%s: Warning: Read error at byte %s, reading %lu byte",
15696|      0|          "%s: Warning: Read error at byte %s, reading %lu bytes", size);
15697|      0|      error(0, e, (char const *)tmp___2, tmp___1, tmp___0, size);
15698|      0|    }
15699|      0|    return;
15700|      0|  }
15701|      0|}
15702|      0|void read_diag_details(char const *name, off_t offset, size_t size) {
15703|       |
15704|      0|  {
15705|      0|    if (ignore_failed_read_option) {
15706|      0|      {
15707|      0|        read_warn_details(name, offset, size);
15708|      0|      }
15709|      0|    } else {
15710|      0|      { read_error_details(name, offset, size); }
15711|      0|    }
15712|      0|    return;
15713|      0|  }
15714|      0|}
15715|       |__attribute__((__noreturn__)) void read_fatal(char const *name);
15716|      0|void read_fatal(char const *name) {
15717|      0|  char *__cil_tmp2;
15718|       |
15719|      0|  {
15720|      0|    { call_arg_fatal("read", name); }
15721|      0|  }
15722|      0|}
15723|       |__attribute__((__noreturn__)) void
15724|       |read_fatal_details(char const *name, off_t offset, size_t size);
15725|      0|void read_fatal_details(char const *name, off_t offset, size_t size) {
15726|      0|  char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
15727|      0|  int e;
15728|      0|  int *tmp;
15729|      0|  char *tmp___0;
15730|      0|  char *tmp___1;
15731|      0|  char *tmp___2;
15732|      0|  void *__cil_tmp10;
15733|       |
15734|      0|  {
15735|      0|    {
15736|      0|      tmp = __errno_location();
15737|      0|      e = *tmp;
15738|      0|      tmp___0 = stringify_uintmax_t_backwards(
15739|      0|          (uintmax_t)offset,
15740|      0|          buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
15741|      0|      tmp___1 = quotearg_colon(name);
15742|      0|      tmp___2 = ngettext("%s: Read error at byte %s, reading %lu byte",
15743|      0|                         "%s: Read error at byte %s, reading %lu bytes", size);
15744|      0|      error(0, e, (char const *)tmp___2, tmp___1, tmp___0, size);
15745|      0|      fatal_exit();
15746|      0|    }
15747|      0|  }
15748|      0|}
15749|      0|void readlink_error(char const *name) {
15750|      0|  char *__cil_tmp2;
15751|       |
15752|      0|  {
15753|      0|    { call_arg_error("readlink", name); }
15754|      0|    return;
15755|      0|  }
15756|      0|}
15757|      0|void readlink_warn(char const *name) {
15758|      0|  char *__cil_tmp2;
15759|       |
15760|      0|  {
15761|      0|    { call_arg_warn("readlink", name); }
15762|      0|    return;
15763|      0|  }
15764|      0|}
15765|      0|void readlink_diag(char const *name) {
15766|       |
15767|      0|  {
15768|      0|    if (ignore_failed_read_option) {
15769|      0|      {
15770|      0|        readlink_warn(name);
15771|      0|      }
15772|      0|    } else {
15773|      0|      { readlink_error(name); }
15774|      0|    }
15775|      0|    return;
15776|      0|  }
15777|      0|}
15778|      0|void savedir_error(char const *name) {
15779|      0|  char *__cil_tmp2;
15780|       |
15781|      0|  {
15782|      0|    { call_arg_error("savedir", name); }
15783|      0|    return;
15784|      0|  }
15785|      0|}
15786|      0|void savedir_warn(char const *name) {
15787|      0|  char *__cil_tmp2;
15788|       |
15789|      0|  {
15790|      0|    { call_arg_warn("savedir", name); }
15791|      0|    return;
15792|      0|  }
15793|      0|}
15794|      0|void savedir_diag(char const *name) {
15795|       |
15796|      0|  {
15797|      0|    if (ignore_failed_read_option) {
15798|      0|      {
15799|      0|        savedir_warn(name);
15800|      0|      }
15801|      0|    } else {
15802|      0|      { savedir_error(name); }
15803|      0|    }
15804|      0|    return;
15805|      0|  }
15806|      0|}
15807|      0|void seek_error(char const *name) {
15808|      0|  char *__cil_tmp2;
15809|       |
15810|      0|  {
15811|      0|    { call_arg_error("seek", name); }
15812|      0|    return;
15813|      0|  }
15814|      0|}
15815|      0|void seek_error_details(char const *name, off_t offset) {
15816|      0|  char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
15817|      0|  int e;
15818|      0|  int *tmp;
15819|      0|  char *tmp___0;
15820|      0|  char *tmp___1;
15821|      0|  char *tmp___2;
15822|      0|  void *__cil_tmp9;
15823|      0|  char *__cil_tmp10;
15824|       |
15825|      0|  {
15826|      0|    {
15827|      0|      tmp = __errno_location();
15828|      0|      e = *tmp;
15829|      0|      tmp___0 = stringify_uintmax_t_backwards(
15830|      0|          (uintmax_t)offset,
15831|      0|          buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
15832|      0|      tmp___1 = quotearg_colon(name);
15833|      0|      tmp___2 = gettext("%s: Cannot seek to %s");
15834|      0|      error(0, e, (char const *)tmp___2, tmp___1, tmp___0);
15835|      0|      exit_status = 2;
15836|      0|    }
15837|      0|    return;
15838|      0|  }
15839|      0|}
15840|      0|void seek_warn(char const *name) {
15841|      0|  char *__cil_tmp2;
15842|       |
15843|      0|  {
15844|      0|    { call_arg_warn("seek", name); }
15845|      0|    return;
15846|      0|  }
15847|      0|}
15848|      0|void seek_warn_details(char const *name, off_t offset) {
15849|      0|  char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
15850|      0|  int e;
15851|      0|  int *tmp;
15852|      0|  char *tmp___0;
15853|      0|  char *tmp___1;
15854|      0|  char *tmp___2;
15855|      0|  void *__cil_tmp9;
15856|      0|  char *__cil_tmp10;
15857|       |
15858|      0|  {
15859|      0|    {
15860|      0|      tmp = __errno_location();
15861|      0|      e = *tmp;
15862|      0|      tmp___0 = stringify_uintmax_t_backwards(
15863|      0|          (uintmax_t)offset,
15864|      0|          buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL));
15865|      0|      tmp___1 = quotearg_colon(name);
15866|      0|      tmp___2 = gettext("%s: Warning: Cannot seek to %s");
15867|      0|      error(0, e, (char const *)tmp___2, tmp___1, tmp___0);
15868|      0|    }
15869|      0|    return;
15870|      0|  }
15871|      0|}
15872|      0|void seek_diag_details(char const *name, off_t offset) {
15873|       |
15874|      0|  {
15875|      0|    if (ignore_failed_read_option) {
15876|      0|      {
15877|      0|        seek_warn_details(name, offset);
15878|      0|      }
15879|      0|    } else {
15880|      0|      { seek_error_details(name, offset); }
15881|      0|    }
15882|      0|    return;
15883|      0|  }
15884|      0|}
15885|      0|void symlink_error(char const *contents, char const *name) {
15886|      0|  int e;
15887|      0|  int *tmp;
15888|      0|  char const *tmp___0;
15889|      0|  char *tmp___1;
15890|      0|  char *tmp___2;
15891|      0|  char *__cil_tmp8;
15892|       |
15893|      0|  {
15894|      0|    {
15895|      0|      tmp = __errno_location();
15896|      0|      e = *tmp;
15897|      0|      tmp___0 = quote_n(1, contents);
15898|      0|      tmp___1 = quotearg_colon(name);
15899|      0|      tmp___2 = gettext("%s: Cannot create symlink to %s");
15900|      0|      error(0, e, (char const *)tmp___2, tmp___1, tmp___0);
15901|      0|      exit_status = 2;
15902|      0|    }
15903|      0|    return;
15904|      0|  }
15905|      0|}
15906|      0|void stat_error(char const *name) {
15907|      0|  char *__cil_tmp2;
15908|       |
15909|      0|  {
15910|      0|    { call_arg_error("stat", name); }
15911|      0|    return;
15912|      0|  }
15913|      0|}
15914|      0|void stat_warn(char const *name) {
15915|      0|  char *__cil_tmp2;
15916|       |
15917|      0|  {
15918|      0|    { call_arg_warn("stat", name); }
15919|      0|    return;
15920|      0|  }
15921|      0|}
15922|      0|void stat_diag(char const *name) {
15923|       |
15924|      0|  {
15925|      0|    if (ignore_failed_read_option) {
15926|      0|      {
15927|      0|        stat_warn(name);
15928|      0|      }
15929|      0|    } else {
15930|      0|      { stat_error(name); }
15931|      0|    }
15932|      0|    return;
15933|      0|  }
15934|      0|}
15935|      0|void truncate_error(char const *name) {
15936|      0|  char *__cil_tmp2;
15937|       |
15938|      0|  {
15939|      0|    { call_arg_error("truncate", name); }
15940|      0|    return;
15941|      0|  }
15942|      0|}
15943|      0|void truncate_warn(char const *name) {
15944|      0|  char *__cil_tmp2;
15945|       |
15946|      0|  {
15947|      0|    { call_arg_warn("truncate", name); }
15948|      0|    return;
15949|      0|  }
15950|      0|}
15951|      0|void unlink_error(char const *name) {
15952|      0|  char *__cil_tmp2;
15953|       |
15954|      0|  {
15955|      0|    { call_arg_error("unlink", name); }
15956|      0|    return;
15957|      0|  }
15958|      0|}
15959|      0|void utime_error(char const *name) {
15960|      0|  char *__cil_tmp2;
15961|       |
15962|      0|  {
15963|      0|    { call_arg_error("utime", name); }
15964|      0|    return;
15965|      0|  }
15966|      0|}
15967|      0|void waitpid_error(char const *name) {
15968|      0|  char *__cil_tmp2;
15969|       |
15970|      0|  {
15971|      0|    { call_arg_error("waitpid", name); }
15972|      0|    return;
15973|      0|  }
15974|      0|}
15975|      0|void write_error(char const *name) {
15976|      0|  char *__cil_tmp2;
15977|       |
15978|      0|  {
15979|      0|    { call_arg_error("write", name); }
15980|      0|    return;
15981|      0|  }
15982|      0|}
15983|      0|void write_error_details(char const *name, size_t status, size_t size) {
15984|      0|  char *tmp;
15985|       |
15986|      0|  {
15987|      0|    if (status == 0UL) {
15988|      0|      {
15989|      0|        write_error(name);
15990|      0|      }
15991|      0|    } else {
15992|      0|      {
15993|      0|        tmp = ngettext("%s: Wrote only %lu of %lu byte",
15994|      0|                       "%s: Wrote only %lu of %lu bytes", size);
15995|      0|        error(0, 0, (char const *)tmp, name, status, size);
15996|      0|        exit_status = 2;
15997|      0|      }
15998|      0|    }
15999|      0|    return;
16000|      0|  }
16001|      0|}
16002|       |__attribute__((__noreturn__)) void
16003|       |write_fatal_details(char const *name, ssize_t status, size_t size);
16004|      0|void write_fatal_details(char const *name, ssize_t status, size_t size) {
16005|       |
16006|      0|  {
16007|      0|    {
16008|      0|      write_error_details(name, (size_t)status, size);
16009|      0|      fatal_exit();
16010|      0|    }
16011|      0|  }
16012|      0|}
16013|      0|pid_t xfork(void) {
16014|      0|  pid_t p;
16015|      0|  __pid_t tmp;
16016|      0|  char *tmp___0;
16017|      0|  char *__cil_tmp4;
16018|      0|  char *__cil_tmp5;
16019|       |
16020|      0|  {
16021|      0|    {
16022|      0|      tmp = fork();
16023|      0|      p = tmp;
16024|      0|    }
16025|      0|    if (p == -1) {
16026|      0|      {
16027|      0|        tmp___0 = gettext("child process");
16028|      0|        call_arg_fatal("fork", (char const *)tmp___0);
16029|      0|      }
16030|      0|    }
16031|      0|    return (p);
16032|      0|  }
16033|      0|}
16034|      0|void xpipe(int *fd) {
16035|      0|  char *tmp;
16036|      0|  int tmp___0;
16037|      0|  char *__cil_tmp4;
16038|      0|  char *__cil_tmp5;
16039|       |
16040|      0|  {
16041|      0|    { tmp___0 = pipe(fd); }
16042|      0|    if (tmp___0 < 0) {
16043|      0|      {
16044|      0|        tmp = gettext("interprocess channel");
16045|      0|        call_arg_fatal("pipe", (char const *)tmp);
16046|      0|      }
16047|      0|    }
16048|      0|    return;
16049|      0|  }
16050|      0|}
16051|      0|char const *quote_n(int n, char const *name) {
16052|      0|  char *tmp;
16053|       |
16054|      0|  {
16055|      0|    { tmp = quotearg_n_style(n, (enum quoting_style)5, name); }
16056|      0|    return ((char const *)tmp);
16057|      0|  }
16058|      0|}
16059|      0|char const *quote(char const *name) {
16060|      0|  char const *tmp;
16061|       |
16062|      0|  {
16063|      0|    { tmp = quote_n(0, name); }
16064|      0|    return (tmp);
16065|      0|  }
16066|      0|}
16067|       |/* #pragma merger("0","00a.names.o.i","") */
16068|       |extern int getc_unlocked(FILE *__stream);
16069|       |extern struct passwd *getpwuid(__uid_t __uid);
16070|       |extern struct passwd *getpwnam(char const *__name);
16071|       |extern struct group *getgrgid(__gid_t __gid);
16072|       |extern struct group *getgrnam(char const *__name);
16073|       |_Bool excluded_filename(struct exclude const *ex, char const *f);
16074|       |char filename_terminator;
16075|       |struct exclude *excluded;
16076|       |char const *files_from_option;
16077|       |_Bool same_order_option;
16078|       |_Bool starting_file_option;
16079|       |void init_names(void);
16080|       |void name_add(char const *name);
16081|       |void name_init(void);
16082|       |void name_term(void);
16083|       |void name_close(void);
16084|       |struct name *addname(char const *string, int change_dir___0);
16085|       |void add_avoided_name(char const *name);
16086|       |void request_stdin(char const *option);
16087|       |static char *cached_uname;
16088|       |static char *cached_gname;
16089|       |static uid_t cached_uid;
16090|       |static gid_t cached_gid;
16091|       |static char *cached_no_such_uname;
16092|       |static char *cached_no_such_gname;
16093|       |static uid_t cached_no_such_uid;
16094|       |static gid_t cached_no_such_gid;
16095|      0|void uid_to_uname(uid_t uid, char **uname) {
16096|      0|  struct passwd *passwd;
16097|      0|  char *__cil_tmp4;
16098|      0|  char *__cil_tmp5;
16099|       |
16100|      0|  {
16101|      0|    if (uid != 0U) {
16102|      0|      if (uid == cached_no_such_uid) {
16103|      0|        {
16104|      0|          *uname = strdup("");
16105|      0|        }
16106|      0|        return;
16107|      0|      }
16108|      0|    }
16109|      0|    if (!cached_uname) {
16110|      0|      goto _L___3;
16111|      0|    } else {
16112|      0|      if (uid != cached_uid) {
16113|      0|      _L___3 : /* CIL Label */
16114|      0|      {
16115|      0|        passwd = getpwuid(uid);
16116|      0|      }
16117|      0|        if (passwd) {
16118|      0|          {
16119|      0|            cached_uid = uid;
16120|      0|            assign_string(&cached_uname, (char const *)passwd->pw_name);
16121|      0|          }
16122|      0|        } else {
16123|      0|          {
16124|      0|            cached_no_such_uid = uid;
16125|      0|            *uname = strdup("");
16126|      0|          }
16127|      0|          return;
16128|      0|        }
16129|      0|      }
16130|      0|    }
16131|      0|    { *uname = strdup((char const *)cached_uname); }
16132|      0|    return;
16133|      0|  }
16134|      0|}
16135|      0|void gid_to_gname(gid_t gid, char **gname) {
16136|      0|  struct group *group;
16137|      0|  char *__cil_tmp4;
16138|      0|  char *__cil_tmp5;
16139|       |
16140|      0|  {
16141|      0|    if (gid != 0U) {
16142|      0|      if (gid == cached_no_such_gid) {
16143|      0|        {
16144|      0|          *gname = strdup("");
16145|      0|        }
16146|      0|        return;
16147|      0|      }
16148|      0|    }
16149|      0|    if (!cached_gname) {
16150|      0|      goto _L___3;
16151|      0|    } else {
16152|      0|      if (gid != cached_gid) {
16153|      0|      _L___3 : /* CIL Label */
16154|      0|      {
16155|      0|        group = getgrgid(gid);
16156|      0|      }
16157|      0|        if (group) {
16158|      0|          {
16159|      0|            cached_gid = gid;
16160|      0|            assign_string(&cached_gname, (char const *)group->gr_name);
16161|      0|          }
16162|      0|        } else {
16163|      0|          {
16164|      0|            cached_no_such_gid = gid;
16165|      0|            *gname = strdup("");
16166|      0|          }
16167|      0|          return;
16168|      0|        }
16169|      0|      }
16170|      0|    }
16171|      0|    { *gname = strdup((char const *)cached_gname); }
16172|      0|    return;
16173|      0|  }
16174|      0|}
16175|      0|int uname_to_uid(char const *uname, uid_t *uidp) {
16176|      0|  struct passwd *passwd;
16177|      0|  int tmp;
16178|      0|  int tmp___0;
16179|       |
16180|      0|  {
16181|      0|    if (cached_no_such_uname) {
16182|      0|      {
16183|      0|        tmp = strcmp(uname, (char const *)cached_no_such_uname);
16184|      0|      }
16185|      0|      if (tmp == 0) {
16186|      0|        return (0);
16187|      0|      }
16188|      0|    }
16189|      0|    if (!cached_uname) {
16190|      0|      goto _L;
16191|      0|    } else {
16192|      0|      if ((int const) * (uname + 0) != (int const) * (cached_uname + 0)) {
16193|      0|        goto _L;
16194|      0|      } else {
16195|      0|        { tmp___0 = strcmp(uname, (char const *)cached_uname); }
16196|      0|        if (tmp___0 != 0) {
16197|      0|        _L : { passwd = getpwnam(uname); }
16198|      0|          if (passwd) {
16199|      0|            {
16200|      0|              cached_uid = passwd->pw_uid;
16201|      0|              assign_string(&cached_uname, (char const *)passwd->pw_name);
16202|      0|            }
16203|      0|          } else {
16204|      0|            { assign_string(&cached_no_such_uname, uname); }
16205|      0|            return (0);
16206|      0|          }
16207|      0|        }
16208|      0|      }
16209|      0|    }
16210|      0|    *uidp = cached_uid;
16211|      0|    return (1);
16212|      0|  }
16213|      0|}
16214|      0|int gname_to_gid(char const *gname, gid_t *gidp) {
16215|      0|  struct group *group;
16216|      0|  int tmp;
16217|      0|  int tmp___0;
16218|       |
16219|      0|  {
16220|      0|    if (cached_no_such_gname) {
16221|      0|      {
16222|      0|        tmp = strcmp(gname, (char const *)cached_no_such_gname);
16223|      0|      }
16224|      0|      if (tmp == 0) {
16225|      0|        return (0);
16226|      0|      }
16227|      0|    }
16228|      0|    if (!cached_gname) {
16229|      0|      goto _L;
16230|      0|    } else {
16231|      0|      if ((int const) * (gname + 0) != (int const) * (cached_gname + 0)) {
16232|      0|        goto _L;
16233|      0|      } else {
16234|      0|        { tmp___0 = strcmp(gname, (char const *)cached_gname); }
16235|      0|        if (tmp___0 != 0) {
16236|      0|        _L : { group = getgrnam(gname); }
16237|      0|          if (group) {
16238|      0|            {
16239|      0|              cached_gid = group->gr_gid;
16240|      0|              assign_string(&cached_gname, gname);
16241|      0|            }
16242|      0|          } else {
16243|      0|            { assign_string(&cached_no_such_gname, gname); }
16244|      0|            return (0);
16245|      0|          }
16246|      0|        }
16247|      0|      }
16248|      0|    }
16249|      0|    *gidp = cached_gid;
16250|      0|    return (1);
16251|      0|  }
16252|      0|}
16253|       |static struct name *namelist;
16254|       |static struct name **nametail = &namelist;
16255|       |static char const **name_array;
16256|       |static int allocated_names;
16257|       |static int names;
16258|       |static int name_index;
16259|      0|void init_names(void) {
16260|      0|  void *tmp;
16261|       |
16262|      0|  {
16263|      0|    {
16264|      0|      allocated_names = 10;
16265|      0|      tmp = xmalloc(sizeof(char const *) * (unsigned long)allocated_names);
16266|      0|      name_array = (char const **)tmp;
16267|      0|      names = 0;
16268|      0|    }
16269|      0|    return;
16270|      0|  }
16271|      0|}
16272|      0|void name_add(char const *name) {
16273|      0|  void *tmp;
16274|      0|  int tmp___0;
16275|       |
16276|      0|  {
16277|      0|    if (names == allocated_names) {
16278|      0|      {
16279|      0|        allocated_names *= 2;
16280|      0|        tmp = xrealloc((void *)name_array,
16281|      0|                       sizeof(char const *) * (unsigned long)allocated_names);
16282|      0|        name_array = (char const **)tmp;
16283|      0|      }
16284|      0|    }
16285|      0|    tmp___0 = names;
16286|      0|    names++;
16287|      0|    *(name_array + tmp___0) = name;
16288|      0|    return;
16289|      0|  }
16290|      0|}
16291|       |static FILE *name_file;
16292|       |static char *name_buffer;
16293|       |static size_t name_buffer_length;
16294|      0|__inline static int is_pattern(char const *string) {
16295|      0|  char *tmp;
16296|      0|  char *tmp___0;
16297|      0|  char *tmp___1;
16298|      0|  int tmp___2;
16299|       |
16300|      0|  {
16301|      0|    { tmp = strchr(string, '*'); }
16302|      0|    if (tmp) {
16303|      0|      tmp___2 = 1;
16304|      0|    } else {
16305|      0|      { tmp___0 = strchr(string, '['); }
16306|      0|      if (tmp___0) {
16307|      0|        tmp___2 = 1;
16308|      0|      } else {
16309|      0|        { tmp___1 = strchr(string, '?'); }
16310|      0|        if (tmp___1) {
16311|      0|          tmp___2 = 1;
16312|      0|        } else {
16313|      0|          tmp___2 = 0;
16314|      0|        }
16315|      0|      }
16316|      0|    }
16317|      0|    return (tmp___2);
16318|      0|  }
16319|      0|}
16320|      0|void name_init(void) {
16321|      0|  void *tmp;
16322|      0|  int tmp___0;
16323|      0|  char *__cil_tmp3;
16324|       |
16325|      0|  {
16326|      0|    {
16327|      0|      tmp = xmalloc((size_t)102);
16328|      0|      name_buffer = (char *)tmp;
16329|      0|      name_buffer_length = (size_t)100;
16330|      0|    }
16331|      0|    if (files_from_option) {
16332|      0|      {
16333|      0|        tmp___0 = strcmp(files_from_option, "-");
16334|      0|      }
16335|      0|      if (tmp___0) {
16336|      0|        {
16337|      0|          name_file = fopen((char const * /* __restrict  */)files_from_option,
16338|      0|                            (char const * /* __restrict  */) "r");
16339|      0|        }
16340|      0|        if (!name_file) {
16341|      0|          {
16342|      0|            open_fatal(files_from_option);
16343|      0|          }
16344|      0|        }
16345|      0|      } else {
16346|      0|        {
16347|      0|          request_stdin("-T");
16348|      0|          name_file = stdin;
16349|      0|        }
16350|      0|      }
16351|      0|    }
16352|      0|    return;
16353|      0|  }
16354|      0|}
16355|      0|void name_term(void) {
16356|       |
16357|      0|  {
16358|      0|    {
16359|      0|      free((void *)name_buffer);
16360|      0|      free((void *)name_array);
16361|      0|    }
16362|      0|    return;
16363|      0|  }
16364|      0|}
16365|      0|static int read_name_from_file(void) {
16366|      0|  int character;
16367|      0|  size_t counter;
16368|      0|  void *tmp;
16369|      0|  size_t tmp___0;
16370|      0|  void *tmp___1;
16371|       |
16372|      0|  {
16373|      0|    counter = (size_t)0;
16374|      0|    {
16375|      0|      while (1) {
16376|      0|      while_continue: /* CIL Label */;
16377|      0|        { character = getc_unlocked(name_file); }
16378|      0|        if (character != -1) {
16379|      0|          if (!(character != (int)filename_terminator)) {
16380|      0|            goto while_break;
16381|      0|          }
16382|      0|        } else {
16383|      0|          goto while_break;
16384|      0|        }
16385|      0|        if (counter == name_buffer_length) {
16386|      0|          if (name_buffer_length * 2UL < name_buffer_length) {
16387|      0|            {
16388|      0|              xalloc_die();
16389|      0|            }
16390|      0|          }
16391|      0|          {
16392|      0|            name_buffer_length *= 2UL;
16393|      0|            tmp = xrealloc((void *)name_buffer, name_buffer_length + 2UL);
16394|      0|            name_buffer = (char *)tmp;
16395|      0|          }
16396|      0|        }
16397|      0|        tmp___0 = counter;
16398|      0|        counter++;
16399|      0|        *(name_buffer + tmp___0) = (char)character;
16400|      0|      }
16401|      0|    while_break: /* CIL Label */;
16402|      0|    }
16403|      0|    if (counter == 0UL) {
16404|      0|      if (character == -1) {
16405|      0|        return (0);
16406|      0|      }
16407|      0|    }
16408|      0|    if (counter == name_buffer_length) {
16409|      0|      if (name_buffer_length * 2UL < name_buffer_length) {
16410|      0|        {
16411|      0|          xalloc_die();
16412|      0|        }
16413|      0|      }
16414|      0|      {
16415|      0|        name_buffer_length *= 2UL;
16416|      0|        tmp___1 = xrealloc((void *)name_buffer, name_buffer_length + 2UL);
16417|      0|        name_buffer = (char *)tmp___1;
16418|      0|      }
16419|      0|    }
16420|      0|    *(name_buffer + counter) = (char)'\000';
16421|      0|    return (1);
16422|      0|  }
16423|      0|}
16424|      0|char *name_next(int change_dirs) {
16425|      0|  char const *source;
16426|      0|  char *cursor;
16427|      0|  int chdir_flag;
16428|      0|  int tmp;
16429|      0|  size_t source_len;
16430|      0|  int tmp___0;
16431|      0|  void *tmp___1;
16432|      0|  size_t tmp___2;
16433|      0|  char *tmp___3;
16434|      0|  int tmp___4;
16435|      0|  int tmp___5;
16436|      0|  char *tmp___6;
16437|      0|  char *__cil_tmp14;
16438|       |
16439|      0|  {
16440|      0|    chdir_flag = 0;
16441|      0|    if ((int)filename_terminator == 0) {
16442|      0|      change_dirs = 0;
16443|      0|    }
16444|      0|    {
16445|      0|      while (1) {
16446|      0|      while_continue: /* CIL Label */;
16447|      0|        if (name_index == names) {
16448|      0|          if (!name_file) {
16449|      0|            goto while_break;
16450|      0|          }
16451|      0|          { tmp = read_name_from_file(); }
16452|      0|          if (!tmp) {
16453|      0|            goto while_break;
16454|      0|          }
16455|      0|        } else {
16456|      0|          {
16457|      0|            tmp___0 = name_index;
16458|      0|            name_index++;
16459|      0|            source = *(name_array + tmp___0);
16460|      0|            source_len = strlen(source);
16461|      0|          }
16462|      0|          if (name_buffer_length < source_len) {
16463|      0|            {
16464|      0|              while (1) {
16465|      0|              while_continue___0: /* CIL Label */;
16466|      0|                name_buffer_length *= 2UL;
16467|      0|                if (!name_buffer_length) {
16468|      0|                  {
16469|      0|                    xalloc_die();
16470|      0|                  }
16471|      0|                }
16472|      0|                if (!(name_buffer_length < source_len)) {
16473|      0|                  goto while_break___0;
16474|      0|                }
16475|      0|              }
16476|      0|            while_break___0: /* CIL Label */;
16477|      0|            }
16478|      0|            {
16479|      0|              free((void *)name_buffer);
16480|      0|              tmp___1 = xmalloc(name_buffer_length + 2UL);
16481|      0|              name_buffer = (char *)tmp___1;
16482|      0|            }
16483|      0|          }
16484|      0|          {
16485|      0|            strcpy((char * /* __restrict  */)name_buffer,
16486|      0|                   (char const * /* __restrict  */)source);
16487|      0|          }
16488|      0|        }
16489|      0|        {
16490|      0|          tmp___2 = strlen((char const *)name_buffer);
16491|      0|          cursor = (name_buffer + tmp___2) - 1;
16492|      0|        }
16493|      0|        {
16494|      0|          while (1) {
16495|      0|          while_continue___1: /* CIL Label */;
16496|      0|            if ((unsigned long)cursor > (unsigned long)name_buffer) {
16497|      0|              if (!((int)*cursor == 47)) {
16498|      0|                goto while_break___1;
16499|      0|              }
16500|      0|            } else {
16501|      0|              goto while_break___1;
16502|      0|            }
16503|      0|            tmp___3 = cursor;
16504|      0|            cursor--;
16505|      0|            *tmp___3 = (char)'\000';
16506|      0|          }
16507|      0|        while_break___1: /* CIL Label */;
16508|      0|        }
16509|      0|        if (chdir_flag) {
16510|      0|          {
16511|      0|            tmp___4 = chdir((char const *)name_buffer);
16512|      0|          }
16513|      0|          if (tmp___4 < 0) {
16514|      0|            {
16515|      0|              chdir_fatal((char const *)name_buffer);
16516|      0|            }
16517|      0|          }
16518|      0|          chdir_flag = 0;
16519|      0|        } else {
16520|      0|          if (change_dirs) {
16521|      0|            {
16522|      0|              tmp___5 = strcmp((char const *)name_buffer, "-C");
16523|      0|            }
16524|      0|            if (tmp___5 == 0) {
16525|      0|              chdir_flag = 1;
16526|      0|            } else {
16527|      0|              { unquote_string(name_buffer); }
16528|      0|              return (name_buffer);
16529|      0|            }
16530|      0|          } else {
16531|      0|            { unquote_string(name_buffer); }
16532|      0|            return (name_buffer);
16533|      0|          }
16534|      0|        }
16535|      0|      }
16536|      0|    while_break: /* CIL Label */;
16537|      0|    }
16538|      0|    if (name_file) {
16539|      0|      if (chdir_flag) {
16540|      0|        {
16541|      0|          tmp___6 = gettext("Missing file name after -C");
16542|      0|          error(0, 0, (char const *)tmp___6);
16543|      0|          fatal_exit();
16544|      0|        }
16545|      0|      }
16546|      0|    }
16547|      0|    return ((char *)0);
16548|      0|  }
16549|      0|}
16550|      0|void name_close(void) {
16551|      0|  int tmp;
16552|       |
16553|      0|  {
16554|      0|    if (name_file) {
16555|      0|      if ((unsigned long)name_file != (unsigned long)stdin) {
16556|      0|        {
16557|      0|          tmp = fclose(name_file);
16558|      0|        }
16559|      0|        if (tmp != 0) {
16560|      0|          {
16561|      0|            close_error((char const *)name_buffer);
16562|      0|          }
16563|      0|        }
16564|      0|      }
16565|      0|    }
16566|      0|    return;
16567|      0|  }
16568|      0|}
16569|       |static struct name *buffer___0;
16570|       |static size_t allocated_size;
16571|       |static int change_dir;
16572|      0|void name_gather(void) {
16573|      0|  char const *name;
16574|      0|  void *tmp;
16575|      0|  char const *dir;
16576|      0|  char *tmp___0;
16577|      0|  char *tmp___1;
16578|      0|  char *tmp___2;
16579|      0|  char *tmp___3;
16580|      0|  int tmp___4;
16581|      0|  size_t needed_size;
16582|      0|  void *tmp___5;
16583|      0|  int change_dir___0;
16584|      0|  int change_dir0;
16585|      0|  char const *dir___0;
16586|      0|  char *tmp___6;
16587|      0|  char *tmp___7;
16588|      0|  char *tmp___8;
16589|      0|  char *tmp___9;
16590|      0|  int tmp___10;
16591|      0|  char *__cil_tmp19;
16592|      0|  char *__cil_tmp20;
16593|       |
16594|      0|  {
16595|      0|    if (same_order_option) {
16596|      0|      if (allocated_size == 0UL) {
16597|      0|        {
16598|      0|          allocated_size =
16599|      0|              ((unsigned long)(&((struct name *)0)->name) + 100UL) + 1UL;
16600|      0|          tmp = xmalloc(allocated_size);
16601|      0|          buffer___0 = (struct name *)tmp;
16602|      0|          memset((void *)buffer___0, 0, allocated_size);
16603|      0|        }
16604|      0|      }
16605|      0|      {
16606|      0|        while (1) {
16607|      0|        while_continue: /* CIL Label */;
16608|      0|          {
16609|      0|            tmp___3 = name_next(0);
16610|      0|            name = (char const *)tmp___3;
16611|      0|          }
16612|      0|          if (name) {
16613|      0|            {
16614|      0|              tmp___4 = strcmp(name, "-C");
16615|      0|            }
16616|      0|            if (!(tmp___4 == 0)) {
16617|      0|              goto while_break;
16618|      0|            }
16619|      0|          } else {
16620|      0|            goto while_break;
16621|      0|          }
16622|      0|          {
16623|      0|            tmp___0 = name_next(0);
16624|      0|            dir = (char const *)tmp___0;
16625|      0|          }
16626|      0|          if (!dir) {
16627|      0|            {
16628|      0|              tmp___1 = gettext("Missing file name after -C");
16629|      0|              error(0, 0, (char const *)tmp___1);
16630|      0|              fatal_exit();
16631|      0|            }
16632|      0|          }
16633|      0|          {
16634|      0|            tmp___2 = xstrdup(dir);
16635|      0|            change_dir = chdir_arg((char const *)tmp___2);
16636|      0|          }
16637|      0|        }
16638|      0|      while_break: /* CIL Label */;
16639|      0|      }
16640|      0|      if (name) {
16641|      0|        {
16642|      0|          buffer___0->length = strlen(name);
16643|      0|          needed_size = ((unsigned long)(&((struct name *)0)->name) +
16644|      0|                         buffer___0->length) +
16645|      0|                        1UL;
16646|      0|        }
16647|      0|        if (allocated_size < needed_size) {
16648|      0|          {
16649|      0|            while (1) {
16650|      0|            while_continue___0: /* CIL Label */;
16651|      0|              allocated_size *= 2UL;
16652|      0|              if (!allocated_size) {
16653|      0|                {
16654|      0|                  xalloc_die();
16655|      0|                }
16656|      0|              }
16657|      0|              if (!(allocated_size < needed_size)) {
16658|      0|                goto while_break___0;
16659|      0|              }
16660|      0|            }
16661|      0|          while_break___0: /* CIL Label */;
16662|      0|          }
16663|      0|          {
16664|      0|            tmp___5 = xrealloc((void *)buffer___0, allocated_size);
16665|      0|            buffer___0 = (struct name *)tmp___5;
16666|      0|          }
16667|      0|        }
16668|      0|        {
16669|      0|          buffer___0->change_dir = change_dir;
16670|      0|          strcpy((char * /* __restrict  */)(buffer___0->name),
16671|      0|                 (char const * /* __restrict  */)name);
16672|      0|          buffer___0->next = (struct name *)0;
16673|      0|          buffer___0->found_count = (uintmax_t)0;
16674|      0|          namelist = buffer___0;
16675|      0|          nametail = &namelist->next;
16676|      0|        }
16677|      0|      } else {
16678|      0|        if (change_dir) {
16679|      0|          {
16680|      0|            addname((char const *)0, change_dir);
16681|      0|          }
16682|      0|        }
16683|      0|      }
16684|      0|    } else {
16685|      0|      change_dir___0 = 0;
16686|      0|      {
16687|      0|        while (1) {
16688|      0|        while_continue___1: /* CIL Label */;
16689|      0|          change_dir0 = change_dir___0;
16690|      0|          {
16691|      0|            while (1) {
16692|      0|            while_continue___2: /* CIL Label */;
16693|      0|              {
16694|      0|                tmp___9 = name_next(0);
16695|      0|                name = (char const *)tmp___9;
16696|      0|              }
16697|      0|              if (name) {
16698|      0|                {
16699|      0|                  tmp___10 = strcmp(name, "-C");
16700|      0|                }
16701|      0|                if (!(tmp___10 == 0)) {
16702|      0|                  goto while_break___2;
16703|      0|                }
16704|      0|              } else {
16705|      0|                goto while_break___2;
16706|      0|              }
16707|      0|              {
16708|      0|                tmp___6 = name_next(0);
16709|      0|                dir___0 = (char const *)tmp___6;
16710|      0|              }
16711|      0|              if (!dir___0) {
16712|      0|                {
16713|      0|                  tmp___7 = gettext("Missing file name after -C");
16714|      0|                  error(0, 0, (char const *)tmp___7);
16715|      0|                  fatal_exit();
16716|      0|                }
16717|      0|              }
16718|      0|              {
16719|      0|                tmp___8 = xstrdup(dir___0);
16720|      0|                change_dir___0 = chdir_arg((char const *)tmp___8);
16721|      0|              }
16722|      0|            }
16723|      0|          while_break___2: /* CIL Label */;
16724|      0|          }
16725|      0|          if (name) {
16726|      0|            {
16727|      0|              addname(name, change_dir___0);
16728|      0|            }
16729|      0|          } else {
16730|      0|            if (change_dir___0 != change_dir0) {
16731|      0|              {
16732|      0|                addname((char const *)0, change_dir___0);
16733|      0|              }
16734|      0|            }
16735|      0|            goto while_break___1;
16736|      0|          }
16737|      0|        }
16738|      0|      while_break___1: /* CIL Label */;
16739|      0|      }
16740|      0|    }
16741|      0|    return;
16742|      0|  }
16743|      0|}
16744|      0|struct name *addname(char const *string, int change_dir___0) {
16745|      0|  size_t length;
16746|      0|  size_t tmp;
16747|      0|  size_t tmp___0;
16748|      0|  struct name *name;
16749|      0|  void *tmp___1;
16750|      0|  int tmp___2;
16751|       |
16752|      0|  {
16753|      0|    if (string) {
16754|      0|      {
16755|      0|        tmp = strlen(string);
16756|      0|        tmp___0 = tmp;
16757|      0|      }
16758|      0|    } else {
16759|      0|      tmp___0 = (size_t)0;
16760|      0|    }
16761|      0|    {
16762|      0|      length = tmp___0;
16763|      0|      tmp___1 =
16764|      0|          xmalloc(((unsigned long)(&((struct name *)0)->name) + length) + 1UL);
16765|      0|      name = (struct name *)tmp___1;
16766|      0|    }
16767|      0|    if (string) {
16768|      0|      {
16769|      0|        name->fake = (char)0;
16770|      0|        strcpy((char * /* __restrict  */)(name->name),
16771|      0|               (char const * /* __restrict  */)string);
16772|      0|      }
16773|      0|    } else {
16774|      0|      name->fake = (char)1;
16775|      0|      name->name[0] = (char)0;
16776|      0|    }
16777|      0|    name->next = (struct name *)0;
16778|      0|    name->length = length;
16779|      0|    name->found_count = (uintmax_t)0;
16780|      0|    name->regexp = (char)0;
16781|      0|    name->firstch = (char)1;
16782|      0|    name->change_dir = change_dir___0;
16783|      0|    name->dir_contents = (char const *)0;
16784|      0|    if (string) {
16785|      0|      {
16786|      0|        tmp___2 = is_pattern(string);
16787|      0|      }
16788|      0|      if (tmp___2) {
16789|      0|        name->regexp = (char)1;
16790|      0|        if ((int const) * (string + 0) == 42) {
16791|      0|          name->firstch = (char)0;
16792|      0|        } else {
16793|      0|          if ((int const) * (string + 0) == 91) {
16794|      0|            name->firstch = (char)0;
16795|      0|          } else {
16796|      0|            if ((int const) * (string + 0) == 63) {
16797|      0|              name->firstch = (char)0;
16798|      0|            }
16799|      0|          }
16800|      0|        }
16801|      0|      }
16802|      0|    }
16803|      0|    *nametail = name;
16804|      0|    nametail = &name->next;
16805|      0|    return (name);
16806|      0|  }
16807|      0|}
16808|      0|static struct name *namelist_match(char const *path, size_t length) {
16809|      0|  struct name *p;
16810|      0|  int tmp;
16811|      0|  int tmp___0;
16812|      0|  int tmp___1;
16813|      0|  int tmp___2;
16814|       |
16815|      0|  {
16816|      0|    p = namelist;
16817|      0|    {
16818|      0|      while (1) {
16819|      0|      while_continue: /* CIL Label */;
16820|      0|        if (!p) {
16821|      0|          goto while_break;
16822|      0|        }
16823|      0|        if (p->firstch) {
16824|      0|          if ((int)p->name[0] != (int)*(path + 0)) {
16825|      0|            goto __Cont;
16826|      0|          }
16827|      0|        }
16828|      0|        if (p->regexp) {
16829|      0|          {
16830|      0|            tmp = fnmatch((char const *)(p->name), path, recursion_option);
16831|      0|            tmp___2 = tmp == 0;
16832|      0|          }
16833|      0|        } else {
16834|      0|          if (p->length <= length) {
16835|      0|            if ((int const) * (path + p->length) == 0) {
16836|      0|              goto _L___3;
16837|      0|            } else {
16838|      0|              if ((int const) * (path + p->length) == 47) {
16839|      0|                if (recursion_option) {
16840|      0|                _L___3 : /* CIL Label */
16841|      0|                {
16842|      0|                  tmp___0 = memcmp((void const *)path, (void const *)(p->name),
16843|      0|                                   p->length);
16844|      0|                }
16845|      0|                  if (tmp___0 == 0) {
16846|      0|                    tmp___1 = 1;
16847|      0|                  } else {
16848|      0|                    tmp___1 = 0;
16849|      0|                  }
16850|      0|                } else {
16851|      0|                  tmp___1 = 0;
16852|      0|                }
16853|      0|              } else {
16854|      0|                tmp___1 = 0;
16855|      0|              }
16856|      0|            }
16857|      0|          } else {
16858|      0|            tmp___1 = 0;
16859|      0|          }
16860|      0|          tmp___2 = tmp___1;
16861|      0|        }
16862|      0|        if (tmp___2) {
16863|      0|          return (p);
16864|      0|        }
16865|      0|      __Cont:
16866|      0|        p = p->next;
16867|      0|      }
16868|      0|    while_break: /* CIL Label */;
16869|      0|    }
16870|      0|    return ((struct name *)0);
16871|      0|  }
16872|      0|}
16873|      0|int name_match(char const *path) {
16874|      0|  size_t length;
16875|      0|  size_t tmp;
16876|      0|  struct name *cursor;
16877|      0|  uintmax_t tmp___0;
16878|       |
16879|      0|  {
16880|      0|    {
16881|      0|      tmp = strlen(path);
16882|      0|      length = tmp;
16883|      0|    }
16884|      0|    {
16885|      0|      while (1) {
16886|      0|      while_continue: /* CIL Label */;
16887|      0|        cursor = namelist;
16888|      0|        if (!cursor) {
16889|      0|          return (!files_from_option);
16890|      0|        }
16891|      0|        if (cursor->fake) {
16892|      0|          {
16893|      0|            chdir_do(cursor->change_dir);
16894|      0|            namelist = (struct name *)0;
16895|      0|            nametail = &namelist;
16896|      0|          }
16897|      0|          return (!files_from_option);
16898|      0|        }
16899|      0|        { cursor = namelist_match(path, length); }
16900|      0|        if (cursor) {
16901|      0|          if ((int const) * (path + cursor->length) == 47) {
16902|      0|            if (recursion_option) {
16903|      0|              if (cursor->found_count == 0UL) {
16904|      0|                (cursor->found_count)++;
16905|      0|              }
16906|      0|            } else {
16907|      0|              (cursor->found_count)++;
16908|      0|            }
16909|      0|          } else {
16910|      0|            (cursor->found_count)++;
16911|      0|          }
16912|      0|          if (starting_file_option) {
16913|      0|            {
16914|      0|              free((void *)namelist);
16915|      0|              namelist = (struct name *)0;
16916|      0|              nametail = &namelist;
16917|      0|            }
16918|      0|          }
16919|      0|          { chdir_do(cursor->change_dir); }
16920|      0|          if (occurrence_option == 0UL) {
16921|      0|            tmp___0 = cursor->found_count;
16922|      0|          } else {
16923|      0|            tmp___0 = (uintmax_t)(cursor->found_count == occurrence_option);
16924|      0|          }
16925|      0|          return ((int)tmp___0);
16926|      0|        }
16927|      0|        if (same_order_option) {
16928|      0|          if (namelist->found_count) {
16929|      0|            {
16930|      0|              name_gather();
16931|      0|            }
16932|      0|            if (namelist->found_count) {
16933|      0|              return (0);
16934|      0|            }
16935|      0|          } else {
16936|      0|            return (0);
16937|      0|          }
16938|      0|        } else {
16939|      0|          return (0);
16940|      0|        }
16941|      0|      }
16942|      0|    while_break: /* CIL Label */;
16943|      0|    }
16944|      0|  }
16945|      0|}
16946|      0|_Bool all_names_found(struct tar_stat_info *p) {
16947|      0|  struct name const *cursor;
16948|      0|  size_t len;
16949|      0|  uintmax_t tmp;
16950|       |
16951|      0|  {
16952|      0|    if (!p->file_name) {
16953|      0|      return ((_Bool)0);
16954|      0|    } else {
16955|      0|      if (occurrence_option == 0UL) {
16956|      0|        return ((_Bool)0);
16957|      0|      } else {
16958|      0|        if (p->had_trailing_slash) {
16959|      0|          return ((_Bool)0);
16960|      0|        }
16961|      0|      }
16962|      0|    }
16963|      0|    {
16964|      0|      len = strlen((char const *)p->file_name);
16965|      0|      cursor = (struct name const *)namelist;
16966|      0|    }
16967|      0|    {
16968|      0|      while (1) {
16969|      0|      while_continue: /* CIL Label */;
16970|      0|        if (!cursor) {
16971|      0|          goto while_break;
16972|      0|        }
16973|      0|        if (cursor->regexp) {
16974|      0|          return ((_Bool)0);
16975|      0|        } else {
16976|      0|          if (occurrence_option == 0UL) {
16977|      0|            tmp = cursor->found_count;
16978|      0|          } else {
16979|      0|            tmp = (uintmax_t const)(cursor->found_count >=
16980|      0|                                    (uintmax_t const)occurrence_option);
16981|      0|          }
16982|      0|          if (tmp) {
16983|      0|          _L___3: /* CIL Label */
16984|      0|            if (len >= (size_t)cursor->length) {
16985|      0|              if ((int)*(p->file_name + cursor->length) == 47) {
16986|      0|                return ((_Bool)0);
16987|      0|              }
16988|      0|            }
16989|      0|          } else {
16990|      0|            if (!cursor->fake) {
16991|      0|              return ((_Bool)0);
16992|      0|            } else {
16993|      0|              goto _L___3;
16994|      0|            }
16995|      0|          }
16996|      0|        }
16997|      0|        cursor = (struct name const *)cursor->next;
16998|      0|      }
16999|      0|    while_break: /* CIL Label */;
17000|      0|    }
17001|      0|    return ((_Bool)1);
17002|      0|  }
17003|      0|}
17004|      0|void names_notfound(void) {
17005|      0|  struct name const *cursor;
17006|      0|  char *tmp;
17007|      0|  char *tmp___0;
17008|      0|  char *tmp___1;
17009|      0|  char *tmp___2;
17010|      0|  char *name;
17011|      0|  char *tmp___3;
17012|      0|  char *tmp___4;
17013|      0|  uintmax_t tmp___5;
17014|      0|  char *__cil_tmp10;
17015|      0|  char *__cil_tmp11;
17016|      0|  char *__cil_tmp12;
17017|       |
17018|      0|  {
17019|      0|    cursor = (struct name const *)namelist;
17020|      0|    {
17021|      0|      while (1) {
17022|      0|      while_continue: /* CIL Label */;
17023|      0|        if (!cursor) {
17024|      0|          goto while_break;
17025|      0|        }
17026|      0|        if (occurrence_option == 0UL) {
17027|      0|          tmp___5 = cursor->found_count;
17028|      0|        } else {
17029|      0|          tmp___5 = (uintmax_t const)(cursor->found_count >=
17030|      0|                                      (uintmax_t const)occurrence_option);
17031|      0|        }
17032|      0|        if (!tmp___5) {
17033|      0|          if (!cursor->fake) {
17034|      0|            if (cursor->found_count == 0UL) {
17035|      0|              {
17036|      0|                tmp = quotearg_colon((char const *)(cursor->name));
17037|      0|                tmp___0 = gettext("%s: Not found in archive");
17038|      0|                error(0, 0, (char const *)tmp___0, tmp);
17039|      0|                exit_status = 2;
17040|      0|              }
17041|      0|            } else {
17042|      0|              {
17043|      0|                tmp___1 = quotearg_colon((char const *)(cursor->name));
17044|      0|                tmp___2 =
17045|      0|                    gettext("%s: Required occurrence not found in archive");
17046|      0|                error(0, 0, (char const *)tmp___2, tmp___1);
17047|      0|                exit_status = 2;
17048|      0|              }
17049|      0|            }
17050|      0|          }
17051|      0|        }
17052|      0|        cursor = (struct name const *)cursor->next;
17053|      0|      }
17054|      0|    while_break: /* CIL Label */;
17055|      0|    }
17056|      0|    namelist = (struct name *)0;
17057|      0|    nametail = &namelist;
17058|      0|    if (same_order_option) {
17059|      0|      {
17060|      0|        while (1) {
17061|      0|        while_continue___0: /* CIL Label */;
17062|      0|          { name = name_next(1); }
17063|      0|          if (!((unsigned long)name != (unsigned long)((void *)0))) {
17064|      0|            goto while_break___0;
17065|      0|          }
17066|      0|          {
17067|      0|            tmp___3 = quotearg_colon((char const *)name);
17068|      0|            tmp___4 = gettext("%s: Not found in archive");
17069|      0|            error(0, 0, (char const *)tmp___4, tmp___3);
17070|      0|            exit_status = 2;
17071|      0|          }
17072|      0|        }
17073|      0|      while_break___0: /* CIL Label */;
17074|      0|      }
17075|      0|    }
17076|      0|    return;
17077|      0|  }
17078|      0|}
17079|       |static struct name *merge_sort(struct name *list, int length,
17080|       |                               int (*compare)(struct name const *,
17081|      0|                                              struct name const *)) {
17082|      0|  struct name *first_list;
17083|      0|  struct name *second_list;
17084|      0|  int first_length;
17085|      0|  int second_length;
17086|      0|  struct name *result;
17087|      0|  struct name **merge_point;
17088|      0|  struct name *cursor;
17089|      0|  int counter;
17090|      0|  int tmp;
17091|      0|  int tmp___0;
17092|       |
17093|      0|  {
17094|      0|    if (length == 1) {
17095|      0|      return (list);
17096|      0|    }
17097|      0|    if (length == 2) {
17098|      0|      {
17099|      0|        tmp = (*compare)((struct name const *)list,
17100|      0|                         (struct name const *)list->next);
17101|      0|      }
17102|      0|      if (tmp > 0) {
17103|      0|        result = list->next;
17104|      0|        result->next = list;
17105|      0|        list->next = (struct name *)0;
17106|      0|        return (result);
17107|      0|      }
17108|      0|      return (list);
17109|      0|    }
17110|      0|    first_list = list;
17111|      0|    first_length = (length + 1) / 2;
17112|      0|    second_length = length / 2;
17113|      0|    cursor = list;
17114|      0|    counter = first_length - 1;
17115|      0|    {
17116|      0|      while (1) {
17117|      0|      while_continue: /* CIL Label */;
17118|      0|        if (!counter) {
17119|      0|          goto while_break;
17120|      0|        }
17121|      0|        goto __Cont;
17122|      0|      __Cont:
17123|      0|        cursor = cursor->next;
17124|      0|        counter--;
17125|      0|      }
17126|      0|    while_break: /* CIL Label */;
17127|      0|    }
17128|      0|    {
17129|      0|      second_list = cursor->next;
17130|      0|      cursor->next = (struct name *)0;
17131|      0|      first_list = merge_sort(first_list, first_length, compare);
17132|      0|      second_list = merge_sort(second_list, second_length, compare);
17133|      0|      merge_point = &result;
17134|      0|    }
17135|      0|    {
17136|      0|      while (1) {
17137|      0|      while_continue___0: /* CIL Label */;
17138|      0|        if (first_list) {
17139|      0|          if (!second_list) {
17140|      0|            goto while_break___0;
17141|      0|          }
17142|      0|        } else {
17143|      0|          goto while_break___0;
17144|      0|        }
17145|      0|        {
17146|      0|          tmp___0 = (*compare)((struct name const *)first_list,
17147|      0|                               (struct name const *)second_list);
17148|      0|        }
17149|      0|        if (tmp___0 < 0) {
17150|      0|          cursor = first_list->next;
17151|      0|          *merge_point = first_list;
17152|      0|          merge_point = &first_list->next;
17153|      0|          first_list = cursor;
17154|      0|        } else {
17155|      0|          cursor = second_list->next;
17156|      0|          *merge_point = second_list;
17157|      0|          merge_point = &second_list->next;
17158|      0|          second_list = cursor;
17159|      0|        }
17160|      0|      }
17161|      0|    while_break___0: /* CIL Label */;
17162|      0|    }
17163|      0|    if (first_list) {
17164|      0|      *merge_point = first_list;
17165|      0|    } else {
17166|      0|      *merge_point = second_list;
17167|      0|    }
17168|      0|    return (result);
17169|      0|  }
17170|      0|}
17171|      0|static int compare_names(struct name const *n1, struct name const *n2) {
17172|      0|  int found_diff;
17173|      0|  int tmp;
17174|      0|  int tmp___0;
17175|      0|  uintmax_t tmp___1;
17176|      0|  uintmax_t tmp___2;
17177|       |
17178|      0|  {
17179|      0|    if (occurrence_option == 0UL) {
17180|      0|      tmp___1 = n2->found_count;
17181|      0|    } else {
17182|      0|      tmp___1 = (uintmax_t const)(n2->found_count >=
17183|      0|                                  (uintmax_t const)occurrence_option);
17184|      0|    }
17185|      0|    if (occurrence_option == 0UL) {
17186|      0|      tmp___2 = n1->found_count;
17187|      0|    } else {
17188|      0|      tmp___2 = (uintmax_t const)(n1->found_count >=
17189|      0|                                  (uintmax_t const)occurrence_option);
17190|      0|    }
17191|      0|    found_diff = (int)(tmp___1 - tmp___2);
17192|      0|    if (found_diff) {
17193|      0|      tmp___0 = found_diff;
17194|      0|    } else {
17195|      0|      {
17196|      0|        tmp = strcmp((char const *)(n1->name), (char const *)(n2->name));
17197|      0|        tmp___0 = tmp;
17198|      0|      }
17199|      0|    }
17200|      0|    return (tmp___0);
17201|      0|  }
17202|      0|}
17203|      0|static void add_hierarchy_to_namelist(struct name *name, dev_t device) {
17204|      0|  char *path;
17205|      0|  char *buffer___2;
17206|      0|  char *tmp;
17207|      0|  size_t name_length;
17208|      0|  size_t allocated_length;
17209|      0|  char *namebuf;
17210|      0|  void *tmp___0;
17211|      0|  char *string;
17212|      0|  size_t string_length;
17213|      0|  int change_dir___0;
17214|      0|  size_t tmp___1;
17215|      0|  void *tmp___2;
17216|      0|  struct name *tmp___3;
17217|      0|  char *__cil_tmp16;
17218|       |
17219|      0|  {
17220|      0|    {
17221|      0|      path = name->name;
17222|      0|      tmp = get_directory_contents(path, device);
17223|      0|      buffer___2 = tmp;
17224|      0|    }
17225|      0|    if (!buffer___2) {
17226|      0|      name->dir_contents = "\000\000\000\000";
17227|      0|    } else {
17228|      0|      name_length = name->length;
17229|      0|      if (name_length >= 100UL) {
17230|      0|        allocated_length = name_length + 100UL;
17231|      0|      } else {
17232|      0|        allocated_length = (size_t)100;
17233|      0|      }
17234|      0|      {
17235|      0|        tmp___0 = xmalloc(allocated_length + 1UL);
17236|      0|        namebuf = (char *)tmp___0;
17237|      0|        change_dir___0 = name->change_dir;
17238|      0|        name->dir_contents = (char const *)buffer___2;
17239|      0|        strcpy((char * /* __restrict  */)namebuf,
17240|      0|               (char const * /* __restrict  */)path);
17241|      0|      }
17242|      0|      if (!((int)*(namebuf + (name_length - 1UL)) == 47)) {
17243|      0|        tmp___1 = name_length;
17244|      0|        name_length++;
17245|      0|        *(namebuf + tmp___1) = (char)'/';
17246|      0|        *(namebuf + name_length) = (char)'\000';
17247|      0|      }
17248|      0|      string = buffer___2;
17249|      0|      {
17250|      0|        while (1) {
17251|      0|        while_continue: /* CIL Label */;
17252|      0|          if (!*string) {
17253|      0|            goto while_break;
17254|      0|          }
17255|      0|          { string_length = strlen((char const *)string); }
17256|      0|          if ((int)*string == 68) {
17257|      0|            if (allocated_length <= name_length + string_length) {
17258|      0|              {
17259|      0|                while (1) {
17260|      0|                while_continue___0: /* CIL Label */;
17261|      0|                  allocated_length *= 2UL;
17262|      0|                  if (!allocated_length) {
17263|      0|                    {
17264|      0|                      xalloc_die();
17265|      0|                    }
17266|      0|                  }
17267|      0|                  if (!(allocated_length <= name_length + string_length)) {
17268|      0|                    goto while_break___0;
17269|      0|                  }
17270|      0|                }
17271|      0|              while_break___0: /* CIL Label */;
17272|      0|              }
17273|      0|              {
17274|      0|                tmp___2 = xrealloc((void *)namebuf, allocated_length + 1UL);
17275|      0|                namebuf = (char *)tmp___2;
17276|      0|              }
17277|      0|            }
17278|      0|            {
17279|      0|              strcpy((char * /* __restrict  */)(namebuf + name_length),
17280|      0|                     (char const * /* __restrict  */)(string + 1));
17281|      0|              tmp___3 = addname((char const *)namebuf, change_dir___0);
17282|      0|              add_hierarchy_to_namelist(tmp___3, device);
17283|      0|            }
17284|      0|          }
17285|      0|          string += string_length + 1UL;
17286|      0|        }
17287|      0|      while_break: /* CIL Label */;
17288|      0|      }
17289|      0|      { free((void *)namebuf); }
17290|      0|    }
17291|      0|    return;
17292|      0|  }
17293|      0|}
17294|      0|void collect_and_sort_names(void) {
17295|      0|  struct name *name;
17296|      0|  struct name *next_name;
17297|      0|  int num_names;
17298|      0|  struct stat statbuf;
17299|      0|  int tmp;
17300|      0|  void *__cil_tmp6;
17301|      0|  char *__cil_tmp7;
17302|       |
17303|      0|  {
17304|      0|    { name_gather(); }
17305|      0|    if (listed_incremental_option) {
17306|      0|      {
17307|      0|        read_directory_file();
17308|      0|      }
17309|      0|    }
17310|      0|    if (!namelist) {
17311|      0|      {
17312|      0|        addname(".", 0);
17313|      0|      }
17314|      0|    }
17315|      0|    name = namelist;
17316|      0|    {
17317|      0|      while (1) {
17318|      0|      while_continue: /* CIL Label */;
17319|      0|        if (!name) {
17320|      0|          goto while_break;
17321|      0|        }
17322|      0|        next_name = name->next;
17323|      0|        if (name->found_count) {
17324|      0|          goto __Cont;
17325|      0|        } else {
17326|      0|          if (name->dir_contents) {
17327|      0|            goto __Cont;
17328|      0|          }
17329|      0|        }
17330|      0|        if (name->regexp) {
17331|      0|          goto __Cont;
17332|      0|        }
17333|      0|        { chdir_do(name->change_dir); }
17334|      0|        if (name->fake) {
17335|      0|          goto __Cont;
17336|      0|        }
17337|      0|        {
17338|      0|          tmp = deref_stat(dereference_option, (char const *)(name->name),
17339|      0|                           &statbuf);
17340|      0|        }
17341|      0|        if (tmp != 0) {
17342|      0|          {
17343|      0|            stat_diag((char const *)(name->name));
17344|      0|          }
17345|      0|          goto __Cont;
17346|      0|        }
17347|      0|        if ((statbuf.st_mode & 61440U) == 16384U) {
17348|      0|          {
17349|      0|            (name->found_count)++;
17350|      0|            add_hierarchy_to_namelist(name, statbuf.st_dev);
17351|      0|          }
17352|      0|        }
17353|      0|      __Cont:
17354|      0|        name = next_name;
17355|      0|      }
17356|      0|    while_break: /* CIL Label */;
17357|      0|    }
17358|      0|    num_names = 0;
17359|      0|    name = namelist;
17360|      0|    {
17361|      0|      while (1) {
17362|      0|      while_continue___0: /* CIL Label */;
17363|      0|        if (!name) {
17364|      0|          goto while_break___0;
17365|      0|        }
17366|      0|        num_names++;
17367|      0|        name = name->next;
17368|      0|      }
17369|      0|    while_break___0: /* CIL Label */;
17370|      0|    }
17371|      0|    {
17372|      0|      namelist = merge_sort(namelist, num_names, &compare_names);
17373|      0|      name = namelist;
17374|      0|    }
17375|      0|    {
17376|      0|      while (1) {
17377|      0|      while_continue___1: /* CIL Label */;
17378|      0|        if (!name) {
17379|      0|          goto while_break___1;
17380|      0|        }
17381|      0|        name->found_count = (uintmax_t)0;
17382|      0|        name = name->next;
17383|      0|      }
17384|      0|    while_break___1: /* CIL Label */;
17385|      0|    }
17386|      0|    return;
17387|      0|  }
17388|      0|}
17389|      0|struct name *name_scan(char const *path) {
17390|      0|  size_t length;
17391|      0|  size_t tmp;
17392|      0|  struct name *cursor;
17393|      0|  struct name *tmp___0;
17394|       |
17395|      0|  {
17396|      0|    {
17397|      0|      tmp = strlen(path);
17398|      0|      length = tmp;
17399|      0|    }
17400|      0|    {
17401|      0|      while (1) {
17402|      0|      while_continue: /* CIL Label */;
17403|      0|        {
17404|      0|          tmp___0 = namelist_match(path, length);
17405|      0|          cursor = tmp___0;
17406|      0|        }
17407|      0|        if (cursor) {
17408|      0|          return (cursor);
17409|      0|        }
17410|      0|        if (same_order_option) {
17411|      0|          if (namelist) {
17412|      0|            if (namelist->found_count) {
17413|      0|              {
17414|      0|                name_gather();
17415|      0|              }
17416|      0|              if (namelist->found_count) {
17417|      0|                return ((struct name *)0);
17418|      0|              }
17419|      0|            } else {
17420|      0|              return ((struct name *)0);
17421|      0|            }
17422|      0|          } else {
17423|      0|            return ((struct name *)0);
17424|      0|          }
17425|      0|        } else {
17426|      0|          return ((struct name *)0);
17427|      0|        }
17428|      0|      }
17429|      0|    while_break: /* CIL Label */;
17430|      0|    }
17431|      0|  }
17432|      0|}
17433|      0|char *name_from_list(void) {
17434|       |
17435|      0|  {
17436|      0|    if (!gnu_list_name) {
17437|      0|      gnu_list_name = namelist;
17438|      0|    }
17439|      0|    {
17440|      0|      while (1) {
17441|      0|      while_continue: /* CIL Label */;
17442|      0|        if (gnu_list_name) {
17443|      0|          if (!gnu_list_name->found_count) {
17444|      0|            if (!gnu_list_name->fake) {
17445|      0|              goto while_break;
17446|      0|            }
17447|      0|          }
17448|      0|        } else {
17449|      0|          goto while_break;
17450|      0|        }
17451|      0|        gnu_list_name = gnu_list_name->next;
17452|      0|      }
17453|      0|    while_break: /* CIL Label */;
17454|      0|    }
17455|      0|    if (gnu_list_name) {
17456|      0|      {
17457|      0|        (gnu_list_name->found_count)++;
17458|      0|        chdir_do(gnu_list_name->change_dir);
17459|      0|      }
17460|      0|      return (gnu_list_name->name);
17461|      0|    }
17462|      0|    return ((char *)0);
17463|      0|  }
17464|      0|}
17465|      0|void blank_name_list(void) {
17466|      0|  struct name *name;
17467|       |
17468|      0|  {
17469|      0|    gnu_list_name = (struct name *)0;
17470|      0|    name = namelist;
17471|      0|    {
17472|      0|      while (1) {
17473|      0|      while_continue: /* CIL Label */;
17474|      0|        if (!name) {
17475|      0|          goto while_break;
17476|      0|        }
17477|      0|        name->found_count = (uintmax_t)0;
17478|      0|        name = name->next;
17479|      0|      }
17480|      0|    while_break: /* CIL Label */;
17481|      0|    }
17482|      0|    return;
17483|      0|  }
17484|      0|}
17485|      0|char *new_name(char const *path, char const *name) {
17486|      0|  size_t pathlen;
17487|      0|  size_t tmp;
17488|      0|  size_t namesize;
17489|      0|  size_t tmp___0;
17490|      0|  int slash;
17491|      0|  char *buffer___2;
17492|      0|  void *tmp___1;
17493|      0|  int tmp___2;
17494|       |
17495|      0|  {
17496|      0|    {
17497|      0|      tmp = strlen(path);
17498|      0|      pathlen = tmp;
17499|      0|      tmp___0 = strlen(name);
17500|      0|      namesize = tmp___0 + 1UL;
17501|      0|    }
17502|      0|    if (pathlen) {
17503|      0|      if (!((int const) * (path + (pathlen - 1UL)) == 47)) {
17504|      0|        tmp___2 = 1;
17505|      0|      } else {
17506|      0|        tmp___2 = 0;
17507|      0|      }
17508|      0|    } else {
17509|      0|      tmp___2 = 0;
17510|      0|    }
17511|      0|    {
17512|      0|      slash = tmp___2;
17513|      0|      tmp___1 = xmalloc((pathlen + (size_t)slash) + namesize);
17514|      0|      buffer___2 = (char *)tmp___1;
17515|      0|      memcpy((void * /* __restrict  */)buffer___2,
17516|      0|             (void const * /* __restrict  */)path, pathlen);
17517|      0|      *(buffer___2 + pathlen) = (char)'/';
17518|      0|      memcpy((void * /* __restrict  */)((buffer___2 + pathlen) + slash),
17519|      0|             (void const * /* __restrict  */)name, namesize);
17520|      0|    }
17521|      0|    return (buffer___2);
17522|      0|  }
17523|      0|}
17524|      0|_Bool excluded_name(char const *name) {
17525|      0|  _Bool tmp;
17526|       |
17527|      0|  {
17528|      0|    { tmp = excluded_filename((struct exclude const *)excluded, name + 0); }
17529|      0|    return (tmp);
17530|      0|  }
17531|      0|}
17532|       |static unsigned int hash_string_hasher(void const *name,
17533|      0|                                       unsigned int n_buckets) {
17534|      0|  size_t tmp;
17535|       |
17536|      0|  {
17537|      0|    { tmp = hash_string((char const *)name, (size_t)n_buckets); }
17538|      0|    return ((unsigned int)tmp);
17539|      0|  }
17540|      0|}
17541|      0|static _Bool hash_string_compare(void const *name1, void const *name2) {
17542|      0|  int tmp;
17543|       |
17544|      0|  {
17545|      0|    { tmp = strcmp((char const *)name1, (char const *)name2); }
17546|      0|    return ((_Bool)(tmp == 0));
17547|      0|  }
17548|      0|}
17549|      0|static _Bool hash_string_insert(Hash_table **table___0, char const *string) {
17550|      0|  Hash_table *t;
17551|      0|  char *s;
17552|      0|  char *tmp;
17553|      0|  char *e;
17554|      0|  Hash_table *tmp___0;
17555|      0|  void *tmp___1;
17556|       |
17557|      0|  {
17558|      0|    {
17559|      0|      t = *table___0;
17560|      0|      tmp = xstrdup(string);
17561|      0|      s = tmp;
17562|      0|    }
17563|      0|    if (t) {
17564|      0|      goto _L;
17565|      0|    } else {
17566|      0|      {
17567|      0|        t = hash_initialize(
17568|      0|            (size_t)0, (Hash_tuning const *)0,
17569|      0|            (size_t(*)(void const *, size_t))(&hash_string_hasher),
17570|      0|            &hash_string_compare, (void (*)(void *))0);
17571|      0|        tmp___0 = t;
17572|      0|        *table___0 = tmp___0;
17573|      0|      }
17574|      0|      if (tmp___0) {
17575|      0|      _L : {
17576|      0|        tmp___1 = hash_insert(t, (void const *)s);
17577|      0|        e = (char *)tmp___1;
17578|      0|      }
17579|      0|        if (!e) {
17580|      0|          {
17581|      0|            xalloc_die();
17582|      0|          }
17583|      0|        }
17584|      0|      } else {
17585|      0|        { xalloc_die(); }
17586|      0|      }
17587|      0|    }
17588|      0|    if ((unsigned long)e == (unsigned long)s) {
17589|      0|      return ((_Bool)1);
17590|      0|    } else {
17591|      0|      { free((void *)s); }
17592|      0|      return ((_Bool)0);
17593|      0|    }
17594|      0|  }
17595|      0|}
17596|       |static _Bool hash_string_lookup(Hash_table const *table___0,
17597|      0|                                char const *string) {
17598|      0|  void *tmp;
17599|      0|  int tmp___0;
17600|       |
17601|      0|  {
17602|      0|    if (table___0) {
17603|      0|      {
17604|      0|        tmp = hash_lookup(table___0, (void const *)string);
17605|      0|      }
17606|      0|      if (tmp) {
17607|      0|        tmp___0 = 1;
17608|      0|      } else {
17609|      0|        tmp___0 = 0;
17610|      0|      }
17611|      0|    } else {
17612|      0|      tmp___0 = 0;
17613|      0|    }
17614|      0|    return ((_Bool)tmp___0);
17615|      0|  }
17616|      0|}
17617|       |static Hash_table *avoided_name_table;
17618|      0|void add_avoided_name(char const *name) {
17619|       |
17620|      0|  {
17621|      0|    { hash_string_insert(&avoided_name_table, name); }
17622|      0|    return;
17623|      0|  }
17624|      0|}
17625|      0|_Bool is_avoided_name(char const *name) {
17626|      0|  _Bool tmp;
17627|       |
17628|      0|  {
17629|      0|    { tmp = hash_string_lookup((Hash_table const *)avoided_name_table, name); }
17630|      0|    return (tmp);
17631|      0|  }
17632|      0|}
17633|       |static Hash_table *prefix_table[2];
17634|       |static char const *const diagnostic[2] = {
17635|       |    (char const * /* const  */) "Removing leading `%s\' from member names",
17636|       |    (char const
17637|       |         * /* const  */) "Removing leading `%s\' from hard link targets"};
17638|       |static char const *const diagnostic___0[2] = {
17639|       |    (char const * /* const  */) "Substituting `.\' for empty member name",
17640|       |    (char const * /* const  */) "Substituting `.\' for empty hard link target"};
17641|      0|char *safer_name_suffix(char const *file_name, _Bool link_target) {
17642|      0|  char const *p;
17643|      0|  size_t prefix_len;
17644|      0|  char c;
17645|      0|  char const *tmp;
17646|      0|  char *prefix;
17647|      0|  void *tmp___0;
17648|      0|  char *tmp___1;
17649|      0|  _Bool tmp___2;
17650|      0|  char *tmp___3;
17651|      0|  char *__cil_tmp12;
17652|       |
17653|      0|  {
17654|      0|    if (absolute_names_option) {
17655|      0|      p = file_name;
17656|      0|    } else {
17657|      0|      prefix_len = (size_t)0;
17658|      0|      p = file_name + prefix_len;
17659|      0|      {
17660|      0|        while (1) {
17661|      0|        while_continue: /* CIL Label */;
17662|      0|          if (!*p) {
17663|      0|            goto while_break;
17664|      0|          }
17665|      0|          if ((int const) * (p + 0) == 46) {
17666|      0|            if ((int const) * (p + 1) == 46) {
17667|      0|              if ((int const) * (p + 2) == 47) {
17668|      0|                prefix_len = (size_t)((p + 2) - file_name);
17669|      0|              } else {
17670|      0|                if (!*(p + 2)) {
17671|      0|                  prefix_len = (size_t)((p + 2) - file_name);
17672|      0|                }
17673|      0|              }
17674|      0|            }
17675|      0|          }
17676|      0|          {
17677|      0|            while (1) {
17678|      0|            while_continue___0: /* CIL Label */;
17679|      0|              tmp = p;
17680|      0|              p++;
17681|      0|              c = (char)*tmp;
17682|      0|              if ((int)c == 47) {
17683|      0|                goto while_break___0;
17684|      0|              }
17685|      0|              if (!*p) {
17686|      0|                goto while_break___0;
17687|      0|              }
17688|      0|            }
17689|      0|          while_break___0: /* CIL Label */;
17690|      0|          }
17691|      0|        }
17692|      0|      while_break: /* CIL Label */;
17693|      0|      }
17694|      0|      p = file_name + prefix_len;
17695|      0|      {
17696|      0|        while (1) {
17697|      0|        while_continue___1: /* CIL Label */;
17698|      0|          if (!((int const) * p == 47)) {
17699|      0|            goto while_break___1;
17700|      0|          }
17701|      0|          goto __Cont;
17702|      0|        __Cont:
17703|      0|          p++;
17704|      0|        }
17705|      0|      while_break___1: /* CIL Label */;
17706|      0|      }
17707|      0|      prefix_len = (size_t)(p - file_name);
17708|      0|      if (prefix_len) {
17709|      0|        {
17710|      0|          tmp___0 = __builtin_alloca(prefix_len + 1UL);
17711|      0|          prefix = (char *)tmp___0;
17712|      0|          memcpy((void * /* __restrict  */)prefix,
17713|      0|                 (void const * /* __restrict  */)file_name, prefix_len);
17714|      0|          *(prefix + prefix_len) = (char)'\000';
17715|      0|          tmp___2 = hash_string_insert(&prefix_table[link_target],
17716|      0|                                       (char const *)prefix);
17717|      0|        }
17718|      0|        if (tmp___2) {
17719|      0|          {
17720|      0|            tmp___1 = gettext((char const *)diagnostic[link_target]);
17721|      0|            error(0, 0, (char const *)tmp___1, prefix);
17722|      0|          }
17723|      0|        }
17724|      0|      }
17725|      0|    }
17726|      0|    if (!*p) {
17727|      0|      if ((unsigned long)p == (unsigned long)file_name) {
17728|      0|        {
17729|      0|          tmp___3 = gettext((char const *)diagnostic___0[link_target]);
17730|      0|          error(0, 0, (char const *)tmp___3);
17731|      0|        }
17732|      0|      }
17733|      0|      p = ".";
17734|      0|    }
17735|      0|    return ((char *)p);
17736|      0|  }
17737|      0|}
17738|      0|size_t stripped_prefix_len(char const *file_name, size_t num) {
17739|      0|  char const *p;
17740|      0|  _Bool slash;
17741|       |
17742|      0|  {
17743|      0|    p = file_name + 0;
17744|      0|    {
17745|      0|      while (1) {
17746|      0|      while_continue: /* CIL Label */;
17747|      0|        if (!((int const) * p == 47)) {
17748|      0|          goto while_break;
17749|      0|        }
17750|      0|        p++;
17751|      0|      }
17752|      0|    while_break: /* CIL Label */;
17753|      0|    }
17754|      0|    {
17755|      0|      while (1) {
17756|      0|      while_continue___0: /* CIL Label */;
17757|      0|        if (!*p) {
17758|      0|          goto while_break___0;
17759|      0|        }
17760|      0|        slash = (_Bool)((int const) * p == 47);
17761|      0|        p++;
17762|      0|        if (slash) {
17763|      0|          num--;
17764|      0|          if (num == 0UL) {
17765|      0|            return ((size_t)(p - file_name));
17766|      0|          }
17767|      0|          {
17768|      0|            while (1) {
17769|      0|            while_continue___1: /* CIL Label */;
17770|      0|              if (!((int const) * p == 47)) {
17771|      0|                goto while_break___1;
17772|      0|              }
17773|      0|              p++;
17774|      0|            }
17775|      0|          while_break___1: /* CIL Label */;
17776|      0|          }
17777|      0|        }
17778|      0|      }
17779|      0|    while_break___0: /* CIL Label */;
17780|      0|    }
17781|      0|    return ((size_t)-1);
17782|      0|  }
17783|      0|}
17784|      0|_Bool contains_dot_dot(char const *name) {
17785|      0|  char const *p;
17786|      0|  char const *tmp;
17787|       |
17788|      0|  {
17789|      0|    p = name + 0;
17790|      0|    {
17791|      0|      while (1) {
17792|      0|      while_continue: /* CIL Label */;
17793|      0|        if ((int const) * (p + 0) == 46) {
17794|      0|          if ((int const) * (p + 1) == 46) {
17795|      0|            if ((int const) * (p + 2) == 47) {
17796|      0|              return ((_Bool)1);
17797|      0|            } else {
17798|      0|              if (!*(p + 2)) {
17799|      0|                return ((_Bool)1);
17800|      0|              }
17801|      0|            }
17802|      0|          }
17803|      0|        }
17804|      0|        {
17805|      0|          while (1) {
17806|      0|          while_continue___0: /* CIL Label */;
17807|      0|            tmp = p;
17808|      0|            p++;
17809|      0|            if (!*tmp) {
17810|      0|              return ((_Bool)0);
17811|      0|            }
17812|      0|            if (!(!((int const) * p == 47))) {
17813|      0|              goto while_break___0;
17814|      0|            }
17815|      0|          }
17816|      0|        while_break___0: /* CIL Label */;
17817|      0|        }
17818|      0|        p++;
17819|      0|      }
17820|      0|    while_break: /* CIL Label */;
17821|      0|    }
17822|      0|  }
17823|      0|}
17824|       |/* #pragma merger("0","00b.rtapelib.o.i","") */
17825|       |extern
17826|       |    __attribute__((__nothrow__)) int(__attribute__((__leaf__)) dup)(int __fd);
17827|       |extern __attribute__((__nothrow__)) int(
17828|       |    __attribute__((__nonnull__(1, 2), __leaf__))
17829|       |    execl)(char const *__path, char const *__arg, ...);
17830|       |extern __attribute__((__nothrow__))
17831|       |__sighandler_t(__attribute__((__leaf__)) signal)(int __sig,
17832|       |                                                 void (*__handler)(int));
17833|       |extern
17834|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
17835|       |                                     atoi)(char const *__nptr)
17836|       |        __attribute__((__pure__));
17837|       |extern
17838|       |    __attribute__((__nothrow__)) long(__attribute__((__nonnull__(1), __leaf__))
17839|       |                                      atol)(char const *__nptr)
17840|       |        __attribute__((__pure__));
17841|       |char const *rmt_command_option;
17842|       |void sys_reset_uid_gid(void);
17843|       |size_t rmt_write__(int handle, char *buffer___2, size_t length);
17844|       |static int from_remote[4][2] = {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}};
17845|       |static int to_remote[4][2] = {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}};
17846|      0|static void _rmt_shutdown(int handle, int errno_value) {
17847|      0|  int *tmp;
17848|       |
17849|      0|  {
17850|      0|    {
17851|      0|      close(from_remote[handle][0]);
17852|      0|      close(to_remote[handle][1]);
17853|      0|      from_remote[handle][0] = -1;
17854|      0|      to_remote[handle][1] = -1;
17855|      0|      tmp = __errno_location();
17856|      0|      *tmp = errno_value;
17857|      0|    }
17858|      0|    return;
17859|      0|  }
17860|      0|}
17861|      0|static int do_command(int handle, char const *buffer___2) {
17862|      0|  size_t length;
17863|      0|  size_t tmp;
17864|      0|  void (*pipe_handler)();
17865|      0|  void (*tmp___0)(int);
17866|      0|  ssize_t written;
17867|      0|  size_t tmp___1;
17868|       |
17869|      0|  {
17870|      0|    {
17871|      0|      tmp = strlen(buffer___2);
17872|      0|      length = tmp;
17873|      0|      tmp___0 = signal(13, (void (*)(int))1);
17874|      0|      pipe_handler = (void (*)())tmp___0;
17875|      0|      tmp___1 =
17876|      0|          full_write(to_remote[handle][1], (void const *)buffer___2, length);
17877|      0|      written = (ssize_t)tmp___1;
17878|      0|      signal(13, (void (*)(int))pipe_handler);
17879|      0|    }
17880|      0|    if ((size_t)written == length) {
17881|      0|      return (0);
17882|      0|    }
17883|      0|    { _rmt_shutdown(handle, 5); }
17884|      0|    return (-1);
17885|      0|  }
17886|      0|}
17887|      0|static char *get_status_string(int handle, char *command_buffer) {
17888|      0|  char *cursor;
17889|      0|  int counter;
17890|      0|  size_t tmp;
17891|      0|  char character;
17892|      0|  size_t tmp___0;
17893|      0|  int *tmp___1;
17894|      0|  int *tmp___2;
17895|       |
17896|      0|  {
17897|      0|    counter = 0;
17898|      0|    cursor = command_buffer;
17899|      0|    {
17900|      0|      while (1) {
17901|      0|      while_continue: /* CIL Label */;
17902|      0|        if (!(counter < 64)) {
17903|      0|          goto while_break;
17904|      0|        }
17905|      0|        { tmp = safe_read(from_remote[handle][0], (void *)cursor, (size_t)1); }
17906|      0|        if (tmp != 1UL) {
17907|      0|          {
17908|      0|            _rmt_shutdown(handle, 5);
17909|      0|          }
17910|      0|          return ((char *)0);
17911|      0|        }
17912|      0|        if ((int)*cursor == 10) {
17913|      0|          *cursor = (char)'\000';
17914|      0|          goto while_break;
17915|      0|        }
17916|      0|        counter++;
17917|      0|        cursor++;
17918|      0|      }
17919|      0|    while_break: /* CIL Label */;
17920|      0|    }
17921|      0|    if (counter == 64) {
17922|      0|      {
17923|      0|        _rmt_shutdown(handle, 5);
17924|      0|      }
17925|      0|      return ((char *)0);
17926|      0|    }
17927|      0|    cursor = command_buffer;
17928|      0|    {
17929|      0|      while (1) {
17930|      0|      while_continue___0: /* CIL Label */;
17931|      0|        if (!*cursor) {
17932|      0|          goto while_break___0;
17933|      0|        }
17934|      0|        if ((int)*cursor != 32) {
17935|      0|          goto while_break___0;
17936|      0|        }
17937|      0|        cursor++;
17938|      0|      }
17939|      0|    while_break___0: /* CIL Label */;
17940|      0|    }
17941|      0|    if ((int)*cursor == 69) {
17942|      0|      goto _L___3;
17943|      0|    } else {
17944|      0|      if ((int)*cursor == 70) {
17945|      0|      _L___3 : /* CIL Label */
17946|      0|      {
17947|      0|        while (1) {
17948|      0|        while_continue___1: /* CIL Label */;
17949|      0|          {
17950|      0|            tmp___0 = safe_read(from_remote[handle][0], (void *)(&character),
17951|      0|                                (size_t)1);
17952|      0|          }
17953|      0|          if (!(tmp___0 == 1UL)) {
17954|      0|            goto while_break___1;
17955|      0|          }
17956|      0|          if ((int)character == 10) {
17957|      0|            goto while_break___1;
17958|      0|          }
17959|      0|        }
17960|      0|      while_break___1: /* CIL Label */;
17961|      0|      }
17962|      0|        {
17963|      0|          tmp___1 = __errno_location();
17964|      0|          *tmp___1 = atoi((char const *)(cursor + 1));
17965|      0|        }
17966|      0|        if ((int)*cursor == 70) {
17967|      0|          {
17968|      0|            tmp___2 = __errno_location();
17969|      0|            _rmt_shutdown(handle, *tmp___2);
17970|      0|          }
17971|      0|        }
17972|      0|        return ((char *)0);
17973|      0|      }
17974|      0|    }
17975|      0|    if ((int)*cursor != 65) {
17976|      0|      {
17977|      0|        _rmt_shutdown(handle, 5);
17978|      0|      }
17979|      0|      return ((char *)0);
17980|      0|    }
17981|      0|    return (cursor + 1);
17982|      0|  }
17983|      0|}
17984|      0|static long get_status(int handle) {
17985|      0|  char command_buffer[64];
17986|      0|  char const *status;
17987|      0|  char *tmp;
17988|      0|  long result;
17989|      0|  long tmp___0;
17990|      0|  int *tmp___1;
17991|      0|  void *__cil_tmp8;
17992|       |
17993|      0|  {
17994|      0|    {
17995|      0|      tmp = get_status_string(handle, command_buffer);
17996|      0|      status = (char const *)tmp;
17997|      0|    }
17998|      0|    if (status) {
17999|      0|      {
18000|      0|        tmp___0 = atol(status);
18001|      0|        result = tmp___0;
18002|      0|      }
18003|      0|      if (0L <= result) {
18004|      0|        return (result);
18005|      0|      }
18006|      0|      {
18007|      0|        tmp___1 = __errno_location();
18008|      0|        *tmp___1 = 5;
18009|      0|      }
18010|      0|    }
18011|      0|    return (-1L);
18012|      0|  }
18013|      0|}
18014|      0|static off_t get_status_off(int handle) {
18015|      0|  char command_buffer[64];
18016|      0|  char const *status;
18017|      0|  char *tmp;
18018|      0|  off_t count;
18019|      0|  int negative;
18020|      0|  int digit;
18021|      0|  char const *tmp___0;
18022|      0|  off_t c10;
18023|      0|  off_t nc;
18024|      0|  int tmp___1;
18025|      0|  int tmp___2;
18026|      0|  void *__cil_tmp13;
18027|       |
18028|      0|  {
18029|      0|    {
18030|      0|      tmp = get_status_string(handle, command_buffer);
18031|      0|      status = (char const *)tmp;
18032|      0|    }
18033|      0|    if (!status) {
18034|      0|      return ((off_t)-1);
18035|      0|    } else {
18036|      0|      count = (off_t)0;
18037|      0|      {
18038|      0|        while (1) {
18039|      0|        while_continue: /* CIL Label */;
18040|      0|          if (!((int const) * status == 32)) {
18041|      0|            if (!((int const) * status == 9)) {
18042|      0|              goto while_break;
18043|      0|            }
18044|      0|          }
18045|      0|          goto __Cont;
18046|      0|        __Cont:
18047|      0|          status++;
18048|      0|        }
18049|      0|      while_break: /* CIL Label */;
18050|      0|      }
18051|      0|      negative = (int const) * status == 45;
18052|      0|      if (negative) {
18053|      0|        tmp___1 = 1;
18054|      0|      } else {
18055|      0|        if ((int const) * status == 43) {
18056|      0|          tmp___1 = 1;
18057|      0|        } else {
18058|      0|          tmp___1 = 0;
18059|      0|        }
18060|      0|      }
18061|      0|      status += tmp___1;
18062|      0|      {
18063|      0|        while (1) {
18064|      0|        while_continue___0: /* CIL Label */;
18065|      0|          tmp___0 = status;
18066|      0|          status++;
18067|      0|          digit = (int)((int const) * tmp___0 - 48);
18068|      0|          if (9U < (unsigned int)digit) {
18069|      0|            goto while_break___0;
18070|      0|          } else {
18071|      0|            c10 = 10L * count;
18072|      0|            if (negative) {
18073|      0|              nc = c10 - (off_t)digit;
18074|      0|            } else {
18075|      0|              nc = c10 + (off_t)digit;
18076|      0|            }
18077|      0|            if (c10 / 10L != count) {
18078|      0|              return ((off_t)-1);
18079|      0|            } else {
18080|      0|              if (negative) {
18081|      0|                tmp___2 = c10 < nc;
18082|      0|              } else {
18083|      0|                tmp___2 = nc < c10;
18084|      0|              }
18085|      0|              if (tmp___2) {
18086|      0|                return ((off_t)-1);
18087|      0|              }
18088|      0|            }
18089|      0|            count = nc;
18090|      0|          }
18091|      0|        }
18092|      0|      while_break___0: /* CIL Label */;
18093|      0|      }
18094|      0|      return (count);
18095|      0|    }
18096|      0|  }
18097|      0|}
18098|      0|static void encode_oflag(char *buf, int oflag) {
18099|      0|  char *__cil_tmp3;
18100|      0|  char *__cil_tmp4;
18101|      0|  char *__cil_tmp5;
18102|      0|  char *__cil_tmp6;
18103|      0|  char *__cil_tmp7;
18104|      0|  char *__cil_tmp8;
18105|      0|  char *__cil_tmp9;
18106|      0|  char *__cil_tmp10;
18107|      0|  char *__cil_tmp11;
18108|      0|  char *__cil_tmp12;
18109|      0|  char *__cil_tmp13;
18110|      0|  char *__cil_tmp14;
18111|      0|  char *__cil_tmp15;
18112|       |
18113|      0|  {
18114|      0|    {
18115|      0|      sprintf((char * /* __restrict  */)buf,
18116|      0|              (char const * /* __restrict  */) "%d ", oflag);
18117|      0|    }
18118|      0|    {
18119|      0|      if ((oflag & 3) == 0) {
18120|      0|        goto case_0;
18121|      0|      }
18122|      0|      if ((oflag & 3) == 2) {
18123|      0|        goto case_2;
18124|      0|      }
18125|      0|      if ((oflag & 3) == 1) {
18126|      0|        goto case_1;
18127|      0|      }
18128|      0|      goto switch_default;
18129|      0|    case_0 : /* CIL Label */
18130|      0|    {
18131|      0|      strcat((char * /* __restrict  */)buf,
18132|      0|             (char const * /* __restrict  */) "O_RDONLY");
18133|      0|    }
18134|      0|      goto switch_break;
18135|      0|    case_2 : /* CIL Label */
18136|      0|    {
18137|      0|      strcat((char * /* __restrict  */)buf,
18138|      0|             (char const * /* __restrict  */) "O_RDWR");
18139|      0|    }
18140|      0|      goto switch_break;
18141|      0|    case_1 : /* CIL Label */
18142|      0|    {
18143|      0|      strcat((char * /* __restrict  */)buf,
18144|      0|             (char const * /* __restrict  */) "O_WRONLY");
18145|      0|    }
18146|      0|      goto switch_break;
18147|      0|    switch_default : /* CIL Label */
18148|      0|    {
18149|      0|      abort();
18150|      0|    }
18151|      0|    switch_break: /* CIL Label */;
18152|      0|    }
18153|      0|    if (oflag & 1024) {
18154|      0|      {
18155|      0|        strcat((char * /* __restrict  */)buf,
18156|      0|               (char const * /* __restrict  */) "|O_APPEND");
18157|      0|      }
18158|      0|    }
18159|      0|    if (oflag & 64) {
18160|      0|      {
18161|      0|        strcat((char * /* __restrict  */)buf,
18162|      0|               (char const * /* __restrict  */) "|O_CREAT");
18163|      0|      }
18164|      0|    }
18165|      0|    if (oflag & 4096) {
18166|      0|      {
18167|      0|        strcat((char * /* __restrict  */)buf,
18168|      0|               (char const * /* __restrict  */) "|O_DSYNC");
18169|      0|      }
18170|      0|    }
18171|      0|    if (oflag & 128) {
18172|      0|      {
18173|      0|        strcat((char * /* __restrict  */)buf,
18174|      0|               (char const * /* __restrict  */) "|O_EXCL");
18175|      0|      }
18176|      0|    }
18177|      0|    if (oflag & 256) {
18178|      0|      {
18179|      0|        strcat((char * /* __restrict  */)buf,
18180|      0|               (char const * /* __restrict  */) "|O_NOCTTY");
18181|      0|      }
18182|      0|    }
18183|      0|    if (oflag & 2048) {
18184|      0|      {
18185|      0|        strcat((char * /* __restrict  */)buf,
18186|      0|               (char const * /* __restrict  */) "|O_NONBLOCK");
18187|      0|      }
18188|      0|    }
18189|      0|    if (oflag & 1052672) {
18190|      0|      {
18191|      0|        strcat((char * /* __restrict  */)buf,
18192|      0|               (char const * /* __restrict  */) "|O_RSYNC");
18193|      0|      }
18194|      0|    }
18195|      0|    if (oflag & 1052672) {
18196|      0|      {
18197|      0|        strcat((char * /* __restrict  */)buf,
18198|      0|               (char const * /* __restrict  */) "|O_SYNC");
18199|      0|      }
18200|      0|    }
18201|      0|    if (oflag & 512) {
18202|      0|      {
18203|      0|        strcat((char * /* __restrict  */)buf,
18204|      0|               (char const * /* __restrict  */) "|O_TRUNC");
18205|      0|      }
18206|      0|    }
18207|      0|    return;
18208|      0|  }
18209|      0|}
18210|       |int rmt_open__(char const *path, int open_mode, int bias,
18211|      0|               char const *remote_shell) {
18212|      0|  int remote_pipe_number;
18213|      0|  char *path_copy;
18214|      0|  char *remote_host;
18215|      0|  char *remote_file;
18216|      0|  char *remote_user;
18217|      0|  int *tmp;
18218|      0|  char *cursor;
18219|      0|  int *tmp___0;
18220|      0|  char const *remote_shell_basename;
18221|      0|  pid_t status;
18222|      0|  char *tmp___1;
18223|      0|  int e;
18224|      0|  int *tmp___2;
18225|      0|  int *tmp___3;
18226|      0|  int tmp___4;
18227|      0|  int tmp___5;
18228|      0|  int e___0;
18229|      0|  int *tmp___6;
18230|      0|  int *tmp___7;
18231|      0|  char *tmp___8;
18232|      0|  int *tmp___9;
18233|      0|  size_t remote_file_len;
18234|      0|  size_t tmp___10;
18235|      0|  char *command_buffer;
18236|      0|  void *tmp___11;
18237|      0|  int e___1;
18238|      0|  int *tmp___12;
18239|      0|  int tmp___13;
18240|      0|  long tmp___14;
18241|      0|  char const *tmp___15;
18242|      0|  char const *tmp___16;
18243|      0|  char *__cil_tmp36;
18244|      0|  char *__cil_tmp37;
18245|      0|  char *__cil_tmp38;
18246|      0|  char *__cil_tmp39;
18247|      0|  char *__cil_tmp40;
18248|      0|  char *__cil_tmp41;
18249|       |
18250|      0|  {
18251|      0|    remote_pipe_number = 0;
18252|      0|    {
18253|      0|      while (1) {
18254|      0|      while_continue: /* CIL Label */;
18255|      0|        if (!(remote_pipe_number < 4)) {
18256|      0|          goto while_break;
18257|      0|        }
18258|      0|        if (from_remote[remote_pipe_number][0] == -1) {
18259|      0|          if (to_remote[remote_pipe_number][1] == -1) {
18260|      0|            goto while_break;
18261|      0|          }
18262|      0|        }
18263|      0|        remote_pipe_number++;
18264|      0|      }
18265|      0|    while_break: /* CIL Label */;
18266|      0|    }
18267|      0|    if (remote_pipe_number == 4) {
18268|      0|      {
18269|      0|        tmp = __errno_location();
18270|      0|        *tmp = 24;
18271|      0|      }
18272|      0|      return (-1);
18273|      0|    }
18274|      0|    {
18275|      0|      path_copy = xstrdup(path);
18276|      0|      remote_host = path_copy;
18277|      0|      remote_user = (char *)0;
18278|      0|      remote_file = (char *)0;
18279|      0|      cursor = path_copy;
18280|      0|    }
18281|      0|    {
18282|      0|      while (1) {
18283|      0|      while_continue___0: /* CIL Label */;
18284|      0|        if (!*cursor) {
18285|      0|          goto while_break___0;
18286|      0|        }
18287|      0|        {
18288|      0|          if ((int)*cursor == 10) {
18289|      0|            goto case_10;
18290|      0|          }
18291|      0|          if ((int)*cursor == 64) {
18292|      0|            goto case_64;
18293|      0|          }
18294|      0|          if ((int)*cursor == 58) {
18295|      0|            goto case_58;
18296|      0|          }
18297|      0|          goto switch_default;
18298|      0|        switch_default: /* CIL Label */
18299|      0|          goto switch_break;
18300|      0|        case_10 : /* CIL Label */
18301|      0|        {
18302|      0|          free((void *)path_copy);
18303|      0|          tmp___0 = __errno_location();
18304|      0|          *tmp___0 = 2;
18305|      0|        }
18306|      0|          return (-1);
18307|      0|        case_64: /* CIL Label */
18308|      0|          if (!remote_user) {
18309|      0|            remote_user = remote_host;
18310|      0|            *cursor = (char)'\000';
18311|      0|            remote_host = cursor + 1;
18312|      0|          }
18313|      0|          goto switch_break;
18314|      0|        case_58: /* CIL Label */
18315|      0|          if (!remote_file) {
18316|      0|            *cursor = (char)'\000';
18317|      0|            remote_file = cursor + 1;
18318|      0|          }
18319|      0|          goto switch_break;
18320|      0|        switch_break: /* CIL Label */;
18321|      0|        }
18322|      0|        cursor++;
18323|      0|      }
18324|      0|    while_break___0: /* CIL Label */;
18325|      0|    }
18326|      0|    if (remote_user) {
18327|      0|      if ((int)*remote_user == 0) {
18328|      0|        remote_user = (char *)0;
18329|      0|      }
18330|      0|    }
18331|      0|    if (!remote_shell) {
18332|      0|      remote_shell = "/usr/bin/rsh";
18333|      0|    }
18334|      0|    {
18335|      0|      tmp___1 = base_name(remote_shell);
18336|      0|      remote_shell_basename = (char const *)tmp___1;
18337|      0|      tmp___4 = pipe(to_remote[remote_pipe_number]);
18338|      0|    }
18339|      0|    if (tmp___4 == -1) {
18340|      0|      goto _L;
18341|      0|    } else {
18342|      0|      { tmp___5 = pipe(from_remote[remote_pipe_number]); }
18343|      0|      if (tmp___5 == -1) {
18344|      0|      _L : {
18345|      0|        tmp___2 = __errno_location();
18346|      0|        e = *tmp___2;
18347|      0|        free((void *)path_copy);
18348|      0|        tmp___3 = __errno_location();
18349|      0|        *tmp___3 = e;
18350|      0|      }
18351|      0|        return (-1);
18352|      0|      }
18353|      0|    }
18354|      0|    { status = fork(); }
18355|      0|    if (status == -1) {
18356|      0|      {
18357|      0|        tmp___6 = __errno_location();
18358|      0|        e___0 = *tmp___6;
18359|      0|        free((void *)path_copy);
18360|      0|        tmp___7 = __errno_location();
18361|      0|        *tmp___7 = e___0;
18362|      0|      }
18363|      0|      return (-1);
18364|      0|    }
18365|      0|    if (status == 0) {
18366|      0|      {
18367|      0|        close(0);
18368|      0|        dup(to_remote[remote_pipe_number][0]);
18369|      0|        close(to_remote[remote_pipe_number][0]);
18370|      0|        close(to_remote[remote_pipe_number][1]);
18371|      0|        close(1);
18372|      0|        dup(from_remote[remote_pipe_number][1]);
18373|      0|        close(from_remote[remote_pipe_number][0]);
18374|      0|        close(from_remote[remote_pipe_number][1]);
18375|      0|        sys_reset_uid_gid();
18376|      0|      }
18377|      0|      if (remote_user) {
18378|      0|        if (rmt_command_option) {
18379|      0|          tmp___15 = rmt_command_option;
18380|      0|        } else {
18381|      0|          tmp___15 = "/etc/rmt";
18382|      0|        }
18383|      0|        {
18384|      0|          execl(remote_shell, remote_shell_basename, remote_host, "-l",
18385|      0|                remote_user, tmp___15, (char *)0);
18386|      0|        }
18387|      0|      } else {
18388|      0|        if (rmt_command_option) {
18389|      0|          tmp___16 = rmt_command_option;
18390|      0|        } else {
18391|      0|          tmp___16 = "/etc/rmt";
18392|      0|        }
18393|      0|        {
18394|      0|          execl(remote_shell, remote_shell_basename, remote_host, tmp___16,
18395|      0|                (char *)0);
18396|      0|        }
18397|      0|      }
18398|      0|      {
18399|      0|        tmp___8 = gettext("Cannot execute remote shell");
18400|      0|        tmp___9 = __errno_location();
18401|      0|        error(128, *tmp___9, (char const *)tmp___8);
18402|      0|      }
18403|      0|    }
18404|      0|    {
18405|      0|      close(from_remote[remote_pipe_number][1]);
18406|      0|      close(to_remote[remote_pipe_number][0]);
18407|      0|      tmp___10 = strlen((char const *)remote_file);
18408|      0|      remote_file_len = tmp___10;
18409|      0|      tmp___11 = xmalloc(remote_file_len + 1000UL);
18410|      0|      command_buffer = (char *)tmp___11;
18411|      0|      sprintf((char * /* __restrict  */)command_buffer,
18412|      0|              (char const * /* __restrict  */) "O%s\n", remote_file);
18413|      0|      encode_oflag((command_buffer + remote_file_len) + 2, open_mode);
18414|      0|      strcat((char * /* __restrict  */)command_buffer,
18415|      0|             (char const * /* __restrict  */) "\n");
18416|      0|      tmp___13 = do_command(remote_pipe_number, (char const *)command_buffer);
18417|      0|    }
18418|      0|    if (tmp___13 == -1) {
18419|      0|      goto _L___0;
18420|      0|    } else {
18421|      0|      { tmp___14 = get_status(remote_pipe_number); }
18422|      0|      if (tmp___14 == -1L) {
18423|      0|      _L___0 : {
18424|      0|        tmp___12 = __errno_location();
18425|      0|        e___1 = *tmp___12;
18426|      0|        free((void *)command_buffer);
18427|      0|        free((void *)path_copy);
18428|      0|        _rmt_shutdown(remote_pipe_number, e___1);
18429|      0|      }
18430|      0|        return (-1);
18431|      0|      }
18432|      0|    }
18433|      0|    {
18434|      0|      free((void *)command_buffer);
18435|      0|      free((void *)path_copy);
18436|      0|    }
18437|      0|    return (remote_pipe_number + bias);
18438|      0|  }
18439|      0|}
18440|      0|int rmt_close__(int handle) {
18441|      0|  long status;
18442|      0|  int tmp;
18443|      0|  int *tmp___0;
18444|      0|  char *__cil_tmp5;
18445|       |
18446|      0|  {
18447|      0|    { tmp = do_command(handle, "C\n"); }
18448|      0|    if (tmp == -1) {
18449|      0|      return (-1);
18450|      0|    }
18451|      0|    {
18452|      0|      status = get_status(handle);
18453|      0|      tmp___0 = __errno_location();
18454|      0|      _rmt_shutdown(handle, *tmp___0);
18455|      0|    }
18456|      0|    return ((int)status);
18457|      0|  }
18458|      0|}
18459|      0|size_t rmt_read__(int handle, char *buffer___2, size_t length) {
18460|      0|  char command_buffer[64];
18461|      0|  size_t status;
18462|      0|  size_t rlen;
18463|      0|  size_t counter;
18464|      0|  int tmp;
18465|      0|  long tmp___0;
18466|      0|  void *__cil_tmp10;
18467|      0|  char *__cil_tmp11;
18468|       |
18469|      0|  {
18470|      0|    {
18471|      0|      sprintf((char * /* __restrict  */)(command_buffer),
18472|      0|              (char const * /* __restrict  */) "R%lu\n", length);
18473|      0|      tmp = do_command(handle, (char const *)(command_buffer));
18474|      0|    }
18475|      0|    if (tmp == -1) {
18476|      0|      return ((size_t)-1);
18477|      0|    } else {
18478|      0|      {
18479|      0|        tmp___0 = get_status(handle);
18480|      0|        status = (size_t)tmp___0;
18481|      0|      }
18482|      0|      if (status == 0xffffffffffffffffUL) {
18483|      0|        return ((size_t)-1);
18484|      0|      }
18485|      0|    }
18486|      0|    counter = (size_t)0;
18487|      0|    {
18488|      0|      while (1) {
18489|      0|      while_continue: /* CIL Label */;
18490|      0|        if (!(counter < status)) {
18491|      0|          goto while_break;
18492|      0|        }
18493|      0|        {
18494|      0|          rlen = safe_read(from_remote[handle][0], (void *)buffer___2,
18495|      0|                           status - counter);
18496|      0|        }
18497|      0|        if (rlen == 0xffffffffffffffffUL) {
18498|      0|          {
18499|      0|            _rmt_shutdown(handle, 5);
18500|      0|          }
18501|      0|          return ((size_t)-1);
18502|      0|        } else {
18503|      0|          if (rlen == 0UL) {
18504|      0|            {
18505|      0|              _rmt_shutdown(handle, 5);
18506|      0|            }
18507|      0|            return ((size_t)-1);
18508|      0|          }
18509|      0|        }
18510|      0|        counter += rlen;
18511|      0|        buffer___2 += rlen;
18512|      0|      }
18513|      0|    while_break: /* CIL Label */;
18514|      0|    }
18515|      0|    return (status);
18516|      0|  }
18517|      0|}
18518|      0|size_t rmt_write__(int handle, char *buffer___2, size_t length) {
18519|      0|  char command_buffer[64];
18520|      0|  void (*pipe_handler)();
18521|      0|  size_t written;
18522|      0|  int tmp;
18523|      0|  void (*tmp___0)(int);
18524|      0|  long r;
18525|      0|  long tmp___1;
18526|      0|  void *__cil_tmp11;
18527|      0|  char *__cil_tmp12;
18528|       |
18529|      0|  {
18530|      0|    {
18531|      0|      sprintf((char * /* __restrict  */)(command_buffer),
18532|      0|              (char const * /* __restrict  */) "W%lu\n", length);
18533|      0|      tmp = do_command(handle, (char const *)(command_buffer));
18534|      0|    }
18535|      0|    if (tmp == -1) {
18536|      0|      return ((size_t)0);
18537|      0|    }
18538|      0|    {
18539|      0|      tmp___0 = signal(13, (void (*)(int))1);
18540|      0|      pipe_handler = (void (*)())tmp___0;
18541|      0|      written =
18542|      0|          full_write(to_remote[handle][1], (void const *)buffer___2, length);
18543|      0|      signal(13, (void (*)(int))pipe_handler);
18544|      0|    }
18545|      0|    if (written == length) {
18546|      0|      {
18547|      0|        tmp___1 = get_status(handle);
18548|      0|        r = tmp___1;
18549|      0|      }
18550|      0|      if (r < 0L) {
18551|      0|        return ((size_t)0);
18552|      0|      }
18553|      0|      if ((size_t)r == length) {
18554|      0|        return (length);
18555|      0|      }
18556|      0|      written = (size_t)r;
18557|      0|    }
18558|      0|    { _rmt_shutdown(handle, 5); }
18559|      0|    return (written);
18560|      0|  }
18561|      0|}
18562|      0|off_t rmt_lseek__(int handle, off_t offset, int whence) {
18563|      0|  char command_buffer[64];
18564|      0|  char operand_buffer[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
18565|      0|                      1UL];
18566|      0|  uintmax_t u;
18567|      0|  char *p;
18568|      0|  int tmp;
18569|      0|  off_t tmp___0;
18570|      0|  void *__cil_tmp10;
18571|      0|  void *__cil_tmp11;
18572|      0|  char *__cil_tmp12;
18573|       |
18574|      0|  {
18575|      0|    if (offset < 0L) {
18576|      0|      u = -((uintmax_t)offset);
18577|      0|    } else {
18578|      0|      u = (uintmax_t)offset;
18579|      0|    }
18580|      0|    p = operand_buffer + sizeof(operand_buffer);
18581|      0|    p--;
18582|      0|    *p = (char)0;
18583|      0|    {
18584|      0|      while (1) {
18585|      0|      while_continue: /* CIL Label */;
18586|      0|        p--;
18587|      0|        *p = (char)(48 + (int)(u % 10UL));
18588|      0|        u /= 10UL;
18589|      0|        if (!(u != 0UL)) {
18590|      0|          goto while_break;
18591|      0|        }
18592|      0|      }
18593|      0|    while_break: /* CIL Label */;
18594|      0|    }
18595|      0|    if (offset < 0L) {
18596|      0|      p--;
18597|      0|      *p = (char)'-';
18598|      0|    }
18599|      0|    {
18600|      0|      if (whence == 0) {
18601|      0|        goto case_0;
18602|      0|      }
18603|      0|      if (whence == 1) {
18604|      0|        goto case_1;
18605|      0|      }
18606|      0|      if (whence == 2) {
18607|      0|        goto case_2;
18608|      0|      }
18609|      0|      goto switch_default;
18610|      0|    case_0: /* CIL Label */
18611|      0|      whence = 0;
18612|      0|      goto switch_break;
18613|      0|    case_1: /* CIL Label */
18614|      0|      whence = 1;
18615|      0|      goto switch_break;
18616|      0|    case_2: /* CIL Label */
18617|      0|      whence = 2;
18618|      0|      goto switch_break;
18619|      0|    switch_default : /* CIL Label */
18620|      0|    {
18621|      0|      abort();
18622|      0|    }
18623|      0|    switch_break: /* CIL Label */;
18624|      0|    }
18625|      0|    {
18626|      0|      sprintf((char * /* __restrict  */)(command_buffer),
18627|      0|              (char const * /* __restrict  */) "L%s\n%d\n", p, whence);
18628|      0|      tmp = do_command(handle, (char const *)(command_buffer));
18629|      0|    }
18630|      0|    if (tmp == -1) {
18631|      0|      return ((off_t)-1);
18632|      0|    }
18633|      0|    { tmp___0 = get_status_off(handle); }
18634|      0|    return (tmp___0);
18635|      0|  }
18636|      0|}
18637|      0|int rmt_ioctl__(int handle, int operation, char *argument) {
18638|      0|  int *tmp;
18639|      0|  char command_buffer[64];
18640|      0|  char operand_buffer[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
18641|      0|                      1UL];
18642|      0|  uintmax_t u;
18643|      0|  char *p;
18644|      0|  int tmp___0;
18645|      0|  long tmp___1;
18646|      0|  ssize_t status;
18647|      0|  size_t counter;
18648|      0|  int tmp___2;
18649|      0|  char copy;
18650|      0|  void *__cil_tmp15;
18651|      0|  void *__cil_tmp16;
18652|      0|  char *__cil_tmp17;
18653|      0|  char *__cil_tmp18;
18654|       |
18655|      0|  {
18656|      0|    {
18657|      0|      if (operation ==
18658|      0|          (int)((unsigned long)(((1U << 30) | (unsigned int)(109 << 8)) | 1U) |
18659|      0|                (sizeof(struct mtop) << 16))) {
18660|      0|        goto case_exp;
18661|      0|      }
18662|      0|      if (operation ==
18663|      0|          (int)((unsigned long)(((2U << 30) | (unsigned int)(109 << 8)) | 2U) |
18664|      0|                (sizeof(struct mtget) << 16))) {
18665|      0|        goto case_exp___0;
18666|      0|      }
18667|      0|      goto switch_default;
18668|      0|    switch_default : /* CIL Label */
18669|      0|    {
18670|      0|      tmp = __errno_location();
18671|      0|      *tmp = 95;
18672|      0|    }
18673|      0|      return (-1);
18674|      0|    case_exp: /* CIL Label */
18675|      0|      if (((struct mtop *)argument)->mt_count < 0) {
18676|      0|        u = -((uintmax_t)((struct mtop *)argument)->mt_count);
18677|      0|      } else {
18678|      0|        u = (uintmax_t)((struct mtop *)argument)->mt_count;
18679|      0|      }
18680|      0|      p = operand_buffer + sizeof(operand_buffer);
18681|      0|      p--;
18682|      0|      *p = (char)0;
18683|      0|      {
18684|      0|        while (1) {
18685|      0|        while_continue: /* CIL Label */;
18686|      0|          p--;
18687|      0|          *p = (char)(48 + (int)(u % 10UL));
18688|      0|          u /= 10UL;
18689|      0|          if (!(u != 0UL)) {
18690|      0|            goto while_break;
18691|      0|          }
18692|      0|        }
18693|      0|      while_break: /* CIL Label */;
18694|      0|      }
18695|      0|      if (((struct mtop *)argument)->mt_count < 0) {
18696|      0|        p--;
18697|      0|        *p = (char)'-';
18698|      0|      }
18699|      0|      {
18700|      0|        sprintf((char * /* __restrict  */)(command_buffer),
18701|      0|                (char const * /* __restrict  */) "I%d\n%s\n",
18702|      0|                (int)((struct mtop *)argument)->mt_op, p);
18703|      0|        tmp___0 = do_command(handle, (char const *)(command_buffer));
18704|      0|      }
18705|      0|      if (tmp___0 == -1) {
18706|      0|        return (-1);
18707|      0|      }
18708|      0|      { tmp___1 = get_status(handle); }
18709|      0|      return ((int)tmp___1);
18710|      0|    case_exp___0 : /* CIL Label */
18711|      0|    {
18712|      0|      tmp___2 = do_command(handle, "S");
18713|      0|    }
18714|      0|      if (tmp___2 == -1) {
18715|      0|        return (-1);
18716|      0|      } else {
18717|      0|        { status = get_status(handle); }
18718|      0|        if (status == -1L) {
18719|      0|          return (-1);
18720|      0|        }
18721|      0|      }
18722|      0|      {
18723|      0|        while (1) {
18724|      0|        while_continue___0: /* CIL Label */;
18725|      0|          if (!(status > 0L)) {
18726|      0|            goto while_break___0;
18727|      0|          }
18728|      0|          {
18729|      0|            counter = safe_read(from_remote[handle][0], (void *)argument,
18730|      0|                                (size_t)status);
18731|      0|          }
18732|      0|          if (counter == 0xffffffffffffffffUL) {
18733|      0|            {
18734|      0|              _rmt_shutdown(handle, 5);
18735|      0|            }
18736|      0|            return (-1);
18737|      0|          } else {
18738|      0|            if (counter == 0UL) {
18739|      0|              {
18740|      0|                _rmt_shutdown(handle, 5);
18741|      0|              }
18742|      0|              return (-1);
18743|      0|            }
18744|      0|          }
18745|      0|          status = (ssize_t)((size_t)status - counter);
18746|      0|          argument += counter;
18747|      0|        }
18748|      0|      while_break___0: /* CIL Label */;
18749|      0|      }
18750|      0|      if (((struct mtget *)argument)->mt_type < 256L) {
18751|      0|        return (0);
18752|      0|      }
18753|      0|      counter = (size_t)0;
18754|      0|      {
18755|      0|        while (1) {
18756|      0|        while_continue___1: /* CIL Label */;
18757|      0|          if (!(counter < (size_t)status)) {
18758|      0|            goto while_break___1;
18759|      0|          }
18760|      0|          copy = *(argument + counter);
18761|      0|          *(argument + counter) = *(argument + (counter + 1UL));
18762|      0|          *(argument + (counter + 1UL)) = copy;
18763|      0|          counter += 2UL;
18764|      0|        }
18765|      0|      while_break___1: /* CIL Label */;
18766|      0|      }
18767|      0|      return (0);
18768|      0|    switch_break: /* CIL Label */;
18769|      0|    }
18770|      0|  }
18771|      0|}
18772|       |/* #pragma merger("0","00c.sparse.o.i","") */
18773|      0|static _Bool tar_sparse_member_p(struct tar_sparse_file *file) {
18774|      0|  _Bool tmp;
18775|       |
18776|      0|  {
18777|      0|    if ((file->optab)->sparse_member_p) {
18778|      0|      {
18779|      0|        tmp = (*((file->optab)->sparse_member_p))(file);
18780|      0|      }
18781|      0|      return (tmp);
18782|      0|    }
18783|      0|    return ((_Bool)0);
18784|      0|  }
18785|      0|}
18786|      0|static _Bool tar_sparse_init(struct tar_sparse_file *file) {
18787|      0|  _Bool tmp;
18788|       |
18789|      0|  {
18790|      0|    file->dumped_size = (size_t)0;
18791|      0|    if ((file->optab)->init) {
18792|      0|      {
18793|      0|        tmp = (*((file->optab)->init))(file);
18794|      0|      }
18795|      0|      return (tmp);
18796|      0|    }
18797|      0|    return ((_Bool)1);
18798|      0|  }
18799|      0|}
18800|      0|static _Bool tar_sparse_done(struct tar_sparse_file *file) {
18801|      0|  _Bool tmp;
18802|       |
18803|      0|  {
18804|      0|    if ((file->optab)->done) {
18805|      0|      {
18806|      0|        tmp = (*((file->optab)->done))(file);
18807|      0|      }
18808|      0|      return (tmp);
18809|      0|    }
18810|      0|    return ((_Bool)1);
18811|      0|  }
18812|      0|}
18813|       |static _Bool tar_sparse_scan(struct tar_sparse_file *file,
18814|      0|                             enum sparse_scan_state state, void *block) {
18815|      0|  _Bool tmp;
18816|       |
18817|      0|  {
18818|      0|    if ((file->optab)->scan_block) {
18819|      0|      {
18820|      0|        tmp = (*((file->optab)->scan_block))(file, state, block);
18821|      0|      }
18822|      0|      return (tmp);
18823|      0|    }
18824|      0|    return ((_Bool)1);
18825|      0|  }
18826|      0|}
18827|      0|static _Bool tar_sparse_dump_region(struct tar_sparse_file *file, size_t i) {
18828|      0|  _Bool tmp;
18829|       |
18830|      0|  {
18831|      0|    if ((file->optab)->dump_region) {
18832|      0|      {
18833|      0|        tmp = (*((file->optab)->dump_region))(file, i);
18834|      0|      }
18835|      0|      return (tmp);
18836|      0|    }
18837|      0|    return ((_Bool)0);
18838|      0|  }
18839|      0|}
18840|      0|static _Bool tar_sparse_extract_region(struct tar_sparse_file *file, size_t i) {
18841|      0|  _Bool tmp;
18842|       |
18843|      0|  {
18844|      0|    if ((file->optab)->extract_region) {
18845|      0|      {
18846|      0|        tmp = (*((file->optab)->extract_region))(file, i);
18847|      0|      }
18848|      0|      return (tmp);
18849|      0|    }
18850|      0|    return ((_Bool)0);
18851|      0|  }
18852|      0|}
18853|      0|static _Bool tar_sparse_dump_header(struct tar_sparse_file *file) {
18854|      0|  _Bool tmp;
18855|       |
18856|      0|  {
18857|      0|    if ((file->optab)->dump_header) {
18858|      0|      {
18859|      0|        tmp = (*((file->optab)->dump_header))(file);
18860|      0|      }
18861|      0|      return (tmp);
18862|      0|    }
18863|      0|    return ((_Bool)0);
18864|      0|  }
18865|      0|}
18866|      0|static _Bool tar_sparse_decode_header(struct tar_sparse_file *file) {
18867|      0|  _Bool tmp;
18868|       |
18869|      0|  {
18870|      0|    if ((file->optab)->decode_header) {
18871|      0|      {
18872|      0|        tmp = (*((file->optab)->decode_header))(file);
18873|      0|      }
18874|      0|      return (tmp);
18875|      0|    }
18876|      0|    return ((_Bool)1);
18877|      0|  }
18878|      0|}
18879|      0|static _Bool tar_sparse_fixup_header(struct tar_sparse_file *file) {
18880|      0|  _Bool tmp;
18881|       |
18882|      0|  {
18883|      0|    if ((file->optab)->fixup_header) {
18884|      0|      {
18885|      0|        tmp = (*((file->optab)->fixup_header))(file);
18886|      0|      }
18887|      0|      return (tmp);
18888|      0|    }
18889|      0|    return ((_Bool)1);
18890|      0|  }
18891|      0|}
18892|       |static _Bool lseek_or_error(struct tar_sparse_file *file, off_t offset,
18893|      0|                            int whence) {
18894|      0|  __off_t tmp;
18895|       |
18896|      0|  {
18897|      0|    { tmp = lseek(file->fd, offset, whence); }
18898|      0|    if (tmp < 0L) {
18899|      0|      {
18900|      0|        seek_diag_details((char const *)(file->stat_info)->orig_file_name,
18901|      0|                          offset);
18902|      0|      }
18903|      0|      return ((_Bool)0);
18904|      0|    }
18905|      0|    return ((_Bool)1);
18906|      0|  }
18907|      0|}
18908|      0|static _Bool zero_block_p(char *buffer___2, size_t size) {
18909|      0|  char *tmp;
18910|      0|  size_t tmp___0;
18911|       |
18912|      0|  {
18913|      0|    {
18914|      0|      while (1) {
18915|      0|      while_continue: /* CIL Label */;
18916|      0|        tmp___0 = size;
18917|      0|        size--;
18918|      0|        if (!tmp___0) {
18919|      0|          goto while_break;
18920|      0|        }
18921|      0|        tmp = buffer___2;
18922|      0|        buffer___2++;
18923|      0|        if (*tmp) {
18924|      0|          return ((_Bool)0);
18925|      0|        }
18926|      0|      }
18927|      0|    while_break: /* CIL Label */;
18928|      0|    }
18929|      0|    return ((_Bool)1);
18930|      0|  }
18931|      0|}
18932|      0|static void sparse_add_map(struct tar_sparse_file *file, struct sp_array *sp) {
18933|      0|  void *tmp;
18934|      0|  void *tmp___0;
18935|      0|  size_t tmp___1;
18936|       |
18937|      0|  {
18938|      0|    if ((unsigned long)(file->stat_info)->sparse_map ==
18939|      0|        (unsigned long)((void *)0)) {
18940|      0|      {
18941|      0|        tmp = xmalloc(21UL * sizeof(*((file->stat_info)->sparse_map + 0)));
18942|      0|        (file->stat_info)->sparse_map = (struct sp_array *)tmp;
18943|      0|        (file->stat_info)->sparse_map_size = (size_t)21;
18944|      0|      }
18945|      0|    } else {
18946|      0|      if ((file->stat_info)->sparse_map_avail ==
18947|      0|          (file->stat_info)->sparse_map_size) {
18948|      0|        {
18949|      0|          (file->stat_info)->sparse_map_size *= 2UL;
18950|      0|          tmp___0 = xrealloc((void *)(file->stat_info)->sparse_map,
18951|      0|                             (file->stat_info)->sparse_map_size *
18952|      0|                                 sizeof(*((file->stat_info)->sparse_map + 0)));
18953|      0|          (file->stat_info)->sparse_map = (struct sp_array *)tmp___0;
18954|      0|        }
18955|      0|      }
18956|      0|    }
18957|      0|    tmp___1 = (file->stat_info)->sparse_map_avail;
18958|      0|    ((file->stat_info)->sparse_map_avail)++;
18959|      0|    *((file->stat_info)->sparse_map + tmp___1) = *sp;
18960|      0|    return;
18961|      0|  }
18962|      0|}
18963|       |static char buffer___1[512];
18964|      0|static _Bool sparse_scan_file(struct tar_sparse_file *file) {
18965|      0|  size_t count;
18966|      0|  size_t offset;
18967|      0|  struct sp_array sp;
18968|      0|  _Bool tmp;
18969|      0|  _Bool tmp___0;
18970|      0|  _Bool tmp___1;
18971|      0|  _Bool tmp___2;
18972|      0|  _Bool tmp___3;
18973|      0|  _Bool tmp___4;
18974|       |
18975|      0|  {
18976|      0|    {
18977|      0|      offset = (size_t)0;
18978|      0|      sp.offset = (off_t)0;
18979|      0|      sp.numbytes = (size_t)0;
18980|      0|      tmp = lseek_or_error(file, (off_t)0, 0);
18981|      0|    }
18982|      0|    if (!tmp) {
18983|      0|      return ((_Bool)0);
18984|      0|    }
18985|      0|    {
18986|      0|      memset((void *)(buffer___1), 0, (size_t)512);
18987|      0|      (file->stat_info)->sparse_map_size = (size_t)0;
18988|      0|      (file->stat_info)->archive_file_size = (off_t)0;
18989|      0|      tmp___0 = tar_sparse_scan(file, (enum sparse_scan_state)0, (void *)0);
18990|      0|    }
18991|      0|    if (!tmp___0) {
18992|      0|      return ((_Bool)0);
18993|      0|    }
18994|      0|    {
18995|      0|      while (1) {
18996|      0|      while_continue: /* CIL Label */;
18997|      0|        {
18998|      0|          count = safe_read(file->fd, (void *)(buffer___1), sizeof(buffer___1));
18999|      0|        }
19000|      0|        if (count != 0UL) {
19001|      0|          if (!(count != 0xffffffffffffffffUL)) {
19002|      0|            goto while_break;
19003|      0|          }
19004|      0|        } else {
19005|      0|          goto while_break;
19006|      0|        }
19007|      0|        { tmp___3 = zero_block_p(buffer___1, count); }
19008|      0|        if (tmp___3) {
19009|      0|          if (sp.numbytes) {
19010|      0|            {
19011|      0|              sparse_add_map(file, &sp);
19012|      0|              sp.numbytes = (size_t)0;
19013|      0|              tmp___1 =
19014|      0|                  tar_sparse_scan(file, (enum sparse_scan_state)1, (void *)0);
19015|      0|            }
19016|      0|            if (!tmp___1) {
19017|      0|              return ((_Bool)0);
19018|      0|            }
19019|      0|          }
19020|      0|        } else {
19021|      0|          if (sp.numbytes == 0UL) {
19022|      0|            sp.offset = (off_t)offset;
19023|      0|          }
19024|      0|          {
19025|      0|            sp.numbytes += count;
19026|      0|            (file->stat_info)->archive_file_size =
19027|      0|                (off_t)((size_t)(file->stat_info)->archive_file_size + count);
19028|      0|            tmp___2 = tar_sparse_scan(file, (enum sparse_scan_state)1,
19029|      0|                                      (void *)(buffer___1));
19030|      0|          }
19031|      0|          if (!tmp___2) {
19032|      0|            return ((_Bool)0);
19033|      0|          }
19034|      0|        }
19035|      0|        {
19036|      0|          offset += count;
19037|      0|          memset((void *)(buffer___1), 0, (size_t)512);
19038|      0|        }
19039|      0|      }
19040|      0|    while_break: /* CIL Label */;
19041|      0|    }
19042|      0|    if (sp.numbytes == 0UL) {
19043|      0|      sp.offset = (off_t)offset;
19044|      0|    }
19045|      0|    {
19046|      0|      sparse_add_map(file, &sp);
19047|      0|      (file->stat_info)->archive_file_size =
19048|      0|          (off_t)((size_t)(file->stat_info)->archive_file_size + count);
19049|      0|      tmp___4 = tar_sparse_scan(file, (enum sparse_scan_state)2, (void *)0);
19050|      0|    }
19051|      0|    return (tmp___4);
19052|      0|  }
19053|      0|}
19054|       |static struct tar_sparse_optab oldgnu_optab;
19055|       |static struct tar_sparse_optab star_optab;
19056|       |static struct tar_sparse_optab pax_optab;
19057|      0|static _Bool sparse_select_optab(struct tar_sparse_file *file) {
19058|      0|  unsigned int tmp;
19059|       |
19060|      0|  {
19061|      0|    if ((unsigned int)current_format == 0U) {
19062|      0|      tmp = (unsigned int)archive_format;
19063|      0|    } else {
19064|      0|      tmp = (unsigned int)current_format;
19065|      0|    }
19066|      0|    {
19067|      0|      if (tmp == 1U) {
19068|      0|        goto case_1;
19069|      0|      }
19070|      0|      if (tmp == 3U) {
19071|      0|        goto case_1;
19072|      0|      }
19073|      0|      if (tmp == 2U) {
19074|      0|        goto case_2;
19075|      0|      }
19076|      0|      if (tmp == 6U) {
19077|      0|        goto case_2;
19078|      0|      }
19079|      0|      if (tmp == 4U) {
19080|      0|        goto case_4;
19081|      0|      }
19082|      0|      if (tmp == 5U) {
19083|      0|        goto case_5;
19084|      0|      }
19085|      0|      goto switch_default;
19086|      0|    case_1: /* CIL Label */
19087|      0|    case_3: /* CIL Label */
19088|      0|      return ((_Bool)0);
19089|      0|    case_2: /* CIL Label */
19090|      0|    case_6: /* CIL Label */
19091|      0|      file->optab = &oldgnu_optab;
19092|      0|      goto switch_break;
19093|      0|    case_4: /* CIL Label */
19094|      0|      file->optab = &pax_optab;
19095|      0|      goto switch_break;
19096|      0|    case_5: /* CIL Label */
19097|      0|      file->optab = &star_optab;
19098|      0|      goto switch_break;
19099|      0|    switch_default: /* CIL Label */
19100|      0|      return ((_Bool)0);
19101|      0|    switch_break: /* CIL Label */;
19102|      0|    }
19103|      0|    return ((_Bool)1);
19104|      0|  }
19105|      0|}
19106|      0|static _Bool sparse_dump_region(struct tar_sparse_file *file, size_t i) {
19107|      0|  union block *blk;
19108|      0|  off_t bytes_left;
19109|      0|  _Bool tmp;
19110|      0|  size_t bufsize;
19111|      0|  size_t bytes_read;
19112|      0|  off_t tmp___0;
19113|       |
19114|      0|  {
19115|      0|    {
19116|      0|      bytes_left = (off_t)((file->stat_info)->sparse_map + i)->numbytes;
19117|      0|      tmp =
19118|      0|          lseek_or_error(file, ((file->stat_info)->sparse_map + i)->offset, 0);
19119|      0|    }
19120|      0|    if (!tmp) {
19121|      0|      return ((_Bool)0);
19122|      0|    }
19123|      0|    {
19124|      0|      while (1) {
19125|      0|      while_continue: /* CIL Label */;
19126|      0|        if (!(bytes_left > 0L)) {
19127|      0|          goto while_break;
19128|      0|        }
19129|      0|        if (bytes_left > 512L) {
19130|      0|          tmp___0 = (off_t)512;
19131|      0|        } else {
19132|      0|          tmp___0 = bytes_left;
19133|      0|        }
19134|      0|        {
19135|      0|          bufsize = (size_t)tmp___0;
19136|      0|          blk = find_next_block();
19137|      0|          memset((void *)(blk->buffer), 0, (size_t)512);
19138|      0|          bytes_read = safe_read(file->fd, (void *)(blk->buffer), bufsize);
19139|      0|        }
19140|      0|        if (bytes_read == 0xffffffffffffffffUL) {
19141|      0|          {
19142|      0|            read_diag_details(
19143|      0|                (char const *)(file->stat_info)->orig_file_name,
19144|      0|                (off_t)(((size_t)((file->stat_info)->sparse_map + i)->offset +
19145|      0|                         ((file->stat_info)->sparse_map + i)->numbytes) -
19146|      0|                        (size_t)bytes_left),
19147|      0|                bufsize);
19148|      0|          }
19149|      0|          return ((_Bool)0);
19150|      0|        }
19151|      0|        {
19152|      0|          bytes_left = (off_t)((size_t)bytes_left - bytes_read);
19153|      0|          file->dumped_size += bytes_read;
19154|      0|          set_next_block_after(blk);
19155|      0|        }
19156|      0|      }
19157|      0|    while_break: /* CIL Label */;
19158|      0|    }
19159|      0|    return ((_Bool)1);
19160|      0|  }
19161|      0|}
19162|      0|static _Bool sparse_extract_region(struct tar_sparse_file *file, size_t i) {
19163|      0|  size_t write_size;
19164|      0|  _Bool tmp;
19165|      0|  int tmp___0;
19166|      0|  size_t count;
19167|      0|  size_t wrbytes;
19168|      0|  union block *blk;
19169|      0|  union block *tmp___1;
19170|      0|  char *tmp___2;
19171|      0|  char *__cil_tmp11;
19172|       |
19173|      0|  {
19174|      0|    {
19175|      0|      tmp =
19176|      0|          lseek_or_error(file, ((file->stat_info)->sparse_map + i)->offset, 0);
19177|      0|    }
19178|      0|    if (!tmp) {
19179|      0|      return ((_Bool)0);
19180|      0|    }
19181|      0|    write_size = ((file->stat_info)->sparse_map + i)->numbytes;
19182|      0|    if (write_size == 0UL) {
19183|      0|      {
19184|      0|        tmp___0 = sys_truncate(file->fd);
19185|      0|      }
19186|      0|      if (tmp___0) {
19187|      0|        {
19188|      0|          truncate_warn((char const *)(file->stat_info)->orig_file_name);
19189|      0|        }
19190|      0|      }
19191|      0|    } else {
19192|      0|      {
19193|      0|        while (1) {
19194|      0|        while_continue: /* CIL Label */;
19195|      0|          if (!(write_size > 0UL)) {
19196|      0|            goto while_break;
19197|      0|          }
19198|      0|          if (write_size > 512UL) {
19199|      0|            wrbytes = (size_t)512;
19200|      0|          } else {
19201|      0|            wrbytes = write_size;
19202|      0|          }
19203|      0|          {
19204|      0|            tmp___1 = find_next_block();
19205|      0|            blk = tmp___1;
19206|      0|          }
19207|      0|          if (!blk) {
19208|      0|            {
19209|      0|              tmp___2 = gettext("Unexpected EOF in archive");
19210|      0|              error(0, 0, (char const *)tmp___2);
19211|      0|              exit_status = 2;
19212|      0|            }
19213|      0|            return ((_Bool)0);
19214|      0|          }
19215|      0|          {
19216|      0|            set_next_block_after(blk);
19217|      0|            count = full_write(file->fd, (void const *)(blk->buffer), wrbytes);
19218|      0|            write_size -= count;
19219|      0|            file->dumped_size += count;
19220|      0|          }
19221|      0|          if (count != wrbytes) {
19222|      0|            {
19223|      0|              write_error_details(
19224|      0|                  (char const *)(file->stat_info)->orig_file_name, count,
19225|      0|                  wrbytes);
19226|      0|            }
19227|      0|            return ((_Bool)0);
19228|      0|          }
19229|      0|        }
19230|      0|      while_break: /* CIL Label */;
19231|      0|      }
19232|      0|    }
19233|      0|    return ((_Bool)1);
19234|      0|  }
19235|      0|}
19236|      0|enum dump_status sparse_dump_file(int fd, struct tar_stat_info *st) {
19237|      0|  _Bool rc___1;
19238|      0|  struct tar_sparse_file file;
19239|      0|  _Bool tmp;
19240|      0|  _Bool tmp___0;
19241|      0|  size_t i;
19242|      0|  _Bool tmp___1;
19243|      0|  int tmp___2;
19244|       |
19245|      0|  {
19246|      0|    {
19247|      0|      file.stat_info = st;
19248|      0|      file.fd = fd;
19249|      0|      tmp = sparse_select_optab(&file);
19250|      0|    }
19251|      0|    if (tmp) {
19252|      0|      {
19253|      0|        tmp___0 = tar_sparse_init(&file);
19254|      0|      }
19255|      0|      if (!tmp___0) {
19256|      0|        return ((enum dump_status)3);
19257|      0|      }
19258|      0|    } else {
19259|      0|      return ((enum dump_status)3);
19260|      0|    }
19261|      0|    { rc___1 = sparse_scan_file(&file); }
19262|      0|    if (rc___1) {
19263|      0|      if ((file.optab)->dump_region) {
19264|      0|        {
19265|      0|          tar_sparse_dump_header(&file);
19266|      0|        }
19267|      0|        if (fd >= 0) {
19268|      0|          i = (size_t)0;
19269|      0|          {
19270|      0|            while (1) {
19271|      0|            while_continue: /* CIL Label */;
19272|      0|              if (rc___1) {
19273|      0|                if (!(i < (file.stat_info)->sparse_map_avail)) {
19274|      0|                  goto while_break;
19275|      0|                }
19276|      0|              } else {
19277|      0|                goto while_break;
19278|      0|              }
19279|      0|              {
19280|      0|                rc___1 = tar_sparse_dump_region(&file, i);
19281|      0|                i++;
19282|      0|              }
19283|      0|            }
19284|      0|          while_break: /* CIL Label */;
19285|      0|          }
19286|      0|        }
19287|      0|      }
19288|      0|    }
19289|      0|    {
19290|      0|      pad_archive((off_t)((size_t)(file.stat_info)->archive_file_size -
19291|      0|                          file.dumped_size));
19292|      0|      tmp___1 = tar_sparse_done(&file);
19293|      0|    }
19294|      0|    if (tmp___1) {
19295|      0|      if (rc___1) {
19296|      0|        tmp___2 = 0;
19297|      0|      } else {
19298|      0|        tmp___2 = 1;
19299|      0|      }
19300|      0|    } else {
19301|      0|      tmp___2 = 1;
19302|      0|    }
19303|      0|    return ((enum dump_status)tmp___2);
19304|      0|  }
19305|      0|}
19306|      0|_Bool sparse_file_p(struct tar_stat_info *st) {
19307|       |
19308|      0|  {
19309|      0|    return ((_Bool)(st->stat.st_blocks <
19310|      0|                    st->stat.st_size / 512L +
19311|      0|                        (__off_t)(st->stat.st_size % 512L != 0L)));
19312|      0|  }
19313|      0|}
19314|      0|_Bool sparse_member_p(struct tar_stat_info *st) {
19315|      0|  struct tar_sparse_file file;
19316|      0|  _Bool tmp;
19317|      0|  _Bool tmp___0;
19318|       |
19319|      0|  {
19320|      0|    { tmp = sparse_select_optab(&file); }
19321|      0|    if (!tmp) {
19322|      0|      return ((_Bool)0);
19323|      0|    }
19324|      0|    {
19325|      0|      file.stat_info = st;
19326|      0|      tmp___0 = tar_sparse_member_p(&file);
19327|      0|    }
19328|      0|    return (tmp___0);
19329|      0|  }
19330|      0|}
19331|      0|_Bool sparse_fixup_header(struct tar_stat_info *st) {
19332|      0|  struct tar_sparse_file file;
19333|      0|  _Bool tmp;
19334|      0|  _Bool tmp___0;
19335|       |
19336|      0|  {
19337|      0|    { tmp = sparse_select_optab(&file); }
19338|      0|    if (!tmp) {
19339|      0|      return ((_Bool)0);
19340|      0|    }
19341|      0|    {
19342|      0|      file.stat_info = st;
19343|      0|      tmp___0 = tar_sparse_fixup_header(&file);
19344|      0|    }
19345|      0|    return (tmp___0);
19346|      0|  }
19347|      0|}
19348|       |enum dump_status sparse_extract_file(int fd, struct tar_stat_info *st,
19349|      0|                                     off_t *size) {
19350|      0|  _Bool rc___1;
19351|      0|  struct tar_sparse_file file;
19352|      0|  size_t i;
19353|      0|  _Bool tmp;
19354|      0|  _Bool tmp___0;
19355|      0|  _Bool tmp___1;
19356|      0|  int tmp___2;
19357|       |
19358|      0|  {
19359|      0|    {
19360|      0|      rc___1 = (_Bool)1;
19361|      0|      file.stat_info = st;
19362|      0|      file.fd = fd;
19363|      0|      tmp = sparse_select_optab(&file);
19364|      0|    }
19365|      0|    if (tmp) {
19366|      0|      {
19367|      0|        tmp___0 = tar_sparse_init(&file);
19368|      0|      }
19369|      0|      if (!tmp___0) {
19370|      0|        return ((enum dump_status)3);
19371|      0|      }
19372|      0|    } else {
19373|      0|      return ((enum dump_status)3);
19374|      0|    }
19375|      0|    {
19376|      0|      rc___1 = tar_sparse_decode_header(&file);
19377|      0|      i = (size_t)0;
19378|      0|    }
19379|      0|    {
19380|      0|      while (1) {
19381|      0|      while_continue: /* CIL Label */;
19382|      0|        if (rc___1) {
19383|      0|          if (!(i < (file.stat_info)->sparse_map_avail)) {
19384|      0|            goto while_break;
19385|      0|          }
19386|      0|        } else {
19387|      0|          goto while_break;
19388|      0|        }
19389|      0|        {
19390|      0|          rc___1 = tar_sparse_extract_region(&file, i);
19391|      0|          i++;
19392|      0|        }
19393|      0|      }
19394|      0|    while_break: /* CIL Label */;
19395|      0|    }
19396|      0|    {
19397|      0|      *size = (off_t)((size_t)(file.stat_info)->archive_file_size -
19398|      0|                      file.dumped_size);
19399|      0|      tmp___1 = tar_sparse_done(&file);
19400|      0|    }
19401|      0|    if (tmp___1) {
19402|      0|      if (rc___1) {
19403|      0|        tmp___2 = 0;
19404|      0|      } else {
19405|      0|        tmp___2 = 1;
19406|      0|      }
19407|      0|    } else {
19408|      0|      tmp___2 = 1;
19409|      0|    }
19410|      0|    return ((enum dump_status)tmp___2);
19411|      0|  }
19412|      0|}
19413|      0|enum dump_status sparse_skip_file(struct tar_stat_info *st) {
19414|      0|  _Bool rc___1;
19415|      0|  struct tar_sparse_file file;
19416|      0|  _Bool tmp;
19417|      0|  _Bool tmp___0;
19418|      0|  _Bool tmp___1;
19419|      0|  int tmp___2;
19420|       |
19421|      0|  {
19422|      0|    {
19423|      0|      rc___1 = (_Bool)1;
19424|      0|      file.stat_info = st;
19425|      0|      file.fd = -1;
19426|      0|      tmp = sparse_select_optab(&file);
19427|      0|    }
19428|      0|    if (tmp) {
19429|      0|      {
19430|      0|        tmp___0 = tar_sparse_init(&file);
19431|      0|      }
19432|      0|      if (!tmp___0) {
19433|      0|        return ((enum dump_status)3);
19434|      0|      }
19435|      0|    } else {
19436|      0|      return ((enum dump_status)3);
19437|      0|    }
19438|      0|    {
19439|      0|      rc___1 = tar_sparse_decode_header(&file);
19440|      0|      skip_file((file.stat_info)->archive_file_size);
19441|      0|      tmp___1 = tar_sparse_done(&file);
19442|      0|    }
19443|      0|    if (tmp___1) {
19444|      0|      if (rc___1) {
19445|      0|        tmp___2 = 0;
19446|      0|      } else {
19447|      0|        tmp___2 = 1;
19448|      0|      }
19449|      0|    } else {
19450|      0|      tmp___2 = 1;
19451|      0|    }
19452|      0|    return ((enum dump_status)tmp___2);
19453|      0|  }
19454|      0|}
19455|       |static char diff_buffer___0[512];
19456|       |static _Bool check_sparse_region(struct tar_sparse_file *file, off_t beg,
19457|      0|                                 off_t end) {
19458|      0|  _Bool tmp;
19459|      0|  size_t bytes_read;
19460|      0|  size_t rdsize;
19461|      0|  char *tmp___0;
19462|      0|  _Bool tmp___1;
19463|      0|  char *__cil_tmp9;
19464|       |
19465|      0|  {
19466|      0|    { tmp = lseek_or_error(file, beg, 0); }
19467|      0|    if (!tmp) {
19468|      0|      return ((_Bool)0);
19469|      0|    }
19470|      0|    {
19471|      0|      while (1) {
19472|      0|      while_continue: /* CIL Label */;
19473|      0|        if (!(beg < end)) {
19474|      0|          goto while_break;
19475|      0|        }
19476|      0|        rdsize = (size_t)(end - beg);
19477|      0|        if (rdsize > 512UL) {
19478|      0|          rdsize = (size_t)512;
19479|      0|        }
19480|      0|        {
19481|      0|          memset((void *)(diff_buffer___0), 0, (size_t)512);
19482|      0|          bytes_read = safe_read(file->fd, (void *)(diff_buffer___0), rdsize);
19483|      0|        }
19484|      0|        if (bytes_read == 0xffffffffffffffffUL) {
19485|      0|          {
19486|      0|            read_diag_details((char const *)(file->stat_info)->orig_file_name,
19487|      0|                              beg, rdsize);
19488|      0|          }
19489|      0|          return ((_Bool)0);
19490|      0|        }
19491|      0|        { tmp___1 = zero_block_p(diff_buffer___0, bytes_read); }
19492|      0|        if (!tmp___1) {
19493|      0|          {
19494|      0|            tmp___0 = gettext("File fragment at %lu is not a hole");
19495|      0|            report_difference(file->stat_info, (char const *)tmp___0, beg);
19496|      0|          }
19497|      0|          return ((_Bool)0);
19498|      0|        }
19499|      0|        beg = (off_t)((size_t)beg + bytes_read);
19500|      0|      }
19501|      0|    while_break: /* CIL Label */;
19502|      0|    }
19503|      0|    return ((_Bool)1);
19504|      0|  }
19505|      0|}
19506|      0|static _Bool check_data_region(struct tar_sparse_file *file, size_t i) {
19507|      0|  size_t size_left;
19508|      0|  _Bool tmp;
19509|      0|  size_t bytes_read;
19510|      0|  size_t rdsize;
19511|      0|  union block *blk;
19512|      0|  union block *tmp___0;
19513|      0|  char *tmp___1;
19514|      0|  char *tmp___2;
19515|      0|  int tmp___3;
19516|      0|  char *__cil_tmp12;
19517|      0|  char *__cil_tmp13;
19518|       |
19519|      0|  {
19520|      0|    {
19521|      0|      tmp =
19522|      0|          lseek_or_error(file, ((file->stat_info)->sparse_map + i)->offset, 0);
19523|      0|    }
19524|      0|    if (!tmp) {
19525|      0|      return ((_Bool)0);
19526|      0|    }
19527|      0|    size_left = ((file->stat_info)->sparse_map + i)->numbytes;
19528|      0|    {
19529|      0|      while (1) {
19530|      0|      while_continue: /* CIL Label */;
19531|      0|        if (!(size_left > 0UL)) {
19532|      0|          goto while_break;
19533|      0|        }
19534|      0|        if (size_left > 512UL) {
19535|      0|          rdsize = (size_t)512;
19536|      0|        } else {
19537|      0|          rdsize = size_left;
19538|      0|        }
19539|      0|        {
19540|      0|          tmp___0 = find_next_block();
19541|      0|          blk = tmp___0;
19542|      0|        }
19543|      0|        if (!blk) {
19544|      0|          {
19545|      0|            tmp___1 = gettext("Unexpected EOF in archive");
19546|      0|            error(0, 0, (char const *)tmp___1);
19547|      0|            exit_status = 2;
19548|      0|          }
19549|      0|          return ((_Bool)0);
19550|      0|        }
19551|      0|        {
19552|      0|          set_next_block_after(blk);
19553|      0|          bytes_read = safe_read(file->fd, (void *)(diff_buffer___0), rdsize);
19554|      0|        }
19555|      0|        if (bytes_read == 0xffffffffffffffffUL) {
19556|      0|          {
19557|      0|            read_diag_details(
19558|      0|                (char const *)(file->stat_info)->orig_file_name,
19559|      0|                (off_t)(((size_t)((file->stat_info)->sparse_map + i)->offset +
19560|      0|                         ((file->stat_info)->sparse_map + i)->numbytes) -
19561|      0|                        size_left),
19562|      0|                rdsize);
19563|      0|          }
19564|      0|          return ((_Bool)0);
19565|      0|        }
19566|      0|        {
19567|      0|          file->dumped_size += bytes_read;
19568|      0|          size_left -= bytes_read;
19569|      0|          tmp___3 = memcmp((void const *)(blk->buffer),
19570|      0|                           (void const *)(diff_buffer___0), rdsize);
19571|      0|        }
19572|      0|        if (tmp___3) {
19573|      0|          {
19574|      0|            tmp___2 = gettext("Contents differ");
19575|      0|            report_difference(file->stat_info, (char const *)tmp___2);
19576|      0|          }
19577|      0|          return ((_Bool)0);
19578|      0|        }
19579|      0|      }
19580|      0|    while_break: /* CIL Label */;
19581|      0|    }
19582|      0|    return ((_Bool)1);
19583|      0|  }
19584|      0|}
19585|      0|_Bool sparse_diff_file(int fd, struct tar_stat_info *st) {
19586|      0|  _Bool rc___1;
19587|      0|  struct tar_sparse_file file;
19588|      0|  size_t i;
19589|      0|  off_t offset;
19590|      0|  _Bool tmp;
19591|      0|  _Bool tmp___0;
19592|      0|  _Bool tmp___1;
19593|      0|  _Bool tmp___2;
19594|      0|  int tmp___3;
19595|       |
19596|      0|  {
19597|      0|    {
19598|      0|      rc___1 = (_Bool)1;
19599|      0|      offset = (off_t)0;
19600|      0|      file.stat_info = st;
19601|      0|      file.fd = fd;
19602|      0|      tmp = sparse_select_optab(&file);
19603|      0|    }
19604|      0|    if (tmp) {
19605|      0|      {
19606|      0|        tmp___0 = tar_sparse_init(&file);
19607|      0|      }
19608|      0|      if (!tmp___0) {
19609|      0|        return ((_Bool)1);
19610|      0|      }
19611|      0|    } else {
19612|      0|      return ((_Bool)1);
19613|      0|    }
19614|      0|    {
19615|      0|      rc___1 = tar_sparse_decode_header(&file);
19616|      0|      i = (size_t)0;
19617|      0|    }
19618|      0|    {
19619|      0|      while (1) {
19620|      0|      while_continue: /* CIL Label */;
19621|      0|        if (rc___1) {
19622|      0|          if (!(i < (file.stat_info)->sparse_map_avail)) {
19623|      0|            goto while_break;
19624|      0|          }
19625|      0|        } else {
19626|      0|          goto while_break;
19627|      0|        }
19628|      0|        {
19629|      0|          tmp___1 = check_sparse_region(
19630|      0|              &file, offset, ((file.stat_info)->sparse_map + i)->offset);
19631|      0|        }
19632|      0|        if (tmp___1) {
19633|      0|          {
19634|      0|            tmp___2 = check_data_region(&file, i);
19635|      0|          }
19636|      0|          if (tmp___2) {
19637|      0|            tmp___3 = 1;
19638|      0|          } else {
19639|      0|            tmp___3 = 0;
19640|      0|          }
19641|      0|        } else {
19642|      0|          tmp___3 = 0;
19643|      0|        }
19644|      0|        rc___1 = (_Bool)tmp___3;
19645|      0|        offset = (off_t)((size_t)((file.stat_info)->sparse_map + i)->offset +
19646|      0|                         ((file.stat_info)->sparse_map + i)->numbytes);
19647|      0|        i++;
19648|      0|      }
19649|      0|    while_break: /* CIL Label */;
19650|      0|    }
19651|      0|    if (!rc___1) {
19652|      0|      {
19653|      0|        skip_file((off_t)((size_t)(file.stat_info)->archive_file_size -
19654|      0|                          file.dumped_size));
19655|      0|      }
19656|      0|    }
19657|      0|    { tar_sparse_done(&file); }
19658|      0|    return (rc___1);
19659|      0|  }
19660|      0|}
19661|       |static _Bool oldgnu_sparse_member_p(struct tar_sparse_file *file
19662|      0|                                    __attribute__((__unused__))) {
19663|       |
19664|      0|  { return ((_Bool)((int)current_header->header.typeflag == 83)); }
19665|      0|}
19666|       |static enum oldgnu_add_status oldgnu_add_sparse(struct tar_sparse_file *file,
19667|      0|                                                struct sparse *s) {
19668|      0|  struct sp_array sp;
19669|       |
19670|      0|  {
19671|      0|    if ((int)s->numbytes[0] == 0) {
19672|      0|      return ((enum oldgnu_add_status)1);
19673|      0|    }
19674|      0|    {
19675|      0|      sp.offset = off_from_header((char const *)(s->offset), sizeof(s->offset));
19676|      0|      sp.numbytes =
19677|      0|          size_from_header((char const *)(s->numbytes), sizeof(s->numbytes));
19678|      0|    }
19679|      0|    if (sp.offset < 0L) {
19680|      0|      return ((enum oldgnu_add_status)2);
19681|      0|    } else {
19682|      0|      if ((size_t)(file->stat_info)->stat.st_size <
19683|      0|          (size_t)sp.offset + sp.numbytes) {
19684|      0|        return ((enum oldgnu_add_status)2);
19685|      0|      } else {
19686|      0|        if ((file->stat_info)->archive_file_size < 0L) {
19687|      0|          return ((enum oldgnu_add_status)2);
19688|      0|        }
19689|      0|      }
19690|      0|    }
19691|      0|    { sparse_add_map(file, &sp); }
19692|      0|    return ((enum oldgnu_add_status)0);
19693|      0|  }
19694|      0|}
19695|      0|static _Bool oldgnu_fixup_header(struct tar_sparse_file *file) {
19696|       |
19697|      0|  {
19698|      0|    {
19699|      0|      (file->stat_info)->archive_file_size = (file->stat_info)->stat.st_size;
19700|      0|      (file->stat_info)->stat.st_size = off_from_header(
19701|      0|          (char const *)(current_header->oldgnu_header.realsize),
19702|      0|          sizeof(current_header->oldgnu_header.realsize));
19703|      0|    }
19704|      0|    return ((_Bool)1);
19705|      0|  }
19706|      0|}
19707|       |static enum oldgnu_add_status rc;
19708|      0|static _Bool oldgnu_get_sparse_info(struct tar_sparse_file *file) {
19709|      0|  size_t i;
19710|      0|  union block *h;
19711|      0|  int ext_p;
19712|      0|  char *tmp;
19713|      0|  char *tmp___0;
19714|      0|  char *__cil_tmp7;
19715|      0|  char *__cil_tmp8;
19716|       |
19717|      0|  {
19718|      0|    h = current_header;
19719|      0|    (file->stat_info)->sparse_map_size = (size_t)0;
19720|      0|    i = (size_t)0;
19721|      0|    {
19722|      0|      while (1) {
19723|      0|      while_continue: /* CIL Label */;
19724|      0|        if (!(i < 4UL)) {
19725|      0|          goto while_break;
19726|      0|        }
19727|      0|        { rc = oldgnu_add_sparse(file, &h->oldgnu_header.sp[i]); }
19728|      0|        if ((unsigned int)rc != 0U) {
19729|      0|          goto while_break;
19730|      0|        }
19731|      0|        i++;
19732|      0|      }
19733|      0|    while_break: /* CIL Label */;
19734|      0|    }
19735|      0|    ext_p = (int)h->oldgnu_header.isextended;
19736|      0|    {
19737|      0|      while (1) {
19738|      0|      while_continue___0: /* CIL Label */;
19739|      0|        if ((unsigned int)rc == 0U) {
19740|      0|          if (!ext_p) {
19741|      0|            goto while_break___0;
19742|      0|          }
19743|      0|        } else {
19744|      0|          goto while_break___0;
19745|      0|        }
19746|      0|        { h = find_next_block(); }
19747|      0|        if (!h) {
19748|      0|          {
19749|      0|            tmp = gettext("Unexpected EOF in archive");
19750|      0|            error(0, 0, (char const *)tmp);
19751|      0|            exit_status = 2;
19752|      0|          }
19753|      0|          return ((_Bool)0);
19754|      0|        }
19755|      0|        {
19756|      0|          set_next_block_after(h);
19757|      0|          i = (size_t)0;
19758|      0|        }
19759|      0|        {
19760|      0|          while (1) {
19761|      0|          while_continue___1: /* CIL Label */;
19762|      0|            if (i < 21UL) {
19763|      0|              if (!((unsigned int)rc == 0U)) {
19764|      0|                goto while_break___1;
19765|      0|              }
19766|      0|            } else {
19767|      0|              goto while_break___1;
19768|      0|            }
19769|      0|            {
19770|      0|              rc = oldgnu_add_sparse(file, &h->sparse_header.sp[i]);
19771|      0|              i++;
19772|      0|            }
19773|      0|          }
19774|      0|        while_break___1: /* CIL Label */;
19775|      0|        }
19776|      0|        ext_p = (int)h->sparse_header.isextended;
19777|      0|      }
19778|      0|    while_break___0: /* CIL Label */;
19779|      0|    }
19780|      0|    if ((unsigned int)rc == 2U) {
19781|      0|      {
19782|      0|        tmp___0 = gettext("%s: invalid sparse archive member");
19783|      0|        error(0, 0, (char const *)tmp___0, (file->stat_info)->orig_file_name);
19784|      0|        exit_status = 2;
19785|      0|      }
19786|      0|      return ((_Bool)0);
19787|      0|    }
19788|      0|    return ((_Bool)1);
19789|      0|  }
19790|      0|}
19791|       |static void oldgnu_store_sparse_info(struct tar_sparse_file *file,
19792|       |                                     size_t *pindex, struct sparse *sp,
19793|      0|                                     size_t sparse_size) {
19794|       |
19795|      0|  {
19796|      0|    {
19797|      0|      while (1) {
19798|      0|      while_continue: /* CIL Label */;
19799|      0|        if (*pindex < (file->stat_info)->sparse_map_avail) {
19800|      0|          if (!(sparse_size > 0UL)) {
19801|      0|            goto while_break;
19802|      0|          }
19803|      0|        } else {
19804|      0|          goto while_break;
19805|      0|        }
19806|      0|        {
19807|      0|          off_to_chars(((file->stat_info)->sparse_map + *pindex)->offset,
19808|      0|                       sp->offset, sizeof(sp->offset));
19809|      0|          size_to_chars(((file->stat_info)->sparse_map + *pindex)->numbytes,
19810|      0|                        sp->numbytes, sizeof(sp->numbytes));
19811|      0|          sparse_size--;
19812|      0|          sp++;
19813|      0|          (*pindex)++;
19814|      0|        }
19815|      0|      }
19816|      0|    while_break: /* CIL Label */;
19817|      0|    }
19818|      0|    return;
19819|      0|  }
19820|      0|}
19821|      0|static _Bool oldgnu_dump_header(struct tar_sparse_file *file) {
19822|      0|  off_t block_ordinal;
19823|      0|  off_t tmp;
19824|      0|  union block *blk;
19825|      0|  size_t i;
19826|       |
19827|      0|  {
19828|      0|    {
19829|      0|      tmp = current_block_ordinal();
19830|      0|      block_ordinal = tmp;
19831|      0|      blk = start_header(file->stat_info);
19832|      0|      blk->header.typeflag = (char)'S';
19833|      0|    }
19834|      0|    if ((file->stat_info)->sparse_map_avail > 4UL) {
19835|      0|      blk->oldgnu_header.isextended = (char)1;
19836|      0|    }
19837|      0|    {
19838|      0|      off_to_chars((file->stat_info)->stat.st_size, blk->oldgnu_header.realsize,
19839|      0|                   sizeof(blk->oldgnu_header.realsize));
19840|      0|      off_to_chars((file->stat_info)->archive_file_size, blk->header.size,
19841|      0|                   sizeof(blk->header.size));
19842|      0|      i = (size_t)0;
19843|      0|      oldgnu_store_sparse_info(file, &i, blk->oldgnu_header.sp, (size_t)4);
19844|      0|      blk->oldgnu_header.isextended =
19845|      0|          (char)(i < (file->stat_info)->sparse_map_avail);
19846|      0|      finish_header(file->stat_info, blk, block_ordinal);
19847|      0|    }
19848|      0|    {
19849|      0|      while (1) {
19850|      0|      while_continue: /* CIL Label */;
19851|      0|        if (!(i < (file->stat_info)->sparse_map_avail)) {
19852|      0|          goto while_break;
19853|      0|        }
19854|      0|        {
19855|      0|          blk = find_next_block();
19856|      0|          memset((void *)(blk->buffer), 0, (size_t)512);
19857|      0|          oldgnu_store_sparse_info(file, &i, blk->sparse_header.sp, (size_t)21);
19858|      0|          set_next_block_after(blk);
19859|      0|        }
19860|      0|        if (i < (file->stat_info)->sparse_map_avail) {
19861|      0|          blk->sparse_header.isextended = (char)1;
19862|      0|        } else {
19863|      0|          goto while_break;
19864|      0|        }
19865|      0|      }
19866|      0|    while_break: /* CIL Label */;
19867|      0|    }
19868|      0|    return ((_Bool)1);
19869|      0|  }
19870|      0|}
19871|       |static struct tar_sparse_optab oldgnu_optab = {
19872|       |    (_Bool(*)(struct tar_sparse_file *))((void *)0),
19873|       |    (_Bool(*)(struct tar_sparse_file *))((void *)0),
19874|       |    &oldgnu_sparse_member_p,
19875|       |    &oldgnu_dump_header,
19876|       |    &oldgnu_fixup_header,
19877|       |    &oldgnu_get_sparse_info,
19878|       |    (_Bool(*)(struct tar_sparse_file *, enum sparse_scan_state, void *))(
19879|       |        (void *)0),
19880|       |    &sparse_dump_region,
19881|       |    &sparse_extract_region};
19882|       |static _Bool star_sparse_member_p(struct tar_sparse_file *file
19883|      0|                                  __attribute__((__unused__))) {
19884|       |
19885|      0|  { return ((_Bool)((int)current_header->header.typeflag == 83)); }
19886|      0|}
19887|      0|static _Bool star_fixup_header(struct tar_sparse_file *file) {
19888|       |
19889|      0|  {
19890|      0|    {
19891|      0|      (file->stat_info)->archive_file_size = (file->stat_info)->stat.st_size;
19892|      0|      (file->stat_info)->stat.st_size = off_from_header(
19893|      0|          (char const *)(current_header->star_in_header.realsize),
19894|      0|          sizeof(current_header->star_in_header.realsize));
19895|      0|    }
19896|      0|    return ((_Bool)1);
19897|      0|  }
19898|      0|}
19899|       |static enum oldgnu_add_status rc___0;
19900|      0|static _Bool star_get_sparse_info(struct tar_sparse_file *file) {
19901|      0|  size_t i;
19902|      0|  union block *h;
19903|      0|  int ext_p;
19904|      0|  char *tmp;
19905|      0|  char *tmp___0;
19906|      0|  char *__cil_tmp7;
19907|      0|  char *__cil_tmp8;
19908|       |
19909|      0|  {
19910|      0|    h = current_header;
19911|      0|    (file->stat_info)->sparse_map_size = (size_t)0;
19912|      0|    if ((int)h->star_in_header.prefix[0] == 0) {
19913|      0|      if ((int)h->star_in_header.sp[0].offset[10] != 0) {
19914|      0|        i = (size_t)0;
19915|      0|        {
19916|      0|          while (1) {
19917|      0|          while_continue: /* CIL Label */;
19918|      0|            if (!(i < 4UL)) {
19919|      0|              goto while_break;
19920|      0|            }
19921|      0|            { rc___0 = oldgnu_add_sparse(file, &h->star_in_header.sp[i]); }
19922|      0|            if ((unsigned int)rc___0 != 0U) {
19923|      0|              goto while_break;
19924|      0|            }
19925|      0|            i++;
19926|      0|          }
19927|      0|        while_break: /* CIL Label */;
19928|      0|        }
19929|      0|        ext_p = (int)h->star_in_header.isextended;
19930|      0|      } else {
19931|      0|        ext_p = 1;
19932|      0|      }
19933|      0|    } else {
19934|      0|      ext_p = 1;
19935|      0|    }
19936|      0|    {
19937|      0|      while (1) {
19938|      0|      while_continue___0: /* CIL Label */;
19939|      0|        if ((unsigned int)rc___0 == 0U) {
19940|      0|          if (!ext_p) {
19941|      0|            goto while_break___0;
19942|      0|          }
19943|      0|        } else {
19944|      0|          goto while_break___0;
19945|      0|        }
19946|      0|        { h = find_next_block(); }
19947|      0|        if (!h) {
19948|      0|          {
19949|      0|            tmp = gettext("Unexpected EOF in archive");
19950|      0|            error(0, 0, (char const *)tmp);
19951|      0|            exit_status = 2;
19952|      0|          }
19953|      0|          return ((_Bool)0);
19954|      0|        }
19955|      0|        {
19956|      0|          set_next_block_after(h);
19957|      0|          i = (size_t)0;
19958|      0|        }
19959|      0|        {
19960|      0|          while (1) {
19961|      0|          while_continue___1: /* CIL Label */;
19962|      0|            if (i < 21UL) {
19963|      0|              if (!((unsigned int)rc___0 == 0U)) {
19964|      0|                goto while_break___1;
19965|      0|              }
19966|      0|            } else {
19967|      0|              goto while_break___1;
19968|      0|            }
19969|      0|            {
19970|      0|              rc___0 = oldgnu_add_sparse(file, &h->star_ext_header.sp[i]);
19971|      0|              i++;
19972|      0|            }
19973|      0|          }
19974|      0|        while_break___1: /* CIL Label */;
19975|      0|        }
19976|      0|        ext_p = (int)h->star_ext_header.isextended;
19977|      0|      }
19978|      0|    while_break___0: /* CIL Label */;
19979|      0|    }
19980|      0|    if ((unsigned int)rc___0 == 2U) {
19981|      0|      {
19982|      0|        tmp___0 = gettext("%s: invalid sparse archive member");
19983|      0|        error(0, 0, (char const *)tmp___0, (file->stat_info)->orig_file_name);
19984|      0|        exit_status = 2;
19985|      0|      }
19986|      0|      return ((_Bool)0);
19987|      0|    }
19988|      0|    return ((_Bool)1);
19989|      0|  }
19990|      0|}
19991|       |static struct tar_sparse_optab star_optab = {
19992|       |    (_Bool(*)(struct tar_sparse_file *))((void *)0),
19993|       |    (_Bool(*)(struct tar_sparse_file *))((void *)0),
19994|       |    &star_sparse_member_p,
19995|       |    (_Bool(*)(struct tar_sparse_file *))((void *)0),
19996|       |    &star_fixup_header,
19997|       |    &star_get_sparse_info,
19998|       |    (_Bool(*)(struct tar_sparse_file *, enum sparse_scan_state, void *))(
19999|       |        (void *)0),
20000|       |    (_Bool(*)(struct tar_sparse_file *, size_t))((void *)0),
20001|       |    &sparse_extract_region};
20002|      0|static _Bool pax_sparse_member_p(struct tar_sparse_file *file) {
20003|       |
20004|      0|  {
20005|      0|    return ((_Bool)((file->stat_info)->archive_file_size !=
20006|      0|                    (file->stat_info)->stat.st_size));
20007|      0|  }
20008|      0|}
20009|      0|static _Bool pax_dump_header(struct tar_sparse_file *file) {
20010|      0|  off_t block_ordinal;
20011|      0|  off_t tmp;
20012|      0|  union block *blk;
20013|      0|  size_t i;
20014|      0|  char *__cil_tmp6;
20015|      0|  char *__cil_tmp7;
20016|      0|  char *__cil_tmp8;
20017|      0|  char *__cil_tmp9;
20018|       |
20019|      0|  {
20020|      0|    {
20021|      0|      tmp = current_block_ordinal();
20022|      0|      block_ordinal = tmp;
20023|      0|      xheader_store("GNU.sparse.size",
20024|      0|                    (struct tar_stat_info const *)file->stat_info, (void *)0);
20025|      0|      xheader_store("GNU.sparse.numblocks",
20026|      0|                    (struct tar_stat_info const *)file->stat_info, (void *)0);
20027|      0|      i = (size_t)0;
20028|      0|    }
20029|      0|    {
20030|      0|      while (1) {
20031|      0|      while_continue: /* CIL Label */;
20032|      0|        if (!(i < (file->stat_info)->sparse_map_avail)) {
20033|      0|          goto while_break;
20034|      0|        }
20035|      0|        {
20036|      0|          xheader_store("GNU.sparse.offset",
20037|      0|                        (struct tar_stat_info const *)file->stat_info,
20038|      0|                        (void *)(&i));
20039|      0|          xheader_store("GNU.sparse.numbytes",
20040|      0|                        (struct tar_stat_info const *)file->stat_info,
20041|      0|                        (void *)(&i));
20042|      0|          i++;
20043|      0|        }
20044|      0|      }
20045|      0|    while_break: /* CIL Label */;
20046|      0|    }
20047|      0|    {
20048|      0|      blk = start_header(file->stat_info);
20049|      0|      off_to_chars((file->stat_info)->archive_file_size, blk->header.size,
20050|      0|                   sizeof(blk->header.size));
20051|      0|      finish_header(file->stat_info, blk, block_ordinal);
20052|      0|    }
20053|      0|    return ((_Bool)1);
20054|      0|  }
20055|      0|}
20056|       |static struct tar_sparse_optab pax_optab = {
20057|       |    (_Bool(*)(struct tar_sparse_file *))((void *)0),
20058|       |    (_Bool(*)(struct tar_sparse_file *))((void *)0),
20059|       |    &pax_sparse_member_p,
20060|       |    &pax_dump_header,
20061|       |    (_Bool(*)(struct tar_sparse_file *))((void *)0),
20062|       |    (_Bool(*)(struct tar_sparse_file *))((void *)0),
20063|       |    (_Bool(*)(struct tar_sparse_file *, enum sparse_scan_state, void *))(
20064|       |        (void *)0),
20065|       |    &sparse_dump_region,
20066|       |    &sparse_extract_region};
20067|       |/* #pragma merger("0","00d.system.o.i","") */
20068|       |extern __attribute__((__nothrow__)) int(
20069|       |    __attribute__((__nonnull__(1, 2), __leaf__))
20070|       |    execlp)(char const *__file, char const *__arg, ...);
20071|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
20072|       |                                        setuid)(__uid_t __uid);
20073|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
20074|       |                                        setgid)(__gid_t __gid);
20075|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
20076|       |                                        ftruncate)(int __fd, __off_t __length);
20077|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
20078|       |                                        kill)(__pid_t __pid, int __sig);
20079|       |extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options);
20080|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__))
20081|       |                                                       exit)(int __status);
20082|       |dev_t ar_dev;
20083|       |ino_t ar_ino;
20084|      0|void sys_stat_nanoseconds(struct tar_stat_info *st) {
20085|       |
20086|      0|  {
20087|      0|    st->atime_nsec = (unsigned long)st->stat.st_atim.tv_nsec;
20088|      0|    st->mtime_nsec = (unsigned long)st->stat.st_mtim.tv_nsec;
20089|      0|    st->ctime_nsec = (unsigned long)st->stat.st_ctim.tv_nsec;
20090|      0|    return;
20091|      0|  }
20092|      0|}
20093|       |static struct stat archive_stat;
20094|      0|_Bool sys_get_archive_stat(void) {
20095|      0|  int tmp;
20096|       |
20097|      0|  {
20098|      0|    { tmp = fstat(archive, &archive_stat); }
20099|      0|    return ((_Bool)(tmp == 0));
20100|      0|  }
20101|      0|}
20102|      0|_Bool sys_file_is_archive(struct tar_stat_info *p) {
20103|      0|  int tmp;
20104|       |
20105|      0|  {
20106|      0|    if (ar_dev) {
20107|      0|      if (p->stat.st_dev == ar_dev) {
20108|      0|        if (p->stat.st_ino == ar_ino) {
20109|      0|          tmp = 1;
20110|      0|        } else {
20111|      0|          tmp = 0;
20112|      0|        }
20113|      0|      } else {
20114|      0|        tmp = 0;
20115|      0|      }
20116|      0|    } else {
20117|      0|      tmp = 0;
20118|      0|    }
20119|      0|    return ((_Bool)tmp);
20120|      0|  }
20121|      0|}
20122|      0|void sys_save_archive_dev_ino(void) {
20123|       |
20124|      0|  {
20125|      0|    if (!(archive >= 1 << 30)) {
20126|      0|      if ((archive_stat.st_mode & 61440U) == 32768U) {
20127|      0|        ar_dev = archive_stat.st_dev;
20128|      0|        ar_ino = archive_stat.st_ino;
20129|      0|      } else {
20130|      0|        ar_dev = (dev_t)0;
20131|      0|      }
20132|      0|    } else {
20133|      0|      ar_dev = (dev_t)0;
20134|      0|    }
20135|      0|    return;
20136|      0|  }
20137|      0|}
20138|       |static char const dev_null[10] = {
20139|       |    (char const)'/', (char const)'d',   (char const)'e', (char const)'v',
20140|       |    (char const)'/', (char const)'n',   (char const)'u', (char const)'l',
20141|       |    (char const)'l', (char const)'\000'};
20142|      0|void sys_detect_dev_null_output(void) {
20143|      0|  struct stat dev_null_stat;
20144|      0|  int tmp;
20145|      0|  int tmp___0;
20146|      0|  int tmp___1;
20147|      0|  void *__cil_tmp5;
20148|       |
20149|      0|  {
20150|      0|    { tmp = strcmp(*(archive_name_array + 0), dev_null); }
20151|      0|    if (tmp == 0) {
20152|      0|      tmp___1 = 1;
20153|      0|    } else {
20154|      0|      if (!(archive >= 1 << 30)) {
20155|      0|        if ((archive_stat.st_mode & 61440U) == 8192U) {
20156|      0|          {
20157|      0|            tmp___0 = stat((char const * /* __restrict  */)(dev_null),
20158|      0|                           (struct stat * /* __restrict  */)(&dev_null_stat));
20159|      0|          }
20160|      0|          if (tmp___0 == 0) {
20161|      0|            if (archive_stat.st_dev == dev_null_stat.st_dev) {
20162|      0|              if (archive_stat.st_ino == dev_null_stat.st_ino) {
20163|      0|                tmp___1 = 1;
20164|      0|              } else {
20165|      0|                tmp___1 = 0;
20166|      0|              }
20167|      0|            } else {
20168|      0|              tmp___1 = 0;
20169|      0|            }
20170|      0|          } else {
20171|      0|            tmp___1 = 0;
20172|      0|          }
20173|      0|        } else {
20174|      0|          tmp___1 = 0;
20175|      0|        }
20176|      0|      } else {
20177|      0|        tmp___1 = 0;
20178|      0|      }
20179|      0|    }
20180|      0|    dev_null_output = (_Bool)tmp___1;
20181|      0|    return;
20182|      0|  }
20183|      0|}
20184|      0|void sys_drain_input_pipe(void) {
20185|      0|  size_t r;
20186|      0|  size_t tmp;
20187|      0|  size_t tmp___0;
20188|       |
20189|      0|  {
20190|      0|    if ((unsigned int)access_mode == 0U) {
20191|      0|      if (!(archive >= 1 << 30)) {
20192|      0|        if ((archive_stat.st_mode & 61440U) == 4096U) {
20193|      0|          goto _L___3;
20194|      0|        } else {
20195|      0|          if ((archive_stat.st_mode & 61440U) == 49152U) {
20196|      0|          _L___3 : /* CIL Label */
20197|      0|          {
20198|      0|            while (1) {
20199|      0|            while_continue: /* CIL Label */;
20200|      0|              if (archive >= 1 << 30) {
20201|      0|                {
20202|      0|                  tmp = rmt_read__(archive - (1 << 30), record_start->buffer,
20203|      0|                                   record_size);
20204|      0|                  r = tmp;
20205|      0|                }
20206|      0|              } else {
20207|      0|                {
20208|      0|                  tmp___0 = safe_read(archive, (void *)(record_start->buffer),
20209|      0|                                      record_size);
20210|      0|                  r = tmp___0;
20211|      0|                }
20212|      0|              }
20213|      0|              if (r != 0UL) {
20214|      0|                if (!(r != 0xffffffffffffffffUL)) {
20215|      0|                  goto while_break;
20216|      0|                }
20217|      0|              } else {
20218|      0|                goto while_break;
20219|      0|              }
20220|      0|              goto while_continue;
20221|      0|            }
20222|      0|          while_break: /* CIL Label */;
20223|      0|          }
20224|      0|          }
20225|      0|        }
20226|      0|      }
20227|      0|    }
20228|      0|    return;
20229|      0|  }
20230|      0|}
20231|      0|void sys_wait_for_child(pid_t child_pid___0) {
20232|      0|  int wait_status;
20233|      0|  int *tmp;
20234|      0|  __pid_t tmp___0;
20235|      0|  union __anonunion_56 __constr_expr_0;
20236|      0|  char *tmp___1;
20237|      0|  union __anonunion_57 __constr_expr_1;
20238|      0|  char *tmp___2;
20239|      0|  union __anonunion_58 __constr_expr_2;
20240|      0|  union __anonunion_59 __constr_expr_3;
20241|      0|  char *__cil_tmp11;
20242|      0|  char *__cil_tmp12;
20243|       |
20244|      0|  {
20245|      0|    if (child_pid___0) {
20246|      0|      {
20247|      0|        while (1) {
20248|      0|        while_continue: /* CIL Label */;
20249|      0|          { tmp___0 = waitpid(child_pid___0, &wait_status, 0); }
20250|      0|          if (!(tmp___0 == -1)) {
20251|      0|            goto while_break;
20252|      0|          }
20253|      0|          { tmp = __errno_location(); }
20254|      0|          if (*tmp != 4) {
20255|      0|            {
20256|      0|              waitpid_error(use_compress_program_option);
20257|      0|            }
20258|      0|            goto while_break;
20259|      0|          }
20260|      0|        }
20261|      0|      while_break: /* CIL Label */;
20262|      0|      }
20263|      0|      __constr_expr_3.__in = wait_status;
20264|      0|      if ((int)((signed char)((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
20265|      0|        {
20266|      0|          __constr_expr_0.__in = wait_status;
20267|      0|          tmp___1 = gettext("Child died with signal %d");
20268|      0|          error(0, 0, (char const *)tmp___1, __constr_expr_0.__i & 127);
20269|      0|          exit_status = 2;
20270|      0|        }
20271|      0|      } else {
20272|      0|        __constr_expr_2.__in = wait_status;
20273|      0|        if ((__constr_expr_2.__i & 65280) >> 8 != 0) {
20274|      0|          {
20275|      0|            __constr_expr_1.__in = wait_status;
20276|      0|            tmp___2 = gettext("Child returned status %d");
20277|      0|            error(0, 0, (char const *)tmp___2,
20278|      0|                  (__constr_expr_1.__i & 65280) >> 8);
20279|      0|            exit_status = 2;
20280|      0|          }
20281|      0|        }
20282|      0|      }
20283|      0|    }
20284|      0|    return;
20285|      0|  }
20286|      0|}
20287|      0|void sys_spawn_shell(void) {
20288|      0|  pid_t child;
20289|      0|  char const *shell;
20290|      0|  char *tmp;
20291|      0|  int wait_status;
20292|      0|  int *tmp___0;
20293|      0|  __pid_t tmp___1;
20294|      0|  char *__cil_tmp7;
20295|      0|  char *__cil_tmp8;
20296|       |
20297|      0|  {
20298|      0|    {
20299|      0|      tmp = getenv("SHELL");
20300|      0|      shell = (char const *)tmp;
20301|      0|    }
20302|      0|    if (!shell) {
20303|      0|      shell = "/bin/sh";
20304|      0|    }
20305|      0|    { child = xfork(); }
20306|      0|    if (child == 0) {
20307|      0|      {
20308|      0|        execlp(shell, "-sh", "-i", (char *)0);
20309|      0|        exec_fatal(shell);
20310|      0|      }
20311|      0|    } else {
20312|      0|      {
20313|      0|        while (1) {
20314|      0|        while_continue: /* CIL Label */;
20315|      0|          { tmp___1 = waitpid(child, &wait_status, 0); }
20316|      0|          if (!(tmp___1 == -1)) {
20317|      0|            goto while_break;
20318|      0|          }
20319|      0|          { tmp___0 = __errno_location(); }
20320|      0|          if (*tmp___0 != 4) {
20321|      0|            {
20322|      0|              waitpid_error(shell);
20323|      0|            }
20324|      0|            goto while_break;
20325|      0|          }
20326|      0|        }
20327|      0|      while_break: /* CIL Label */;
20328|      0|      }
20329|      0|    }
20330|      0|    return;
20331|      0|  }
20332|      0|}
20333|      0|_Bool sys_compare_uid(struct stat *a, struct stat *b) {
20334|       |
20335|      0|  { return ((_Bool)(a->st_uid == b->st_uid)); }
20336|      0|}
20337|      0|_Bool sys_compare_gid(struct stat *a, struct stat *b) {
20338|       |
20339|      0|  { return ((_Bool)(a->st_gid == b->st_gid)); }
20340|      0|}
20341|      0|_Bool sys_compare_links(struct stat *link_data, struct stat *stat_data) {
20342|      0|  int tmp;
20343|       |
20344|      0|  {
20345|      0|    if (stat_data->st_dev == link_data->st_dev) {
20346|      0|      if (stat_data->st_ino == link_data->st_ino) {
20347|      0|        tmp = 1;
20348|      0|      } else {
20349|      0|        tmp = 0;
20350|      0|      }
20351|      0|    } else {
20352|      0|      tmp = 0;
20353|      0|    }
20354|      0|    return ((_Bool)tmp);
20355|      0|  }
20356|      0|}
20357|      0|int sys_truncate(int fd) {
20358|      0|  off_t pos;
20359|      0|  __off_t tmp;
20360|      0|  int tmp___0;
20361|      0|  int tmp___1;
20362|       |
20363|      0|  {
20364|      0|    {
20365|      0|      tmp = lseek(fd, (off_t)0, 1);
20366|      0|      pos = tmp;
20367|      0|    }
20368|      0|    if (pos < 0L) {
20369|      0|      tmp___1 = -1;
20370|      0|    } else {
20371|      0|      {
20372|      0|        tmp___0 = ftruncate(fd, pos);
20373|      0|        tmp___1 = tmp___0;
20374|      0|      }
20375|      0|    }
20376|      0|    return (tmp___1);
20377|      0|  }
20378|      0|}
20379|      0|void sys_reset_uid_gid(void) {
20380|      0|  __uid_t tmp;
20381|      0|  __gid_t tmp___0;
20382|       |
20383|      0|  {
20384|      0|    {
20385|      0|      tmp = getuid();
20386|      0|      setuid(tmp);
20387|      0|      tmp___0 = getgid();
20388|      0|      setgid(tmp___0);
20389|      0|    }
20390|      0|    return;
20391|      0|  }
20392|      0|}
20393|      0|static int is_regular_file(char const *name) {
20394|      0|  struct stat stbuf;
20395|      0|  int *tmp;
20396|      0|  int tmp___0;
20397|      0|  void *__cil_tmp5;
20398|       |
20399|      0|  {
20400|      0|    {
20401|      0|      tmp___0 = stat((char const * /* __restrict  */)name,
20402|      0|                     (struct stat * /* __restrict  */)(&stbuf));
20403|      0|    }
20404|      0|    if (tmp___0 == 0) {
20405|      0|      return ((stbuf.st_mode & 61440U) == 32768U);
20406|      0|    } else {
20407|      0|      { tmp = __errno_location(); }
20408|      0|      return (*tmp == 2);
20409|      0|    }
20410|      0|  }
20411|      0|}
20412|      0|size_t sys_write_archive_buffer(void) {
20413|      0|  size_t tmp;
20414|      0|  size_t tmp___0;
20415|      0|  size_t tmp___1;
20416|       |
20417|      0|  {
20418|      0|    if (archive >= 1 << 30) {
20419|      0|      {
20420|      0|        tmp =
20421|      0|            rmt_write__(archive - (1 << 30), record_start->buffer, record_size);
20422|      0|        tmp___1 = tmp;
20423|      0|      }
20424|      0|    } else {
20425|      0|      {
20426|      0|        tmp___0 = full_write(archive, (void const *)(record_start->buffer),
20427|      0|                             record_size);
20428|      0|        tmp___1 = tmp___0;
20429|      0|      }
20430|      0|    }
20431|      0|    return (tmp___1);
20432|      0|  }
20433|      0|}
20434|      0|static void xdup2(int from, int into) {
20435|      0|  int status;
20436|      0|  int tmp;
20437|      0|  int e;
20438|      0|  int *tmp___0;
20439|      0|  char *tmp___1;
20440|      0|  int *tmp___2;
20441|      0|  int e___0;
20442|      0|  int *tmp___3;
20443|      0|  char *tmp___4;
20444|      0|  char *__cil_tmp12;
20445|      0|  char *__cil_tmp13;
20446|       |
20447|      0|  {
20448|      0|    if (from != into) {
20449|      0|      {
20450|      0|        tmp = close(into);
20451|      0|        status = tmp;
20452|      0|      }
20453|      0|      if (status != 0) {
20454|      0|        {
20455|      0|          tmp___2 = __errno_location();
20456|      0|        }
20457|      0|        if (*tmp___2 != 9) {
20458|      0|          {
20459|      0|            tmp___0 = __errno_location();
20460|      0|            e = *tmp___0;
20461|      0|            tmp___1 = gettext("Cannot close");
20462|      0|            error(0, e, (char const *)tmp___1);
20463|      0|            fatal_exit();
20464|      0|          }
20465|      0|        }
20466|      0|      }
20467|      0|      { status = dup(from); }
20468|      0|      if (status != into) {
20469|      0|        if (status < 0) {
20470|      0|          {
20471|      0|            tmp___3 = __errno_location();
20472|      0|            e___0 = *tmp___3;
20473|      0|            tmp___4 = gettext("Cannot dup");
20474|      0|            error(0, e___0, (char const *)tmp___4);
20475|      0|            fatal_exit();
20476|      0|          }
20477|      0|        }
20478|      0|        { abort(); }
20479|      0|      }
20480|      0|      { xclose(from); }
20481|      0|    }
20482|      0|    return;
20483|      0|  }
20484|      0|}
20485|      0|pid_t sys_child_open_for_compress(void) {
20486|      0|  int parent_pipe[2];
20487|      0|  int child_pipe[2];
20488|      0|  pid_t grandchild_pid;
20489|      0|  pid_t child_pid___0;
20490|      0|  int wait_status;
20491|      0|  char *tmp;
20492|      0|  int saved_errno;
20493|      0|  int *tmp___0;
20494|      0|  int *tmp___1;
20495|      0|  int tmp___2;
20496|      0|  void *tmp___3;
20497|      0|  int tmp___4;
20498|      0|  char *tmp___5;
20499|      0|  int tmp___7;
20500|      0|  int tmp___8;
20501|      0|  void *tmp___9;
20502|      0|  int tmp___10;
20503|      0|  size_t status;
20504|      0|  char *cursor;
20505|      0|  size_t length;
20506|      0|  size_t size;
20507|      0|  int *tmp___11;
20508|      0|  __pid_t tmp___12;
20509|      0|  union __anonunion_60 __constr_expr_4;
20510|      0|  union __anonunion_61 __constr_expr_5;
20511|      0|  union __anonunion_62 __constr_expr_6;
20512|      0|  union __anonunion_63 __constr_expr_7;
20513|      0|  void *__cil_tmp28;
20514|      0|  void *__cil_tmp29;
20515|      0|  char *__cil_tmp30;
20516|      0|  char *__cil_tmp31;
20517|       |
20518|      0|  {
20519|      0|    {
20520|      0|      xpipe(parent_pipe);
20521|      0|      child_pid___0 = xfork();
20522|      0|    }
20523|      0|    if (child_pid___0 > 0) {
20524|      0|      {
20525|      0|        archive = parent_pipe[1];
20526|      0|        xclose(parent_pipe[0]);
20527|      0|      }
20528|      0|      return (child_pid___0);
20529|      0|    }
20530|      0|    {
20531|      0|      tmp = gettext("tar (child)");
20532|      0|      program_name = (char const *)tmp;
20533|      0|      xdup2(parent_pipe[0], 0);
20534|      0|      xclose(parent_pipe[1]);
20535|      0|      tmp___2 = strcmp(*(archive_name_array + 0), "-");
20536|      0|    }
20537|      0|    if (tmp___2 != 0) {
20538|      0|      if (!force_local_option) {
20539|      0|        {
20540|      0|          rmt_path__ = strchr(*(archive_name_array + 0), ':');
20541|      0|        }
20542|      0|        if (rmt_path__) {
20543|      0|          if ((unsigned long)rmt_path__ >
20544|      0|              (unsigned long)*(archive_name_array + 0)) {
20545|      0|            {
20546|      0|              tmp___3 = memchr(
20547|      0|                  (void const *)*(archive_name_array + 0), '/',
20548|      0|                  (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));
20549|      0|            }
20550|      0|            if (tmp___3) {
20551|      0|              goto _L___1;
20552|      0|            }
20553|      0|          } else {
20554|      0|            goto _L___1;
20555|      0|          }
20556|      0|        } else {
20557|      0|          goto _L___1;
20558|      0|        }
20559|      0|      } else {
20560|      0|      _L___1 : { tmp___4 = is_regular_file(*(archive_name_array + 0)); }
20561|      0|        if (tmp___4) {
20562|      0|          if (backup_option) {
20563|      0|            {
20564|      0|              maybe_backup_file(*(archive_name_array + 0), 1);
20565|      0|            }
20566|      0|          }
20567|      0|          {
20568|      0|            archive = creat(*(archive_name_array + 0),
20569|      0|                            (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
20570|      0|                                     ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
20571|      0|          }
20572|      0|          if (archive < 0) {
20573|      0|            {
20574|      0|              tmp___0 = __errno_location();
20575|      0|              saved_errno = *tmp___0;
20576|      0|            }
20577|      0|            if (backup_option) {
20578|      0|              {
20579|      0|                undo_last_backup();
20580|      0|              }
20581|      0|            }
20582|      0|            {
20583|      0|              tmp___1 = __errno_location();
20584|      0|              *tmp___1 = saved_errno;
20585|      0|              open_fatal(*(archive_name_array + 0));
20586|      0|            }
20587|      0|          }
20588|      0|          {
20589|      0|            xdup2(archive, 1);
20590|      0|            execlp(use_compress_program_option, use_compress_program_option,
20591|      0|                   (char *)0);
20592|      0|            exec_fatal(use_compress_program_option);
20593|      0|          }
20594|      0|        }
20595|      0|      }
20596|      0|    }
20597|      0|    {
20598|      0|      xpipe(child_pipe);
20599|      0|      grandchild_pid = xfork();
20600|      0|    }
20601|      0|    if (grandchild_pid == 0) {
20602|      0|      {
20603|      0|        tmp___5 = gettext("tar (grandchild)");
20604|      0|        program_name = (char const *)tmp___5;
20605|      0|        xdup2(child_pipe[1], 1);
20606|      0|        xclose(child_pipe[0]);
20607|      0|        execlp(use_compress_program_option, use_compress_program_option,
20608|      0|               (char *)0);
20609|      0|        exec_fatal(use_compress_program_option);
20610|      0|      }
20611|      0|    }
20612|      0|    {
20613|      0|      xdup2(child_pipe[0], 0);
20614|      0|      xclose(child_pipe[1]);
20615|      0|      tmp___10 = strcmp(*(archive_name_array + 0), "-");
20616|      0|    }
20617|      0|    if (tmp___10 == 0) {
20618|      0|      archive = 1;
20619|      0|    } else {
20620|      0|      if (!force_local_option) {
20621|      0|        {
20622|      0|          rmt_path__ = strchr(*(archive_name_array + 0), ':');
20623|      0|        }
20624|      0|        if (rmt_path__) {
20625|      0|          if ((unsigned long)rmt_path__ >
20626|      0|              (unsigned long)*(archive_name_array + 0)) {
20627|      0|            {
20628|      0|              tmp___9 = memchr(
20629|      0|                  (void const *)*(archive_name_array + 0), '/',
20630|      0|                  (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));
20631|      0|            }
20632|      0|            if (tmp___9) {
20633|      0|              {
20634|      0|                tmp___8 =
20635|      0|                    creat(*(archive_name_array + 0),
20636|      0|                          (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
20637|      0|                                   ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
20638|      0|                archive = tmp___8;
20639|      0|              }
20640|      0|            } else {
20641|      0|              {
20642|      0|                tmp___7 = rmt_open__(*(archive_name_array + 0), 65, 1 << 30,
20643|      0|                                     rsh_command_option);
20644|      0|                archive = tmp___7;
20645|      0|              }
20646|      0|            }
20647|      0|          } else {
20648|      0|            {
20649|      0|              tmp___8 =
20650|      0|                  creat(*(archive_name_array + 0),
20651|      0|                        (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
20652|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
20653|      0|              archive = tmp___8;
20654|      0|            }
20655|      0|          }
20656|      0|        } else {
20657|      0|          {
20658|      0|            tmp___8 = creat(*(archive_name_array + 0),
20659|      0|                            (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
20660|      0|                                     ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
20661|      0|            archive = tmp___8;
20662|      0|          }
20663|      0|        }
20664|      0|      } else {
20665|      0|        {
20666|      0|          tmp___8 = creat(*(archive_name_array + 0),
20667|      0|                          (mode_t)(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
20668|      0|                                   ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
20669|      0|          archive = tmp___8;
20670|      0|        }
20671|      0|      }
20672|      0|      if (archive < 0) {
20673|      0|        {
20674|      0|          open_fatal(*(archive_name_array + 0));
20675|      0|        }
20676|      0|      }
20677|      0|    }
20678|      0|    {
20679|      0|      while (1) {
20680|      0|      while_continue: /* CIL Label */;
20681|      0|        status = (size_t)0;
20682|      0|        length = (size_t)0;
20683|      0|        cursor = record_start->buffer;
20684|      0|        {
20685|      0|          while (1) {
20686|      0|          while_continue___0: /* CIL Label */;
20687|      0|            if (!(length < record_size)) {
20688|      0|              goto while_break___0;
20689|      0|            }
20690|      0|            {
20691|      0|              size = record_size - length;
20692|      0|              status = safe_read(0, (void *)cursor, size);
20693|      0|            }
20694|      0|            if (status == 0xffffffffffffffffUL) {
20695|      0|              {
20696|      0|                read_fatal(use_compress_program_option);
20697|      0|              }
20698|      0|            }
20699|      0|            if (status == 0UL) {
20700|      0|              goto while_break___0;
20701|      0|            }
20702|      0|            length += status;
20703|      0|            cursor += status;
20704|      0|          }
20705|      0|        while_break___0: /* CIL Label */;
20706|      0|        }
20707|      0|        if (status == 0UL) {
20708|      0|          if (length > 0UL) {
20709|      0|            {
20710|      0|              memset((void *)(record_start->buffer + length), 0,
20711|      0|                     record_size - length);
20712|      0|              status = sys_write_archive_buffer();
20713|      0|            }
20714|      0|            if (status != record_size) {
20715|      0|              {
20716|      0|                archive_write_error((ssize_t)status);
20717|      0|              }
20718|      0|            }
20719|      0|          }
20720|      0|          goto while_break;
20721|      0|        }
20722|      0|        { status = sys_write_archive_buffer(); }
20723|      0|        if (status != record_size) {
20724|      0|          {
20725|      0|            archive_write_error((ssize_t)status);
20726|      0|          }
20727|      0|        }
20728|      0|      }
20729|      0|    while_break: /* CIL Label */;
20730|      0|    }
20731|      0|    {
20732|      0|      while (1) {
20733|      0|      while_continue___1: /* CIL Label */;
20734|      0|        { tmp___12 = waitpid(grandchild_pid, &wait_status, 0); }
20735|      0|        if (!(tmp___12 == -1)) {
20736|      0|          goto while_break___1;
20737|      0|        }
20738|      0|        { tmp___11 = __errno_location(); }
20739|      0|        if (*tmp___11 != 4) {
20740|      0|          {
20741|      0|            waitpid_error(use_compress_program_option);
20742|      0|          }
20743|      0|          goto while_break___1;
20744|      0|        }
20745|      0|      }
20746|      0|    while_break___1: /* CIL Label */;
20747|      0|    }
20748|      0|    __constr_expr_7.__in = wait_status;
20749|      0|    if ((int)((signed char)((__constr_expr_7.__i & 127) + 1)) >> 1 > 0) {
20750|      0|      {
20751|      0|        __constr_expr_4.__in = wait_status;
20752|      0|        kill(child_pid___0, __constr_expr_4.__i & 127);
20753|      0|        exit_status = 2;
20754|      0|      }
20755|      0|    } else {
20756|      0|      __constr_expr_6.__in = wait_status;
20757|      0|      if ((__constr_expr_6.__i & 65280) >> 8 != 0) {
20758|      0|        __constr_expr_5.__in = wait_status;
20759|      0|        exit_status = (__constr_expr_5.__i & 65280) >> 8;
20760|      0|      }
20761|      0|    }
20762|      0|    { exit(exit_status); }
20763|      0|  }
20764|      0|}
20765|      0|pid_t sys_child_open_for_uncompress(void) {
20766|      0|  int parent_pipe[2];
20767|      0|  int child_pipe[2];
20768|      0|  pid_t grandchild_pid;
20769|      0|  pid_t child_pid___0;
20770|      0|  int wait_status;
20771|      0|  char *tmp;
20772|      0|  int tmp___0;
20773|      0|  void *tmp___1;
20774|      0|  int tmp___2;
20775|      0|  char *tmp___3;
20776|      0|  int tmp___5;
20777|      0|  int tmp___6;
20778|      0|  void *tmp___7;
20779|      0|  int tmp___8;
20780|      0|  char *cursor;
20781|      0|  size_t maximum;
20782|      0|  size_t count;
20783|      0|  size_t status;
20784|      0|  size_t tmp___9;
20785|      0|  size_t tmp___10;
20786|      0|  size_t tmp___11;
20787|      0|  int *tmp___12;
20788|      0|  __pid_t tmp___13;
20789|      0|  union __anonunion_64 __constr_expr_8;
20790|      0|  union __anonunion_65 __constr_expr_9;
20791|      0|  union __anonunion_66 __constr_expr_10;
20792|      0|  union __anonunion_67 __constr_expr_11;
20793|      0|  void *__cil_tmp28;
20794|      0|  void *__cil_tmp29;
20795|      0|  char *__cil_tmp30;
20796|      0|  char *__cil_tmp31;
20797|       |
20798|      0|  {
20799|      0|    {
20800|      0|      xpipe(parent_pipe);
20801|      0|      child_pid___0 = xfork();
20802|      0|    }
20803|      0|    if (child_pid___0 > 0) {
20804|      0|      {
20805|      0|        read_full_records_option = (_Bool)1;
20806|      0|        archive = parent_pipe[0];
20807|      0|        xclose(parent_pipe[1]);
20808|      0|      }
20809|      0|      return (child_pid___0);
20810|      0|    }
20811|      0|    {
20812|      0|      tmp = gettext("tar (child)");
20813|      0|      program_name = (char const *)tmp;
20814|      0|      xdup2(parent_pipe[1], 1);
20815|      0|      xclose(parent_pipe[0]);
20816|      0|      tmp___0 = strcmp(*(archive_name_array + 0), "-");
20817|      0|    }
20818|      0|    if (tmp___0 != 0) {
20819|      0|      if (!force_local_option) {
20820|      0|        {
20821|      0|          rmt_path__ = strchr(*(archive_name_array + 0), ':');
20822|      0|        }
20823|      0|        if (rmt_path__) {
20824|      0|          if ((unsigned long)rmt_path__ >
20825|      0|              (unsigned long)*(archive_name_array + 0)) {
20826|      0|            {
20827|      0|              tmp___1 = memchr(
20828|      0|                  (void const *)*(archive_name_array + 0), '/',
20829|      0|                  (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));
20830|      0|            }
20831|      0|            if (tmp___1) {
20832|      0|              goto _L___1;
20833|      0|            }
20834|      0|          } else {
20835|      0|            goto _L___1;
20836|      0|          }
20837|      0|        } else {
20838|      0|          goto _L___1;
20839|      0|        }
20840|      0|      } else {
20841|      0|      _L___1 : { tmp___2 = is_regular_file(*(archive_name_array + 0)); }
20842|      0|        if (tmp___2) {
20843|      0|          {
20844|      0|            archive = open(*(archive_name_array + 0), 0,
20845|      0|                           ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
20846|      0|                               ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
20847|      0|          }
20848|      0|          if (archive < 0) {
20849|      0|            {
20850|      0|              open_fatal(*(archive_name_array + 0));
20851|      0|            }
20852|      0|          }
20853|      0|          {
20854|      0|            xdup2(archive, 0);
20855|      0|            execlp(use_compress_program_option, use_compress_program_option,
20856|      0|                   "-d", (char *)0);
20857|      0|            exec_fatal(use_compress_program_option);
20858|      0|          }
20859|      0|        }
20860|      0|      }
20861|      0|    }
20862|      0|    {
20863|      0|      xpipe(child_pipe);
20864|      0|      grandchild_pid = xfork();
20865|      0|    }
20866|      0|    if (grandchild_pid == 0) {
20867|      0|      {
20868|      0|        tmp___3 = gettext("tar (grandchild)");
20869|      0|        program_name = (char const *)tmp___3;
20870|      0|        xdup2(child_pipe[0], 0);
20871|      0|        xclose(child_pipe[1]);
20872|      0|        execlp(use_compress_program_option, use_compress_program_option, "-d",
20873|      0|               (char *)0);
20874|      0|        exec_fatal(use_compress_program_option);
20875|      0|      }
20876|      0|    }
20877|      0|    {
20878|      0|      xdup2(child_pipe[1], 1);
20879|      0|      xclose(child_pipe[0]);
20880|      0|      tmp___8 = strcmp(*(archive_name_array + 0), "-");
20881|      0|    }
20882|      0|    if (tmp___8 == 0) {
20883|      0|      archive = 0;
20884|      0|    } else {
20885|      0|      if (!force_local_option) {
20886|      0|        {
20887|      0|          rmt_path__ = strchr(*(archive_name_array + 0), ':');
20888|      0|        }
20889|      0|        if (rmt_path__) {
20890|      0|          if ((unsigned long)rmt_path__ >
20891|      0|              (unsigned long)*(archive_name_array + 0)) {
20892|      0|            {
20893|      0|              tmp___7 = memchr(
20894|      0|                  (void const *)*(archive_name_array + 0), '/',
20895|      0|                  (size_t)(rmt_path__ - (char *)*(archive_name_array + 0)));
20896|      0|            }
20897|      0|            if (tmp___7) {
20898|      0|              {
20899|      0|                tmp___6 = open(*(archive_name_array + 0), 0,
20900|      0|                               ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
20901|      0|                                   ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
20902|      0|                archive = tmp___6;
20903|      0|              }
20904|      0|            } else {
20905|      0|              {
20906|      0|                tmp___5 = rmt_open__(*(archive_name_array + 0), 0, 1 << 30,
20907|      0|                                     rsh_command_option);
20908|      0|                archive = tmp___5;
20909|      0|              }
20910|      0|            }
20911|      0|          } else {
20912|      0|            {
20913|      0|              tmp___6 = open(*(archive_name_array + 0), 0,
20914|      0|                             ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
20915|      0|                                 ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
20916|      0|              archive = tmp___6;
20917|      0|            }
20918|      0|          }
20919|      0|        } else {
20920|      0|          {
20921|      0|            tmp___6 = open(*(archive_name_array + 0), 0,
20922|      0|                           ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
20923|      0|                               ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
20924|      0|            archive = tmp___6;
20925|      0|          }
20926|      0|        }
20927|      0|      } else {
20928|      0|        {
20929|      0|          tmp___6 = open(*(archive_name_array + 0), 0,
20930|      0|                         ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) |
20931|      0|                             ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
20932|      0|          archive = tmp___6;
20933|      0|        }
20934|      0|      }
20935|      0|    }
20936|      0|    if (archive < 0) {
20937|      0|      {
20938|      0|        open_fatal(*(archive_name_array + 0));
20939|      0|      }
20940|      0|    }
20941|      0|    {
20942|      0|      while (1) {
20943|      0|      while_continue: /* CIL Label */;
20944|      0|        { clear_read_error_count(); }
20945|      0|      error_loop:
20946|      0|        if (archive >= 1 << 30) {
20947|      0|          {
20948|      0|            tmp___9 = rmt_read__(archive - (1 << 30), record_start->buffer,
20949|      0|                                 record_size);
20950|      0|            status = tmp___9;
20951|      0|          }
20952|      0|        } else {
20953|      0|          {
20954|      0|            tmp___10 =
20955|      0|                safe_read(archive, (void *)(record_start->buffer), record_size);
20956|      0|            status = tmp___10;
20957|      0|          }
20958|      0|        }
20959|      0|        if (status == 0xffffffffffffffffUL) {
20960|      0|          {
20961|      0|            archive_read_error();
20962|      0|          }
20963|      0|          goto error_loop;
20964|      0|        }
20965|      0|        if (status == 0UL) {
20966|      0|          goto while_break;
20967|      0|        }
20968|      0|        cursor = record_start->buffer;
20969|      0|        maximum = status;
20970|      0|        {
20971|      0|          while (1) {
20972|      0|          while_continue___0: /* CIL Label */;
20973|      0|            if (!maximum) {
20974|      0|              goto while_break___0;
20975|      0|            }
20976|      0|            if (maximum < 512UL) {
20977|      0|              count = maximum;
20978|      0|            } else {
20979|      0|              count = (size_t)512;
20980|      0|            }
20981|      0|            { tmp___11 = full_write(1, (void const *)cursor, count); }
20982|      0|            if (tmp___11 != count) {
20983|      0|              {
20984|      0|                write_error(use_compress_program_option);
20985|      0|              }
20986|      0|            }
20987|      0|            cursor += count;
20988|      0|            maximum -= count;
20989|      0|          }
20990|      0|        while_break___0: /* CIL Label */;
20991|      0|        }
20992|      0|      }
20993|      0|    while_break: /* CIL Label */;
20994|      0|    }
20995|      0|    { xclose(1); }
20996|      0|    {
20997|      0|      while (1) {
20998|      0|      while_continue___1: /* CIL Label */;
20999|      0|        { tmp___13 = waitpid(grandchild_pid, &wait_status, 0); }
21000|      0|        if (!(tmp___13 == -1)) {
21001|      0|          goto while_break___1;
21002|      0|        }
21003|      0|        { tmp___12 = __errno_location(); }
21004|      0|        if (*tmp___12 != 4) {
21005|      0|          {
21006|      0|            waitpid_error(use_compress_program_option);
21007|      0|          }
21008|      0|          goto while_break___1;
21009|      0|        }
21010|      0|      }
21011|      0|    while_break___1: /* CIL Label */;
21012|      0|    }
21013|      0|    __constr_expr_11.__in = wait_status;
21014|      0|    if ((int)((signed char)((__constr_expr_11.__i & 127) + 1)) >> 1 > 0) {
21015|      0|      {
21016|      0|        __constr_expr_8.__in = wait_status;
21017|      0|        kill(child_pid___0, __constr_expr_8.__i & 127);
21018|      0|        exit_status = 2;
21019|      0|      }
21020|      0|    } else {
21021|      0|      __constr_expr_10.__in = wait_status;
21022|      0|      if ((__constr_expr_10.__i & 65280) >> 8 != 0) {
21023|      0|        __constr_expr_9.__in = wait_status;
21024|      0|        exit_status = (__constr_expr_9.__i & 65280) >> 8;
21025|      0|      }
21026|      0|    }
21027|      0|    { exit(exit_status); }
21028|      0|  }
21029|      0|}
21030|       |/* #pragma merger("0","00e.tar.o.i","") */
21031|       |extern char *optarg;
21032|       |extern int optind;
21033|       |extern int printf(char const *__restrict __format, ...);
21034|       |extern int puts(char const *__s);
21035|       |extern int fputs_unlocked(char const *__restrict __s,
21036|       |                          FILE *__restrict __stream);
21037|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
21038|       |                                           setlocale)(int __category,
21039|       |                                                      char const *__locale);
21040|       |extern
21041|       |    __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
21042|       |                                        textdomain)(char const *__domainname);
21043|       |extern __attribute__((__nothrow__)) char *(__attribute__((
21044|       |    __leaf__)) bindtextdomain)(char const *__domainname, char const *__dirname);
21045|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) getopt_long)(
21046|       |    int ___argc, char *const *___argv, char const *__shortopts,
21047|       |    struct option const *__longopts, int *__longind);
21048|       |char const *simple_backup_suffix;
21049|       |enum backup_type xget_version(char const *context, char const *version);
21050|       |struct exclude *new_exclude(void);
21051|       |void add_exclude(struct exclude *ex, char const *pattern, int options);
21052|       |int add_exclude_file(void (*add_func)(struct exclude *, char const *, int),
21053|       |                     struct exclude *ex, char const *filename, int options,
21054|       |                     char line_end);
21055|       |struct mode_change *mode_compile(char const *mode_string,
21056|       |                                 unsigned int masked_ops);
21057|       |int check_links_option;
21058|       |int allocated_archive_names;
21059|       |void update_archive(void);
21060|       |_Bool get_date(struct timespec *result, char const *p,
21061|       |               struct timespec const *now);
21062|       |void prepend_default_options(char const *options, int *pargc, char ***pargv);
21063|       |static char const *stdin_used_by;
21064|      0|void request_stdin(char const *option) {
21065|      0|  char *tmp;
21066|      0|  char *__cil_tmp3;
21067|       |
21068|      0|  {
21069|      0|    if (stdin_used_by) {
21070|      0|      {
21071|      0|        tmp = gettext("Options `-%s\' and `-%s\' both want standard input");
21072|      0|        error(0, 0, (char const *)tmp, stdin_used_by, option);
21073|      0|        usage(2);
21074|      0|      }
21075|      0|    }
21076|      0|    stdin_used_by = option;
21077|      0|    return;
21078|      0|  }
21079|      0|}
21080|       |static FILE *confirm_file;
21081|       |static int confirm_file_EOF;
21082|      0|int confirm(char const *message_action, char const *message_name) {
21083|      0|  char const *tmp;
21084|      0|  int reply;
21085|      0|  int tmp___0;
21086|      0|  int tmp___1;
21087|      0|  int character;
21088|      0|  int tmp___2;
21089|      0|  char *__cil_tmp9;
21090|      0|  char *__cil_tmp10;
21091|       |
21092|      0|  {
21093|      0|    if (!confirm_file) {
21094|      0|      if (archive == 0) {
21095|      0|        goto _L___3;
21096|      0|      } else {
21097|      0|        if (stdin_used_by) {
21098|      0|        _L___3 : /* CIL Label */
21099|      0|        {
21100|      0|          confirm_file = fopen((char const * /* __restrict  */) "/dev/tty",
21101|      0|                               (char const * /* __restrict  */) "r");
21102|      0|        }
21103|      0|          if (!confirm_file) {
21104|      0|            {
21105|      0|              open_fatal("/dev/tty");
21106|      0|            }
21107|      0|          }
21108|      0|        } else {
21109|      0|          {
21110|      0|            request_stdin("-w");
21111|      0|            confirm_file = stdin;
21112|      0|          }
21113|      0|        }
21114|      0|      }
21115|      0|    }
21116|      0|    {
21117|      0|      tmp = quote(message_name);
21118|      0|      fprintf((FILE * /* __restrict  */) stdlis,
21119|      0|              (char const * /* __restrict  */) "%s %s?", message_action, tmp);
21120|      0|      fflush_unlocked(stdlis);
21121|      0|    }
21122|      0|    if (confirm_file_EOF) {
21123|      0|      tmp___1 = -1;
21124|      0|    } else {
21125|      0|      {
21126|      0|        tmp___0 = getc_unlocked(confirm_file);
21127|      0|        tmp___1 = tmp___0;
21128|      0|      }
21129|      0|    }
21130|      0|    reply = tmp___1;
21131|      0|    character = reply;
21132|      0|    {
21133|      0|      while (1) {
21134|      0|      while_continue: /* CIL Label */;
21135|      0|        if (!(character != 10)) {
21136|      0|          goto while_break;
21137|      0|        }
21138|      0|        if (character == -1) {
21139|      0|          {
21140|      0|            confirm_file_EOF = 1;
21141|      0|            fputc_unlocked('\n', stdlis);
21142|      0|            fflush_unlocked(stdlis);
21143|      0|          }
21144|      0|          goto while_break;
21145|      0|        }
21146|      0|        { character = getc_unlocked(confirm_file); }
21147|      0|      }
21148|      0|    while_break: /* CIL Label */;
21149|      0|    }
21150|      0|    if (reply == 121) {
21151|      0|      tmp___2 = 1;
21152|      0|    } else {
21153|      0|      if (reply == 89) {
21154|      0|        tmp___2 = 1;
21155|      0|      } else {
21156|      0|        tmp___2 = 0;
21157|      0|      }
21158|      0|    }
21159|      0|    return (tmp___2);
21160|      0|  }
21161|      0|}
21162|       |static struct fmttab const fmttab[6] = {
21163|       |    {"v7", (enum archive_format)1},
21164|       |    {"oldgnu", (enum archive_format)2},
21165|       |    {"ustar", (enum archive_format)3},
21166|       |    {"posix", (enum archive_format)4},
21167|       |    {"gnu", (enum archive_format)6},
21168|       |    {(char const *)((void *)0), (enum archive_format)0}};
21169|      0|static void set_archive_format(char const *name) {
21170|      0|  struct fmttab const *p;
21171|      0|  char *tmp;
21172|      0|  char *tmp___0;
21173|      0|  int tmp___1;
21174|      0|  char *__cil_tmp6;
21175|       |
21176|      0|  {
21177|      0|    p = fmttab;
21178|      0|    {
21179|      0|      while (1) {
21180|      0|      while_continue: /* CIL Label */;
21181|      0|        { tmp___1 = strcmp((char const *)p->name, name); }
21182|      0|        if (!(tmp___1 != 0)) {
21183|      0|          goto while_break;
21184|      0|        }
21185|      0|        p++;
21186|      0|        if (!p->name) {
21187|      0|          {
21188|      0|            tmp = quotearg_colon(name);
21189|      0|            tmp___0 = gettext("%s: Invalid archive format");
21190|      0|            error(0, 0, (char const *)tmp___0, tmp);
21191|      0|            usage(2);
21192|      0|          }
21193|      0|        }
21194|      0|      }
21195|      0|    while_break: /* CIL Label */;
21196|      0|    }
21197|      0|    archive_format = (enum archive_format)p->fmt;
21198|      0|    return;
21199|      0|  }
21200|      0|}
21201|      0|static char const *archive_format_string(enum archive_format fmt) {
21202|      0|  struct fmttab const *p;
21203|      0|  char *__cil_tmp3;
21204|       |
21205|      0|  {
21206|      0|    p = fmttab;
21207|      0|    {
21208|      0|      while (1) {
21209|      0|      while_continue: /* CIL Label */;
21210|      0|        if (!p->name) {
21211|      0|          goto while_break;
21212|      0|        }
21213|      0|        if ((unsigned int const)p->fmt == (unsigned int const)fmt) {
21214|      0|          return ((char const *)p->name);
21215|      0|        }
21216|      0|        p++;
21217|      0|      }
21218|      0|    while_break: /* CIL Label */;
21219|      0|    }
21220|      0|    return ("unknown?");
21221|      0|  }
21222|      0|}
21223|      0|static void assert_format(unsigned int fmt_mask) {
21224|      0|  char *tmp;
21225|      0|  char *__cil_tmp3;
21226|       |
21227|      0|  {
21228|      0|    if (((unsigned int)(1 << (unsigned int)archive_format) & fmt_mask) == 0U) {
21229|      0|      {
21230|      0|        tmp = gettext("GNU features wanted on incompatible archive format");
21231|      0|        error(0, 0, (char const *)tmp);
21232|      0|        usage(2);
21233|      0|      }
21234|      0|    }
21235|      0|    return;
21236|      0|  }
21237|      0|}
21238|       |static int show_help;
21239|       |static int show_version;
21240|       |static struct option long_options[104] = {
21241|       |    {"absolute-names", 0, (int *)0, 'P'},
21242|       |    {"after-date", 1, (int *)0, 'N'},
21243|       |    {"anchored", 0, (int *)0, 128},
21244|       |    {"append", 0, (int *)0, 'r'},
21245|       |    {"atime-preserve", 0, (int *)0, 129},
21246|       |    {"backup", 2, (int *)0, 130},
21247|       |    {"block-number", 0, (int *)0, 'R'},
21248|       |    {"blocking-factor", 1, (int *)0, 'b'},
21249|       |    {"bzip2", 0, (int *)0, 'j'},
21250|       |    {"catenate", 0, (int *)0, 'A'},
21251|       |    {"checkpoint", 0, (int *)0, 131},
21252|       |    {"check-links", 0, &check_links_option, 1},
21253|       |    {"compare", 0, (int *)0, 'd'},
21254|       |    {"compress", 0, (int *)0, 'Z'},
21255|       |    {"concatenate", 0, (int *)0, 'A'},
21256|       |    {"confirmation", 0, (int *)0, 'w'},
21257|       |    {"create", 0, (int *)0, 'c'},
21258|       |    {"delete", 0, (int *)0, 132},
21259|       |    {"dereference", 0, (int *)0, 'h'},
21260|       |    {"diff", 0, (int *)0, 'd'},
21261|       |    {"directory", 1, (int *)0, 'C'},
21262|       |    {"exclude", 1, (int *)0, 133},
21263|       |    {"exclude-from", 1, (int *)0, 'X'},
21264|       |    {"extract", 0, (int *)0, 'x'},
21265|       |    {"file", 1, (int *)0, 'f'},
21266|       |    {"files-from", 1, (int *)0, 'T'},
21267|       |    {"force-local", 0, (int *)0, 134},
21268|       |    {"format", 1, (int *)0, 135},
21269|       |    {"get", 0, (int *)0, 'x'},
21270|       |    {"group", 1, (int *)0, 136},
21271|       |    {"gunzip", 0, (int *)0, 'z'},
21272|       |    {"gzip", 0, (int *)0, 'z'},
21273|       |    {"help", 0, &show_help, 1},
21274|       |    {"ignore-case", 0, (int *)0, 137},
21275|       |    {"ignore-failed-read", 0, (int *)0, 138},
21276|       |    {"ignore-zeros", 0, (int *)0, 'i'},
21277|       |    {"incremental", 0, (int *)0, 'G'},
21278|       |    {"index-file", 1, (int *)0, 139},
21279|       |    {"info-script", 1, (int *)0, 'F'},
21280|       |    {"interactive", 0, (int *)0, 'w'},
21281|       |    {"keep-newer-files", 0, (int *)0, 140},
21282|       |    {"keep-old-files", 0, (int *)0, 'k'},
21283|       |    {"label", 1, (int *)0, 'V'},
21284|       |    {"list", 0, (int *)0, 't'},
21285|       |    {"listed-incremental", 1, (int *)0, 'g'},
21286|       |    {"mode", 1, (int *)0, 141},
21287|       |    {"multi-volume", 0, (int *)0, 'M'},
21288|       |    {"new-volume-script", 1, (int *)0, 'F'},
21289|       |    {"newer", 1, (int *)0, 'N'},
21290|       |    {"newer-mtime", 1, (int *)0, 142},
21291|       |    {"null", 0, (int *)0, 148},
21292|       |    {"no-anchored", 0, (int *)0, 143},
21293|       |    {"no-ignore-case", 0, (int *)0, 144},
21294|       |    {"no-overwrite-dir", 0, (int *)0, 145},
21295|       |    {"no-wildcards", 0, (int *)0, 146},
21296|       |    {"no-wildcards-match-slash", 0, (int *)0, 147},
21297|       |    {"no-recursion", 0, &recursion_option, 0},
21298|       |    {"no-same-owner", 0, &same_owner_option, -1},
21299|       |    {"no-same-permissions", 0, &same_permissions_option, -1},
21300|       |    {"numeric-owner", 0, (int *)0, 149},
21301|       |    {"occurrence", 2, (int *)0, 150},
21302|       |    {"old-archive", 0, (int *)0, 'o'},
21303|       |    {"one-file-system", 0, (int *)0, 'l'},
21304|       |    {"overwrite", 0, (int *)0, 151},
21305|       |    {"owner", 1, (int *)0, 152},
21306|       |    {"pax-option", 1, (int *)0, 153},
21307|       |    {"portability", 0, (int *)0, 'o'},
21308|       |    {"posix", 0, (int *)0, 154},
21309|       |    {"preserve", 0, (int *)0, 155},
21310|       |    {"preserve-order", 0, (int *)0, 's'},
21311|       |    {"preserve-permissions", 0, (int *)0, 'p'},
21312|       |    {"recursion", 0, &recursion_option, 1 << 3},
21313|       |    {"recursive-unlink", 0, (int *)0, 157},
21314|       |    {"read-full-records", 0, (int *)0, 'B'},
21315|       |    {"record-size", 1, (int *)0, 156},
21316|       |    {"remove-files", 0, (int *)0, 158},
21317|       |    {"rmt-command", 1, (int *)0, 159},
21318|       |    {"rsh-command", 1, (int *)0, 160},
21319|       |    {"same-order", 0, (int *)0, 's'},
21320|       |    {"same-owner", 0, &same_owner_option, 1},
21321|       |    {"same-permissions", 0, (int *)0, 'p'},
21322|       |    {"show-defaults", 0, (int *)0, 161},
21323|       |    {"show-omitted-dirs", 0, (int *)0, 162},
21324|       |    {"sparse", 0, (int *)0, 'S'},
21325|       |    {"starting-file", 1, (int *)0, 'K'},
21326|       |    {"strip-path", 1, (int *)0, 163},
21327|       |    {"suffix", 1, (int *)0, 164},
21328|       |    {"tape-length", 1, (int *)0, 'L'},
21329|       |    {"to-stdout", 0, (int *)0, 'O'},
21330|       |    {"totals", 0, (int *)0, 165},
21331|       |    {"touch", 0, (int *)0, 'm'},
21332|       |    {"uncompress", 0, (int *)0, 'Z'},
21333|       |    {"ungzip", 0, (int *)0, 'z'},
21334|       |    {"unlink-first", 0, (int *)0, 'U'},
21335|       |    {"update", 0, (int *)0, 'u'},
21336|       |    {"utc", 0, (int *)0, 167},
21337|       |    {"use-compress-program", 1, (int *)0, 166},
21338|       |    {"verbose", 0, (int *)0, 'v'},
21339|       |    {"verify", 0, (int *)0, 'W'},
21340|       |    {"version", 0, &show_version, 1},
21341|       |    {"volno-file", 1, (int *)0, 168},
21342|       |    {"wildcards", 0, (int *)0, 169},
21343|       |    {"wildcards-match-slash", 0, (int *)0, 170},
21344|       |    {(char const *)0, 0, (int *)0, 0}};
21345|       |__attribute__((__noreturn__)) void usage(int status);
21346|      0|void usage(int status) {
21347|      0|  char *tmp;
21348|      0|  char *tmp___0;
21349|      0|  char *tmp___1;
21350|      0|  char *tmp___2;
21351|      0|  char *tmp___3;
21352|      0|  char *tmp___4;
21353|      0|  char *tmp___5;
21354|      0|  char *tmp___6;
21355|      0|  char *tmp___7;
21356|      0|  char *tmp___8;
21357|      0|  char *tmp___9;
21358|      0|  char *tmp___10;
21359|      0|  char *tmp___11;
21360|      0|  char *tmp___12;
21361|      0|  char *tmp___13;
21362|      0|  char *tmp___14;
21363|      0|  char const *tmp___15;
21364|      0|  char *tmp___16;
21365|      0|  char *tmp___17;
21366|      0|  char *__cil_tmp21;
21367|      0|  char *__cil_tmp22;
21368|      0|  char *__cil_tmp23;
21369|      0|  char *__cil_tmp24;
21370|      0|  char *__cil_tmp25;
21371|      0|  char *__cil_tmp26;
21372|      0|  char *__cil_tmp27;
21373|      0|  char *__cil_tmp28;
21374|      0|  char *__cil_tmp29;
21375|      0|  char *__cil_tmp30;
21376|      0|  char *__cil_tmp31;
21377|      0|  char *__cil_tmp32;
21378|      0|  char *__cil_tmp33;
21379|      0|  char *__cil_tmp34;
21380|      0|  char *__cil_tmp35;
21381|      0|  char *__cil_tmp36;
21382|      0|  char *__cil_tmp37;
21383|      0|  char *__cil_tmp38;
21384|       |
21385|      0|  {
21386|      0|    if (status != 0) {
21387|      0|      {
21388|      0|        tmp = gettext("Try `%s --help\' for more information.\n");
21389|      0|        fprintf((FILE * /* __restrict  */) stderr,
21390|      0|                (char const * /* __restrict  */)tmp, program_name);
21391|      0|      }
21392|      0|    } else {
21393|      0|      {
21394|      0|        tmp___0 = gettext(
21395|      0|            "GNU `tar\' saves many files together into a single tape or disk "
21396|      0|            "archive, and\ncan restore individual files from the archive.\n");
21397|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___0,
21398|      0|                       (FILE * /* __restrict  */) stdout);
21399|      0|        tmp___1 =
21400|      0|            gettext("\nUsage: %s [OPTION]... [FILE]...\n\nExamples:\n  %s -cf "
21401|      0|                    "archive.tar foo bar  # Create archive.tar from files foo "
21402|      0|                    "and bar.\n  %s -tvf archive.tar         # List all files "
21403|      0|                    "in archive.tar verbosely.\n  %s -xf archive.tar          "
21404|      0|                    "# Extract all files from archive.tar.\n");
21405|      0|        printf((char const * /* __restrict  */)tmp___1, program_name,
21406|      0|               program_name, program_name, program_name);
21407|      0|        tmp___2 = gettext("\nIf a long option shows an argument as mandatory, "
21408|      0|                          "then it is mandatory\nfor the equivalent short "
21409|      0|                          "option also.  Similarly for optional arguments.\n");
21410|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___2,
21411|      0|                       (FILE * /* __restrict  */) stdout);
21412|      0|        tmp___3 = gettext(
21413|      0|            "\nMain operation mode:\n  -t, --list              list the "
21414|      0|            "contents of an archive\n  -x, --extract, --get    extract files "
21415|      0|            "from an archive\n  -c, --create            create a new archive\n "
21416|      0|            " -d, --diff, --compare   find differences between archive and "
21417|      0|            "file system\n  -r, --append            append files to the end of "
21418|      0|            "an archive\n  -u, --update            only append files newer "
21419|      0|            "than copy in archive\n  -A, --catenate          append tar files "
21420|      0|            "to an archive\n      --concatenate       same as -A\n      "
21421|      0|            "--delete            delete from the archive (not on mag "
21422|      0|            "tapes!)\n");
21423|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___3,
21424|      0|                       (FILE * /* __restrict  */) stdout);
21425|      0|        tmp___4 = gettext(
21426|      0|            "\nOperation modifiers:\n  -W, --verify               attempt to "
21427|      0|            "verify the archive after writing it\n      --remove-files         "
21428|      0|            "remove files after adding them to the archive\n  -k, "
21429|      0|            "--keep-old-files       don\'t replace existing files when "
21430|      0|            "extracting\n      --keep-newer-files     don\'t replace existing "
21431|      0|            "files that are newer\n                             than their "
21432|      0|            "archive copies\n      --overwrite            overwrite existing "
21433|      0|            "files when extracting\n      --no-overwrite-dir     preserve "
21434|      0|            "metadata of existing directories\n  -U, --unlink-first         "
21435|      0|            "remove each file prior to extracting over it\n      "
21436|      0|            "--recursive-unlink     empty hierarchies prior to extracting "
21437|      0|            "directory\n  -S, --sparse               handle sparse files "
21438|      0|            "efficiently\n  -O, --to-stdout            extract files to "
21439|      0|            "standard output\n  -G, --incremental          handle old "
21440|      0|            "GNU-format incremental backup\n  -g, --listed-incremental=FILE\n  "
21441|      0|            "                           handle new GNU-format incremental "
21442|      0|            "backup\n      --ignore-failed-read   do not exit with nonzero on "
21443|      0|            "unreadable files\n      --occurrence[=NUM]     process only the "
21444|      0|            "NUMth occurrence of each file in\n                             "
21445|      0|            "the archive. This option is valid only in\n                       "
21446|      0|            "      conjunction with one of the subcommands --delete,\n         "
21447|      0|            "                    --diff, --extract or --list and when a list "
21448|      0|            "of\n                             files is given either on the "
21449|      0|            "command line or\n                             via -T option.\n    "
21450|      0|            "                         NUM defaults to 1.\n");
21451|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___4,
21452|      0|                       (FILE * /* __restrict  */) stdout);
21453|      0|        tmp___5 = gettext(
21454|      0|            "\nHandling of file attributes:\n      --owner=NAME             "
21455|      0|            "force NAME as owner for added files\n      --group=NAME           "
21456|      0|            "  force NAME as group for added files\n      --mode=CHANGES       "
21457|      0|            "    force (symbolic) mode CHANGES for added files\n      "
21458|      0|            "--atime-preserve         don\'t change access times on dumped "
21459|      0|            "files\n  -m, --modification-time      don\'t extract file "
21460|      0|            "modified time\n      --same-owner             try extracting "
21461|      0|            "files with the same ownership\n      --no-same-owner          "
21462|      0|            "extract files as yourself\n      --numeric-owner          always "
21463|      0|            "use numbers for user/group names\n  -p, --same-permissions       "
21464|      0|            "extract permissions information\n      --no-same-permissions    "
21465|      0|            "do not extract permissions information\n      "
21466|      0|            "--preserve-permissions   same as -p\n  -s, --same-order           "
21467|      0|            "  sort names to extract to match archive\n      --preserve-order  "
21468|      0|            "       same as -s\n      --preserve               same as both -p "
21469|      0|            "and -s\n");
21470|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___5,
21471|      0|                       (FILE * /* __restrict  */) stdout);
21472|      0|        tmp___6 = gettext(
21473|      0|            "\nDevice selection and switching:\n  -f, --file=ARCHIVE           "
21474|      0|            "  use archive file or device ARCHIVE\n      --force-local         "
21475|      0|            "     archive file is local even if has a colon\n      "
21476|      0|            "--rmt-command=COMMAND      use given rmt COMMAND instead of "
21477|      0|            "/etc/rmt\n      --rsh-command=COMMAND      use remote COMMAND "
21478|      0|            "instead of rsh\n  -[0-7][lmh]                    specify drive "
21479|      0|            "and density\n  -M, --multi-volume             create/list/extract "
21480|      0|            "multi-volume archive\n  -L, --tape-length=NUM          change "
21481|      0|            "tape after writing NUM x 1024 bytes\n  -F, --info-script=FILE     "
21482|      0|            "    run script at end of each tape (implies -M)\n      "
21483|      0|            "--new-volume-script=FILE   same as -F FILE\n      "
21484|      0|            "--volno-file=FILE          use/update the volume number in "
21485|      0|            "FILE\n");
21486|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___6,
21487|      0|                       (FILE * /* __restrict  */) stdout);
21488|      0|        tmp___7 = gettext(
21489|      0|            "\nDevice blocking:\n  -b, --blocking-factor=BLOCKS   BLOCKS x 512 "
21490|      0|            "bytes per record\n      --record-size=SIZE         SIZE bytes per "
21491|      0|            "record, multiple of 512\n  -i, --ignore-zeros             ignore "
21492|      0|            "zeroed blocks in archive (means EOF)\n  -B, --read-full-records   "
21493|      0|            "     reblock as we read (for 4.2BSD pipes)\n");
21494|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___7,
21495|      0|                       (FILE * /* __restrict  */) stdout);
21496|      0|        tmp___8 = gettext(
21497|      0|            "\nArchive format selection:\n      --format=FMTNAME               "
21498|      0|            "create archive of the given format.\n                             "
21499|      0|            "        FMTNAME is one of the following:\n                        "
21500|      0|            "             v7        old V7 tar format\n                        "
21501|      0|            "             oldgnu    GNU format as per tar <= 1.12\n            "
21502|      0|            "                         gnu       GNU tar 1.13 format\n          "
21503|      0|            "                           ustar     POSIX 1003.1-1988 (ustar) "
21504|      0|            "format\n                                     posix     POSIX "
21505|      0|            "1003.1-2001 (pax) format\n      --old-archive, --portability   "
21506|      0|            "same as --format=v7\n      --posix                        same as "
21507|      0|            "--format=posix\n  --pax-option "
21508|      0|            "keyword[[:]=value][,keyword[[:]=value], ...]\n                    "
21509|      0|            "                 control pax keywords\n  -V, --label=NAME         "
21510|      0|            "          create archive with volume name NAME\n              "
21511|      0|            "PATTERN                at list/extract time, a globbing PATTERN\n "
21512|      0|            " -j, --bzip2                        filter the archive through "
21513|      0|            "bzip2\n  -z, --gzip, --ungzip               filter the archive "
21514|      0|            "through gzip\n  -Z, --compress, --uncompress       filter the "
21515|      0|            "archive through compress\n      --use-compress-program=PROG    "
21516|      0|            "filter through PROG (must accept -d)\n");
21517|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___8,
21518|      0|                       (FILE * /* __restrict  */) stdout);
21519|      0|        tmp___9 = gettext(
21520|      0|            "\nLocal file selection:\n  -C, --directory=DIR          change to "
21521|      0|            "directory DIR\n  -T, --files-from=NAME        get names to "
21522|      0|            "extract or create from file NAME\n      --null                   "
21523|      0|            "-T reads null-terminated names, disable -C\n      "
21524|      0|            "--exclude=PATTERN        exclude files, given as a PATTERN\n  -X, "
21525|      0|            "--exclude-from=FILE      exclude patterns listed in FILE\n      "
21526|      0|            "--anchored               exclude patterns match file name start "
21527|      0|            "(default)\n      --no-anchored            exclude patterns match "
21528|      0|            "after any /\n      --ignore-case            exclusion ignores "
21529|      0|            "case\n      --no-ignore-case         exclusion is case sensitive "
21530|      0|            "(default)\n      --wildcards              exclude patterns use "
21531|      0|            "wildcards (default)\n      --no-wildcards           exclude "
21532|      0|            "patterns are plain strings\n      --wildcards-match-slash  "
21533|      0|            "exclude pattern wildcards match \'/\' (default)\n      "
21534|      0|            "--no-wildcards-match-slash exclude pattern wildcards do not match "
21535|      0|            "\'/\'\n  -P, --absolute-names         don\'t strip leading `/\'s "
21536|      0|            "from file names\n  -h, --dereference            dump instead the "
21537|      0|            "files symlinks point to\n      --no-recursion           avoid "
21538|      0|            "descending automatically in directories\n  -l, --one-file-system  "
21539|      0|            "      stay in local file system when creating archive\n  -K, "
21540|      0|            "--starting-file=NAME     begin at file NAME in the archive\n      "
21541|      0|            "--strip-path=NUM         strip NUM leading components from file "
21542|      0|            "names\n                               before extraction\n");
21543|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___9,
21544|      0|                       (FILE * /* __restrict  */) stdout);
21545|      0|        tmp___10 = gettext("  -N, --newer=DATE-OR-FILE     only store files "
21546|      0|                           "newer than DATE-OR-FILE\n      --newer-mtime=DATE  "
21547|      0|                           "     compare date and time when data changed "
21548|      0|                           "only\n      --after-date=DATE        same as -N\n");
21549|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___10,
21550|      0|                       (FILE * /* __restrict  */) stdout);
21551|      0|        tmp___11 =
21552|      0|            gettext("      --backup[=CONTROL]       backup before removal, "
21553|      0|                    "choose version control\n      --suffix=SUFFIX          "
21554|      0|                    "backup before removal, override usual suffix\n");
21555|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___11,
21556|      0|                       (FILE * /* __restrict  */) stdout);
21557|      0|        tmp___12 = gettext(
21558|      0|            "\nInformative output:\n      --help            print this help, "
21559|      0|            "then exit\n      --version         print tar program version "
21560|      0|            "number, then exit\n  -v, --verbose         verbosely list files "
21561|      0|            "processed\n      --checkpoint      print directory names while "
21562|      0|            "reading the archive\n      --check-links     print a message if "
21563|      0|            "not all links are dumped\n      --totals          print total "
21564|      0|            "bytes written while creating archive\n      --index-file=FILE "
21565|      0|            "send verbose output to FILE\n      --utc             print file "
21566|      0|            "modification dates in UTC\n  -R, --block-number    show block "
21567|      0|            "number within archive with each message\n  -w, --interactive     "
21568|      0|            "ask for confirmation for every action\n      --confirmation    "
21569|      0|            "same as -w\n");
21570|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___12,
21571|      0|                       (FILE * /* __restrict  */) stdout);
21572|      0|        tmp___13 = gettext(
21573|      0|            "\nCompatibility options:\n  -o                                 "
21574|      0|            "when creating, same as --old-archive\n                            "
21575|      0|            "         when extracting, same as --no-same-owner\n");
21576|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___13,
21577|      0|                       (FILE * /* __restrict  */) stdout);
21578|      0|        tmp___14 =
21579|      0|            gettext("\nThe backup suffix is `~\', unless set with --suffix or "
21580|      0|                    "SIMPLE_BACKUP_SUFFIX.\nThe version control may be set "
21581|      0|                    "with --backup or VERSION_CONTROL, values are:\n\n  t, "
21582|      0|                    "numbered     make numbered backups\n  nil, existing   "
21583|      0|                    "numbered if numbered backups exist, simple otherwise\n  "
21584|      0|                    "never, simple   always make simple backups\n");
21585|      0|        fputs_unlocked((char const * /* __restrict  */)tmp___14,
21586|      0|                       (FILE * /* __restrict  */) stdout);
21587|      0|        tmp___15 = archive_format_string((enum archive_format)6);
21588|      0|        tmp___16 =
21589|      0|            gettext("\nARCHIVE may be FILE, HOST:FILE or USER@HOST:FILE; DATE "
21590|      0|                    "may be a textual date\nor a file name starting with `/\' "
21591|      0|                    "or `.\', in which case the file\'s date is used.\n*This* "
21592|      0|                    "`tar\' defaults to `--format=%s -f%s -b%d\'.\n");
21593|      0|        printf((char const * /* __restrict  */)tmp___16, tmp___15, "-", 20);
21594|      0|        tmp___17 = gettext("\nReport bugs to <%s>.\n");
21595|      0|        printf((char const * /* __restrict  */)tmp___17, "bug-tar@gnu.org");
21596|      0|      }
21597|      0|    }
21598|      0|    { exit(status); }
21599|      0|  }
21600|      0|}
21601|      0|static void set_subcommand_option(enum subcommand subcommand) {
21602|      0|  char *tmp;
21603|      0|  char *__cil_tmp3;
21604|       |
21605|      0|  {
21606|      0|    if ((unsigned int)subcommand_option != 0U) {
21607|      0|      if ((unsigned int)subcommand_option != (unsigned int)subcommand) {
21608|      0|        {
21609|      0|          tmp = gettext("You may not specify more than one `-Acdtrux\' option");
21610|      0|          error(0, 0, (char const *)tmp);
21611|      0|          usage(2);
21612|      0|        }
21613|      0|      }
21614|      0|    }
21615|      0|    subcommand_option = subcommand;
21616|      0|    return;
21617|      0|  }
21618|      0|}
21619|      0|static void set_use_compress_program_option(char const *string) {
21620|      0|  char *tmp;
21621|      0|  int tmp___0;
21622|      0|  char *__cil_tmp4;
21623|       |
21624|      0|  {
21625|      0|    if (use_compress_program_option) {
21626|      0|      {
21627|      0|        tmp___0 = strcmp(use_compress_program_option, string);
21628|      0|      }
21629|      0|      if (tmp___0 != 0) {
21630|      0|        {
21631|      0|          tmp = gettext("Conflicting compression options");
21632|      0|          error(0, 0, (char const *)tmp);
21633|      0|          usage(2);
21634|      0|        }
21635|      0|      }
21636|      0|    }
21637|      0|    use_compress_program_option = string;
21638|      0|    return;
21639|      0|  }
21640|      0|}
21641|      0|static void decode_options(int argc, char **argv) {
21642|      0|  int optchar;
21643|      0|  int input_files;
21644|      0|  char const *textual_date_option;
21645|      0|  char const *backup_suffix_string;
21646|      0|  char const *version_control_string;
21647|      0|  int exclude_options;
21648|      0|  _Bool o_option;
21649|      0|  int pax_option;
21650|      0|  char *tmp;
21651|      0|  int new_argc;
21652|      0|  char **new_argv;
21653|      0|  char *const *in;
21654|      0|  char **out;
21655|      0|  char const *letter;
21656|      0|  char buffer___2[3];
21657|      0|  char const *cursor;
21658|      0|  size_t tmp___0;
21659|      0|  void *tmp___1;
21660|      0|  char **tmp___2;
21661|      0|  char *const *tmp___3;
21662|      0|  char *const *tmp___4;
21663|      0|  char **tmp___5;
21664|      0|  char *tmp___6;
21665|      0|  char **tmp___7;
21666|      0|  char *const *tmp___8;
21667|      0|  char *tmp___9;
21668|      0|  char **tmp___10;
21669|      0|  char *const *tmp___11;
21670|      0|  char *tmp___12;
21671|      0|  uintmax_t u;
21672|      0|  char *tmp___13;
21673|      0|  char *tmp___14;
21674|      0|  strtol_error tmp___15;
21675|      0|  void *tmp___16;
21676|      0|  int tmp___17;
21677|      0|  char *tmp___18;
21678|      0|  uintmax_t u___0;
21679|      0|  char *tmp___19;
21680|      0|  char *tmp___20;
21681|      0|  strtol_error tmp___21;
21682|      0|  char *tmp___22;
21683|      0|  struct stat st;
21684|      0|  char *tmp___23;
21685|      0|  int tmp___24;
21686|      0|  char const *tmp___25;
21687|      0|  char const *tmp___26;
21688|      0|  char *tmp___27;
21689|      0|  _Bool tmp___28;
21690|      0|  int e;
21691|      0|  int *tmp___29;
21692|      0|  char *tmp___30;
21693|      0|  int tmp___31;
21694|      0|  char *tmp___32;
21695|      0|  uintmax_t g;
21696|      0|  char *tmp___33;
21697|      0|  char *tmp___34;
21698|      0|  strtol_error tmp___35;
21699|      0|  size_t tmp___36;
21700|      0|  int tmp___37;
21701|      0|  char *tmp___38;
21702|      0|  uintmax_t u___1;
21703|      0|  char *tmp___39;
21704|      0|  char *tmp___40;
21705|      0|  strtol_error tmp___41;
21706|      0|  uintmax_t u___2;
21707|      0|  char *tmp___42;
21708|      0|  char *tmp___43;
21709|      0|  strtol_error tmp___44;
21710|      0|  size_t tmp___45;
21711|      0|  int tmp___46;
21712|      0|  uintmax_t u___3;
21713|      0|  char *tmp___47;
21714|      0|  char *tmp___48;
21715|      0|  strtol_error tmp___49;
21716|      0|  char *tmp___50;
21717|      0|  char const *tmp___51;
21718|      0|  uintmax_t u___4;
21719|      0|  char *tmp___52;
21720|      0|  char *tmp___53;
21721|      0|  strtol_error tmp___54;
21722|      0|  char *tmp___55;
21723|      0|  char *tmp___56;
21724|      0|  char *tmp___57;
21725|      0|  char *tmp___58;
21726|      0|  char *tmp___59;
21727|      0|  char *tmp___60;
21728|      0|  char *tmp___61;
21729|      0|  char *tmp___62;
21730|      0|  size_t volume_label_max_len;
21731|      0|  char *tmp___63;
21732|      0|  char *tmp___64;
21733|      0|  size_t tmp___65;
21734|      0|  char *tmp___66;
21735|      0|  char *tmp___67;
21736|      0|  char *tmp___68;
21737|      0|  char *tmp___69;
21738|      0|  char *tmp___70;
21739|      0|  char *tmp___71;
21740|      0|  int tmp___72;
21741|      0|  char *tmp___73;
21742|      0|  int tmp___74;
21743|      0|  char *tmp___75;
21744|      0|  char const *treated_as;
21745|      0|  char const *tmp___76;
21746|      0|  char *tmp___77;
21747|      0|  int tmp___78;
21748|      0|  unsigned long tmp___79;
21749|      0|  void *__cil_tmp110;
21750|      0|  void *__cil_tmp111;
21751|      0|  char *__cil_tmp112;
21752|      0|  char *__cil_tmp113;
21753|      0|  char *__cil_tmp114;
21754|      0|  char *__cil_tmp115;
21755|      0|  char *__cil_tmp116;
21756|      0|  char *__cil_tmp117;
21757|      0|  char *__cil_tmp118;
21758|      0|  char *__cil_tmp119;
21759|      0|  char *__cil_tmp120;
21760|      0|  char *__cil_tmp121;
21761|      0|  char *__cil_tmp122;
21762|      0|  char *__cil_tmp123;
21763|      0|  char *__cil_tmp124;
21764|      0|  char *__cil_tmp125;
21765|      0|  char *__cil_tmp126;
21766|      0|  char *__cil_tmp127;
21767|      0|  char *__cil_tmp128;
21768|      0|  char *__cil_tmp129;
21769|      0|  char *__cil_tmp130;
21770|      0|  char *__cil_tmp131;
21771|      0|  char *__cil_tmp132;
21772|      0|  char *__cil_tmp133;
21773|      0|  char *__cil_tmp134;
21774|      0|  char *__cil_tmp135;
21775|      0|  char *__cil_tmp136;
21776|      0|  char *__cil_tmp137;
21777|      0|  char *__cil_tmp138;
21778|      0|  char *__cil_tmp139;
21779|      0|  char *__cil_tmp140;
21780|      0|  char *__cil_tmp141;
21781|      0|  char *__cil_tmp142;
21782|      0|  char *__cil_tmp143;
21783|      0|  char *__cil_tmp144;
21784|      0|  char *__cil_tmp145;
21785|      0|  char *__cil_tmp146;
21786|      0|  char *__cil_tmp147;
21787|      0|  char *__cil_tmp148;
21788|      0|  char *__cil_tmp149;
21789|      0|  char *__cil_tmp150;
21790|      0|  char *__cil_tmp151;
21791|      0|  char *__cil_tmp152;
21792|      0|  char *__cil_tmp153;
21793|      0|  char *__cil_tmp154;
21794|      0|  char *__cil_tmp155;
21795|      0|  char *__cil_tmp156;
21796|      0|  char *__cil_tmp157;
21797|      0|  char *__cil_tmp158;
21798|      0|  char *__cil_tmp159;
21799|      0|  char *__cil_tmp160;
21800|      0|  char *__cil_tmp161;
21801|      0|  char *__cil_tmp162;
21802|      0|  char *__cil_tmp163;
21803|      0|  char *__cil_tmp164;
21804|      0|  char *__cil_tmp165;
21805|      0|  char *__cil_tmp166;
21806|      0|  char *__cil_tmp167;
21807|      0|  char *__cil_tmp168;
21808|      0|  char *__cil_tmp169;
21809|      0|  char *__cil_tmp170;
21810|      0|  char *__cil_tmp171;
21811|      0|  char *__cil_tmp172;
21812|       |
21813|      0|  {
21814|      0|    {
21815|      0|      textual_date_option = (char const *)0;
21816|      0|      version_control_string = (char const *)0;
21817|      0|      exclude_options = 1 << 28;
21818|      0|      o_option = (_Bool)0;
21819|      0|      pax_option = 0;
21820|      0|      subcommand_option = (enum subcommand)0;
21821|      0|      archive_format = (enum archive_format)0;
21822|      0|      blocking_factor = 20;
21823|      0|      record_size = (size_t)10240;
21824|      0|      excluded = new_exclude();
21825|      0|      newer_mtime_option.tv_sec = -1L << (sizeof(time_t) * 8UL - 1UL);
21826|      0|      newer_mtime_option.tv_nsec = (__syscall_slong_t)-1;
21827|      0|      recursion_option = 1 << 3;
21828|      0|      owner_option = (uid_t)-1;
21829|      0|      group_option = (gid_t)-1;
21830|      0|      tmp = getenv("SIMPLE_BACKUP_SUFFIX");
21831|      0|      backup_suffix_string = (char const *)tmp;
21832|      0|    }
21833|      0|    if (argc > 1) {
21834|      0|      if ((int)*(*(argv + 1) + 0) != 45) {
21835|      0|        {
21836|      0|          buffer___2[0] = (char)'-';
21837|      0|          buffer___2[2] = (char)'\000';
21838|      0|          tmp___0 = strlen((char const *)*(argv + 1));
21839|      0|          new_argc = (int)((size_t)(argc - 1) + tmp___0);
21840|      0|          tmp___1 = xmalloc((unsigned long)(new_argc + 1) * sizeof(char *));
21841|      0|          new_argv = (char **)tmp___1;
21842|      0|          in = (char *const *)argv;
21843|      0|          out = new_argv;
21844|      0|          tmp___2 = out;
21845|      0|          out++;
21846|      0|          tmp___3 = in;
21847|      0|          in++;
21848|      0|          *tmp___2 = (char *)*tmp___3;
21849|      0|          tmp___4 = in;
21850|      0|          in++;
21851|      0|          letter = (char const *)*tmp___4;
21852|      0|        }
21853|      0|        {
21854|      0|          while (1) {
21855|      0|          while_continue: /* CIL Label */;
21856|      0|            if (!*letter) {
21857|      0|              goto while_break;
21858|      0|            }
21859|      0|            {
21860|      0|              buffer___2[1] = (char)*letter;
21861|      0|              tmp___5 = out;
21862|      0|              out++;
21863|      0|              *tmp___5 = xstrdup((char const *)(buffer___2));
21864|      0|              tmp___6 = strchr("-01234567ABC:F:GIK:L:MN:OPRST:UV:WX:Zb:cdf:g:"
21865|      0|                               "hijklmoprstuvwxyz",
21866|      0|                               (int)*letter);
21867|      0|              cursor = (char const *)tmp___6;
21868|      0|            }
21869|      0|            if (cursor) {
21870|      0|              if ((int const) * (cursor + 1) == 58) {
21871|      0|                if ((unsigned long)in < (unsigned long)(argv + argc)) {
21872|      0|                  tmp___7 = out;
21873|      0|                  out++;
21874|      0|                  tmp___8 = in;
21875|      0|                  in++;
21876|      0|                  *tmp___7 = (char *)*tmp___8;
21877|      0|                } else {
21878|      0|                  {
21879|      0|                    tmp___9 = gettext("Old option `%c\' requires an argument.");
21880|      0|                    error(0, 0, (char const *)tmp___9, (int const) * letter);
21881|      0|                    usage(2);
21882|      0|                  }
21883|      0|                }
21884|      0|              }
21885|      0|            }
21886|      0|            letter++;
21887|      0|          }
21888|      0|        while_break: /* CIL Label */;
21889|      0|        }
21890|      0|        {
21891|      0|          while (1) {
21892|      0|          while_continue___0: /* CIL Label */;
21893|      0|            if (!((unsigned long)in < (unsigned long)(argv + argc))) {
21894|      0|              goto while_break___0;
21895|      0|            }
21896|      0|            tmp___10 = out;
21897|      0|            out++;
21898|      0|            tmp___11 = in;
21899|      0|            in++;
21900|      0|            *tmp___10 = (char *)*tmp___11;
21901|      0|          }
21902|      0|        while_break___0: /* CIL Label */;
21903|      0|        }
21904|      0|        *out = (char *)0;
21905|      0|        argc = new_argc;
21906|      0|        argv = new_argv;
21907|      0|      }
21908|      0|    }
21909|      0|    {
21910|      0|      input_files = 0;
21911|      0|      tmp___12 = getenv("TAR_OPTIONS");
21912|      0|      prepend_default_options((char const *)tmp___12, &argc, &argv);
21913|      0|    }
21914|      0|    {
21915|      0|      while (1) {
21916|      0|      while_continue___1: /* CIL Label */;
21917|      0|        {
21918|      0|          optchar = getopt_long(
21919|      0|              argc, (char *const *)argv,
21920|      0|              "-01234567ABC:F:GIK:L:MN:OPRST:UV:WX:Zb:cdf:g:hijklmoprstuvwxyz",
21921|      0|              (struct option const *)(long_options), (int *)0);
21922|      0|        }
21923|      0|        if (!(optchar != -1)) {
21924|      0|          goto while_break___1;
21925|      0|        }
21926|      0|        {
21927|      0|          if (optchar == 63) {
21928|      0|            goto case_63;
21929|      0|          }
21930|      0|          if (optchar == 0) {
21931|      0|            goto case_0;
21932|      0|          }
21933|      0|          if (optchar == 1) {
21934|      0|            goto case_1;
21935|      0|          }
21936|      0|          if (optchar == 65) {
21937|      0|            goto case_65;
21938|      0|          }
21939|      0|          if (optchar == 98) {
21940|      0|            goto case_98;
21941|      0|          }
21942|      0|          if (optchar == 66) {
21943|      0|            goto case_66;
21944|      0|          }
21945|      0|          if (optchar == 99) {
21946|      0|            goto case_99;
21947|      0|          }
21948|      0|          if (optchar == 67) {
21949|      0|            goto case_67;
21950|      0|          }
21951|      0|          if (optchar == 100) {
21952|      0|            goto case_100;
21953|      0|          }
21954|      0|          if (optchar == 102) {
21955|      0|            goto case_102;
21956|      0|          }
21957|      0|          if (optchar == 70) {
21958|      0|            goto case_70;
21959|      0|          }
21960|      0|          if (optchar == 103) {
21961|      0|            goto case_103;
21962|      0|          }
21963|      0|          if (optchar == 71) {
21964|      0|            goto case_71;
21965|      0|          }
21966|      0|          if (optchar == 104) {
21967|      0|            goto case_104;
21968|      0|          }
21969|      0|          if (optchar == 105) {
21970|      0|            goto case_105;
21971|      0|          }
21972|      0|          if (optchar == 73) {
21973|      0|            goto case_73;
21974|      0|          }
21975|      0|          if (optchar == 106) {
21976|      0|            goto case_106;
21977|      0|          }
21978|      0|          if (optchar == 107) {
21979|      0|            goto case_107;
21980|      0|          }
21981|      0|          if (optchar == 75) {
21982|      0|            goto case_75;
21983|      0|          }
21984|      0|          if (optchar == 108) {
21985|      0|            goto case_108;
21986|      0|          }
21987|      0|          if (optchar == 76) {
21988|      0|            goto case_76;
21989|      0|          }
21990|      0|          if (optchar == 109) {
21991|      0|            goto case_109;
21992|      0|          }
21993|      0|          if (optchar == 77) {
21994|      0|            goto case_77;
21995|      0|          }
21996|      0|          if (optchar == 78) {
21997|      0|            goto case_78;
21998|      0|          }
21999|      0|          if (optchar == 142) {
22000|      0|            goto case_142;
22001|      0|          }
22002|      0|          if (optchar == 111) {
22003|      0|            goto case_111;
22004|      0|          }
22005|      0|          if (optchar == 79) {
22006|      0|            goto case_79;
22007|      0|          }
22008|      0|          if (optchar == 112) {
22009|      0|            goto case_112;
22010|      0|          }
22011|      0|          if (optchar == 80) {
22012|      0|            goto case_80;
22013|      0|          }
22014|      0|          if (optchar == 114) {
22015|      0|            goto case_114;
22016|      0|          }
22017|      0|          if (optchar == 82) {
22018|      0|            goto case_82;
22019|      0|          }
22020|      0|          if (optchar == 115) {
22021|      0|            goto case_115;
22022|      0|          }
22023|      0|          if (optchar == 83) {
22024|      0|            goto case_83;
22025|      0|          }
22026|      0|          if (optchar == 116) {
22027|      0|            goto case_116;
22028|      0|          }
22029|      0|          if (optchar == 84) {
22030|      0|            goto case_84;
22031|      0|          }
22032|      0|          if (optchar == 117) {
22033|      0|            goto case_117;
22034|      0|          }
22035|      0|          if (optchar == 85) {
22036|      0|            goto case_85;
22037|      0|          }
22038|      0|          if (optchar == 167) {
22039|      0|            goto case_167;
22040|      0|          }
22041|      0|          if (optchar == 118) {
22042|      0|            goto case_118;
22043|      0|          }
22044|      0|          if (optchar == 86) {
22045|      0|            goto case_86;
22046|      0|          }
22047|      0|          if (optchar == 119) {
22048|      0|            goto case_119;
22049|      0|          }
22050|      0|          if (optchar == 87) {
22051|      0|            goto case_87;
22052|      0|          }
22053|      0|          if (optchar == 120) {
22054|      0|            goto case_120;
22055|      0|          }
22056|      0|          if (optchar == 88) {
22057|      0|            goto case_88;
22058|      0|          }
22059|      0|          if (optchar == 121) {
22060|      0|            goto case_121;
22061|      0|          }
22062|      0|          if (optchar == 122) {
22063|      0|            goto case_122;
22064|      0|          }
22065|      0|          if (optchar == 90) {
22066|      0|            goto case_90;
22067|      0|          }
22068|      0|          if (optchar == 128) {
22069|      0|            goto case_128;
22070|      0|          }
22071|      0|          if (optchar == 129) {
22072|      0|            goto case_129;
22073|      0|          }
22074|      0|          if (optchar == 131) {
22075|      0|            goto case_131;
22076|      0|          }
22077|      0|          if (optchar == 130) {
22078|      0|            goto case_130;
22079|      0|          }
22080|      0|          if (optchar == 132) {
22081|      0|            goto case_132;
22082|      0|          }
22083|      0|          if (optchar == 133) {
22084|      0|            goto case_133;
22085|      0|          }
22086|      0|          if (optchar == 134) {
22087|      0|            goto case_134;
22088|      0|          }
22089|      0|          if (optchar == 135) {
22090|      0|            goto case_135;
22091|      0|          }
22092|      0|          if (optchar == 139) {
22093|      0|            goto case_139;
22094|      0|          }
22095|      0|          if (optchar == 137) {
22096|      0|            goto case_137;
22097|      0|          }
22098|      0|          if (optchar == 138) {
22099|      0|            goto case_138;
22100|      0|          }
22101|      0|          if (optchar == 140) {
22102|      0|            goto case_140;
22103|      0|          }
22104|      0|          if (optchar == 136) {
22105|      0|            goto case_136;
22106|      0|          }
22107|      0|          if (optchar == 141) {
22108|      0|            goto case_141;
22109|      0|          }
22110|      0|          if (optchar == 143) {
22111|      0|            goto case_143;
22112|      0|          }
22113|      0|          if (optchar == 144) {
22114|      0|            goto case_144;
22115|      0|          }
22116|      0|          if (optchar == 145) {
22117|      0|            goto case_145;
22118|      0|          }
22119|      0|          if (optchar == 146) {
22120|      0|            goto case_146;
22121|      0|          }
22122|      0|          if (optchar == 147) {
22123|      0|            goto case_147;
22124|      0|          }
22125|      0|          if (optchar == 148) {
22126|      0|            goto case_148;
22127|      0|          }
22128|      0|          if (optchar == 149) {
22129|      0|            goto case_149;
22130|      0|          }
22131|      0|          if (optchar == 150) {
22132|      0|            goto case_150;
22133|      0|          }
22134|      0|          if (optchar == 151) {
22135|      0|            goto case_151;
22136|      0|          }
22137|      0|          if (optchar == 152) {
22138|      0|            goto case_152;
22139|      0|          }
22140|      0|          if (optchar == 153) {
22141|      0|            goto case_153;
22142|      0|          }
22143|      0|          if (optchar == 154) {
22144|      0|            goto case_154;
22145|      0|          }
22146|      0|          if (optchar == 155) {
22147|      0|            goto case_155;
22148|      0|          }
22149|      0|          if (optchar == 156) {
22150|      0|            goto case_156;
22151|      0|          }
22152|      0|          if (optchar == 157) {
22153|      0|            goto case_157;
22154|      0|          }
22155|      0|          if (optchar == 158) {
22156|      0|            goto case_158;
22157|      0|          }
22158|      0|          if (optchar == 159) {
22159|      0|            goto case_159;
22160|      0|          }
22161|      0|          if (optchar == 160) {
22162|      0|            goto case_160;
22163|      0|          }
22164|      0|          if (optchar == 161) {
22165|      0|            goto case_161;
22166|      0|          }
22167|      0|          if (optchar == 163) {
22168|      0|            goto case_163;
22169|      0|          }
22170|      0|          if (optchar == 164) {
22171|      0|            goto case_164;
22172|      0|          }
22173|      0|          if (optchar == 165) {
22174|      0|            goto case_165;
22175|      0|          }
22176|      0|          if (optchar == 166) {
22177|      0|            goto case_166;
22178|      0|          }
22179|      0|          if (optchar == 168) {
22180|      0|            goto case_168;
22181|      0|          }
22182|      0|          if (optchar == 169) {
22183|      0|            goto case_169;
22184|      0|          }
22185|      0|          if (optchar == 170) {
22186|      0|            goto case_170;
22187|      0|          }
22188|      0|          if (optchar == 48) {
22189|      0|            goto case_48;
22190|      0|          }
22191|      0|          if (optchar == 49) {
22192|      0|            goto case_48;
22193|      0|          }
22194|      0|          if (optchar == 50) {
22195|      0|            goto case_48;
22196|      0|          }
22197|      0|          if (optchar == 51) {
22198|      0|            goto case_48;
22199|      0|          }
22200|      0|          if (optchar == 52) {
22201|      0|            goto case_48;
22202|      0|          }
22203|      0|          if (optchar == 53) {
22204|      0|            goto case_48;
22205|      0|          }
22206|      0|          if (optchar == 54) {
22207|      0|            goto case_48;
22208|      0|          }
22209|      0|          if (optchar == 55) {
22210|      0|            goto case_48;
22211|      0|          }
22212|      0|          goto switch_break;
22213|      0|        case_63 : /* CIL Label */
22214|      0|        {
22215|      0|          usage(2);
22216|      0|        }
22217|      0|        case_0: /* CIL Label */
22218|      0|          goto switch_break;
22219|      0|        case_1 : /* CIL Label */
22220|      0|        {
22221|      0|          name_add((char const *)optarg);
22222|      0|          input_files++;
22223|      0|        }
22224|      0|          goto switch_break;
22225|      0|        case_65 : /* CIL Label */
22226|      0|        {
22227|      0|          set_subcommand_option((enum subcommand)2);
22228|      0|        }
22229|      0|          goto switch_break;
22230|      0|        case_98 : /* CIL Label */
22231|      0|        {
22232|      0|          tmp___15 = xstrtoumax((char const *)optarg, (char **)0, 10, &u, "");
22233|      0|        }
22234|      0|          if ((unsigned int)tmp___15 == 0U) {
22235|      0|            blocking_factor = (int)u;
22236|      0|            if (u == (uintmax_t)blocking_factor) {
22237|      0|              if (0 < blocking_factor) {
22238|      0|                record_size = u * 512UL;
22239|      0|                if (!(u == record_size / 512UL)) {
22240|      0|                  {
22241|      0|                    tmp___13 = gettext("Invalid blocking factor");
22242|      0|                    tmp___14 = quotearg_colon((char const *)optarg);
22243|      0|                    error(0, 0, "%s: %s", tmp___14, tmp___13);
22244|      0|                    usage(2);
22245|      0|                  }
22246|      0|                }
22247|      0|              } else {
22248|      0|                {
22249|      0|                  tmp___13 = gettext("Invalid blocking factor");
22250|      0|                  tmp___14 = quotearg_colon((char const *)optarg);
22251|      0|                  error(0, 0, "%s: %s", tmp___14, tmp___13);
22252|      0|                  usage(2);
22253|      0|                }
22254|      0|              }
22255|      0|            } else {
22256|      0|              {
22257|      0|                tmp___13 = gettext("Invalid blocking factor");
22258|      0|                tmp___14 = quotearg_colon((char const *)optarg);
22259|      0|                error(0, 0, "%s: %s", tmp___14, tmp___13);
22260|      0|                usage(2);
22261|      0|              }
22262|      0|            }
22263|      0|          } else {
22264|      0|            {
22265|      0|              tmp___13 = gettext("Invalid blocking factor");
22266|      0|              tmp___14 = quotearg_colon((char const *)optarg);
22267|      0|              error(0, 0, "%s: %s", tmp___14, tmp___13);
22268|      0|              usage(2);
22269|      0|            }
22270|      0|          }
22271|      0|          goto switch_break;
22272|      0|        case_66: /* CIL Label */
22273|      0|          read_full_records_option = (_Bool)1;
22274|      0|          goto switch_break;
22275|      0|        case_99 : /* CIL Label */
22276|      0|        {
22277|      0|          set_subcommand_option((enum subcommand)3);
22278|      0|        }
22279|      0|          goto switch_break;
22280|      0|        case_67 : /* CIL Label */
22281|      0|        {
22282|      0|          name_add("-C");
22283|      0|          name_add((char const *)optarg);
22284|      0|        }
22285|      0|          goto switch_break;
22286|      0|        case_100 : /* CIL Label */
22287|      0|        {
22288|      0|          set_subcommand_option((enum subcommand)5);
22289|      0|        }
22290|      0|          goto switch_break;
22291|      0|        case_102: /* CIL Label */
22292|      0|          if (archive_names == allocated_archive_names) {
22293|      0|            {
22294|      0|              allocated_archive_names *= 2;
22295|      0|              tmp___16 = xrealloc((void *)archive_name_array,
22296|      0|                                  sizeof(char const *) *
22297|      0|                                      (unsigned long)allocated_archive_names);
22298|      0|              archive_name_array = (char const **)tmp___16;
22299|      0|            }
22300|      0|          }
22301|      0|          tmp___17 = archive_names;
22302|      0|          archive_names++;
22303|      0|          *(archive_name_array + tmp___17) = (char const *)optarg;
22304|      0|          goto switch_break;
22305|      0|        case_70: /* CIL Label */
22306|      0|          info_script_option = (char const *)optarg;
22307|      0|          multi_volume_option = (_Bool)1;
22308|      0|          goto switch_break;
22309|      0|        case_103: /* CIL Label */
22310|      0|          listed_incremental_option = (char const *)optarg;
22311|      0|          after_date_option = 1;
22312|      0|        case_71: /* CIL Label */
22313|      0|          incremental_option = (_Bool)1;
22314|      0|          goto switch_break;
22315|      0|        case_104: /* CIL Label */
22316|      0|          dereference_option = (_Bool)1;
22317|      0|          goto switch_break;
22318|      0|        case_105: /* CIL Label */
22319|      0|          ignore_zeros_option = (_Bool)1;
22320|      0|          goto switch_break;
22321|      0|        case_73 : /* CIL Label */
22322|      0|        {
22323|      0|          tmp___18 = gettext("Warning: the -I option is not supported; perhaps "
22324|      0|                             "you meant -j or -T?");
22325|      0|          error(0, 0, (char const *)tmp___18);
22326|      0|          usage(2);
22327|      0|        }
22328|      0|          goto switch_break;
22329|      0|        case_106 : /* CIL Label */
22330|      0|        {
22331|      0|          set_use_compress_program_option("bzip2");
22332|      0|        }
22333|      0|          goto switch_break;
22334|      0|        case_107: /* CIL Label */
22335|      0|          old_files_option = (enum old_files)4;
22336|      0|          goto switch_break;
22337|      0|        case_75 : /* CIL Label */
22338|      0|        {
22339|      0|          starting_file_option = (_Bool)1;
22340|      0|          addname((char const *)optarg, 0);
22341|      0|        }
22342|      0|          goto switch_break;
22343|      0|        case_108: /* CIL Label */
22344|      0|          one_file_system_option = (_Bool)1;
22345|      0|          goto switch_break;
22346|      0|        case_76 : /* CIL Label */
22347|      0|        {
22348|      0|          tmp___21 =
22349|      0|              xstrtoumax((char const *)optarg, (char **)0, 10, &u___0, "");
22350|      0|        }
22351|      0|          if ((unsigned int)tmp___21 != 0U) {
22352|      0|            {
22353|      0|              tmp___19 = gettext("Invalid tape length");
22354|      0|              tmp___20 = quotearg_colon((char const *)optarg);
22355|      0|              error(0, 0, "%s: %s", tmp___20, tmp___19);
22356|      0|              usage(2);
22357|      0|            }
22358|      0|          }
22359|      0|          tape_length_option = (tarlong)1024 * (tarlong)u___0;
22360|      0|          multi_volume_option = (_Bool)1;
22361|      0|          goto switch_break;
22362|      0|        case_109: /* CIL Label */
22363|      0|          touch_option = (_Bool)1;
22364|      0|          goto switch_break;
22365|      0|        case_77: /* CIL Label */
22366|      0|          multi_volume_option = (_Bool)1;
22367|      0|          goto switch_break;
22368|      0|        case_78: /* CIL Label */
22369|      0|          after_date_option = 1;
22370|      0|        case_142: /* CIL Label */
22371|      0|          if (0L <= newer_mtime_option.tv_nsec) {
22372|      0|            {
22373|      0|              tmp___22 = gettext("More than one threshold date");
22374|      0|              error(0, 0, (char const *)tmp___22);
22375|      0|              usage(2);
22376|      0|            }
22377|      0|          }
22378|      0|          if ((int)*optarg == 47) {
22379|      0|            goto _L___3;
22380|      0|          } else {
22381|      0|            if ((int)*optarg == 46) {
22382|      0|            _L___3 : /* CIL Label */
22383|      0|            {
22384|      0|              tmp___24 =
22385|      0|                  deref_stat(dereference_option, (char const *)optarg, &st);
22386|      0|            }
22387|      0|              if (tmp___24 != 0) {
22388|      0|                {
22389|      0|                  stat_error((char const *)optarg);
22390|      0|                  tmp___23 = gettext("Date file not found");
22391|      0|                  error(0, 0, (char const *)tmp___23);
22392|      0|                  usage(2);
22393|      0|                }
22394|      0|              }
22395|      0|              newer_mtime_option.tv_sec = st.st_mtim.tv_sec;
22396|      0|              newer_mtime_option.tv_nsec = st.st_mtim.tv_nsec;
22397|      0|            } else {
22398|      0|              {
22399|      0|                tmp___28 = get_date(&newer_mtime_option, (char const *)optarg,
22400|      0|                                    (struct timespec const *)((void *)0));
22401|      0|              }
22402|      0|              if (tmp___28) {
22403|      0|                textual_date_option = (char const *)optarg;
22404|      0|              } else {
22405|      0|                {
22406|      0|                  tmp___25 = quote((char const *)optarg);
22407|      0|                  tmp___26 = tartime(newer_mtime_option.tv_sec);
22408|      0|                  tmp___27 =
22409|      0|                      gettext("Substituting %s for unknown date format %s");
22410|      0|                  error(0, 0, (char const *)tmp___27, tmp___26, tmp___25);
22411|      0|                  newer_mtime_option.tv_nsec = (__syscall_slong_t)0;
22412|      0|                }
22413|      0|              }
22414|      0|            }
22415|      0|          }
22416|      0|          goto switch_break;
22417|      0|        case_111: /* CIL Label */
22418|      0|          o_option = (_Bool)1;
22419|      0|          goto switch_break;
22420|      0|        case_79: /* CIL Label */
22421|      0|          to_stdout_option = (_Bool)1;
22422|      0|          goto switch_break;
22423|      0|        case_112: /* CIL Label */
22424|      0|          same_permissions_option = 1;
22425|      0|          goto switch_break;
22426|      0|        case_80: /* CIL Label */
22427|      0|          absolute_names_option = (_Bool)1;
22428|      0|          goto switch_break;
22429|      0|        case_114 : /* CIL Label */
22430|      0|        {
22431|      0|          set_subcommand_option((enum subcommand)1);
22432|      0|        }
22433|      0|          goto switch_break;
22434|      0|        case_82: /* CIL Label */
22435|      0|          block_number_option = (_Bool)1;
22436|      0|          goto switch_break;
22437|      0|        case_115: /* CIL Label */
22438|      0|          same_order_option = (_Bool)1;
22439|      0|          goto switch_break;
22440|      0|        case_83: /* CIL Label */
22441|      0|          sparse_option = (_Bool)1;
22442|      0|          goto switch_break;
22443|      0|        case_116 : /* CIL Label */
22444|      0|        {
22445|      0|          set_subcommand_option((enum subcommand)7);
22446|      0|          verbose_option++;
22447|      0|        }
22448|      0|          goto switch_break;
22449|      0|        case_84: /* CIL Label */
22450|      0|          files_from_option = (char const *)optarg;
22451|      0|          goto switch_break;
22452|      0|        case_117 : /* CIL Label */
22453|      0|        {
22454|      0|          set_subcommand_option((enum subcommand)8);
22455|      0|        }
22456|      0|          goto switch_break;
22457|      0|        case_85: /* CIL Label */
22458|      0|          old_files_option = (enum old_files)3;
22459|      0|          goto switch_break;
22460|      0|        case_167: /* CIL Label */
22461|      0|          utc_option = (_Bool)1;
22462|      0|          goto switch_break;
22463|      0|        case_118: /* CIL Label */
22464|      0|          verbose_option++;
22465|      0|          goto switch_break;
22466|      0|        case_86: /* CIL Label */
22467|      0|          volume_label_option = (char const *)optarg;
22468|      0|          goto switch_break;
22469|      0|        case_119: /* CIL Label */
22470|      0|          interactive_option = (_Bool)1;
22471|      0|          goto switch_break;
22472|      0|        case_87: /* CIL Label */
22473|      0|          verify_option = (_Bool)1;
22474|      0|          goto switch_break;
22475|      0|        case_120 : /* CIL Label */
22476|      0|        {
22477|      0|          set_subcommand_option((enum subcommand)6);
22478|      0|        }
22479|      0|          goto switch_break;
22480|      0|        case_88 : /* CIL Label */
22481|      0|        {
22482|      0|          tmp___31 =
22483|      0|              add_exclude_file(&add_exclude, excluded, (char const *)optarg,
22484|      0|                               exclude_options | recursion_option, (char)'\n');
22485|      0|        }
22486|      0|          if (tmp___31 != 0) {
22487|      0|            {
22488|      0|              tmp___29 = __errno_location();
22489|      0|              e = *tmp___29;
22490|      0|              tmp___30 = quotearg_colon((char const *)optarg);
22491|      0|              error(0, e, "%s", tmp___30);
22492|      0|              fatal_exit();
22493|      0|            }
22494|      0|          }
22495|      0|          goto switch_break;
22496|      0|        case_121 : /* CIL Label */
22497|      0|        {
22498|      0|          tmp___32 = gettext(
22499|      0|              "Warning: the -y option is not supported; perhaps you meant -j?");
22500|      0|          error(0, 0, (char const *)tmp___32);
22501|      0|          usage(2);
22502|      0|        }
22503|      0|          goto switch_break;
22504|      0|        case_122 : /* CIL Label */
22505|      0|        {
22506|      0|          set_use_compress_program_option("gzip");
22507|      0|        }
22508|      0|          goto switch_break;
22509|      0|        case_90 : /* CIL Label */
22510|      0|        {
22511|      0|          set_use_compress_program_option("compress");
22512|      0|        }
22513|      0|          goto switch_break;
22514|      0|        case_128: /* CIL Label */
22515|      0|          exclude_options |= 1 << 30;
22516|      0|          goto switch_break;
22517|      0|        case_129: /* CIL Label */
22518|      0|          atime_preserve_option = (_Bool)1;
22519|      0|          goto switch_break;
22520|      0|        case_131: /* CIL Label */
22521|      0|          checkpoint_option = (_Bool)1;
22522|      0|          goto switch_break;
22523|      0|        case_130: /* CIL Label */
22524|      0|          backup_option = (_Bool)1;
22525|      0|          if (optarg) {
22526|      0|            version_control_string = (char const *)optarg;
22527|      0|          }
22528|      0|          goto switch_break;
22529|      0|        case_132 : /* CIL Label */
22530|      0|        {
22531|      0|          set_subcommand_option((enum subcommand)4);
22532|      0|        }
22533|      0|          goto switch_break;
22534|      0|        case_133 : /* CIL Label */
22535|      0|        {
22536|      0|          add_exclude(excluded, (char const *)optarg,
22537|      0|                      exclude_options | recursion_option);
22538|      0|        }
22539|      0|          goto switch_break;
22540|      0|        case_134: /* CIL Label */
22541|      0|          force_local_option = (_Bool)1;
22542|      0|          goto switch_break;
22543|      0|        case_135 : /* CIL Label */
22544|      0|        {
22545|      0|          set_archive_format((char const *)optarg);
22546|      0|        }
22547|      0|          goto switch_break;
22548|      0|        case_139: /* CIL Label */
22549|      0|          index_file_name = (char const *)optarg;
22550|      0|          goto switch_break;
22551|      0|        case_137: /* CIL Label */
22552|      0|          exclude_options |= 1 << 4;
22553|      0|          goto switch_break;
22554|      0|        case_138: /* CIL Label */
22555|      0|          ignore_failed_read_option = (_Bool)1;
22556|      0|          goto switch_break;
22557|      0|        case_140: /* CIL Label */
22558|      0|          old_files_option = (enum old_files)5;
22559|      0|          goto switch_break;
22560|      0|        case_136 : /* CIL Label */
22561|      0|        {
22562|      0|          tmp___36 = strlen((char const *)optarg);
22563|      0|        }
22564|      0|          if (tmp___36 < 32UL) {
22565|      0|            {
22566|      0|              tmp___37 = gname_to_gid((char const *)optarg, &group_option);
22567|      0|            }
22568|      0|            if (!tmp___37) {
22569|      0|              goto _L;
22570|      0|            }
22571|      0|          } else {
22572|      0|          _L : {
22573|      0|            tmp___35 = xstrtoumax((char const *)optarg, (char **)0, 10, &g, "");
22574|      0|          }
22575|      0|            if ((unsigned int)tmp___35 == 0U) {
22576|      0|              if (g == (uintmax_t)((gid_t)g)) {
22577|      0|                group_option = (gid_t)g;
22578|      0|              } else {
22579|      0|                {
22580|      0|                  tmp___33 = gettext("%s: Invalid group");
22581|      0|                  tmp___34 = quotearg_colon((char const *)optarg);
22582|      0|                  error(0, 0, "%s: %s", tmp___34, tmp___33);
22583|      0|                  fatal_exit();
22584|      0|                }
22585|      0|              }
22586|      0|            } else {
22587|      0|              {
22588|      0|                tmp___33 = gettext("%s: Invalid group");
22589|      0|                tmp___34 = quotearg_colon((char const *)optarg);
22590|      0|                error(0, 0, "%s: %s", tmp___34, tmp___33);
22591|      0|                fatal_exit();
22592|      0|              }
22593|      0|            }
22594|      0|          }
22595|      0|          goto switch_break;
22596|      0|        case_141 : /* CIL Label */
22597|      0|        {
22598|      0|          mode_option = mode_compile((char const *)optarg, 7U);
22599|      0|        }
22600|      0|          if ((unsigned long)mode_option ==
22601|      0|              (unsigned long)((struct mode_change *)0)) {
22602|      0|            {
22603|      0|              tmp___38 = gettext("Invalid mode given on option");
22604|      0|              error(0, 0, (char const *)tmp___38);
22605|      0|              fatal_exit();
22606|      0|            }
22607|      0|          }
22608|      0|          if ((unsigned long)mode_option ==
22609|      0|              (unsigned long)((struct mode_change *)1)) {
22610|      0|            {
22611|      0|              xalloc_die();
22612|      0|            }
22613|      0|          }
22614|      0|          goto switch_break;
22615|      0|        case_143: /* CIL Label */
22616|      0|          exclude_options &= ~(1 << 30);
22617|      0|          goto switch_break;
22618|      0|        case_144: /* CIL Label */
22619|      0|          exclude_options &= ~(1 << 4);
22620|      0|          goto switch_break;
22621|      0|        case_145: /* CIL Label */
22622|      0|          old_files_option = (enum old_files)1;
22623|      0|          goto switch_break;
22624|      0|        case_146: /* CIL Label */
22625|      0|          exclude_options &= ~(1 << 28);
22626|      0|          goto switch_break;
22627|      0|        case_147: /* CIL Label */
22628|      0|          exclude_options |= 1;
22629|      0|          goto switch_break;
22630|      0|        case_148: /* CIL Label */
22631|      0|          filename_terminator = (char)'\000';
22632|      0|          goto switch_break;
22633|      0|        case_149: /* CIL Label */
22634|      0|          numeric_owner_option = (_Bool)1;
22635|      0|          goto switch_break;
22636|      0|        case_150: /* CIL Label */
22637|      0|          if (!optarg) {
22638|      0|            occurrence_option = (uintmax_t)1;
22639|      0|          } else {
22640|      0|            {
22641|      0|              tmp___41 =
22642|      0|                  xstrtoumax((char const *)optarg, (char **)0, 10, &u___1, "");
22643|      0|            }
22644|      0|            if ((unsigned int)tmp___41 == 0U) {
22645|      0|              occurrence_option = u___1;
22646|      0|            } else {
22647|      0|              {
22648|      0|                tmp___39 = gettext("Invalid number");
22649|      0|                tmp___40 = quotearg_colon((char const *)optarg);
22650|      0|                error(0, 0, "%s: %s", tmp___40, tmp___39);
22651|      0|                fatal_exit();
22652|      0|              }
22653|      0|            }
22654|      0|          }
22655|      0|          goto switch_break;
22656|      0|        case_151: /* CIL Label */
22657|      0|          old_files_option = (enum old_files)2;
22658|      0|          goto switch_break;
22659|      0|        case_152 : /* CIL Label */
22660|      0|        {
22661|      0|          tmp___45 = strlen((char const *)optarg);
22662|      0|        }
22663|      0|          if (tmp___45 < 32UL) {
22664|      0|            {
22665|      0|              tmp___46 = uname_to_uid((char const *)optarg, &owner_option);
22666|      0|            }
22667|      0|            if (!tmp___46) {
22668|      0|              goto _L___0;
22669|      0|            }
22670|      0|          } else {
22671|      0|          _L___0 : {
22672|      0|            tmp___44 =
22673|      0|                xstrtoumax((char const *)optarg, (char **)0, 10, &u___2, "");
22674|      0|          }
22675|      0|            if ((unsigned int)tmp___44 == 0U) {
22676|      0|              if (u___2 == (uintmax_t)((uid_t)u___2)) {
22677|      0|                owner_option = (uid_t)u___2;
22678|      0|              } else {
22679|      0|                {
22680|      0|                  tmp___42 = gettext("Invalid owner");
22681|      0|                  tmp___43 = quotearg_colon((char const *)optarg);
22682|      0|                  error(0, 0, "%s: %s", tmp___43, tmp___42);
22683|      0|                  fatal_exit();
22684|      0|                }
22685|      0|              }
22686|      0|            } else {
22687|      0|              {
22688|      0|                tmp___42 = gettext("Invalid owner");
22689|      0|                tmp___43 = quotearg_colon((char const *)optarg);
22690|      0|                error(0, 0, "%s: %s", tmp___43, tmp___42);
22691|      0|                fatal_exit();
22692|      0|              }
22693|      0|            }
22694|      0|          }
22695|      0|          goto switch_break;
22696|      0|        case_153 : /* CIL Label */
22697|      0|        {
22698|      0|          pax_option++;
22699|      0|          xheader_set_option(optarg);
22700|      0|        }
22701|      0|          goto switch_break;
22702|      0|        case_154 : /* CIL Label */
22703|      0|        {
22704|      0|          set_archive_format("posix");
22705|      0|        }
22706|      0|          goto switch_break;
22707|      0|        case_155: /* CIL Label */
22708|      0|          same_permissions_option = 1;
22709|      0|          same_order_option = (_Bool)1;
22710|      0|          goto switch_break;
22711|      0|        case_156 : /* CIL Label */
22712|      0|        {
22713|      0|          tmp___49 =
22714|      0|              xstrtoumax((char const *)optarg, (char **)0, 10, &u___3, "");
22715|      0|        }
22716|      0|          if ((unsigned int)tmp___49 == 0U) {
22717|      0|            if (!(u___3 == u___3)) {
22718|      0|              {
22719|      0|                tmp___47 = gettext("Invalid record size");
22720|      0|                tmp___48 = quotearg_colon((char const *)optarg);
22721|      0|                error(0, 0, "%s: %s", tmp___48, tmp___47);
22722|      0|                usage(2);
22723|      0|              }
22724|      0|            }
22725|      0|          } else {
22726|      0|            {
22727|      0|              tmp___47 = gettext("Invalid record size");
22728|      0|              tmp___48 = quotearg_colon((char const *)optarg);
22729|      0|              error(0, 0, "%s: %s", tmp___48, tmp___47);
22730|      0|              usage(2);
22731|      0|            }
22732|      0|          }
22733|      0|          record_size = u___3;
22734|      0|          if (record_size % 512UL != 0UL) {
22735|      0|            {
22736|      0|              tmp___50 = gettext("Record size must be a multiple of %d.");
22737|      0|              error(0, 0, (char const *)tmp___50, 512);
22738|      0|              usage(2);
22739|      0|            }
22740|      0|          }
22741|      0|          blocking_factor = (int)(record_size / 512UL);
22742|      0|          goto switch_break;
22743|      0|        case_157: /* CIL Label */
22744|      0|          recursive_unlink_option = (_Bool)1;
22745|      0|          goto switch_break;
22746|      0|        case_158: /* CIL Label */
22747|      0|          remove_files_option = (_Bool)1;
22748|      0|          goto switch_break;
22749|      0|        case_159: /* CIL Label */
22750|      0|          rmt_command_option = (char const *)optarg;
22751|      0|          goto switch_break;
22752|      0|        case_160: /* CIL Label */
22753|      0|          rsh_command_option = (char const *)optarg;
22754|      0|          goto switch_break;
22755|      0|        case_161 : /* CIL Label */
22756|      0|        {
22757|      0|          tmp___51 = archive_format_string((enum archive_format)6);
22758|      0|          printf((char const * /* __restrict  */) "--format=%s -f%s -b%d\n",
22759|      0|                 tmp___51, "-", 20);
22760|      0|          exit(0);
22761|      0|        }
22762|      0|        case_163 : /* CIL Label */
22763|      0|        {
22764|      0|          tmp___54 =
22765|      0|              xstrtoumax((char const *)optarg, (char **)0, 10, &u___4, "");
22766|      0|        }
22767|      0|          if ((unsigned int)tmp___54 == 0U) {
22768|      0|            if (!(u___4 == u___4)) {
22769|      0|              {
22770|      0|                tmp___52 = gettext("Invalid number of elements");
22771|      0|                tmp___53 = quotearg_colon((char const *)optarg);
22772|      0|                error(0, 0, "%s: %s", tmp___53, tmp___52);
22773|      0|                usage(2);
22774|      0|              }
22775|      0|            }
22776|      0|          } else {
22777|      0|            {
22778|      0|              tmp___52 = gettext("Invalid number of elements");
22779|      0|              tmp___53 = quotearg_colon((char const *)optarg);
22780|      0|              error(0, 0, "%s: %s", tmp___53, tmp___52);
22781|      0|              usage(2);
22782|      0|            }
22783|      0|          }
22784|      0|          strip_path_elements = u___4;
22785|      0|          goto switch_break;
22786|      0|        case_164: /* CIL Label */
22787|      0|          backup_option = (_Bool)1;
22788|      0|          backup_suffix_string = (char const *)optarg;
22789|      0|          goto switch_break;
22790|      0|        case_165: /* CIL Label */
22791|      0|          totals_option = (_Bool)1;
22792|      0|          goto switch_break;
22793|      0|        case_166 : /* CIL Label */
22794|      0|        {
22795|      0|          set_use_compress_program_option((char const *)optarg);
22796|      0|        }
22797|      0|          goto switch_break;
22798|      0|        case_168: /* CIL Label */
22799|      0|          volno_file_option = (char const *)optarg;
22800|      0|          goto switch_break;
22801|      0|        case_169: /* CIL Label */
22802|      0|          exclude_options |= 1 << 28;
22803|      0|          goto switch_break;
22804|      0|        case_170: /* CIL Label */
22805|      0|          exclude_options &= -2;
22806|      0|          goto switch_break;
22807|      0|        case_48:  /* CIL Label */
22808|      0|        case_49:  /* CIL Label */
22809|      0|        case_50:  /* CIL Label */
22810|      0|        case_51:  /* CIL Label */
22811|      0|        case_52:  /* CIL Label */
22812|      0|        case_53:  /* CIL Label */
22813|      0|        case_54:  /* CIL Label */
22814|      0|        case_55 : /* CIL Label */
22815|      0|        {
22816|      0|          tmp___55 =
22817|      0|              gettext("Options `-[0-7][lmh]\' not supported by *this* tar");
22818|      0|          error(0, 0, (char const *)tmp___55);
22819|      0|          usage(2);
22820|      0|        }
22821|      0|        switch_break: /* CIL Label */;
22822|      0|        }
22823|      0|      }
22824|      0|    while_break___1: /* CIL Label */;
22825|      0|    }
22826|      0|    if (o_option) {
22827|      0|      if ((unsigned int)subcommand_option == 3U) {
22828|      0|        {
22829|      0|          set_archive_format("v7");
22830|      0|        }
22831|      0|      } else {
22832|      0|        same_owner_option = 1;
22833|      0|      }
22834|      0|    }
22835|      0|    {
22836|      0|      while (1) {
22837|      0|      while_continue___2: /* CIL Label */;
22838|      0|        if (!(optind < argc)) {
22839|      0|          goto while_break___2;
22840|      0|        }
22841|      0|        {
22842|      0|          name_add((char const *)*(argv + optind));
22843|      0|          input_files++;
22844|      0|          optind++;
22845|      0|        }
22846|      0|      }
22847|      0|    while_break___2: /* CIL Label */;
22848|      0|    }
22849|      0|    if (show_version) {
22850|      0|      {
22851|      0|        printf((char const * /* __restrict  */) "tar (%s) %s\n%s\n", "GNU tar",
22852|      0|               "1.14", "Copyright (C) 2004 Free Software Foundation, Inc.");
22853|      0|        tmp___56 = gettext(
22854|      0|            "This program comes with NO WARRANTY, to the extent permitted by "
22855|      0|            "law.\nYou may redistribute it under the terms of the GNU General "
22856|      0|            "Public License;\nsee the file named COPYING for details.");
22857|      0|        puts((char const *)tmp___56);
22858|      0|        tmp___57 = gettext("Written by John Gilmore and Jay Fenlason.");
22859|      0|        puts((char const *)tmp___57);
22860|      0|        exit(0);
22861|      0|      }
22862|      0|    }
22863|      0|    if (show_help) {
22864|      0|      {
22865|      0|        usage(0);
22866|      0|      }
22867|      0|    }
22868|      0|    if ((unsigned int)archive_format == 0U) {
22869|      0|      if (pax_option) {
22870|      0|        archive_format = (enum archive_format)4;
22871|      0|      } else {
22872|      0|        archive_format = (enum archive_format)6;
22873|      0|      }
22874|      0|    }
22875|      0|    if (volume_label_option) {
22876|      0|      if ((unsigned int)subcommand_option == 3U) {
22877|      0|        {
22878|      0|          assert_format((unsigned int)((1 << 2) | (1 << 6)));
22879|      0|        }
22880|      0|      }
22881|      0|    }
22882|      0|    if (incremental_option) {
22883|      0|      {
22884|      0|        assert_format((unsigned int)((1 << 2) | (1 << 6)));
22885|      0|      }
22886|      0|    } else {
22887|      0|      if (multi_volume_option) {
22888|      0|        {
22889|      0|          assert_format((unsigned int)((1 << 2) | (1 << 6)));
22890|      0|        }
22891|      0|      }
22892|      0|    }
22893|      0|    if (sparse_option) {
22894|      0|      {
22895|      0|        assert_format((unsigned int)(((1 << 2) | (1 << 6)) | (1 << 4)));
22896|      0|      }
22897|      0|    }
22898|      0|    if (occurrence_option) {
22899|      0|      if (!input_files) {
22900|      0|        if (!files_from_option) {
22901|      0|          {
22902|      0|            tmp___58 =
22903|      0|                gettext("--occurrence is meaningless without a file list");
22904|      0|            error(0, 0, (char const *)tmp___58);
22905|      0|            usage(2);
22906|      0|          }
22907|      0|        }
22908|      0|      }
22909|      0|      if ((unsigned int)subcommand_option != 4U) {
22910|      0|        if ((unsigned int)subcommand_option != 5U) {
22911|      0|          if ((unsigned int)subcommand_option != 6U) {
22912|      0|            if ((unsigned int)subcommand_option != 7U) {
22913|      0|              {
22914|      0|                tmp___59 = gettext("--occurrence cannot be used in the "
22915|      0|                                   "requested operation mode");
22916|      0|                error(0, 0, (char const *)tmp___59);
22917|      0|                usage(2);
22918|      0|              }
22919|      0|            }
22920|      0|          }
22921|      0|        }
22922|      0|      }
22923|      0|    }
22924|      0|    if (archive_names == 0) {
22925|      0|      {
22926|      0|        archive_names = 1;
22927|      0|        tmp___60 = getenv("TAPE");
22928|      0|        *(archive_name_array + 0) = (char const *)tmp___60;
22929|      0|      }
22930|      0|      if (!*(archive_name_array + 0)) {
22931|      0|        *(archive_name_array + 0) = "-";
22932|      0|      }
22933|      0|    }
22934|      0|    if (archive_names > 1) {
22935|      0|      if (!multi_volume_option) {
22936|      0|        {
22937|      0|          tmp___61 = gettext("Multiple archive files require `-M\' option");
22938|      0|          error(0, 0, (char const *)tmp___61);
22939|      0|          usage(2);
22940|      0|        }
22941|      0|      }
22942|      0|    }
22943|      0|    if (listed_incremental_option) {
22944|      0|      if (0L <= newer_mtime_option.tv_nsec) {
22945|      0|        {
22946|      0|          tmp___62 =
22947|      0|              gettext("Cannot combine --listed-incremental with --newer");
22948|      0|          error(0, 0, (char const *)tmp___62);
22949|      0|          usage(2);
22950|      0|        }
22951|      0|      }
22952|      0|    }
22953|      0|    if (volume_label_option) {
22954|      0|      if (multi_volume_option) {
22955|      0|        tmp___79 =
22956|      0|            ((sizeof(" Volume ") - 1UL) +
22957|      0|             ((((sizeof(int) * 8UL - 1UL) * 302UL) / 1000UL + 1UL) + 1UL)) -
22958|      0|            1UL;
22959|      0|      } else {
22960|      0|        tmp___79 = 0UL;
22961|      0|      }
22962|      0|      {
22963|      0|        volume_label_max_len =
22964|      0|            (sizeof(current_header->header.name) - 1UL) - tmp___79;
22965|      0|        tmp___65 = strlen(volume_label_option);
22966|      0|      }
22967|      0|      if (volume_label_max_len < tmp___65) {
22968|      0|        {
22969|      0|          tmp___63 = quotearg_colon(volume_label_option);
22970|      0|          tmp___64 =
22971|      0|              ngettext("%s: Volume label is too long (limit is %lu byte)",
22972|      0|                       "%s: Volume label is too long (limit is %lu bytes)",
22973|      0|                       volume_label_max_len);
22974|      0|          error(0, 0, (char const *)tmp___64, tmp___63, volume_label_max_len);
22975|      0|          usage(2);
22976|      0|        }
22977|      0|      }
22978|      0|    }
22979|      0|    if (verify_option) {
22980|      0|      if (multi_volume_option) {
22981|      0|        {
22982|      0|          tmp___66 = gettext("Cannot verify multi-volume archives");
22983|      0|          error(0, 0, (char const *)tmp___66);
22984|      0|          usage(2);
22985|      0|        }
22986|      0|      }
22987|      0|      if (use_compress_program_option) {
22988|      0|        {
22989|      0|          tmp___67 = gettext("Cannot verify compressed archives");
22990|      0|          error(0, 0, (char const *)tmp___67);
22991|      0|          usage(2);
22992|      0|        }
22993|      0|      }
22994|      0|    }
22995|      0|    if (use_compress_program_option) {
22996|      0|      if (multi_volume_option) {
22997|      0|        {
22998|      0|          tmp___68 = gettext("Cannot use multi-volume compressed archives");
22999|      0|          error(0, 0, (char const *)tmp___68);
23000|      0|          usage(2);
23001|      0|        }
23002|      0|      }
23003|      0|      if ((unsigned int)subcommand_option == 8U) {
23004|      0|        {
23005|      0|          tmp___69 = gettext("Cannot update compressed archives");
23006|      0|          error(0, 0, (char const *)tmp___69);
23007|      0|          usage(2);
23008|      0|        }
23009|      0|      }
23010|      0|    }
23011|      0|    if (pax_option) {
23012|      0|      if ((unsigned int)archive_format != 4U) {
23013|      0|        if ((unsigned int)subcommand_option != 6U) {
23014|      0|          {
23015|      0|            tmp___70 =
23016|      0|                gettext("--pax-option can be used only on POSIX archives");
23017|      0|            error(0, 0, (char const *)tmp___70);
23018|      0|            usage(2);
23019|      0|          }
23020|      0|        } else {
23021|      0|          if ((unsigned int)subcommand_option != 5U) {
23022|      0|            {
23023|      0|              tmp___70 =
23024|      0|                  gettext("--pax-option can be used only on POSIX archives");
23025|      0|              error(0, 0, (char const *)tmp___70);
23026|      0|              usage(2);
23027|      0|            }
23028|      0|          } else {
23029|      0|            if ((unsigned int)subcommand_option != 7U) {
23030|      0|              {
23031|      0|                tmp___70 =
23032|      0|                    gettext("--pax-option can be used only on POSIX archives");
23033|      0|                error(0, 0, (char const *)tmp___70);
23034|      0|                usage(2);
23035|      0|              }
23036|      0|            }
23037|      0|          }
23038|      0|        }
23039|      0|      }
23040|      0|    }
23041|      0|    if (recursive_unlink_option) {
23042|      0|      old_files_option = (enum old_files)3;
23043|      0|    }
23044|      0|    if (utc_option) {
23045|      0|      verbose_option = 2;
23046|      0|    }
23047|      0|    if (!rmt_command_option) {
23048|      0|      rmt_command_option = "/usr/local/libexec/rmt";
23049|      0|    }
23050|      0|    {
23051|      0|      if ((unsigned int)subcommand_option == 3U) {
23052|      0|        goto case_3;
23053|      0|      }
23054|      0|      if ((unsigned int)subcommand_option == 6U) {
23055|      0|        goto case_6;
23056|      0|      }
23057|      0|      if ((unsigned int)subcommand_option == 7U) {
23058|      0|        goto case_6;
23059|      0|      }
23060|      0|      if ((unsigned int)subcommand_option == 5U) {
23061|      0|        goto case_6;
23062|      0|      }
23063|      0|      if ((unsigned int)subcommand_option == 2U) {
23064|      0|        goto case_2;
23065|      0|      }
23066|      0|      if ((unsigned int)subcommand_option == 8U) {
23067|      0|        goto case_2;
23068|      0|      }
23069|      0|      if ((unsigned int)subcommand_option == 1U) {
23070|      0|        goto case_2;
23071|      0|      }
23072|      0|      goto switch_default;
23073|      0|    case_3: /* CIL Label */
23074|      0|      if (input_files == 0) {
23075|      0|        if (!files_from_option) {
23076|      0|          {
23077|      0|            tmp___71 = gettext("Cowardly refusing to create an empty archive");
23078|      0|            error(0, 0, (char const *)tmp___71);
23079|      0|            usage(2);
23080|      0|          }
23081|      0|        }
23082|      0|      }
23083|      0|      goto switch_break___0;
23084|      0|    case_6: /* CIL Label */
23085|      0|    case_7: /* CIL Label */
23086|      0|    case_5: /* CIL Label */
23087|      0|      archive_name_cursor = archive_name_array;
23088|      0|      {
23089|      0|        while (1) {
23090|      0|        while_continue___3: /* CIL Label */;
23091|      0|          if (!((unsigned long)archive_name_cursor <
23092|      0|                (unsigned long)(archive_name_array + archive_names))) {
23093|      0|            goto while_break___3;
23094|      0|          }
23095|      0|          { tmp___72 = strcmp(*archive_name_cursor, "-"); }
23096|      0|          if (!tmp___72) {
23097|      0|            {
23098|      0|              request_stdin("-f");
23099|      0|            }
23100|      0|          }
23101|      0|          archive_name_cursor++;
23102|      0|        }
23103|      0|      while_break___3: /* CIL Label */;
23104|      0|      }
23105|      0|      goto switch_break___0;
23106|      0|    case_2:     /* CIL Label */
23107|      0|    case_8:     /* CIL Label */
23108|      0|    case_1___0: /* CIL Label */
23109|      0|      archive_name_cursor = archive_name_array;
23110|      0|      {
23111|      0|        while (1) {
23112|      0|        while_continue___4: /* CIL Label */;
23113|      0|          if (!((unsigned long)archive_name_cursor <
23114|      0|                (unsigned long)(archive_name_array + archive_names))) {
23115|      0|            goto while_break___4;
23116|      0|          }
23117|      0|          { tmp___74 = strcmp(*archive_name_cursor, "-"); }
23118|      0|          if (!tmp___74) {
23119|      0|            {
23120|      0|              tmp___73 =
23121|      0|                  gettext("Options `-Aru\' are incompatible with `-f -\'");
23122|      0|              error(0, 0, (char const *)tmp___73);
23123|      0|              usage(2);
23124|      0|            }
23125|      0|          }
23126|      0|          archive_name_cursor++;
23127|      0|        }
23128|      0|      while_break___4: /* CIL Label */;
23129|      0|      }
23130|      0|    switch_default: /* CIL Label */
23131|      0|      goto switch_break___0;
23132|      0|    switch_break___0: /* CIL Label */;
23133|      0|    }
23134|      0|    archive_name_cursor = archive_name_array;
23135|      0|    if (backup_suffix_string) {
23136|      0|      {
23137|      0|        tmp___75 = xstrdup(backup_suffix_string);
23138|      0|        simple_backup_suffix = (char const *)tmp___75;
23139|      0|      }
23140|      0|    }
23141|      0|    if (backup_option) {
23142|      0|      {
23143|      0|        backup_type = xget_version("--backup", version_control_string);
23144|      0|      }
23145|      0|    }
23146|      0|    if (verbose_option) {
23147|      0|      if (textual_date_option) {
23148|      0|        {
23149|      0|          tmp___76 = tartime(newer_mtime_option.tv_sec);
23150|      0|          treated_as = tmp___76;
23151|      0|          tmp___78 = strcmp(textual_date_option, treated_as);
23152|      0|        }
23153|      0|        if (tmp___78 != 0) {
23154|      0|          {
23155|      0|            tmp___77 = gettext("Treating date `%s\' as %s + %ld nanoseconds");
23156|      0|            error(0, 0, (char const *)tmp___77, textual_date_option, treated_as,
23157|      0|                  newer_mtime_option.tv_nsec);
23158|      0|          }
23159|      0|        }
23160|      0|      }
23161|      0|    }
23162|      0|    return;
23163|      0|  }
23164|      0|}
23165|      0|int main(int argc, char **argv) {
23166|      0|  int tmp;
23167|      0|  void *tmp___0;
23168|      0|  char *tmp___1;
23169|      0|  char *tmp___2;
23170|      0|  int tmp___3;
23171|      0|  int tmp___4;
23172|      0|  char *tmp___5;
23173|      0|  int tmp___6;
23174|      0|  int tmp___7;
23175|      0|  char *__cil_tmp12;
23176|      0|  char *__cil_tmp13;
23177|      0|  char *__cil_tmp14;
23178|      0|  char *__cil_tmp15;
23179|       |
23180|      0|  {
23181|      0|    { tmp = clock_gettime(0, &start_timespec); }
23182|      0|    if (tmp != 0) {
23183|      0|      {
23184|      0|        start_timespec.tv_sec = time((time_t *)0);
23185|      0|      }
23186|      0|    }
23187|      0|    {
23188|      0|      program_name = (char const *)*(argv + 0);
23189|      0|      setlocale(6, "");
23190|      0|      bindtextdomain("tar", "/usr/local/share/locale");
23191|      0|      textdomain("tar");
23192|      0|      exit_status = 0;
23193|      0|      filename_terminator = (char)'\n';
23194|      0|      set_quoting_style((struct quoting_options *)0, (enum quoting_style)4);
23195|      0|      allocated_archive_names = 10;
23196|      0|      tmp___0 = xmalloc(sizeof(char const *) *
23197|      0|                        (unsigned long)allocated_archive_names);
23198|      0|      archive_name_array = (char const **)tmp___0;
23199|      0|      archive_names = 0;
23200|      0|      signal(17, (void (*)(int))0);
23201|      0|      init_names();
23202|      0|      decode_options(argc, argv);
23203|      0|      name_init();
23204|      0|    }
23205|      0|    if (volno_file_option) {
23206|      0|      {
23207|      0|        init_volume_number();
23208|      0|      }
23209|      0|    }
23210|      0|    {
23211|      0|      if ((unsigned int)subcommand_option == 0U) {
23212|      0|        goto case_0;
23213|      0|      }
23214|      0|      if ((unsigned int)subcommand_option == 2U) {
23215|      0|        goto case_2;
23216|      0|      }
23217|      0|      if ((unsigned int)subcommand_option == 8U) {
23218|      0|        goto case_2;
23219|      0|      }
23220|      0|      if ((unsigned int)subcommand_option == 1U) {
23221|      0|        goto case_2;
23222|      0|      }
23223|      0|      if ((unsigned int)subcommand_option == 4U) {
23224|      0|        goto case_4;
23225|      0|      }
23226|      0|      if ((unsigned int)subcommand_option == 3U) {
23227|      0|        goto case_3;
23228|      0|      }
23229|      0|      if ((unsigned int)subcommand_option == 6U) {
23230|      0|        goto case_6;
23231|      0|      }
23232|      0|      if ((unsigned int)subcommand_option == 7U) {
23233|      0|        goto case_7;
23234|      0|      }
23235|      0|      if ((unsigned int)subcommand_option == 5U) {
23236|      0|        goto case_5;
23237|      0|      }
23238|      0|      goto switch_break;
23239|      0|    case_0 : /* CIL Label */
23240|      0|    {
23241|      0|      tmp___1 = gettext("You must specify one of the `-Acdtrux\' options");
23242|      0|      error(0, 0, (char const *)tmp___1);
23243|      0|      usage(2);
23244|      0|    }
23245|      0|    case_2:  /* CIL Label */
23246|      0|    case_8:  /* CIL Label */
23247|      0|    case_1 : /* CIL Label */
23248|      0|    {
23249|      0|      update_archive();
23250|      0|    }
23251|      0|      goto switch_break;
23252|      0|    case_4 : /* CIL Label */
23253|      0|    {
23254|      0|      delete_archive_members();
23255|      0|    }
23256|      0|      goto switch_break;
23257|      0|    case_3 : /* CIL Label */
23258|      0|    {
23259|      0|      create_archive();
23260|      0|      name_close();
23261|      0|    }
23262|      0|      if (totals_option) {
23263|      0|        {
23264|      0|          print_total_written();
23265|      0|        }
23266|      0|      }
23267|      0|      goto switch_break;
23268|      0|    case_6 : /* CIL Label */
23269|      0|    {
23270|      0|      extr_init();
23271|      0|      read_and(&extract_archive);
23272|      0|      extract_finish();
23273|      0|    }
23274|      0|      goto switch_break;
23275|      0|    case_7 : /* CIL Label */
23276|      0|    {
23277|      0|      read_and(&list_archive);
23278|      0|    }
23279|      0|      goto switch_break;
23280|      0|    case_5 : /* CIL Label */
23281|      0|    {
23282|      0|      diff_init();
23283|      0|      read_and(&diff_archive);
23284|      0|    }
23285|      0|      goto switch_break;
23286|      0|    switch_break: /* CIL Label */;
23287|      0|    }
23288|      0|    if (check_links_option) {
23289|      0|      {
23290|      0|        check_links();
23291|      0|      }
23292|      0|    }
23293|      0|    if (volno_file_option) {
23294|      0|      {
23295|      0|        closeout_volume_number();
23296|      0|      }
23297|      0|    }
23298|      0|    {
23299|      0|      free((void *)archive_name_array);
23300|      0|      name_term();
23301|      0|    }
23302|      0|    if ((unsigned long)stdlis != (unsigned long)stderr) {
23303|      0|      {
23304|      0|        tmp___3 = ferror_unlocked(stdlis);
23305|      0|      }
23306|      0|      if (tmp___3) {
23307|      0|        {
23308|      0|          tmp___2 = gettext("Error in writing to standard output");
23309|      0|          error(0, 0, (char const *)tmp___2);
23310|      0|          fatal_exit();
23311|      0|        }
23312|      0|      } else {
23313|      0|        { tmp___4 = fclose(stdlis); }
23314|      0|        if (tmp___4 != 0) {
23315|      0|          {
23316|      0|            tmp___2 = gettext("Error in writing to standard output");
23317|      0|            error(0, 0, (char const *)tmp___2);
23318|      0|            fatal_exit();
23319|      0|          }
23320|      0|        }
23321|      0|      }
23322|      0|    }
23323|      0|    if (exit_status == 2) {
23324|      0|      {
23325|      0|        tmp___5 = gettext("Error exit delayed from previous errors");
23326|      0|        error(0, 0, (char const *)tmp___5);
23327|      0|      }
23328|      0|    }
23329|      0|    { tmp___6 = ferror_unlocked(stderr); }
23330|      0|    if (tmp___6) {
23331|      0|      exit_status = 2;
23332|      0|    } else {
23333|      0|      { tmp___7 = fclose(stderr); }
23334|      0|      if (tmp___7 != 0) {
23335|      0|        exit_status = 2;
23336|      0|      }
23337|      0|    }
23338|      0|    return (exit_status);
23339|      0|  }
23340|      0|}
23341|      0|void tar_stat_init(struct tar_stat_info *st) {
23342|       |
23343|      0|  {
23344|      0|    { memset((void *)st, 0, sizeof(*st)); }
23345|      0|    return;
23346|      0|  }
23347|      0|}
23348|      0|void tar_stat_destroy(struct tar_stat_info *st) {
23349|       |
23350|      0|  {
23351|      0|    {
23352|      0|      free((void *)st->orig_file_name);
23353|      0|      free((void *)st->file_name);
23354|      0|      free((void *)st->link_name);
23355|      0|      free((void *)st->uname);
23356|      0|      free((void *)st->gname);
23357|      0|      free((void *)st->sparse_map);
23358|      0|      memset((void *)st, 0, sizeof(*st));
23359|      0|    }
23360|      0|    return;
23361|      0|  }
23362|      0|}
23363|       |/* #pragma merger("0","00f.update.o.i","") */
23364|      0|static void append_file(char *path) {
23365|      0|  int handle;
23366|      0|  int tmp;
23367|      0|  struct stat stat_data;
23368|      0|  off_t bytes_left;
23369|      0|  union block *start;
23370|      0|  union block *tmp___0;
23371|      0|  size_t buffer_size;
23372|      0|  size_t tmp___1;
23373|      0|  size_t status;
23374|      0|  char buf[(((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) + 1UL];
23375|      0|  char *tmp___2;
23376|      0|  char *tmp___3;
23377|      0|  char *tmp___4;
23378|      0|  int tmp___5;
23379|      0|  int tmp___6;
23380|      0|  void *__cil_tmp17;
23381|      0|  void *__cil_tmp18;
23382|       |
23383|      0|  {
23384|      0|    {
23385|      0|      tmp = open((char const *)path, 0);
23386|      0|      handle = tmp;
23387|      0|    }
23388|      0|    if (handle < 0) {
23389|      0|      {
23390|      0|        open_error((char const *)path);
23391|      0|      }
23392|      0|      return;
23393|      0|    }
23394|      0|    { tmp___5 = fstat(handle, &stat_data); }
23395|      0|    if (tmp___5 != 0) {
23396|      0|      {
23397|      0|        stat_error((char const *)path);
23398|      0|      }
23399|      0|    } else {
23400|      0|      bytes_left = stat_data.st_size;
23401|      0|      {
23402|      0|        while (1) {
23403|      0|        while_continue: /* CIL Label */;
23404|      0|          if (!(bytes_left > 0L)) {
23405|      0|            goto while_break;
23406|      0|          }
23407|      0|          {
23408|      0|            tmp___0 = find_next_block();
23409|      0|            start = tmp___0;
23410|      0|            tmp___1 = available_space_after(start);
23411|      0|            buffer_size = tmp___1;
23412|      0|          }
23413|      0|          if ((size_t)bytes_left < buffer_size) {
23414|      0|            buffer_size = (size_t)bytes_left;
23415|      0|            status = buffer_size % 512UL;
23416|      0|            if (status) {
23417|      0|              {
23418|      0|                memset((void *)(start->buffer + bytes_left), 0, 512UL - status);
23419|      0|              }
23420|      0|            }
23421|      0|          }
23422|      0|          { status = safe_read(handle, (void *)(start->buffer), buffer_size); }
23423|      0|          if (status == 0xffffffffffffffffUL) {
23424|      0|            {
23425|      0|              read_fatal_details((char const *)path,
23426|      0|                                 stat_data.st_size - bytes_left, buffer_size);
23427|      0|            }
23428|      0|          }
23429|      0|          if (status == 0UL) {
23430|      0|            {
23431|      0|              tmp___2 = stringify_uintmax_t_backwards(
23432|      0|                  (uintmax_t)bytes_left,
23433|      0|                  buf + ((((sizeof(uintmax_t) * 8UL) * 302UL) / 1000UL + 1UL) +
23434|      0|                         1UL));
23435|      0|              tmp___3 = quotearg_colon((char const *)path);
23436|      0|              tmp___4 = ngettext("%s: File shrank by %s byte",
23437|      0|                                 "%s: File shrank by %s bytes",
23438|      0|                                 (unsigned long)bytes_left);
23439|      0|              error(0, 0, (char const *)tmp___4, tmp___3, tmp___2);
23440|      0|              fatal_exit();
23441|      0|            }
23442|      0|          }
23443|      0|          {
23444|      0|            bytes_left = (off_t)((size_t)bytes_left - status);
23445|      0|            set_next_block_after(start + (status - 1UL) / 512UL);
23446|      0|          }
23447|      0|        }
23448|      0|      while_break: /* CIL Label */;
23449|      0|      }
23450|      0|    }
23451|      0|    { tmp___6 = close(handle); }
23452|      0|    if (tmp___6 != 0) {
23453|      0|      {
23454|      0|        close_error((char const *)path);
23455|      0|      }
23456|      0|    }
23457|      0|    return;
23458|      0|  }
23459|      0|}
23460|      0|void update_archive(void) {
23461|      0|  enum read_header previous_status;
23462|      0|  int found_end;
23463|      0|  enum read_header status;
23464|      0|  enum read_header tmp;
23465|      0|  struct name *name;
23466|      0|  struct stat s;
23467|      0|  enum archive_format unused;
23468|      0|  int tmp___0;
23469|      0|  char *tmp___1;
23470|      0|  char *tmp___2;
23471|      0|  char *path;
23472|      0|  _Bool tmp___3;
23473|      0|  int tmp___4;
23474|      0|  void *__cil_tmp14;
23475|      0|  char *__cil_tmp15;
23476|      0|  char *__cil_tmp16;
23477|      0|  char *__cil_tmp17;
23478|       |
23479|      0|  {
23480|      0|    {
23481|      0|      previous_status = (enum read_header)0;
23482|      0|      found_end = 0;
23483|      0|      name_gather();
23484|      0|      open_archive((enum access_mode)2);
23485|      0|      xheader_write_global();
23486|      0|    }
23487|      0|    {
23488|      0|      while (1) {
23489|      0|      while_continue: /* CIL Label */;
23490|      0|        if (!(!found_end)) {
23491|      0|          goto while_break;
23492|      0|        }
23493|      0|        {
23494|      0|          tmp = read_header((_Bool)0);
23495|      0|          status = tmp;
23496|      0|        }
23497|      0|        {
23498|      0|          if ((unsigned int)status == 0U) {
23499|      0|            goto case_0;
23500|      0|          }
23501|      0|          if ((unsigned int)status == 2U) {
23502|      0|            goto case_0;
23503|      0|          }
23504|      0|          if ((unsigned int)status == 1U) {
23505|      0|            goto case_1;
23506|      0|          }
23507|      0|          if ((unsigned int)status == 3U) {
23508|      0|            goto case_3;
23509|      0|          }
23510|      0|          if ((unsigned int)status == 4U) {
23511|      0|            goto case_4;
23512|      0|          }
23513|      0|          if ((unsigned int)status == 5U) {
23514|      0|            goto case_5;
23515|      0|          }
23516|      0|          goto switch_break;
23517|      0|        case_0:  /* CIL Label */
23518|      0|        case_2 : /* CIL Label */
23519|      0|        {
23520|      0|          abort();
23521|      0|        }
23522|      0|        case_1: /* CIL Label */
23523|      0|          if ((unsigned int)subcommand_option == 8U) {
23524|      0|            {
23525|      0|              name = name_scan((char const *)current_stat_info.file_name);
23526|      0|            }
23527|      0|            if ((unsigned long)name != (unsigned long)((void *)0)) {
23528|      0|              {
23529|      0|                decode_header(current_header, &current_stat_info, &unused, 0);
23530|      0|                chdir_do(name->change_dir);
23531|      0|                tmp___0 =
23532|      0|                    deref_stat(dereference_option,
23533|      0|                               (char const *)current_stat_info.file_name, &s);
23534|      0|              }
23535|      0|              if (tmp___0 == 0) {
23536|      0|                if (s.st_mtim.tv_sec <= current_stat_info.stat.st_mtim.tv_sec) {
23537|      0|                  {
23538|      0|                    add_avoided_name((char const *)current_stat_info.file_name);
23539|      0|                  }
23540|      0|                }
23541|      0|              }
23542|      0|            }
23543|      0|          }
23544|      0|          { skip_member(); }
23545|      0|          goto switch_break;
23546|      0|        case_3: /* CIL Label */
23547|      0|          current_block = current_header;
23548|      0|          found_end = 1;
23549|      0|          goto switch_break;
23550|      0|        case_4: /* CIL Label */
23551|      0|          found_end = 1;
23552|      0|          goto switch_break;
23553|      0|        case_5 : /* CIL Label */
23554|      0|        {
23555|      0|          set_next_block_after(current_header);
23556|      0|        }
23557|      0|          {
23558|      0|            if ((unsigned int)previous_status == 0U) {
23559|      0|              goto case_0___0;
23560|      0|            }
23561|      0|            if ((unsigned int)previous_status == 1U) {
23562|      0|              goto case_1___0;
23563|      0|            }
23564|      0|            if ((unsigned int)previous_status == 3U) {
23565|      0|              goto case_1___0;
23566|      0|            }
23567|      0|            if ((unsigned int)previous_status == 5U) {
23568|      0|              goto case_5___0;
23569|      0|            }
23570|      0|            if ((unsigned int)previous_status == 4U) {
23571|      0|              goto case_4___0;
23572|      0|            }
23573|      0|            if ((unsigned int)previous_status == 2U) {
23574|      0|              goto case_4___0;
23575|      0|            }
23576|      0|            goto switch_break___0;
23577|      0|          case_0___0 : /* CIL Label */
23578|      0|          {
23579|      0|            tmp___1 = gettext("This does not look like a tar archive");
23580|      0|            error(0, 0, (char const *)tmp___1);
23581|      0|          }
23582|      0|          case_1___0:  /* CIL Label */
23583|      0|          case_3___0 : /* CIL Label */
23584|      0|          {
23585|      0|            tmp___2 = gettext("Skipping to next header");
23586|      0|            error(0, 0, (char const *)tmp___2);
23587|      0|            exit_status = 2;
23588|      0|          }
23589|      0|          case_5___0: /* CIL Label */
23590|      0|            goto switch_break___0;
23591|      0|          case_4___0:  /* CIL Label */
23592|      0|          case_2___0 : /* CIL Label */
23593|      0|          {
23594|      0|            abort();
23595|      0|          }
23596|      0|          switch_break___0: /* CIL Label */;
23597|      0|          }
23598|      0|          goto switch_break;
23599|      0|        switch_break: /* CIL Label */;
23600|      0|        }
23601|      0|        previous_status = status;
23602|      0|      }
23603|      0|    while_break: /* CIL Label */;
23604|      0|    }
23605|      0|    {
23606|      0|      reset_eof();
23607|      0|      time_to_start_writing = (_Bool)1;
23608|      0|      output_start = current_block->buffer;
23609|      0|    }
23610|      0|    {
23611|      0|      while (1) {
23612|      0|      while_continue___0: /* CIL Label */;
23613|      0|        { path = name_from_list(); }
23614|      0|        if (!((unsigned long)path != (unsigned long)((void *)0))) {
23615|      0|          goto while_break___0;
23616|      0|        }
23617|      0|        { tmp___3 = excluded_name((char const *)path); }
23618|      0|        if (tmp___3) {
23619|      0|          goto while_continue___0;
23620|      0|        }
23621|      0|        if (interactive_option) {
23622|      0|          {
23623|      0|            tmp___4 = confirm("add", (char const *)path);
23624|      0|          }
23625|      0|          if (!tmp___4) {
23626|      0|            goto while_continue___0;
23627|      0|          }
23628|      0|        }
23629|      0|        if ((unsigned int)subcommand_option == 2U) {
23630|      0|          {
23631|      0|            append_file(path);
23632|      0|          }
23633|      0|        } else {
23634|      0|          { dump_file(path, 1, (dev_t)0); }
23635|      0|        }
23636|      0|      }
23637|      0|    while_break___0: /* CIL Label */;
23638|      0|    }
23639|      0|    {
23640|      0|      write_eot();
23641|      0|      close_archive();
23642|      0|      names_notfound();
23643|      0|    }
23644|      0|    return;
23645|      0|  }
23646|      0|}
23647|       |/* #pragma merger("0","010.utf8.o.i","") */
23648|       |static iconv_t conv_desc[2] = {(iconv_t)-1, (iconv_t)-1};
23649|      0|static iconv_t utf8_init(_Bool to_utf) {
23650|       |
23651|      0|  {
23652|      0|    if ((unsigned long)conv_desc[(int)to_utf] == (unsigned long)((iconv_t)-1)) {
23653|      0|      if (to_utf) {
23654|      0|        conv_desc[(int)to_utf] = (iconv_t)-1;
23655|      0|      } else {
23656|      0|        conv_desc[(int)to_utf] = (iconv_t)-1;
23657|      0|      }
23658|      0|    }
23659|      0|    return (conv_desc[(int)to_utf]);
23660|      0|  }
23661|      0|}
23662|      0|_Bool utf8_convert(_Bool to_utf, char const *input, char **output) {
23663|      0|  char *ib;
23664|      0|  char *ob;
23665|      0|  size_t inlen;
23666|      0|  size_t outlen;
23667|      0|  size_t rc___1;
23668|      0|  iconv_t cd;
23669|      0|  iconv_t tmp;
23670|      0|  size_t tmp___0;
23671|      0|  char *tmp___1;
23672|      0|  void *tmp___2;
23673|       |
23674|      0|  {
23675|      0|    {
23676|      0|      tmp = utf8_init(to_utf);
23677|      0|      cd = tmp;
23678|      0|    }
23679|      0|    if ((unsigned long)cd == (unsigned long)((iconv_t)0)) {
23680|      0|      {
23681|      0|        *output = xstrdup(input);
23682|      0|      }
23683|      0|      return ((_Bool)1);
23684|      0|    } else {
23685|      0|      if ((unsigned long)cd == (unsigned long)((iconv_t)-1)) {
23686|      0|        return ((_Bool)0);
23687|      0|      }
23688|      0|    }
23689|      0|    {
23690|      0|      tmp___0 = strlen(input);
23691|      0|      inlen = tmp___0 + 1UL;
23692|      0|      outlen = inlen * 16UL + 1UL;
23693|      0|      tmp___2 = xmalloc(outlen);
23694|      0|      tmp___1 = (char *)tmp___2;
23695|      0|      *output = tmp___1;
23696|      0|      ob = tmp___1;
23697|      0|      ib = (char *)input;
23698|      0|      rc___1 = (size_t)0;
23699|      0|      *ob = (char)0;
23700|      0|    }
23701|      0|    return ((_Bool)(rc___1 != 0xffffffffffffffffUL));
23702|      0|  }
23703|      0|}
23704|      0|_Bool string_ascii_p(char const *str) {
23705|      0|  unsigned char const *p;
23706|       |
23707|      0|  {
23708|      0|    p = (unsigned char const *)str;
23709|      0|    {
23710|      0|      while (1) {
23711|      0|      while_continue: /* CIL Label */;
23712|      0|        if (!*p) {
23713|      0|          goto while_break;
23714|      0|        }
23715|      0|        if ((int const) * p > 127) {
23716|      0|          return ((_Bool)0);
23717|      0|        }
23718|      0|        p++;
23719|      0|      }
23720|      0|    while_break: /* CIL Label */;
23721|      0|    }
23722|      0|    return ((_Bool)1);
23723|      0|  }
23724|      0|}
23725|       |/* #pragma merger("0","011.addext.o.i","") */
23726|       |extern
23727|       |    __attribute__((__nothrow__)) long(__attribute__((__nonnull__(1), __leaf__))
23728|       |                                      pathconf)(char const *__path, int __name);
23729|       |void addext(char *filename, char const *ext, int e);
23730|       |size_t base_len(char const *name);
23731|      0|void addext(char *filename, char const *ext, int e) {
23732|      0|  char *s;
23733|      0|  char *tmp;
23734|      0|  size_t slen;
23735|      0|  size_t tmp___0;
23736|      0|  size_t extlen;
23737|      0|  size_t tmp___1;
23738|      0|  size_t slen_max;
23739|      0|  long name_max;
23740|      0|  int *tmp___2;
23741|      0|  char c;
23742|      0|  long size;
23743|      0|  int *tmp___3;
23744|       |
23745|      0|  {
23746|      0|    {
23747|      0|      tmp = base_name((char const *)filename);
23748|      0|      s = tmp;
23749|      0|      tmp___0 = base_len((char const *)s);
23750|      0|      slen = tmp___0;
23751|      0|      tmp___1 = strlen(ext);
23752|      0|      extlen = tmp___1;
23753|      0|      slen_max = (size_t)255;
23754|      0|    }
23755|      0|    if (14UL < slen + extlen) {
23756|      0|      goto _L___3;
23757|      0|    } else {
23758|      0|      if (0) {
23759|      0|      _L___3 : /* CIL Label */
23760|      0|      {
23761|      0|        tmp___2 = __errno_location();
23762|      0|        *tmp___2 = 0;
23763|      0|      }
23764|      0|        if ((unsigned long)s == (unsigned long)filename) {
23765|      0|          {
23766|      0|            name_max = pathconf(".", 3);
23767|      0|          }
23768|      0|        } else {
23769|      0|          c = *s;
23770|      0|          if (!((int)c == 47)) {
23771|      0|            *s = (char)0;
23772|      0|          }
23773|      0|          {
23774|      0|            name_max = pathconf((char const *)filename, 3);
23775|      0|            *s = c;
23776|      0|          }
23777|      0|        }
23778|      0|        if (0L <= name_max) {
23779|      0|          goto _L;
23780|      0|        } else {
23781|      0|          { tmp___3 = __errno_location(); }
23782|      0|          if (*tmp___3 == 0) {
23783|      0|          _L:
23784|      0|            slen_max = (size_t)name_max;
23785|      0|            size = (long)slen_max;
23786|      0|            if (name_max != size) {
23787|      0|              slen_max = (size_t)-1;
23788|      0|            }
23789|      0|          }
23790|      0|        }
23791|      0|      }
23792|      0|    }
23793|      0|    if (slen + extlen <= slen_max) {
23794|      0|      {
23795|      0|        strcpy((char * /* __restrict  */)(s + slen),
23796|      0|               (char const * /* __restrict  */)ext);
23797|      0|      }
23798|      0|    } else {
23799|      0|      if (slen_max <= slen) {
23800|      0|        slen = slen_max - 1UL;
23801|      0|      }
23802|      0|      *(s + slen) = (char)e;
23803|      0|      *(s + (slen + 1UL)) = (char)0;
23804|      0|    }
23805|      0|    return;
23806|      0|  }
23807|      0|}
23808|       |/* #pragma merger("0","012.argmatch.o.i","") */
23809|       |int argmatch(char const *arg, char const *const *arglist, char const *vallist,
23810|       |             size_t valsize);
23811|       |void (*argmatch_die)(void);
23812|       |void argmatch_invalid(char const *context, char const *value, int problem);
23813|       |void argmatch_valid(char const *const *arglist, char const *vallist,
23814|       |                    size_t valsize);
23815|       |int __xargmatch_internal(char const *context, char const *arg,
23816|       |                         char const *const *arglist, char const *vallist,
23817|       |                         size_t valsize, void (*exit_fn)(void));
23818|       |int volatile exit_failure;
23819|      0|static void __argmatch_die(void) {
23820|       |
23821|      0|  {
23822|      0|    { exit((int)exit_failure); }
23823|      0|  }
23824|      0|}
23825|       |void (*argmatch_die)(void) = &__argmatch_die;
23826|       |int argmatch(char const *arg, char const *const *arglist, char const *vallist,
23827|      0|             size_t valsize) {
23828|      0|  int i;
23829|      0|  size_t arglen;
23830|      0|  int matchind;
23831|      0|  int ambiguous;
23832|      0|  int tmp;
23833|      0|  size_t tmp___0;
23834|      0|  int tmp___1;
23835|       |
23836|      0|  {
23837|      0|    {
23838|      0|      matchind = -1;
23839|      0|      ambiguous = 0;
23840|      0|      arglen = strlen(arg);
23841|      0|      i = 0;
23842|      0|    }
23843|      0|    {
23844|      0|      while (1) {
23845|      0|      while_continue: /* CIL Label */;
23846|      0|        if (!*(arglist + i)) {
23847|      0|          goto while_break;
23848|      0|        }
23849|      0|        { tmp___1 = strncmp((char const *)*(arglist + i), arg, arglen); }
23850|      0|        if (!tmp___1) {
23851|      0|          {
23852|      0|            tmp___0 = strlen((char const *)*(arglist + i));
23853|      0|          }
23854|      0|          if (tmp___0 == arglen) {
23855|      0|            return (i);
23856|      0|          } else {
23857|      0|            if (matchind == -1) {
23858|      0|              matchind = i;
23859|      0|            } else {
23860|      0|              if ((unsigned long)vallist == (unsigned long)((void *)0)) {
23861|      0|                ambiguous = 1;
23862|      0|              } else {
23863|      0|                {
23864|      0|                  tmp = memcmp(
23865|      0|                      (void const *)(vallist + valsize * (size_t)matchind),
23866|      0|                      (void const *)(vallist + valsize * (size_t)i), valsize);
23867|      0|                }
23868|      0|                if (tmp) {
23869|      0|                  ambiguous = 1;
23870|      0|                }
23871|      0|              }
23872|      0|            }
23873|      0|          }
23874|      0|        }
23875|      0|        i++;
23876|      0|      }
23877|      0|    while_break: /* CIL Label */;
23878|      0|    }
23879|      0|    if (ambiguous) {
23880|      0|      return (-2);
23881|      0|    } else {
23882|      0|      return (matchind);
23883|      0|    }
23884|      0|  }
23885|      0|}
23886|      0|void argmatch_invalid(char const *context, char const *value, int problem) {
23887|      0|  char const *format;
23888|      0|  char *tmp;
23889|      0|  char *tmp___0;
23890|      0|  char *tmp___1;
23891|      0|  char const *tmp___2;
23892|      0|  char *tmp___3;
23893|      0|  char *__cil_tmp10;
23894|      0|  char *__cil_tmp11;
23895|       |
23896|      0|  {
23897|      0|    if (problem == -1) {
23898|      0|      {
23899|      0|        tmp = gettext("invalid argument %s for %s");
23900|      0|        tmp___1 = tmp;
23901|      0|      }
23902|      0|    } else {
23903|      0|      {
23904|      0|        tmp___0 = gettext("ambiguous argument %s for %s");
23905|      0|        tmp___1 = tmp___0;
23906|      0|      }
23907|      0|    }
23908|      0|    {
23909|      0|      format = (char const *)tmp___1;
23910|      0|      tmp___2 = quote_n(1, context);
23911|      0|      tmp___3 = quotearg_n_style(0, (enum quoting_style)5, value);
23912|      0|      error(0, 0, format, tmp___3, tmp___2);
23913|      0|    }
23914|      0|    return;
23915|      0|  }
23916|      0|}
23917|       |void argmatch_valid(char const *const *arglist, char const *vallist,
23918|      0|                    size_t valsize) {
23919|      0|  int i;
23920|      0|  char const *last_val;
23921|      0|  char *tmp;
23922|      0|  int tmp___0;
23923|      0|  char *__cil_tmp8;
23924|       |
23925|      0|  {
23926|      0|    {
23927|      0|      last_val = (char const *)((void *)0);
23928|      0|      tmp = gettext("Valid arguments are:");
23929|      0|      fprintf((FILE * /* __restrict  */) stderr,
23930|      0|              (char const * /* __restrict  */)tmp);
23931|      0|      i = 0;
23932|      0|    }
23933|      0|    {
23934|      0|      while (1) {
23935|      0|      while_continue: /* CIL Label */;
23936|      0|        if (!*(arglist + i)) {
23937|      0|          goto while_break;
23938|      0|        }
23939|      0|        if (i == 0) {
23940|      0|          {
23941|      0|            fprintf((FILE * /* __restrict  */) stderr,
23942|      0|                    (char const * /* __restrict  */) "\n  - `%s\'",
23943|      0|                    *(arglist + i));
23944|      0|            last_val = vallist + valsize * (size_t)i;
23945|      0|          }
23946|      0|        } else {
23947|      0|          {
23948|      0|            tmp___0 =
23949|      0|                memcmp((void const *)last_val,
23950|      0|                       (void const *)(vallist + valsize * (size_t)i), valsize);
23951|      0|          }
23952|      0|          if (tmp___0) {
23953|      0|            {
23954|      0|              fprintf((FILE * /* __restrict  */) stderr,
23955|      0|                      (char const * /* __restrict  */) "\n  - `%s\'",
23956|      0|                      *(arglist + i));
23957|      0|              last_val = vallist + valsize * (size_t)i;
23958|      0|            }
23959|      0|          } else {
23960|      0|            {
23961|      0|              fprintf((FILE * /* __restrict  */) stderr,
23962|      0|                      (char const * /* __restrict  */) ", `%s\'",
23963|      0|                      *(arglist + i));
23964|      0|            }
23965|      0|          }
23966|      0|        }
23967|      0|        i++;
23968|      0|      }
23969|      0|    while_break: /* CIL Label */;
23970|      0|    }
23971|      0|    { putc_unlocked('\n', stderr); }
23972|      0|    return;
23973|      0|  }
23974|      0|}
23975|       |int __xargmatch_internal(char const *context, char const *arg,
23976|       |                         char const *const *arglist, char const *vallist,
23977|      0|                         size_t valsize, void (*exit_fn)(void)) {
23978|      0|  int res;
23979|      0|  int tmp;
23980|       |
23981|      0|  {
23982|      0|    {
23983|      0|      tmp = argmatch(arg, arglist, vallist, valsize);
23984|      0|      res = tmp;
23985|      0|    }
23986|      0|    if (res >= 0) {
23987|      0|      return (res);
23988|      0|    }
23989|      0|    {
23990|      0|      argmatch_invalid(context, arg, res);
23991|      0|      argmatch_valid(arglist, vallist, valsize);
23992|      0|      (*exit_fn)();
23993|      0|    }
23994|      0|    return (-1);
23995|      0|  }
23996|      0|}
23997|       |/* #pragma merger("0","013.backupfile.o.i","") */
23998|       |extern DIR *(__attribute__((__nonnull__(1))) opendir)(char const *__name);
23999|       |extern int(__attribute__((__nonnull__(1))) closedir)(DIR *__dirp);
24000|       |extern struct dirent *(__attribute__((__nonnull__(1))) readdir)(DIR *__dirp);
24001|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
24002|       |                                           malloc)(size_t __size)
24003|       |    __attribute__((__malloc__));
24004|       |enum backup_type get_version(char const *context, char const *version);
24005|       |size_t dir_len(char const *path);
24006|       |char const *simple_backup_suffix = "~";
24007|       |static int max_backup_version(char const *file, char const *dir);
24008|       |static int version_number(char const *base, char const *backup,
24009|       |                          size_t base_length);
24010|       |char *find_backup_file_name(char const *file,
24011|      0|                            enum backup_type backup_type___0) {
24012|      0|  size_t backup_suffix_size_max;
24013|      0|  size_t file_len;
24014|      0|  size_t tmp;
24015|      0|  size_t numbered_suffix_size_max;
24016|      0|  char *s;
24017|      0|  char const *suffix;
24018|      0|  size_t tmp___0;
24019|      0|  void *tmp___1;
24020|      0|  int highest_backup;
24021|      0|  size_t dirlen;
24022|      0|  size_t tmp___2;
24023|      0|  size_t tmp___3;
24024|      0|  char *tmp___4;
24025|      0|  char *numbered_suffix;
24026|      0|  char *__cil_tmp17;
24027|      0|  char *__cil_tmp18;
24028|       |
24029|      0|  {
24030|      0|    {
24031|      0|      tmp = strlen(file);
24032|      0|      file_len = tmp;
24033|      0|      numbered_suffix_size_max =
24034|      0|          (((sizeof(int) * 8UL - 1UL) * 302UL) / 1000UL + 2UL) + 4UL;
24035|      0|      suffix = simple_backup_suffix;
24036|      0|      tmp___0 = strlen(simple_backup_suffix);
24037|      0|      backup_suffix_size_max = tmp___0 + 1UL;
24038|      0|    }
24039|      0|    if (backup_suffix_size_max < numbered_suffix_size_max) {
24040|      0|      backup_suffix_size_max = numbered_suffix_size_max;
24041|      0|    }
24042|      0|    {
24043|      0|      tmp___1 = malloc(((file_len + 1UL) + backup_suffix_size_max) +
24044|      0|                       numbered_suffix_size_max);
24045|      0|      s = (char *)tmp___1;
24046|      0|    }
24047|      0|    if (s) {
24048|      0|      if ((unsigned int)backup_type___0 != 1U) {
24049|      0|        {
24050|      0|          tmp___2 = dir_len(file);
24051|      0|          dirlen = tmp___2;
24052|      0|          memcpy((void * /* __restrict  */)s,
24053|      0|                 (void const * /* __restrict  */)file, dirlen);
24054|      0|        }
24055|      0|        if (dirlen == 0UL) {
24056|      0|          tmp___3 = dirlen;
24057|      0|          dirlen++;
24058|      0|          *(s + tmp___3) = (char)'.';
24059|      0|        }
24060|      0|        {
24061|      0|          *(s + dirlen) = (char)'\000';
24062|      0|          tmp___4 = base_name(file);
24063|      0|          highest_backup =
24064|      0|              max_backup_version((char const *)tmp___4, (char const *)s);
24065|      0|        }
24066|      0|        if ((unsigned int)backup_type___0 == 2U) {
24067|      0|          if (!(highest_backup == 0)) {
24068|      0|            {
24069|      0|              numbered_suffix = s + (file_len + backup_suffix_size_max);
24070|      0|              sprintf((char * /* __restrict  */)numbered_suffix,
24071|      0|                      (char const * /* __restrict  */) ".~%d~",
24072|      0|                      highest_backup + 1);
24073|      0|              suffix = (char const *)numbered_suffix;
24074|      0|            }
24075|      0|          }
24076|      0|        } else {
24077|      0|          {
24078|      0|            numbered_suffix = s + (file_len + backup_suffix_size_max);
24079|      0|            sprintf((char * /* __restrict  */)numbered_suffix,
24080|      0|                    (char const * /* __restrict  */) ".~%d~",
24081|      0|                    highest_backup + 1);
24082|      0|            suffix = (char const *)numbered_suffix;
24083|      0|          }
24084|      0|        }
24085|      0|      }
24086|      0|      {
24087|      0|        strcpy((char * /* __restrict  */)s,
24088|      0|               (char const * /* __restrict  */)file);
24089|      0|        addext(s, suffix, '~');
24090|      0|      }
24091|      0|    }
24092|      0|    return (s);
24093|      0|  }
24094|      0|}
24095|      0|static int max_backup_version(char const *file, char const *dir) {
24096|      0|  DIR *dirp;
24097|      0|  struct dirent *dp;
24098|      0|  int highest_version;
24099|      0|  int this_version;
24100|      0|  size_t file_name_length;
24101|      0|  size_t tmp;
24102|      0|  int tmp___0;
24103|       |
24104|      0|  {
24105|      0|    { dirp = opendir(dir); }
24106|      0|    if (!dirp) {
24107|      0|      return (0);
24108|      0|    }
24109|      0|    {
24110|      0|      highest_version = 0;
24111|      0|      file_name_length = base_len(file);
24112|      0|    }
24113|      0|    {
24114|      0|      while (1) {
24115|      0|      while_continue: /* CIL Label */;
24116|      0|        { dp = readdir(dirp); }
24117|      0|        if (!((unsigned long)dp != (unsigned long)((struct dirent *)0))) {
24118|      0|          goto while_break;
24119|      0|        }
24120|      0|        if (!(dp->d_ino != 0UL)) {
24121|      0|          goto while_continue;
24122|      0|        } else {
24123|      0|          { tmp = strlen((char const *)(dp->d_name)); }
24124|      0|          if (tmp < file_name_length + 4UL) {
24125|      0|            goto while_continue;
24126|      0|          }
24127|      0|        }
24128|      0|        {
24129|      0|          this_version = version_number(file, (char const *)(dp->d_name),
24130|      0|                                        file_name_length);
24131|      0|        }
24132|      0|        if (this_version > highest_version) {
24133|      0|          highest_version = this_version;
24134|      0|        }
24135|      0|      }
24136|      0|    while_break: /* CIL Label */;
24137|      0|    }
24138|      0|    { tmp___0 = closedir(dirp); }
24139|      0|    if (tmp___0) {
24140|      0|      return (0);
24141|      0|    }
24142|      0|    return (highest_version);
24143|      0|  }
24144|      0|}
24145|       |static int version_number(char const *base, char const *backup,
24146|      0|                          size_t base_length) {
24147|      0|  int version;
24148|      0|  char const *p;
24149|      0|  int tmp;
24150|       |
24151|      0|  {
24152|      0|    {
24153|      0|      version = 0;
24154|      0|      tmp = strncmp(base, backup, base_length);
24155|      0|    }
24156|      0|    if (tmp == 0) {
24157|      0|      if ((int const) * (backup + base_length) == 46) {
24158|      0|        if ((int const) * (backup + (base_length + 1UL)) == 126) {
24159|      0|          p = backup + (base_length + 2UL);
24160|      0|          {
24161|      0|            while (1) {
24162|      0|            while_continue: /* CIL Label */;
24163|      0|              if (!((unsigned int)*p - 48U <= 9U)) {
24164|      0|                goto while_break;
24165|      0|              }
24166|      0|              version = (version * 10 + (int)*p) - 48;
24167|      0|              p++;
24168|      0|            }
24169|      0|          while_break: /* CIL Label */;
24170|      0|          }
24171|      0|          if ((int const) * (p + 0) != 126) {
24172|      0|            version = 0;
24173|      0|          } else {
24174|      0|            if (*(p + 1)) {
24175|      0|              version = 0;
24176|      0|            }
24177|      0|          }
24178|      0|        }
24179|      0|      }
24180|      0|    }
24181|      0|    return (version);
24182|      0|  }
24183|      0|}
24184|       |static char const *const backup_args[9] = {
24185|       |    (char const * /* const  */) "none",
24186|       |    (char const * /* const  */) "off",
24187|       |    (char const * /* const  */) "simple",
24188|       |    (char const * /* const  */) "never",
24189|       |    (char const * /* const  */) "existing",
24190|       |    (char const * /* const  */) "nil",
24191|       |    (char const * /* const  */) "numbered",
24192|       |    (char const * /* const  */) "t",
24193|       |    (char const * /* const  */)0};
24194|       |static enum backup_type const backup_types[8] = {
24195|       |    (enum backup_type const)0, (enum backup_type const)0,
24196|       |    (enum backup_type const)1, (enum backup_type const)1,
24197|       |    (enum backup_type const)2, (enum backup_type const)2,
24198|       |    (enum backup_type const)3, (enum backup_type const)3};
24199|      0|enum backup_type get_version(char const *context, char const *version) {
24200|      0|  int tmp;
24201|       |
24202|      0|  {
24203|      0|    if ((unsigned long)version == (unsigned long)((char const *)0)) {
24204|      0|      return ((enum backup_type)2);
24205|      0|    } else {
24206|      0|      if ((int const) * version == 0) {
24207|      0|        return ((enum backup_type)2);
24208|      0|      } else {
24209|      0|        {
24210|      0|          tmp = __xargmatch_internal(context, version, backup_args,
24211|      0|                                     (char const *)(backup_types),
24212|      0|                                     sizeof(backup_types[0]), argmatch_die);
24213|      0|        }
24214|      0|        return ((enum backup_type)backup_types[tmp]);
24215|      0|      }
24216|      0|    }
24217|      0|  }
24218|      0|}
24219|      0|enum backup_type xget_version(char const *context, char const *version) {
24220|      0|  enum backup_type tmp;
24221|      0|  char *tmp___0;
24222|      0|  enum backup_type tmp___1;
24223|      0|  char *__cil_tmp6;
24224|      0|  char *__cil_tmp7;
24225|      0|  char *__cil_tmp8;
24226|      0|  char *__cil_tmp9;
24227|       |
24228|      0|  {
24229|      0|    if (version) {
24230|      0|      if (*version) {
24231|      0|        {
24232|      0|          tmp = get_version(context, version);
24233|      0|        }
24234|      0|        return (tmp);
24235|      0|      } else {
24236|      0|        {
24237|      0|          tmp___0 = getenv("VERSION_CONTROL");
24238|      0|          tmp___1 = get_version("$VERSION_CONTROL", (char const *)tmp___0);
24239|      0|        }
24240|      0|        return (tmp___1);
24241|      0|      }
24242|      0|    } else {
24243|      0|      {
24244|      0|        tmp___0 = getenv("VERSION_CONTROL");
24245|      0|        tmp___1 = get_version("$VERSION_CONTROL", (char const *)tmp___0);
24246|      0|      }
24247|      0|      return (tmp___1);
24248|      0|    }
24249|      0|  }
24250|      0|}
24251|       |/* #pragma merger("0","014.basename.o.i","") */
24252|      0|char *base_name(char const *name) {
24253|      0|  char const *base;
24254|      0|  char const *p;
24255|       |
24256|      0|  {
24257|      0|    base = name + 0;
24258|      0|    p = base;
24259|      0|    {
24260|      0|      while (1) {
24261|      0|      while_continue: /* CIL Label */;
24262|      0|        if (!*p) {
24263|      0|          goto while_break;
24264|      0|        }
24265|      0|        if ((int const) * p == 47) {
24266|      0|          {
24267|      0|            while (1) {
24268|      0|            while_continue___0: /* CIL Label */;
24269|      0|              p++;
24270|      0|              if (!((int const) * p == 47)) {
24271|      0|                goto while_break___0;
24272|      0|              }
24273|      0|            }
24274|      0|          while_break___0: /* CIL Label */;
24275|      0|          }
24276|      0|          if (!*p) {
24277|      0|            if ((int const) * base == 47) {
24278|      0|              base = p - 1;
24279|      0|            }
24280|      0|            goto while_break;
24281|      0|          }
24282|      0|          base = p;
24283|      0|        }
24284|      0|        p++;
24285|      0|      }
24286|      0|    while_break: /* CIL Label */;
24287|      0|    }
24288|      0|    return ((char *)base);
24289|      0|  }
24290|      0|}
24291|      0|size_t base_len(char const *name) {
24292|      0|  size_t len;
24293|       |
24294|      0|  {
24295|      0|    { len = strlen(name); }
24296|      0|    {
24297|      0|      while (1) {
24298|      0|      while_continue: /* CIL Label */;
24299|      0|        if (1UL < len) {
24300|      0|          if (!((int const) * (name + (len - 1UL)) == 47)) {
24301|      0|            goto while_break;
24302|      0|          }
24303|      0|        } else {
24304|      0|          goto while_break;
24305|      0|        }
24306|      0|        goto __Cont;
24307|      0|      __Cont:
24308|      0|        len--;
24309|      0|      }
24310|      0|    while_break: /* CIL Label */;
24311|      0|    }
24312|      0|    return (len);
24313|      0|  }
24314|      0|}
24315|       |/* #pragma merger("0","015.dirname.o.i","") */
24316|      0|size_t dir_len(char const *path) {
24317|      0|  size_t prefix_length;
24318|      0|  size_t length;
24319|      0|  char *tmp;
24320|       |
24321|      0|  {
24322|      0|    {
24323|      0|      prefix_length = (size_t)0;
24324|      0|      tmp = base_name(path);
24325|      0|      length = (size_t)(tmp - (char *)path);
24326|      0|    }
24327|      0|    {
24328|      0|      while (1) {
24329|      0|      while_continue: /* CIL Label */;
24330|      0|        if (!(prefix_length < length)) {
24331|      0|          goto while_break;
24332|      0|        }
24333|      0|        if (!((int const) * (path + (length - 1UL)) == 47)) {
24334|      0|          return (length);
24335|      0|        }
24336|      0|        length--;
24337|      0|      }
24338|      0|    while_break: /* CIL Label */;
24339|      0|    }
24340|      0|    return (prefix_length +
24341|      0|            (size_t)((int const) * (path + prefix_length) == 47));
24342|      0|  }
24343|      0|}
24344|      0|char *dir_name(char const *path) {
24345|      0|  size_t length;
24346|      0|  size_t tmp;
24347|      0|  int append_dot;
24348|      0|  char *newpath;
24349|      0|  void *tmp___0;
24350|      0|  size_t tmp___1;
24351|       |
24352|      0|  {
24353|      0|    {
24354|      0|      tmp = dir_len(path);
24355|      0|      length = tmp;
24356|      0|      append_dot = length == 0UL;
24357|      0|      tmp___0 = xmalloc((length + (size_t)append_dot) + 1UL);
24358|      0|      newpath = (char *)tmp___0;
24359|      0|      memcpy((void * /* __restrict  */)newpath,
24360|      0|             (void const * /* __restrict  */)path, length);
24361|      0|    }
24362|      0|    if (append_dot) {
24363|      0|      tmp___1 = length;
24364|      0|      length++;
24365|      0|      *(newpath + tmp___1) = (char)'.';
24366|      0|    }
24367|      0|    *(newpath + length) = (char)0;
24368|      0|    return (newpath);
24369|      0|  }
24370|      0|}
24371|       |/* #pragma merger("0","016.exclude.o.i","") */
24372|       |extern __attribute__((__nothrow__)) int(
24373|       |    __attribute__((__nonnull__(1, 2), __leaf__))
24374|       |    strcasecmp)(char const *__s1, char const *__s2) __attribute__((__pure__));
24375|       |extern __attribute__((__nothrow__)) int(
24376|       |    __attribute__((__nonnull__(1, 2), __leaf__))
24377|       |    strncasecmp)(char const *__s1, char const *__s2, size_t __n)
24378|       |    __attribute__((__pure__));
24379|       |void *xzalloc(size_t s);
24380|       |void *x2realloc(void *p, size_t *pn);
24381|       |void *x2nrealloc(void *p, size_t *pn, size_t s);
24382|      0|__inline static _Bool is_space(unsigned char c) {
24383|      0|  unsigned short const **tmp;
24384|       |
24385|      0|  {
24386|      0|    { tmp = __ctype_b_loc(); }
24387|      0|    return ((_Bool)(((int const) * (*tmp + (int)c) & 8192) != 0));
24388|      0|  }
24389|      0|}
24390|      0|struct exclude *new_exclude(void) {
24391|      0|  struct exclude *tmp;
24392|      0|  void *tmp___0;
24393|       |
24394|      0|  {
24395|      0|    { tmp___0 = xzalloc(sizeof(*tmp)); }
24396|      0|    return ((struct exclude *)tmp___0);
24397|      0|  }
24398|      0|}
24399|       |static int fnmatch_no_wildcards(char const *pattern, char const *f,
24400|      0|                                int options) {
24401|      0|  int tmp;
24402|      0|  int tmp___0;
24403|      0|  int tmp___1;
24404|      0|  size_t patlen;
24405|      0|  size_t tmp___2;
24406|      0|  int r;
24407|      0|  int tmp___3;
24408|      0|  int tmp___4;
24409|      0|  int tmp___5;
24410|       |
24411|      0|  {
24412|      0|    if (!(options & (1 << 3))) {
24413|      0|      if (options & (1 << 4)) {
24414|      0|        {
24415|      0|          tmp = strcasecmp(pattern, f);
24416|      0|          tmp___1 = tmp;
24417|      0|        }
24418|      0|      } else {
24419|      0|        {
24420|      0|          tmp___0 = strcmp(pattern, f);
24421|      0|          tmp___1 = tmp___0;
24422|      0|        }
24423|      0|      }
24424|      0|      return (tmp___1);
24425|      0|    } else {
24426|      0|      {
24427|      0|        tmp___2 = strlen(pattern);
24428|      0|        patlen = tmp___2;
24429|      0|      }
24430|      0|      if (options & (1 << 4)) {
24431|      0|        {
24432|      0|          tmp___3 = strncasecmp(pattern, f, patlen);
24433|      0|          tmp___5 = tmp___3;
24434|      0|        }
24435|      0|      } else {
24436|      0|        {
24437|      0|          tmp___4 = strncmp(pattern, f, patlen);
24438|      0|          tmp___5 = tmp___4;
24439|      0|        }
24440|      0|      }
24441|      0|      r = tmp___5;
24442|      0|      if (!r) {
24443|      0|        r = (int)*(f + patlen);
24444|      0|        if (r == 47) {
24445|      0|          r = 0;
24446|      0|        }
24447|      0|      }
24448|      0|      return (r);
24449|      0|    }
24450|      0|  }
24451|      0|}
24452|      0|_Bool excluded_filename(struct exclude const *ex, char const *f) {
24453|      0|  size_t exclude_count;
24454|      0|  struct patopts const *exclude;
24455|      0|  size_t i;
24456|      0|  _Bool excluded___0;
24457|      0|  char const *pattern;
24458|      0|  int options;
24459|      0|  int (*matcher)(char const *, char const *, int);
24460|      0|  _Bool matched;
24461|      0|  int tmp;
24462|      0|  char const *p;
24463|      0|  int tmp___0;
24464|       |
24465|      0|  {
24466|      0|    exclude_count = (size_t)ex->exclude_count;
24467|      0|    if (exclude_count == 0UL) {
24468|      0|      return ((_Bool)0);
24469|      0|    } else {
24470|      0|      exclude = (struct patopts const *)ex->exclude;
24471|      0|      excluded___0 =
24472|      0|          (_Bool)(!(!((exclude + 0)->options & (int const)(1 << 29))));
24473|      0|      i = (size_t)0;
24474|      0|      {
24475|      0|        while (1) {
24476|      0|        while_continue: /* CIL Label */;
24477|      0|          if (!(i < exclude_count)) {
24478|      0|            goto while_break;
24479|      0|          }
24480|      0|          pattern = (char const *)(exclude + i)->pattern;
24481|      0|          options = (int)(exclude + i)->options;
24482|      0|          if ((int)excluded___0 == !(!(options & (1 << 29)))) {
24483|      0|            if (options & (1 << 28)) {
24484|      0|              matcher = &fnmatch;
24485|      0|            } else {
24486|      0|              matcher = &fnmatch_no_wildcards;
24487|      0|            }
24488|      0|            {
24489|      0|              tmp = (*matcher)(pattern, f, options);
24490|      0|              matched = (_Bool)(tmp == 0);
24491|      0|            }
24492|      0|            if (!(options & (1 << 30))) {
24493|      0|              p = f;
24494|      0|              {
24495|      0|                while (1) {
24496|      0|                while_continue___0: /* CIL Label */;
24497|      0|                  if (*p) {
24498|      0|                    if (!(!matched)) {
24499|      0|                      goto while_break___0;
24500|      0|                    }
24501|      0|                  } else {
24502|      0|                    goto while_break___0;
24503|      0|                  }
24504|      0|                  if ((int const) * p == 47) {
24505|      0|                    if ((int const) * (p + 1) != 47) {
24506|      0|                      {
24507|      0|                        tmp___0 = (*matcher)(pattern, p + 1, options);
24508|      0|                        matched = (_Bool)(tmp___0 == 0);
24509|      0|                      }
24510|      0|                    }
24511|      0|                  }
24512|      0|                  p++;
24513|      0|                }
24514|      0|              while_break___0: /* CIL Label */;
24515|      0|              }
24516|      0|            }
24517|      0|            excluded___0 = (_Bool)((int)excluded___0 ^ (int)matched);
24518|      0|          }
24519|      0|          i++;
24520|      0|        }
24521|      0|      while_break: /* CIL Label */;
24522|      0|      }
24523|      0|      return (excluded___0);
24524|      0|    }
24525|      0|  }
24526|      0|}
24527|      0|void add_exclude(struct exclude *ex, char const *pattern, int options) {
24528|      0|  struct patopts *patopts;
24529|      0|  void *tmp;
24530|      0|  size_t tmp___0;
24531|       |
24532|      0|  {
24533|      0|    if (ex->exclude_count == ex->exclude_alloc) {
24534|      0|      {
24535|      0|        tmp = x2nrealloc((void *)ex->exclude, &ex->exclude_alloc,
24536|      0|                         sizeof(*(ex->exclude)));
24537|      0|        ex->exclude = (struct patopts *)tmp;
24538|      0|      }
24539|      0|    }
24540|      0|    tmp___0 = ex->exclude_count;
24541|      0|    (ex->exclude_count)++;
24542|      0|    patopts = ex->exclude + tmp___0;
24543|      0|    patopts->pattern = pattern;
24544|      0|    patopts->options = options;
24545|      0|    return;
24546|      0|  }
24547|      0|}
24548|       |int add_exclude_file(void (*add_func)(struct exclude *, char const *, int),
24549|       |                     struct exclude *ex, char const *filename, int options,
24550|      0|                     char line_end) {
24551|      0|  _Bool use_stdin;
24552|      0|  FILE *in;
24553|      0|  char *buf;
24554|      0|  char *p;
24555|      0|  char const *pattern;
24556|      0|  char const *lim;
24557|      0|  size_t buf_alloc;
24558|      0|  size_t buf_count;
24559|      0|  int c;
24560|      0|  int e;
24561|      0|  void *tmp;
24562|      0|  size_t tmp___0;
24563|      0|  int *tmp___1;
24564|      0|  int tmp___2;
24565|      0|  int *tmp___3;
24566|      0|  int tmp___4;
24567|      0|  void *tmp___5;
24568|      0|  char *pattern_end;
24569|      0|  _Bool tmp___6;
24570|      0|  _Bool tmp___7;
24571|      0|  int *tmp___8;
24572|      0|  int tmp___9;
24573|      0|  int tmp___10;
24574|      0|  int tmp___11;
24575|       |
24576|      0|  {
24577|      0|    if ((int const) * (filename + 0) == 45) {
24578|      0|      if (!*(filename + 1)) {
24579|      0|        tmp___9 = 1;
24580|      0|      } else {
24581|      0|        tmp___9 = 0;
24582|      0|      }
24583|      0|    } else {
24584|      0|      tmp___9 = 0;
24585|      0|    }
24586|      0|    use_stdin = (_Bool)tmp___9;
24587|      0|    buf = (char *)((void *)0);
24588|      0|    buf_alloc = (size_t)0;
24589|      0|    buf_count = (size_t)0;
24590|      0|    e = 0;
24591|      0|    if (use_stdin) {
24592|      0|      in = stdin;
24593|      0|    } else {
24594|      0|      {
24595|      0|        in = fopen((char const * /* __restrict  */)filename,
24596|      0|                   (char const * /* __restrict  */) "r");
24597|      0|      }
24598|      0|      if (!in) {
24599|      0|        return (-1);
24600|      0|      }
24601|      0|    }
24602|      0|    {
24603|      0|      while (1) {
24604|      0|      while_continue: /* CIL Label */;
24605|      0|        { c = getc_unlocked(in); }
24606|      0|        if (!(c != -1)) {
24607|      0|          goto while_break;
24608|      0|        }
24609|      0|        if (buf_count == buf_alloc) {
24610|      0|          {
24611|      0|            tmp = x2realloc((void *)buf, &buf_alloc);
24612|      0|            buf = (char *)tmp;
24613|      0|          }
24614|      0|        }
24615|      0|        tmp___0 = buf_count;
24616|      0|        buf_count++;
24617|      0|        *(buf + tmp___0) = (char)c;
24618|      0|      }
24619|      0|    while_break: /* CIL Label */;
24620|      0|    }
24621|      0|    { tmp___2 = ferror_unlocked(in); }
24622|      0|    if (tmp___2) {
24623|      0|      {
24624|      0|        tmp___1 = __errno_location();
24625|      0|        e = *tmp___1;
24626|      0|      }
24627|      0|    }
24628|      0|    if (!use_stdin) {
24629|      0|      {
24630|      0|        tmp___4 = fclose(in);
24631|      0|      }
24632|      0|      if (tmp___4 != 0) {
24633|      0|        {
24634|      0|          tmp___3 = __errno_location();
24635|      0|          e = *tmp___3;
24636|      0|        }
24637|      0|      }
24638|      0|    }
24639|      0|    {
24640|      0|      tmp___5 = xrealloc((void *)buf, buf_count + 1UL);
24641|      0|      buf = (char *)tmp___5;
24642|      0|      *(buf + buf_count) = line_end;
24643|      0|    }
24644|      0|    if (buf_count == 0UL) {
24645|      0|      tmp___10 = 0;
24646|      0|    } else {
24647|      0|      if ((int)*(buf + (buf_count - 1UL)) == (int)line_end) {
24648|      0|        tmp___10 = 0;
24649|      0|      } else {
24650|      0|        tmp___10 = 1;
24651|      0|      }
24652|      0|    }
24653|      0|    lim = (char const *)((buf + buf_count) + tmp___10);
24654|      0|    pattern = (char const *)buf;
24655|      0|    p = buf;
24656|      0|    {
24657|      0|      while (1) {
24658|      0|      while_continue___0: /* CIL Label */;
24659|      0|        if (!((unsigned long)p < (unsigned long)lim)) {
24660|      0|          goto while_break___0;
24661|      0|        }
24662|      0|        if ((int)*p == (int)line_end) {
24663|      0|          {
24664|      0|            pattern_end = p;
24665|      0|            tmp___7 = is_space((unsigned char)line_end);
24666|      0|          }
24667|      0|          if (tmp___7) {
24668|      0|            {
24669|      0|              while (1) {
24670|      0|              while_continue___1: /* CIL Label */;
24671|      0|                if ((unsigned long)pattern_end == (unsigned long)pattern) {
24672|      0|                  goto next_pattern;
24673|      0|                } else {
24674|      0|                  { tmp___6 = is_space((unsigned char)*(pattern_end + -1)); }
24675|      0|                  if (!tmp___6) {
24676|      0|                    goto while_break___1;
24677|      0|                  }
24678|      0|                }
24679|      0|                pattern_end--;
24680|      0|              }
24681|      0|            while_break___1: /* CIL Label */;
24682|      0|            }
24683|      0|          }
24684|      0|          {
24685|      0|            *pattern_end = (char)'\000';
24686|      0|            (*add_func)(ex, pattern, options);
24687|      0|          }
24688|      0|        next_pattern:
24689|      0|          pattern = (char const *)(p + 1);
24690|      0|        }
24691|      0|        p++;
24692|      0|      }
24693|      0|    while_break___0: /* CIL Label */;
24694|      0|    }
24695|      0|    {
24696|      0|      tmp___8 = __errno_location();
24697|      0|      *tmp___8 = e;
24698|      0|    }
24699|      0|    if (e) {
24700|      0|      tmp___11 = -1;
24701|      0|    } else {
24702|      0|      tmp___11 = 0;
24703|      0|    }
24704|      0|    return (tmp___11);
24705|      0|  }
24706|      0|}
24707|       |/* #pragma merger("0","017.exitfail.o.i","") */
24708|       |int volatile exit_failure = (int volatile)1;
24709|       |/* #pragma merger("0","018.full-write.o.i","") */
24710|       |size_t safe_write(int fd, void const *buf, size_t count);
24711|      0|size_t full_write(int fd, void const *buf, size_t count) {
24712|      0|  size_t total;
24713|      0|  char const *ptr;
24714|      0|  size_t n_rw;
24715|      0|  size_t tmp;
24716|      0|  int *tmp___0;
24717|       |
24718|      0|  {
24719|      0|    total = (size_t)0;
24720|      0|    ptr = (char const *)buf;
24721|      0|    {
24722|      0|      while (1) {
24723|      0|      while_continue: /* CIL Label */;
24724|      0|        if (!(count > 0UL)) {
24725|      0|          goto while_break;
24726|      0|        }
24727|      0|        {
24728|      0|          tmp = safe_write(fd, (void const *)ptr, count);
24729|      0|          n_rw = tmp;
24730|      0|        }
24731|      0|        if (n_rw == 0xffffffffffffffffUL) {
24732|      0|          goto while_break;
24733|      0|        }
24734|      0|        if (n_rw == 0UL) {
24735|      0|          {
24736|      0|            tmp___0 = __errno_location();
24737|      0|            *tmp___0 = 28;
24738|      0|          }
24739|      0|          goto while_break;
24740|      0|        }
24741|      0|        total += n_rw;
24742|      0|        ptr += n_rw;
24743|      0|        count -= n_rw;
24744|      0|      }
24745|      0|    while_break: /* CIL Label */;
24746|      0|    }
24747|      0|    return (total);
24748|      0|  }
24749|      0|}
24750|       |/* #pragma merger("0","019.getdate.o.i","") */
24751|       |__attribute__((__nothrow__))
24752|       |time_t(__attribute__((__leaf__)) rpl_mktime)(struct tm *tp);
24753|       |int gettime(struct timespec *ts);
24754|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
24755|       |                                        toupper)(int __c);
24756|       |static int yyerror(char *s __attribute__((__unused__)));
24757|       |static int yylex(YYSTYPE *lvalp, parser_control *pc);
24758|       |static char const yytranslate[275] = {
24759|       |    (char const)0,  (char const)2,  (char const)2,  (char const)2,
24760|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24761|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24762|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24763|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24764|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24765|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24766|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24767|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24768|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24769|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24770|       |    (char const)23, (char const)2,  (char const)2,  (char const)24,
24771|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24772|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24773|       |    (char const)2,  (char const)2,  (char const)22, (char const)2,
24774|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24775|       |    (char const)21, (char const)2,  (char const)2,  (char const)2,
24776|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24777|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24778|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24779|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24780|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24781|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24782|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24783|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24784|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24785|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24786|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24787|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24788|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24789|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24790|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24791|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24792|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24793|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24794|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24795|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24796|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24797|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24798|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24799|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24800|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24801|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24802|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24803|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24804|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24805|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24806|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24807|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24808|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24809|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24810|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24811|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24812|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24813|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24814|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24815|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24816|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24817|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24818|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24819|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24820|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24821|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24822|       |    (char const)2,  (char const)2,  (char const)2,  (char const)2,
24823|       |    (char const)1,  (char const)3,  (char const)4,  (char const)5,
24824|       |    (char const)6,  (char const)7,  (char const)8,  (char const)9,
24825|       |    (char const)10, (char const)11, (char const)12, (char const)13,
24826|       |    (char const)14, (char const)15, (char const)16, (char const)17,
24827|       |    (char const)18, (char const)19, (char const)20};
24828|       |static short const yyr1[66] = {
24829|       |    (short const)0,  (short const)25, (short const)25, (short const)26,
24830|       |    (short const)27, (short const)27, (short const)28, (short const)28,
24831|       |    (short const)28, (short const)28, (short const)28, (short const)28,
24832|       |    (short const)28, (short const)29, (short const)29, (short const)29,
24833|       |    (short const)29, (short const)29, (short const)30, (short const)30,
24834|       |    (short const)31, (short const)31, (short const)31, (short const)32,
24835|       |    (short const)32, (short const)32, (short const)33, (short const)33,
24836|       |    (short const)33, (short const)33, (short const)33, (short const)33,
24837|       |    (short const)33, (short const)33, (short const)33, (short const)34,
24838|       |    (short const)34, (short const)35, (short const)35, (short const)35,
24839|       |    (short const)35, (short const)35, (short const)35, (short const)35,
24840|       |    (short const)35, (short const)35, (short const)35, (short const)35,
24841|       |    (short const)35, (short const)35, (short const)35, (short const)35,
24842|       |    (short const)35, (short const)35, (short const)35, (short const)35,
24843|       |    (short const)35, (short const)36, (short const)36, (short const)37,
24844|       |    (short const)37, (short const)38, (short const)38, (short const)39,
24845|       |    (short const)40, (short const)40};
24846|       |static short const yyr2[66] = {
24847|       |    (short const)0, (short const)1, (short const)1, (short const)2,
24848|       |    (short const)0, (short const)2, (short const)1, (short const)1,
24849|       |    (short const)1, (short const)1, (short const)1, (short const)1,
24850|       |    (short const)1, (short const)2, (short const)4, (short const)4,
24851|       |    (short const)6, (short const)6, (short const)1, (short const)2,
24852|       |    (short const)1, (short const)1, (short const)2, (short const)1,
24853|       |    (short const)2, (short const)2, (short const)3, (short const)5,
24854|       |    (short const)3, (short const)3, (short const)3, (short const)2,
24855|       |    (short const)4, (short const)2, (short const)3, (short const)2,
24856|       |    (short const)1, (short const)2, (short const)2, (short const)1,
24857|       |    (short const)2, (short const)2, (short const)1, (short const)2,
24858|       |    (short const)2, (short const)1, (short const)2, (short const)2,
24859|       |    (short const)1, (short const)2, (short const)2, (short const)1,
24860|       |    (short const)2, (short const)2, (short const)2, (short const)2,
24861|       |    (short const)1, (short const)1, (short const)1, (short const)1,
24862|       |    (short const)1, (short const)1, (short const)1, (short const)1,
24863|       |    (short const)0, (short const)1};
24864|       |static short const yydefact[81] = {
24865|       |    (short const)4,  (short const)0,  (short const)1,  (short const)2,
24866|       |    (short const)60, (short const)62, (short const)59, (short const)61,
24867|       |    (short const)3,  (short const)57, (short const)58, (short const)23,
24868|       |    (short const)45, (short const)21, (short const)48, (short const)18,
24869|       |    (short const)51, (short const)0,  (short const)42, (short const)56,
24870|       |    (short const)39, (short const)20, (short const)0,  (short const)63,
24871|       |    (short const)0,  (short const)0,  (short const)5,  (short const)6,
24872|       |    (short const)7,  (short const)8,  (short const)10, (short const)9,
24873|       |    (short const)11, (short const)36, (short const)12, (short const)24,
24874|       |    (short const)19, (short const)0,  (short const)31, (short const)22,
24875|       |    (short const)44, (short const)47, (short const)50, (short const)41,
24876|       |    (short const)53, (short const)38, (short const)25, (short const)43,
24877|       |    (short const)46, (short const)13, (short const)49, (short const)33,
24878|       |    (short const)40, (short const)52, (short const)37, (short const)0,
24879|       |    (short const)0,  (short const)0,  (short const)54, (short const)55,
24880|       |    (short const)35, (short const)30, (short const)0,  (short const)29,
24881|       |    (short const)34, (short const)28, (short const)64, (short const)26,
24882|       |    (short const)32, (short const)65, (short const)15, (short const)0,
24883|       |    (short const)14, (short const)0,  (short const)64, (short const)27,
24884|       |    (short const)17, (short const)16, (short const)0,  (short const)0,
24885|       |    (short const)0};
24886|       |static short const yydefgoto[16] = {
24887|       |    (short const)78, (short const)2,  (short const)3,  (short const)26,
24888|       |    (short const)27, (short const)28, (short const)29, (short const)30,
24889|       |    (short const)31, (short const)32, (short const)33, (short const)8,
24890|       |    (short const)9,  (short const)10, (short const)34, (short const)72};
24891|       |static short const yypact[81] = {
24892|       |    (short const) - 19,    (short const)29,       (short const) - 32768,
24893|       |    (short const)15,       (short const) - 32768, (short const) - 32768,
24894|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24895|       |    (short const) - 32768, (short const) - 32768, (short const) - 8,
24896|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24897|       |    (short const)36,       (short const) - 32768, (short const) - 4,
24898|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24899|       |    (short const)38,       (short const)30,       (short const) - 5,
24900|       |    (short const)39,       (short const)40,       (short const) - 32768,
24901|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24902|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24903|       |    (short const)49,       (short const) - 32768, (short const) - 32768,
24904|       |    (short const) - 32768, (short const)41,       (short const)32,
24905|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24906|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24907|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24908|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24909|       |    (short const)33,       (short const) - 32768, (short const) - 32768,
24910|       |    (short const) - 32768, (short const)42,       (short const)43,
24911|       |    (short const)44,       (short const) - 32768, (short const) - 32768,
24912|       |    (short const) - 32768, (short const) - 32768, (short const)45,
24913|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24914|       |    (short const) - 6,     (short const)46,       (short const) - 32768,
24915|       |    (short const) - 32768, (short const) - 32768, (short const)19,
24916|       |    (short const) - 32768, (short const)47,       (short const)8,
24917|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24918|       |    (short const)56,       (short const)57,       (short const) - 32768};
24919|       |static short const yypgoto[16] = {
24920|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24921|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24922|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24923|       |    (short const) - 32768, (short const) - 32768, (short const) - 32768,
24924|       |    (short const) - 32768, (short const) - 11,    (short const) - 32768,
24925|       |    (short const) - 10};
24926|       |static short const yytable[71] = {
24927|       |    (short const)46, (short const)47, (short const)1,  (short const)48,
24928|       |    (short const)69, (short const)49, (short const)50, (short const)51,
24929|       |    (short const)52, (short const)53, (short const)54, (short const)70,
24930|       |    (short const)55, (short const)37, (short const)38, (short const)35,
24931|       |    (short const)71, (short const)56, (short const)69, (short const)57,
24932|       |    (short const)11, (short const)12, (short const)13, (short const)14,
24933|       |    (short const)15, (short const)76, (short const)16, (short const)17,
24934|       |    (short const)18, (short const)19, (short const)20, (short const)21,
24935|       |    (short const)22, (short const)23, (short const)24, (short const)25,
24936|       |    (short const)40, (short const)5,  (short const)41, (short const)7,
24937|       |    (short const)36, (short const)42, (short const)39, (short const)43,
24938|       |    (short const)44, (short const)45, (short const)4,  (short const)5,
24939|       |    (short const)6,  (short const)7,  (short const)63, (short const)64,
24940|       |    (short const)60, (short const)58, (short const)59, (short const)62,
24941|       |    (short const)79, (short const)80, (short const)61, (short const)65,
24942|       |    (short const)74, (short const)66, (short const)67, (short const)68,
24943|       |    (short const)77, (short const)75, (short const)0,  (short const)0,
24944|       |    (short const)0,  (short const)0,  (short const)73};
24945|       |static short const yycheck[71] = {
24946|       |    (short const)5,    (short const)6,    (short const)21,   (short const)8,
24947|       |    (short const)10,   (short const)10,   (short const)11,   (short const)12,
24948|       |    (short const)13,   (short const)14,   (short const)15,   (short const)17,
24949|       |    (short const)17,   (short const)17,   (short const)18,   (short const)23,
24950|       |    (short const)22,   (short const)22,   (short const)10,   (short const)24,
24951|       |    (short const)5,    (short const)6,    (short const)7,    (short const)8,
24952|       |    (short const)9,    (short const)17,   (short const)11,   (short const)12,
24953|       |    (short const)13,   (short const)14,   (short const)15,   (short const)16,
24954|       |    (short const)17,   (short const)18,   (short const)19,   (short const)20,
24955|       |    (short const)6,    (short const)18,   (short const)8,    (short const)20,
24956|       |    (short const)4,    (short const)11,   (short const)4,    (short const)13,
24957|       |    (short const)14,   (short const)15,   (short const)17,   (short const)18,
24958|       |    (short const)19,   (short const)20,   (short const)17,   (short const)18,
24959|       |    (short const)3,    (short const)14,   (short const)14,   (short const)23,
24960|       |    (short const)0,    (short const)0,    (short const)17,   (short const)17,
24961|       |    (short const)71,   (short const)18,   (short const)18,   (short const)18,
24962|       |    (short const)74,   (short const)18,   (short const) - 1, (short const) - 1,
24963|       |    (short const) - 1, (short const) - 1, (short const)24};
24964|       |int yyparse(void *parm);
24965|      0|int yyparse(void *parm) {
24966|      0|  register int yystate;
24967|      0|  register int yyn;
24968|      0|  register short *yyssp;
24969|      0|  register YYSTYPE *yyvsp;
24970|      0|  int yyerrstatus;
24971|      0|  int yychar1;
24972|      0|  short yyssa[200];
24973|      0|  YYSTYPE yyvsa[200];
24974|      0|  short *yyss;
24975|      0|  YYSTYPE *yyvs;
24976|      0|  int yystacksize;
24977|      0|  int yyfree_stacks;
24978|      0|  int yychar;
24979|      0|  YYSTYPE yylval;
24980|      0|  int yynerrs;
24981|      0|  YYSTYPE yyval;
24982|      0|  int yylen;
24983|      0|  YYSTYPE *yyvs1;
24984|      0|  short *yyss1;
24985|      0|  int size;
24986|      0|  void *tmp;
24987|      0|  void *tmp___0;
24988|      0|  int tmp___1;
24989|      0|  long tmp___2;
24990|      0|  void *__cil_tmp26;
24991|      0|  void *__cil_tmp27;
24992|      0|  int __cil_tmp28;
24993|      0|  char *__cil_tmp29;
24994|      0|  char *__cil_tmp30;
24995|       |
24996|      0|  {
24997|      0|    yychar1 = 0;
24998|      0|    yyss = yyssa;
24999|      0|    yyvs = yyvsa;
25000|      0|    yystacksize = 200;
25001|      0|    yyfree_stacks = 0;
25002|      0|    yystate = 0;
25003|      0|    yyerrstatus = 0;
25004|      0|    yynerrs = 0;
25005|      0|    yychar = -2;
25006|      0|    yyssp = yyss - 1;
25007|      0|    yyvsp = yyvs;
25008|      0|  yynewstate:
25009|      0|    yyssp++;
25010|      0|    *yyssp = (short)yystate;
25011|      0|    if ((unsigned long)yyssp >= (unsigned long)((yyss + yystacksize) - 1)) {
25012|      0|      yyvs1 = yyvs;
25013|      0|      yyss1 = yyss;
25014|      0|      size = (int)((yyssp - yyss) + 1L);
25015|      0|      if (yystacksize >= 10000) {
25016|      0|        {
25017|      0|          yyerror((char *)"parser stack overflow");
25018|      0|        }
25019|      0|        if (yyfree_stacks) {
25020|      0|          {
25021|      0|            free((void *)yyss);
25022|      0|            free((void *)yyvs);
25023|      0|          }
25024|      0|        }
25025|      0|        return (2);
25026|      0|      }
25027|      0|      yystacksize *= 2;
25028|      0|      if (yystacksize > 10000) {
25029|      0|        yystacksize = 10000;
25030|      0|      }
25031|      0|      {
25032|      0|        tmp = __builtin_alloca((unsigned long)yystacksize * sizeof(*yyssp));
25033|      0|        yyss = (short *)tmp;
25034|      0|        __builtin_memcpy(
25035|      0|            (void *)((char *)yyss), (void const *)((char *)yyss1),
25036|      0|            (unsigned long)((unsigned int)size * (unsigned int)sizeof(*yyssp)));
25037|      0|        tmp___0 = __builtin_alloca((unsigned long)yystacksize * sizeof(*yyvsp));
25038|      0|        yyvs = (YYSTYPE *)tmp___0;
25039|      0|        __builtin_memcpy(
25040|      0|            (void *)((char *)yyvs), (void const *)((char *)yyvs1),
25041|      0|            (unsigned long)((unsigned int)size * (unsigned int)sizeof(*yyvsp)));
25042|      0|        yyssp = (yyss + size) - 1;
25043|      0|        yyvsp = (yyvs + size) - 1;
25044|      0|      }
25045|      0|      if ((unsigned long)yyssp >= (unsigned long)((yyss + yystacksize) - 1)) {
25046|      0|        goto yyabortlab;
25047|      0|      }
25048|      0|    }
25049|      0|    goto yybackup;
25050|      0|  yybackup:
25051|      0|    yyn = (int)yypact[yystate];
25052|      0|    if (yyn == -32768) {
25053|      0|      goto yydefault;
25054|      0|    }
25055|      0|    if (yychar == -2) {
25056|      0|      {
25057|      0|        yychar = yylex(&yylval, (parser_control *)parm);
25058|      0|      }
25059|      0|    }
25060|      0|    if (yychar <= 0) {
25061|      0|      yychar1 = 0;
25062|      0|      yychar = 0;
25063|      0|    } else {
25064|      0|      if ((unsigned int)yychar <= 274U) {
25065|      0|        tmp___1 = (int const)yytranslate[yychar];
25066|      0|      } else {
25067|      0|        tmp___1 = (int const)41;
25068|      0|      }
25069|      0|      yychar1 = (int)tmp___1;
25070|      0|    }
25071|      0|    yyn += yychar1;
25072|      0|    if (yyn < 0) {
25073|      0|      goto yydefault;
25074|      0|    } else {
25075|      0|      if (yyn > 70) {
25076|      0|        goto yydefault;
25077|      0|      } else {
25078|      0|        if ((int const)yycheck[yyn] != (int const)yychar1) {
25079|      0|          goto yydefault;
25080|      0|        }
25081|      0|      }
25082|      0|    }
25083|      0|    yyn = (int)yytable[yyn];
25084|      0|    if (yyn < 0) {
25085|      0|      if (yyn == -32768) {
25086|      0|        goto yyerrlab;
25087|      0|      }
25088|      0|      yyn = -yyn;
25089|      0|      goto yyreduce;
25090|      0|    } else {
25091|      0|      if (yyn == 0) {
25092|      0|        goto yyerrlab;
25093|      0|      }
25094|      0|    }
25095|      0|    if (yyn == 80) {
25096|      0|      goto yyacceptlab;
25097|      0|    }
25098|      0|    if (yychar != 0) {
25099|      0|      yychar = -2;
25100|      0|    }
25101|      0|    yyvsp++;
25102|      0|    *yyvsp = yylval;
25103|      0|    if (yyerrstatus) {
25104|      0|      yyerrstatus--;
25105|      0|    }
25106|      0|    yystate = yyn;
25107|      0|    goto yynewstate;
25108|      0|  yydefault:
25109|      0|    yyn = (int)yydefact[yystate];
25110|      0|    if (yyn == 0) {
25111|      0|      goto yyerrlab;
25112|      0|    }
25113|      0|  yyreduce:
25114|      0|    yylen = (int)yyr2[yyn];
25115|      0|    if (yylen > 0) {
25116|      0|      yyval = *(yyvsp + (1 - yylen));
25117|      0|    }
25118|      0|    {
25119|      0|      if (yyn == 3) {
25120|      0|        goto case_3;
25121|      0|      }
25122|      0|      if (yyn == 6) {
25123|      0|        goto case_6;
25124|      0|      }
25125|      0|      if (yyn == 7) {
25126|      0|        goto case_7;
25127|      0|      }
25128|      0|      if (yyn == 8) {
25129|      0|        goto case_8;
25130|      0|      }
25131|      0|      if (yyn == 9) {
25132|      0|        goto case_9;
25133|      0|      }
25134|      0|      if (yyn == 10) {
25135|      0|        goto case_10;
25136|      0|      }
25137|      0|      if (yyn == 11) {
25138|      0|        goto case_11;
25139|      0|      }
25140|      0|      if (yyn == 13) {
25141|      0|        goto case_13;
25142|      0|      }
25143|      0|      if (yyn == 14) {
25144|      0|        goto case_14;
25145|      0|      }
25146|      0|      if (yyn == 15) {
25147|      0|        goto case_15;
25148|      0|      }
25149|      0|      if (yyn == 16) {
25150|      0|        goto case_16;
25151|      0|      }
25152|      0|      if (yyn == 17) {
25153|      0|        goto case_17;
25154|      0|      }
25155|      0|      if (yyn == 18) {
25156|      0|        goto case_18;
25157|      0|      }
25158|      0|      if (yyn == 19) {
25159|      0|        goto case_19;
25160|      0|      }
25161|      0|      if (yyn == 20) {
25162|      0|        goto case_20;
25163|      0|      }
25164|      0|      if (yyn == 21) {
25165|      0|        goto case_21;
25166|      0|      }
25167|      0|      if (yyn == 22) {
25168|      0|        goto case_22;
25169|      0|      }
25170|      0|      if (yyn == 23) {
25171|      0|        goto case_23;
25172|      0|      }
25173|      0|      if (yyn == 24) {
25174|      0|        goto case_24;
25175|      0|      }
25176|      0|      if (yyn == 25) {
25177|      0|        goto case_25;
25178|      0|      }
25179|      0|      if (yyn == 26) {
25180|      0|        goto case_26;
25181|      0|      }
25182|      0|      if (yyn == 27) {
25183|      0|        goto case_27;
25184|      0|      }
25185|      0|      if (yyn == 28) {
25186|      0|        goto case_28;
25187|      0|      }
25188|      0|      if (yyn == 29) {
25189|      0|        goto case_29;
25190|      0|      }
25191|      0|      if (yyn == 30) {
25192|      0|        goto case_30;
25193|      0|      }
25194|      0|      if (yyn == 31) {
25195|      0|        goto case_31;
25196|      0|      }
25197|      0|      if (yyn == 32) {
25198|      0|        goto case_32;
25199|      0|      }
25200|      0|      if (yyn == 33) {
25201|      0|        goto case_33;
25202|      0|      }
25203|      0|      if (yyn == 34) {
25204|      0|        goto case_34;
25205|      0|      }
25206|      0|      if (yyn == 35) {
25207|      0|        goto case_35;
25208|      0|      }
25209|      0|      if (yyn == 37) {
25210|      0|        goto case_37;
25211|      0|      }
25212|      0|      if (yyn == 38) {
25213|      0|        goto case_38;
25214|      0|      }
25215|      0|      if (yyn == 39) {
25216|      0|        goto case_39;
25217|      0|      }
25218|      0|      if (yyn == 40) {
25219|      0|        goto case_40;
25220|      0|      }
25221|      0|      if (yyn == 41) {
25222|      0|        goto case_41;
25223|      0|      }
25224|      0|      if (yyn == 42) {
25225|      0|        goto case_42;
25226|      0|      }
25227|      0|      if (yyn == 43) {
25228|      0|        goto case_43;
25229|      0|      }
25230|      0|      if (yyn == 44) {
25231|      0|        goto case_44;
25232|      0|      }
25233|      0|      if (yyn == 45) {
25234|      0|        goto case_45;
25235|      0|      }
25236|      0|      if (yyn == 46) {
25237|      0|        goto case_46;
25238|      0|      }
25239|      0|      if (yyn == 47) {
25240|      0|        goto case_47;
25241|      0|      }
25242|      0|      if (yyn == 48) {
25243|      0|        goto case_48;
25244|      0|      }
25245|      0|      if (yyn == 49) {
25246|      0|        goto case_49;
25247|      0|      }
25248|      0|      if (yyn == 50) {
25249|      0|        goto case_50;
25250|      0|      }
25251|      0|      if (yyn == 51) {
25252|      0|        goto case_51;
25253|      0|      }
25254|      0|      if (yyn == 52) {
25255|      0|        goto case_52;
25256|      0|      }
25257|      0|      if (yyn == 53) {
25258|      0|        goto case_53;
25259|      0|      }
25260|      0|      if (yyn == 54) {
25261|      0|        goto case_54;
25262|      0|      }
25263|      0|      if (yyn == 55) {
25264|      0|        goto case_55;
25265|      0|      }
25266|      0|      if (yyn == 56) {
25267|      0|        goto case_56;
25268|      0|      }
25269|      0|      if (yyn == 60) {
25270|      0|        goto case_60;
25271|      0|      }
25272|      0|      if (yyn == 62) {
25273|      0|        goto case_62;
25274|      0|      }
25275|      0|      if (yyn == 63) {
25276|      0|        goto case_63;
25277|      0|      }
25278|      0|      if (yyn == 64) {
25279|      0|        goto case_64;
25280|      0|      }
25281|      0|      if (yyn == 65) {
25282|      0|        goto case_65;
25283|      0|      }
25284|      0|      goto switch_break;
25285|      0|    case_3: /* CIL Label */
25286|      0|      ((parser_control *)parm)->seconds = (yyvsp + 0)->timespec;
25287|      0|      ((parser_control *)parm)->timespec_seen = (_Bool)1;
25288|      0|      goto switch_break;
25289|      0|    case_6: /* CIL Label */
25290|      0|      (((parser_control *)parm)->times_seen)++;
25291|      0|      goto switch_break;
25292|      0|    case_7: /* CIL Label */
25293|      0|      (((parser_control *)parm)->local_zones_seen)++;
25294|      0|      goto switch_break;
25295|      0|    case_8: /* CIL Label */
25296|      0|      (((parser_control *)parm)->zones_seen)++;
25297|      0|      goto switch_break;
25298|      0|    case_9: /* CIL Label */
25299|      0|      (((parser_control *)parm)->dates_seen)++;
25300|      0|      goto switch_break;
25301|      0|    case_10: /* CIL Label */
25302|      0|      (((parser_control *)parm)->days_seen)++;
25303|      0|      goto switch_break;
25304|      0|    case_11: /* CIL Label */
25305|      0|      (((parser_control *)parm)->rels_seen)++;
25306|      0|      goto switch_break;
25307|      0|    case_13: /* CIL Label */
25308|      0|      ((parser_control *)parm)->hour = (yyvsp + -1)->textintval.value;
25309|      0|      ((parser_control *)parm)->minutes = 0L;
25310|      0|      ((parser_control *)parm)->seconds.tv_sec = (__time_t)0;
25311|      0|      ((parser_control *)parm)->seconds.tv_nsec = (__syscall_slong_t)0;
25312|      0|      ((parser_control *)parm)->meridian = (int)(yyvsp + 0)->intval;
25313|      0|      goto switch_break;
25314|      0|    case_14: /* CIL Label */
25315|      0|      ((parser_control *)parm)->hour = (yyvsp + -3)->textintval.value;
25316|      0|      ((parser_control *)parm)->minutes = (yyvsp + -1)->textintval.value;
25317|      0|      ((parser_control *)parm)->seconds.tv_sec = (__time_t)0;
25318|      0|      ((parser_control *)parm)->seconds.tv_nsec = (__syscall_slong_t)0;
25319|      0|      ((parser_control *)parm)->meridian = (int)(yyvsp + 0)->intval;
25320|      0|      goto switch_break;
25321|      0|    case_15: /* CIL Label */
25322|      0|      ((parser_control *)parm)->hour = (yyvsp + -3)->textintval.value;
25323|      0|      ((parser_control *)parm)->minutes = (yyvsp + -1)->textintval.value;
25324|      0|      ((parser_control *)parm)->seconds.tv_sec = (__time_t)0;
25325|      0|      ((parser_control *)parm)->seconds.tv_nsec = (__syscall_slong_t)0;
25326|      0|      ((parser_control *)parm)->meridian = 2;
25327|      0|      (((parser_control *)parm)->zones_seen)++;
25328|      0|      ((parser_control *)parm)->time_zone =
25329|      0|          (yyvsp + 0)->textintval.value % 100L +
25330|      0|          ((yyvsp + 0)->textintval.value / 100L) * 60L;
25331|      0|      goto switch_break;
25332|      0|    case_16: /* CIL Label */
25333|      0|      ((parser_control *)parm)->hour = (yyvsp + -5)->textintval.value;
25334|      0|      ((parser_control *)parm)->minutes = (yyvsp + -3)->textintval.value;
25335|      0|      ((parser_control *)parm)->seconds = (yyvsp + -1)->timespec;
25336|      0|      ((parser_control *)parm)->meridian = (int)(yyvsp + 0)->intval;
25337|      0|      goto switch_break;
25338|      0|    case_17: /* CIL Label */
25339|      0|      ((parser_control *)parm)->hour = (yyvsp + -5)->textintval.value;
25340|      0|      ((parser_control *)parm)->minutes = (yyvsp + -3)->textintval.value;
25341|      0|      ((parser_control *)parm)->seconds = (yyvsp + -1)->timespec;
25342|      0|      ((parser_control *)parm)->meridian = 2;
25343|      0|      (((parser_control *)parm)->zones_seen)++;
25344|      0|      ((parser_control *)parm)->time_zone =
25345|      0|          (yyvsp + 0)->textintval.value % 100L +
25346|      0|          ((yyvsp + 0)->textintval.value / 100L) * 60L;
25347|      0|      goto switch_break;
25348|      0|    case_18: /* CIL Label */
25349|      0|      ((parser_control *)parm)->local_isdst = (int)(yyvsp + 0)->intval;
25350|      0|      goto switch_break;
25351|      0|    case_19: /* CIL Label */
25352|      0|      if ((yyvsp + -1)->intval < 0L) {
25353|      0|        tmp___2 = 1L;
25354|      0|      } else {
25355|      0|        tmp___2 = (yyvsp + -1)->intval + 1L;
25356|      0|      }
25357|      0|      ((parser_control *)parm)->local_isdst = (int)tmp___2;
25358|      0|      goto switch_break;
25359|      0|    case_20: /* CIL Label */
25360|      0|      ((parser_control *)parm)->time_zone = (yyvsp + 0)->intval;
25361|      0|      goto switch_break;
25362|      0|    case_21: /* CIL Label */
25363|      0|      ((parser_control *)parm)->time_zone = (yyvsp + 0)->intval + 60L;
25364|      0|      goto switch_break;
25365|      0|    case_22: /* CIL Label */
25366|      0|      ((parser_control *)parm)->time_zone = (yyvsp + -1)->intval + 60L;
25367|      0|      goto switch_break;
25368|      0|    case_23: /* CIL Label */
25369|      0|      ((parser_control *)parm)->day_ordinal = 1L;
25370|      0|      ((parser_control *)parm)->day_number = (int)(yyvsp + 0)->intval;
25371|      0|      goto switch_break;
25372|      0|    case_24: /* CIL Label */
25373|      0|      ((parser_control *)parm)->day_ordinal = 1L;
25374|      0|      ((parser_control *)parm)->day_number = (int)(yyvsp + -1)->intval;
25375|      0|      goto switch_break;
25376|      0|    case_25: /* CIL Label */
25377|      0|      ((parser_control *)parm)->day_ordinal = (yyvsp + -1)->textintval.value;
25378|      0|      ((parser_control *)parm)->day_number = (int)(yyvsp + 0)->intval;
25379|      0|      goto switch_break;
25380|      0|    case_26: /* CIL Label */
25381|      0|      ((parser_control *)parm)->month = (yyvsp + -2)->textintval.value;
25382|      0|      ((parser_control *)parm)->day = (yyvsp + 0)->textintval.value;
25383|      0|      goto switch_break;
25384|      0|    case_27: /* CIL Label */
25385|      0|      if (4UL <= (yyvsp + -4)->textintval.digits) {
25386|      0|        ((parser_control *)parm)->year = (yyvsp + -4)->textintval;
25387|      0|        ((parser_control *)parm)->month = (yyvsp + -2)->textintval.value;
25388|      0|        ((parser_control *)parm)->day = (yyvsp + 0)->textintval.value;
25389|      0|      } else {
25390|      0|        ((parser_control *)parm)->month = (yyvsp + -4)->textintval.value;
25391|      0|        ((parser_control *)parm)->day = (yyvsp + -2)->textintval.value;
25392|      0|        ((parser_control *)parm)->year = (yyvsp + 0)->textintval;
25393|      0|      }
25394|      0|      goto switch_break;
25395|      0|    case_28: /* CIL Label */
25396|      0|      ((parser_control *)parm)->year = (yyvsp + -2)->textintval;
25397|      0|      ((parser_control *)parm)->month = -(yyvsp + -1)->textintval.value;
25398|      0|      ((parser_control *)parm)->day = -(yyvsp + 0)->textintval.value;
25399|      0|      goto switch_break;
25400|      0|    case_29: /* CIL Label */
25401|      0|      ((parser_control *)parm)->day = (yyvsp + -2)->textintval.value;
25402|      0|      ((parser_control *)parm)->month = (yyvsp + -1)->intval;
25403|      0|      ((parser_control *)parm)->year.value = -(yyvsp + 0)->textintval.value;
25404|      0|      ((parser_control *)parm)->year.digits = (yyvsp + 0)->textintval.digits;
25405|      0|      goto switch_break;
25406|      0|    case_30: /* CIL Label */
25407|      0|      ((parser_control *)parm)->month = (yyvsp + -2)->intval;
25408|      0|      ((parser_control *)parm)->day = -(yyvsp + -1)->textintval.value;
25409|      0|      ((parser_control *)parm)->year.value = -(yyvsp + 0)->textintval.value;
25410|      0|      ((parser_control *)parm)->year.digits = (yyvsp + 0)->textintval.digits;
25411|      0|      goto switch_break;
25412|      0|    case_31: /* CIL Label */
25413|      0|      ((parser_control *)parm)->month = (yyvsp + -1)->intval;
25414|      0|      ((parser_control *)parm)->day = (yyvsp + 0)->textintval.value;
25415|      0|      goto switch_break;
25416|      0|    case_32: /* CIL Label */
25417|      0|      ((parser_control *)parm)->month = (yyvsp + -3)->intval;
25418|      0|      ((parser_control *)parm)->day = (yyvsp + -2)->textintval.value;
25419|      0|      ((parser_control *)parm)->year = (yyvsp + 0)->textintval;
25420|      0|      goto switch_break;
25421|      0|    case_33: /* CIL Label */
25422|      0|      ((parser_control *)parm)->day = (yyvsp + -1)->textintval.value;
25423|      0|      ((parser_control *)parm)->month = (yyvsp + 0)->intval;
25424|      0|      goto switch_break;
25425|      0|    case_34: /* CIL Label */
25426|      0|      ((parser_control *)parm)->day = (yyvsp + -2)->textintval.value;
25427|      0|      ((parser_control *)parm)->month = (yyvsp + -1)->intval;
25428|      0|      ((parser_control *)parm)->year = (yyvsp + 0)->textintval;
25429|      0|      goto switch_break;
25430|      0|    case_35: /* CIL Label */
25431|      0|      ((parser_control *)parm)->rel_ns = -((parser_control *)parm)->rel_ns;
25432|      0|      ((parser_control *)parm)->rel_seconds =
25433|      0|          -((parser_control *)parm)->rel_seconds;
25434|      0|      ((parser_control *)parm)->rel_minutes =
25435|      0|          -((parser_control *)parm)->rel_minutes;
25436|      0|      ((parser_control *)parm)->rel_hour = -((parser_control *)parm)->rel_hour;
25437|      0|      ((parser_control *)parm)->rel_day = -((parser_control *)parm)->rel_day;
25438|      0|      ((parser_control *)parm)->rel_month =
25439|      0|          -((parser_control *)parm)->rel_month;
25440|      0|      ((parser_control *)parm)->rel_year = -((parser_control *)parm)->rel_year;
25441|      0|      goto switch_break;
25442|      0|    case_37: /* CIL Label */
25443|      0|      ((parser_control *)parm)->rel_year +=
25444|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25445|      0|      goto switch_break;
25446|      0|    case_38: /* CIL Label */
25447|      0|      ((parser_control *)parm)->rel_year +=
25448|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25449|      0|      goto switch_break;
25450|      0|    case_39: /* CIL Label */
25451|      0|      ((parser_control *)parm)->rel_year += (yyvsp + 0)->intval;
25452|      0|      goto switch_break;
25453|      0|    case_40: /* CIL Label */
25454|      0|      ((parser_control *)parm)->rel_month +=
25455|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25456|      0|      goto switch_break;
25457|      0|    case_41: /* CIL Label */
25458|      0|      ((parser_control *)parm)->rel_month +=
25459|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25460|      0|      goto switch_break;
25461|      0|    case_42: /* CIL Label */
25462|      0|      ((parser_control *)parm)->rel_month += (yyvsp + 0)->intval;
25463|      0|      goto switch_break;
25464|      0|    case_43: /* CIL Label */
25465|      0|      ((parser_control *)parm)->rel_day +=
25466|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25467|      0|      goto switch_break;
25468|      0|    case_44: /* CIL Label */
25469|      0|      ((parser_control *)parm)->rel_day +=
25470|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25471|      0|      goto switch_break;
25472|      0|    case_45: /* CIL Label */
25473|      0|      ((parser_control *)parm)->rel_day += (yyvsp + 0)->intval;
25474|      0|      goto switch_break;
25475|      0|    case_46: /* CIL Label */
25476|      0|      ((parser_control *)parm)->rel_hour +=
25477|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25478|      0|      goto switch_break;
25479|      0|    case_47: /* CIL Label */
25480|      0|      ((parser_control *)parm)->rel_hour +=
25481|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25482|      0|      goto switch_break;
25483|      0|    case_48: /* CIL Label */
25484|      0|      ((parser_control *)parm)->rel_hour += (yyvsp + 0)->intval;
25485|      0|      goto switch_break;
25486|      0|    case_49: /* CIL Label */
25487|      0|      ((parser_control *)parm)->rel_minutes +=
25488|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25489|      0|      goto switch_break;
25490|      0|    case_50: /* CIL Label */
25491|      0|      ((parser_control *)parm)->rel_minutes +=
25492|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25493|      0|      goto switch_break;
25494|      0|    case_51: /* CIL Label */
25495|      0|      ((parser_control *)parm)->rel_minutes += (yyvsp + 0)->intval;
25496|      0|      goto switch_break;
25497|      0|    case_52: /* CIL Label */
25498|      0|      ((parser_control *)parm)->rel_seconds +=
25499|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25500|      0|      goto switch_break;
25501|      0|    case_53: /* CIL Label */
25502|      0|      ((parser_control *)parm)->rel_seconds +=
25503|      0|          (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
25504|      0|      goto switch_break;
25505|      0|    case_54: /* CIL Label */
25506|      0|      ((parser_control *)parm)->rel_seconds +=
25507|      0|          (yyvsp + -1)->timespec.tv_sec * (yyvsp + 0)->intval;
25508|      0|      ((parser_control *)parm)->rel_ns +=
25509|      0|          (yyvsp + -1)->timespec.tv_nsec * (yyvsp + 0)->intval;
25510|      0|      goto switch_break;
25511|      0|    case_55: /* CIL Label */
25512|      0|      ((parser_control *)parm)->rel_seconds +=
25513|      0|          (yyvsp + -1)->timespec.tv_sec * (yyvsp + 0)->intval;
25514|      0|      ((parser_control *)parm)->rel_ns +=
25515|      0|          (yyvsp + -1)->timespec.tv_nsec * (yyvsp + 0)->intval;
25516|      0|      goto switch_break;
25517|      0|    case_56: /* CIL Label */
25518|      0|      ((parser_control *)parm)->rel_seconds += (yyvsp + 0)->intval;
25519|      0|      goto switch_break;
25520|      0|    case_60: /* CIL Label */
25521|      0|      yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
25522|      0|      yyval.timespec.tv_nsec = (__syscall_slong_t)0;
25523|      0|      goto switch_break;
25524|      0|    case_62: /* CIL Label */
25525|      0|      yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
25526|      0|      yyval.timespec.tv_nsec = (__syscall_slong_t)0;
25527|      0|      goto switch_break;
25528|      0|    case_63: /* CIL Label */
25529|      0|      if (((parser_control *)parm)->dates_seen) {
25530|      0|        if (!((parser_control *)parm)->rels_seen) {
25531|      0|          if (((parser_control *)parm)->times_seen) {
25532|      0|            ((parser_control *)parm)->year = (yyvsp + 0)->textintval;
25533|      0|          } else {
25534|      0|            if (2UL < (yyvsp + 0)->textintval.digits) {
25535|      0|              ((parser_control *)parm)->year = (yyvsp + 0)->textintval;
25536|      0|            } else {
25537|      0|              goto _L___4;
25538|      0|            }
25539|      0|          }
25540|      0|        } else {
25541|      0|          goto _L___4;
25542|      0|        }
25543|      0|      } else {
25544|      0|      _L___4: /* CIL Label */
25545|      0|        if (4UL < (yyvsp + 0)->textintval.digits) {
25546|      0|          (((parser_control *)parm)->dates_seen)++;
25547|      0|          ((parser_control *)parm)->day = (yyvsp + 0)->textintval.value % 100L;
25548|      0|          ((parser_control *)parm)->month =
25549|      0|              ((yyvsp + 0)->textintval.value / 100L) % 100L;
25550|      0|          ((parser_control *)parm)->year.value =
25551|      0|              (yyvsp + 0)->textintval.value / 10000L;
25552|      0|          ((parser_control *)parm)->year.digits =
25553|      0|              (yyvsp + 0)->textintval.digits - 4UL;
25554|      0|        } else {
25555|      0|          (((parser_control *)parm)->times_seen)++;
25556|      0|          if ((yyvsp + 0)->textintval.digits <= 2UL) {
25557|      0|            ((parser_control *)parm)->hour = (yyvsp + 0)->textintval.value;
25558|      0|            ((parser_control *)parm)->minutes = 0L;
25559|      0|          } else {
25560|      0|            ((parser_control *)parm)->hour =
25561|      0|                (yyvsp + 0)->textintval.value / 100L;
25562|      0|            ((parser_control *)parm)->minutes =
25563|      0|                (yyvsp + 0)->textintval.value % 100L;
25564|      0|          }
25565|      0|          ((parser_control *)parm)->seconds.tv_sec = (__time_t)0;
25566|      0|          ((parser_control *)parm)->seconds.tv_nsec = (__syscall_slong_t)0;
25567|      0|          ((parser_control *)parm)->meridian = 2;
25568|      0|        }
25569|      0|      }
25570|      0|      goto switch_break;
25571|      0|    case_64: /* CIL Label */
25572|      0|      yyval.intval = 2L;
25573|      0|      goto switch_break;
25574|      0|    case_65: /* CIL Label */
25575|      0|      yyval.intval = (yyvsp + 0)->intval;
25576|      0|      goto switch_break;
25577|      0|    switch_break: /* CIL Label */;
25578|      0|    }
25579|      0|    yyvsp -= yylen;
25580|      0|    yyssp -= yylen;
25581|      0|    yyvsp++;
25582|      0|    *yyvsp = yyval;
25583|      0|    yyn = (int)yyr1[yyn];
25584|      0|    yystate = (int)((int const)yypgoto[yyn - 25] + (int const) * yyssp);
25585|      0|    if (yystate >= 0) {
25586|      0|      if (yystate <= 70) {
25587|      0|        if ((int const)yycheck[yystate] == (int const) * yyssp) {
25588|      0|          yystate = (int)yytable[yystate];
25589|      0|        } else {
25590|      0|          yystate = (int)yydefgoto[yyn - 25];
25591|      0|        }
25592|      0|      } else {
25593|      0|        yystate = (int)yydefgoto[yyn - 25];
25594|      0|      }
25595|      0|    } else {
25596|      0|      yystate = (int)yydefgoto[yyn - 25];
25597|      0|    }
25598|      0|    goto yynewstate;
25599|      0|  yyerrlab:
25600|      0|    if (!yyerrstatus) {
25601|      0|      {
25602|      0|        yynerrs++;
25603|      0|        yyerror((char *)"parse error");
25604|      0|      }
25605|      0|    }
25606|      0|    goto yyerrlab1;
25607|      0|  yyerrlab1:
25608|      0|    if (yyerrstatus == 3) {
25609|      0|      if (yychar == 0) {
25610|      0|        goto yyabortlab;
25611|      0|      }
25612|      0|      yychar = -2;
25613|      0|    }
25614|      0|    yyerrstatus = 3;
25615|      0|    goto yyerrhandle;
25616|      0|  yyerrdefault:
25617|      0|    if ((unsigned long)yyssp == (unsigned long)yyss) {
25618|      0|      goto yyabortlab;
25619|      0|    }
25620|      0|    yyvsp--;
25621|      0|    yyssp--;
25622|      0|    yystate = (int)*yyssp;
25623|      0|  yyerrhandle:
25624|      0|    yyn = (int)yypact[yystate];
25625|      0|    if (yyn == -32768) {
25626|      0|      goto yyerrdefault;
25627|      0|    }
25628|      0|    yyn++;
25629|      0|    if (yyn < 0) {
25630|      0|      goto yyerrdefault;
25631|      0|    } else {
25632|      0|      if (yyn > 70) {
25633|      0|        goto yyerrdefault;
25634|      0|      } else {
25635|      0|        if ((int const)yycheck[yyn] != 1) {
25636|      0|          goto yyerrdefault;
25637|      0|        }
25638|      0|      }
25639|      0|    }
25640|      0|    yyn = (int)yytable[yyn];
25641|      0|    if (yyn < 0) {
25642|      0|      if (yyn == -32768) {
25643|      0|        goto yyerrdefault;
25644|      0|      }
25645|      0|      yyn = -yyn;
25646|      0|      goto yyreduce;
25647|      0|    } else {
25648|      0|      if (yyn == 0) {
25649|      0|        goto yyerrdefault;
25650|      0|      }
25651|      0|    }
25652|      0|    if (yyn == 80) {
25653|      0|      goto yyacceptlab;
25654|      0|    }
25655|      0|    yyvsp++;
25656|      0|    *yyvsp = yylval;
25657|      0|    yystate = yyn;
25658|      0|    goto yynewstate;
25659|      0|  yyacceptlab:
25660|      0|    if (yyfree_stacks) {
25661|      0|      {
25662|      0|        free((void *)yyss);
25663|      0|        free((void *)yyvs);
25664|      0|      }
25665|      0|    }
25666|      0|    return (0);
25667|      0|  yyabortlab:
25668|      0|    if (yyfree_stacks) {
25669|      0|      {
25670|      0|        free((void *)yyss);
25671|      0|        free((void *)yyvs);
25672|      0|      }
25673|      0|    }
25674|      0|    return (1);
25675|      0|  }
25676|      0|}
25677|       |static table const meridian_table[5] = {{"AM", 264, 0},
25678|       |                                        {"A.M.", 264, 0},
25679|       |                                        {"PM", 264, 1},
25680|       |                                        {"P.M.", 264, 1},
25681|       |                                        {(char const *)0, 0, 0}};
25682|       |static table const dst_table[1] = {{"DST", 258, 0}};
25683|       |static table const month_and_day_table[25] = {
25684|       |    {"JANUARY", 266, 1},    {"FEBRUARY", 266, 2}, {"MARCH", 266, 3},
25685|       |    {"APRIL", 266, 4},      {"MAY", 266, 5},      {"JUNE", 266, 6},
25686|       |    {"JULY", 266, 7},       {"AUGUST", 266, 8},   {"SEPTEMBER", 266, 9},
25687|       |    {"SEPT", 266, 9},       {"OCTOBER", 266, 10}, {"NOVEMBER", 266, 11},
25688|       |    {"DECEMBER", 266, 12},  {"SUNDAY", 259, 0},   {"MONDAY", 259, 1},
25689|       |    {"TUESDAY", 259, 2},    {"TUES", 259, 2},     {"WEDNESDAY", 259, 3},
25690|       |    {"WEDNES", 259, 3},     {"THURSDAY", 259, 4}, {"THUR", 259, 4},
25691|       |    {"THURS", 259, 4},      {"FRIDAY", 259, 5},   {"SATURDAY", 259, 6},
25692|       |    {(char const *)0, 0, 0}};
25693|       |static table const time_units_table[11] = {
25694|       |    {"YEAR", 269, 1},   {"MONTH", 267, 1},      {"FORTNIGHT", 260, 14},
25695|       |    {"WEEK", 260, 7},   {"DAY", 260, 1},        {"HOUR", 262, 1},
25696|       |    {"MINUTE", 265, 1}, {"MIN", 265, 1},        {"SECOND", 268, 1},
25697|       |    {"SEC", 268, 1},    {(char const *)0, 0, 0}};
25698|       |static table const relative_time_table[20] = {
25699|       |    {"TOMORROW", 260, 1}, {"YESTERDAY", 260, -1}, {"TODAY", 260, 0},
25700|       |    {"NOW", 260, 0},      {"LAST", 272, -1},      {"THIS", 272, 0},
25701|       |    {"NEXT", 272, 1},     {"FIRST", 272, 1},      {"THIRD", 272, 3},
25702|       |    {"FOURTH", 272, 4},   {"FIFTH", 272, 5},      {"SIXTH", 272, 6},
25703|       |    {"SEVENTH", 272, 7},  {"EIGHTH", 272, 8},     {"NINTH", 272, 9},
25704|       |    {"TENTH", 272, 10},   {"ELEVENTH", 272, 11},  {"TWELFTH", 272, 12},
25705|       |    {"AGO", 257, 1},      {(char const *)0, 0, 0}};
25706|       |static table const time_zone_table[51] = {
25707|       |    {"GMT", 270, 0},     {"UT", 270, 0},     {"UTC", 270, 0},
25708|       |    {"WET", 270, 0},     {"WEST", 261, 0},   {"BST", 261, 0},
25709|       |    {"ART", 270, -180},  {"BRT", 270, -180}, {"BRST", 261, -180},
25710|       |    {"NST", 270, -210},  {"NDT", 261, -210}, {"AST", 270, -240},
25711|       |    {"ADT", 261, -240},  {"CLT", 270, -240}, {"CLST", 261, -240},
25712|       |    {"EST", 270, -300},  {"EDT", 261, -300}, {"CST", 270, -360},
25713|       |    {"CDT", 261, -360},  {"MST", 270, -420}, {"MDT", 261, -420},
25714|       |    {"PST", 270, -480},  {"PDT", 261, -480}, {"AKST", 270, -540},
25715|       |    {"AKDT", 261, -540}, {"HST", 270, -600}, {"HAST", 270, -600},
25716|       |    {"HADT", 261, -600}, {"SST", 270, -720}, {"WAT", 270, 60},
25717|       |    {"CET", 270, 60},    {"CEST", 261, 60},  {"MET", 270, 60},
25718|       |    {"MEZ", 270, 60},    {"MEST", 261, 60},  {"MESZ", 261, 60},
25719|       |    {"EET", 270, 120},   {"EEST", 261, 120}, {"CAT", 270, 120},
25720|       |    {"SAST", 270, 120},  {"EAT", 270, 180},  {"MSK", 270, 180},
25721|       |    {"MSD", 261, 180},   {"IST", 270, 330},  {"SGT", 270, 480},
25722|       |    {"KST", 270, 540},   {"JST", 270, 540},  {"GST", 270, 600},
25723|       |    {"NZST", 270, 720},  {"NZDT", 261, 720}, {(char const *)0, 0, 0}};
25724|       |static table const military_table[26] = {
25725|       |    {"A", 270, -60},  {"B", 270, -120},       {"C", 270, -180},
25726|       |    {"D", 270, -240}, {"E", 270, -300},       {"F", 270, -360},
25727|       |    {"G", 270, -420}, {"H", 270, -480},       {"I", 270, -540},
25728|       |    {"K", 270, -600}, {"L", 270, -660},       {"M", 270, -720},
25729|       |    {"N", 270, 60},   {"O", 270, 120},        {"P", 270, 180},
25730|       |    {"Q", 270, 240},  {"R", 270, 300},        {"S", 270, 360},
25731|       |    {"T", 270, 420},  {"U", 270, 480},        {"V", 270, 540},
25732|       |    {"W", 270, 600},  {"X", 270, 660},        {"Y", 270, 720},
25733|       |    {"Z", 270, 0},    {(char const *)0, 0, 0}};
25734|      0|static int to_hour(long hours, int meridian) {
25735|      0|  long tmp;
25736|      0|  int tmp___0;
25737|      0|  long tmp___1;
25738|      0|  int tmp___2;
25739|      0|  long tmp___3;
25740|       |
25741|      0|  {
25742|      0|    {
25743|      0|      if (meridian == 2) {
25744|      0|        goto case_2;
25745|      0|      }
25746|      0|      if (meridian == 0) {
25747|      0|        goto case_0;
25748|      0|      }
25749|      0|      if (meridian == 1) {
25750|      0|        goto case_1;
25751|      0|      }
25752|      0|      goto switch_default;
25753|      0|    case_2: /* CIL Label */
25754|      0|      if (0L <= hours) {
25755|      0|        if (hours < 24L) {
25756|      0|          tmp = hours;
25757|      0|        } else {
25758|      0|          tmp = -1L;
25759|      0|        }
25760|      0|      } else {
25761|      0|        tmp = -1L;
25762|      0|      }
25763|      0|      return ((int)tmp);
25764|      0|    case_0: /* CIL Label */
25765|      0|      if (0L < hours) {
25766|      0|        if (hours < 12L) {
25767|      0|          tmp___1 = hours;
25768|      0|        } else {
25769|      0|          goto _L___3;
25770|      0|        }
25771|      0|      } else {
25772|      0|      _L___3: /* CIL Label */
25773|      0|        if (hours == 12L) {
25774|      0|          tmp___0 = 0;
25775|      0|        } else {
25776|      0|          tmp___0 = -1;
25777|      0|        }
25778|      0|        tmp___1 = (long)tmp___0;
25779|      0|      }
25780|      0|      return ((int)tmp___1);
25781|      0|    case_1: /* CIL Label */
25782|      0|      if (0L < hours) {
25783|      0|        if (hours < 12L) {
25784|      0|          tmp___3 = hours + 12L;
25785|      0|        } else {
25786|      0|          goto _L___4;
25787|      0|        }
25788|      0|      } else {
25789|      0|      _L___4: /* CIL Label */
25790|      0|        if (hours == 12L) {
25791|      0|          tmp___2 = 12;
25792|      0|        } else {
25793|      0|          tmp___2 = -1;
25794|      0|        }
25795|      0|        tmp___3 = (long)tmp___2;
25796|      0|      }
25797|      0|      return ((int)tmp___3);
25798|      0|    switch_default : /* CIL Label */
25799|      0|    {
25800|      0|      abort();
25801|      0|    }
25802|      0|    switch_break: /* CIL Label */;
25803|      0|    }
25804|      0|  }
25805|      0|}
25806|      0|static long to_year(textint textyear) {
25807|      0|  long year;
25808|      0|  int tmp;
25809|       |
25810|      0|  {
25811|      0|    year = textyear.value;
25812|      0|    if (year < 0L) {
25813|      0|      year = -year;
25814|      0|    } else {
25815|      0|      if (textyear.digits == 2UL) {
25816|      0|        if (year < 69L) {
25817|      0|          tmp = 2000;
25818|      0|        } else {
25819|      0|          tmp = 1900;
25820|      0|        }
25821|      0|        year += (long)tmp;
25822|      0|      }
25823|      0|    }
25824|      0|    return (year);
25825|      0|  }
25826|      0|}
25827|      0|static table const *lookup_zone(parser_control const *pc, char const *name) {
25828|      0|  table const *tp;
25829|      0|  int tmp;
25830|      0|  int tmp___0;
25831|       |
25832|      0|  {
25833|      0|    tp = (table const *)(pc->local_time_zone_table);
25834|      0|    {
25835|      0|      while (1) {
25836|      0|      while_continue: /* CIL Label */;
25837|      0|        if (!tp->name) {
25838|      0|          goto while_break;
25839|      0|        }
25840|      0|        { tmp = strcmp(name, (char const *)tp->name); }
25841|      0|        if (tmp == 0) {
25842|      0|          return (tp);
25843|      0|        }
25844|      0|        tp++;
25845|      0|      }
25846|      0|    while_break: /* CIL Label */;
25847|      0|    }
25848|      0|    tp = time_zone_table;
25849|      0|    {
25850|      0|      while (1) {
25851|      0|      while_continue___0: /* CIL Label */;
25852|      0|        if (!tp->name) {
25853|      0|          goto while_break___0;
25854|      0|        }
25855|      0|        { tmp___0 = strcmp(name, (char const *)tp->name); }
25856|      0|        if (tmp___0 == 0) {
25857|      0|          return (tp);
25858|      0|        }
25859|      0|        tp++;
25860|      0|      }
25861|      0|    while_break___0: /* CIL Label */;
25862|      0|    }
25863|      0|    return ((table const *)0);
25864|      0|  }
25865|      0|}
25866|      0|static table const *lookup_word(parser_control const *pc, char *word) {
25867|      0|  char *p;
25868|      0|  char *q;
25869|      0|  size_t wordlen;
25870|      0|  table const *tp;
25871|      0|  _Bool period_found;
25872|      0|  _Bool abbrev;
25873|      0|  int tmp;
25874|      0|  unsigned short const **tmp___0;
25875|      0|  int tmp___1;
25876|      0|  int tmp___2;
25877|      0|  int tmp___3;
25878|      0|  int tmp___4;
25879|      0|  int tmp___5;
25880|      0|  int tmp___6;
25881|      0|  int tmp___7;
25882|      0|  int tmp___8;
25883|      0|  char tmp___9;
25884|      0|  int tmp___10;
25885|       |
25886|      0|  {
25887|      0|    p = word;
25888|      0|    {
25889|      0|      while (1) {
25890|      0|      while_continue: /* CIL Label */;
25891|      0|        if (!*p) {
25892|      0|          goto while_break;
25893|      0|        }
25894|      0|        { tmp___0 = __ctype_b_loc(); }
25895|      0|        if ((int const) * (*tmp___0 + (int)((unsigned char)*p)) & 512) {
25896|      0|          {
25897|      0|            tmp = toupper((int)((unsigned char)*p));
25898|      0|            *p = (char)tmp;
25899|      0|          }
25900|      0|        }
25901|      0|        p++;
25902|      0|      }
25903|      0|    while_break: /* CIL Label */;
25904|      0|    }
25905|      0|    tp = meridian_table;
25906|      0|    {
25907|      0|      while (1) {
25908|      0|      while_continue___0: /* CIL Label */;
25909|      0|        if (!tp->name) {
25910|      0|          goto while_break___0;
25911|      0|        }
25912|      0|        { tmp___1 = strcmp((char const *)word, (char const *)tp->name); }
25913|      0|        if (tmp___1 == 0) {
25914|      0|          return (tp);
25915|      0|        }
25916|      0|        tp++;
25917|      0|      }
25918|      0|    while_break___0: /* CIL Label */;
25919|      0|    }
25920|      0|    { wordlen = strlen((char const *)word); }
25921|      0|    if (wordlen == 3UL) {
25922|      0|      tmp___10 = 1;
25923|      0|    } else {
25924|      0|      if (wordlen == 4UL) {
25925|      0|        if ((int)*(word + 3) == 46) {
25926|      0|          tmp___10 = 1;
25927|      0|        } else {
25928|      0|          tmp___10 = 0;
25929|      0|        }
25930|      0|      } else {
25931|      0|        tmp___10 = 0;
25932|      0|      }
25933|      0|    }
25934|      0|    abbrev = (_Bool)tmp___10;
25935|      0|    tp = month_and_day_table;
25936|      0|    {
25937|      0|      while (1) {
25938|      0|      while_continue___1: /* CIL Label */;
25939|      0|        if (!tp->name) {
25940|      0|          goto while_break___1;
25941|      0|        }
25942|      0|        if (abbrev) {
25943|      0|          {
25944|      0|            tmp___2 =
25945|      0|                strncmp((char const *)word, (char const *)tp->name, (size_t)3);
25946|      0|            tmp___4 = tmp___2;
25947|      0|          }
25948|      0|        } else {
25949|      0|          {
25950|      0|            tmp___3 = strcmp((char const *)word, (char const *)tp->name);
25951|      0|            tmp___4 = tmp___3;
25952|      0|          }
25953|      0|        }
25954|      0|        if (tmp___4 == 0) {
25955|      0|          return (tp);
25956|      0|        }
25957|      0|        tp++;
25958|      0|      }
25959|      0|    while_break___1: /* CIL Label */;
25960|      0|    }
25961|      0|    { tp = lookup_zone(pc, (char const *)word); }
25962|      0|    if (tp) {
25963|      0|      return (tp);
25964|      0|    }
25965|      0|    { tmp___5 = strcmp((char const *)word, (char const *)dst_table[0].name); }
25966|      0|    if (tmp___5 == 0) {
25967|      0|      return (dst_table);
25968|      0|    }
25969|      0|    tp = time_units_table;
25970|      0|    {
25971|      0|      while (1) {
25972|      0|      while_continue___2: /* CIL Label */;
25973|      0|        if (!tp->name) {
25974|      0|          goto while_break___2;
25975|      0|        }
25976|      0|        { tmp___6 = strcmp((char const *)word, (char const *)tp->name); }
25977|      0|        if (tmp___6 == 0) {
25978|      0|          return (tp);
25979|      0|        }
25980|      0|        tp++;
25981|      0|      }
25982|      0|    while_break___2: /* CIL Label */;
25983|      0|    }
25984|      0|    if ((int)*(word + (wordlen - 1UL)) == 83) {
25985|      0|      *(word + (wordlen - 1UL)) = (char)'\000';
25986|      0|      tp = time_units_table;
25987|      0|      {
25988|      0|        while (1) {
25989|      0|        while_continue___3: /* CIL Label */;
25990|      0|          if (!tp->name) {
25991|      0|            goto while_break___3;
25992|      0|          }
25993|      0|          { tmp___7 = strcmp((char const *)word, (char const *)tp->name); }
25994|      0|          if (tmp___7 == 0) {
25995|      0|            return (tp);
25996|      0|          }
25997|      0|          tp++;
25998|      0|        }
25999|      0|      while_break___3: /* CIL Label */;
26000|      0|      }
26001|      0|      *(word + (wordlen - 1UL)) = (char)'S';
26002|      0|    }
26003|      0|    tp = relative_time_table;
26004|      0|    {
26005|      0|      while (1) {
26006|      0|      while_continue___4: /* CIL Label */;
26007|      0|        if (!tp->name) {
26008|      0|          goto while_break___4;
26009|      0|        }
26010|      0|        { tmp___8 = strcmp((char const *)word, (char const *)tp->name); }
26011|      0|        if (tmp___8 == 0) {
26012|      0|          return (tp);
26013|      0|        }
26014|      0|        tp++;
26015|      0|      }
26016|      0|    while_break___4: /* CIL Label */;
26017|      0|    }
26018|      0|    if (wordlen == 1UL) {
26019|      0|      tp = military_table;
26020|      0|      {
26021|      0|        while (1) {
26022|      0|        while_continue___5: /* CIL Label */;
26023|      0|          if (!tp->name) {
26024|      0|            goto while_break___5;
26025|      0|          }
26026|      0|          if ((int)*(word + 0) == (int)*(tp->name + 0)) {
26027|      0|            return (tp);
26028|      0|          }
26029|      0|          tp++;
26030|      0|        }
26031|      0|      while_break___5: /* CIL Label */;
26032|      0|      }
26033|      0|    }
26034|      0|    period_found = (_Bool)0;
26035|      0|    q = word;
26036|      0|    p = q;
26037|      0|    {
26038|      0|      while (1) {
26039|      0|      while_continue___6: /* CIL Label */;
26040|      0|        tmp___9 = *q;
26041|      0|        *p = tmp___9;
26042|      0|        if (!tmp___9) {
26043|      0|          goto while_break___6;
26044|      0|        }
26045|      0|        if ((int)*q == 46) {
26046|      0|          period_found = (_Bool)1;
26047|      0|        } else {
26048|      0|          p++;
26049|      0|        }
26050|      0|        q++;
26051|      0|      }
26052|      0|    while_break___6: /* CIL Label */;
26053|      0|    }
26054|      0|    if (period_found) {
26055|      0|      {
26056|      0|        tp = lookup_zone(pc, (char const *)word);
26057|      0|      }
26058|      0|      if (tp) {
26059|      0|        return (tp);
26060|      0|      }
26061|      0|    }
26062|      0|    return ((table const *)0);
26063|      0|  }
26064|      0|}
26065|      0|static int yylex(YYSTYPE *lvalp, parser_control *pc) {
26066|      0|  unsigned char c;
26067|      0|  size_t count;
26068|      0|  unsigned short const **tmp;
26069|      0|  char const *p;
26070|      0|  int sign;
26071|      0|  unsigned long value;
26072|      0|  unsigned long value1;
26073|      0|  time_t s;
26074|      0|  int ns;
26075|      0|  int digits;
26076|      0|  unsigned long value1___0;
26077|      0|  char const *tmp___0;
26078|      0|  char const *tmp___1;
26079|      0|  char buff[20];
26080|      0|  char *p___0;
26081|      0|  table const *tp;
26082|      0|  char *tmp___2;
26083|      0|  unsigned short const **tmp___3;
26084|      0|  unsigned short const **tmp___4;
26085|      0|  char const *tmp___5;
26086|      0|  char const *tmp___6;
26087|      0|  int tmp___7;
26088|      0|  int tmp___8;
26089|      0|  void *__cil_tmp26;
26090|       |
26091|      0|  {
26092|      0|    {
26093|      0|      while (1) {
26094|      0|      while_continue: /* CIL Label */;
26095|      0|        {
26096|      0|          while (1) {
26097|      0|          while_continue___0: /* CIL Label */;
26098|      0|            {
26099|      0|              c = (unsigned char)*(pc->input);
26100|      0|              tmp = __ctype_b_loc();
26101|      0|            }
26102|      0|            if (!(((int const) * (*tmp + (int)c) & 8192) != 0)) {
26103|      0|              goto while_break___0;
26104|      0|            }
26105|      0|            (pc->input)++;
26106|      0|          }
26107|      0|        while_break___0: /* CIL Label */;
26108|      0|        }
26109|      0|        if ((unsigned int)c - 48U <= 9U) {
26110|      0|          goto _L___6;
26111|      0|        } else {
26112|      0|          if ((int)c == 45) {
26113|      0|            goto _L___6;
26114|      0|          } else {
26115|      0|            if ((int)c == 43) {
26116|      0|            _L___6: /* CIL Label */
26117|      0|              if ((int)c == 45) {
26118|      0|                goto _L___3;
26119|      0|              } else {
26120|      0|                if ((int)c == 43) {
26121|      0|                _L___3: /* CIL Label */
26122|      0|                  if ((int)c == 45) {
26123|      0|                    sign = -1;
26124|      0|                  } else {
26125|      0|                    sign = 1;
26126|      0|                  }
26127|      0|                  (pc->input)++;
26128|      0|                  c = (unsigned char)*(pc->input);
26129|      0|                  if (!((unsigned int)c - 48U <= 9U)) {
26130|      0|                    goto __Cont;
26131|      0|                  }
26132|      0|                } else {
26133|      0|                  sign = 0;
26134|      0|                }
26135|      0|              }
26136|      0|              p = pc->input;
26137|      0|              value = 0UL;
26138|      0|              {
26139|      0|                while (1) {
26140|      0|                while_continue___1: /* CIL Label */;
26141|      0|                  value1 = value + (unsigned long)((int)c - 48);
26142|      0|                  if (value1 < value) {
26143|      0|                    return ('?');
26144|      0|                  }
26145|      0|                  value = value1;
26146|      0|                  p++;
26147|      0|                  c = (unsigned char)*p;
26148|      0|                  if (!((unsigned int)c - 48U <= 9U)) {
26149|      0|                    goto while_break___1;
26150|      0|                  }
26151|      0|                  if (1844674407370955161UL < value) {
26152|      0|                    return ('?');
26153|      0|                  }
26154|      0|                  value *= 10UL;
26155|      0|                }
26156|      0|              while_break___1: /* CIL Label */;
26157|      0|              }
26158|      0|              if ((int)c == 46) {
26159|      0|                goto _L___5;
26160|      0|              } else {
26161|      0|                if ((int)c == 44) {
26162|      0|                _L___5: /* CIL Label */
26163|      0|                  if ((unsigned int)*(p + 1) - 48U <= 9U) {
26164|      0|                    if (sign < 0) {
26165|      0|                      s = (time_t)(-value);
26166|      0|                      if (0L < s) {
26167|      0|                        return ('?');
26168|      0|                      }
26169|      0|                      value1___0 = (unsigned long)(-s);
26170|      0|                    } else {
26171|      0|                      s = (time_t)value;
26172|      0|                      if (s < 0L) {
26173|      0|                        return ('?');
26174|      0|                      }
26175|      0|                      value1___0 = (unsigned long)s;
26176|      0|                    }
26177|      0|                    if (value != value1___0) {
26178|      0|                      return ('?');
26179|      0|                    }
26180|      0|                    p++;
26181|      0|                    tmp___0 = p;
26182|      0|                    p++;
26183|      0|                    ns = (int)((int const) * tmp___0 - 48);
26184|      0|                    digits = 2;
26185|      0|                    {
26186|      0|                      while (1) {
26187|      0|                      while_continue___2: /* CIL Label */;
26188|      0|                        if (!(digits <= 9)) {
26189|      0|                          goto while_break___2;
26190|      0|                        }
26191|      0|                        ns *= 10;
26192|      0|                        if ((unsigned int)*p - 48U <= 9U) {
26193|      0|                          tmp___1 = p;
26194|      0|                          p++;
26195|      0|                          ns += (int)((int const) * tmp___1 - 48);
26196|      0|                        }
26197|      0|                        digits++;
26198|      0|                      }
26199|      0|                    while_break___2: /* CIL Label */;
26200|      0|                    }
26201|      0|                    if (sign < 0) {
26202|      0|                      {
26203|      0|                        while (1) {
26204|      0|                        while_continue___3: /* CIL Label */;
26205|      0|                          if (!((unsigned int)*p - 48U <= 9U)) {
26206|      0|                            goto while_break___3;
26207|      0|                          }
26208|      0|                          if ((int const) * p != 48) {
26209|      0|                            ns++;
26210|      0|                            goto while_break___3;
26211|      0|                          }
26212|      0|                          p++;
26213|      0|                        }
26214|      0|                      while_break___3: /* CIL Label */;
26215|      0|                      }
26216|      0|                    }
26217|      0|                    {
26218|      0|                      while (1) {
26219|      0|                      while_continue___4: /* CIL Label */;
26220|      0|                        if (!((unsigned int)*p - 48U <= 9U)) {
26221|      0|                          goto while_break___4;
26222|      0|                        }
26223|      0|                        p++;
26224|      0|                      }
26225|      0|                    while_break___4: /* CIL Label */;
26226|      0|                    }
26227|      0|                    if (sign < 0) {
26228|      0|                      if (ns) {
26229|      0|                        s--;
26230|      0|                        if (!(s < 0L)) {
26231|      0|                          return ('?');
26232|      0|                        }
26233|      0|                        ns = 1000000000 - ns;
26234|      0|                      }
26235|      0|                    }
26236|      0|                    lvalp->timespec.tv_sec = s;
26237|      0|                    lvalp->timespec.tv_nsec = (__syscall_slong_t)ns;
26238|      0|                    pc->input = p;
26239|      0|                    if (sign) {
26240|      0|                      tmp___7 = 273;
26241|      0|                    } else {
26242|      0|                      tmp___7 = 274;
26243|      0|                    }
26244|      0|                    return (tmp___7);
26245|      0|                  } else {
26246|      0|                    goto _L___4;
26247|      0|                  }
26248|      0|                } else {
26249|      0|                _L___4: /* CIL Label */
26250|      0|                  if (sign < 0) {
26251|      0|                    lvalp->textintval.value = (long)(-value);
26252|      0|                    if (0L < lvalp->textintval.value) {
26253|      0|                      return ('?');
26254|      0|                    }
26255|      0|                  } else {
26256|      0|                    lvalp->textintval.value = (long)value;
26257|      0|                    if (lvalp->textintval.value < 0L) {
26258|      0|                      return ('?');
26259|      0|                    }
26260|      0|                  }
26261|      0|                  lvalp->textintval.digits = (size_t)(p - pc->input);
26262|      0|                  pc->input = p;
26263|      0|                  if (sign) {
26264|      0|                    tmp___8 = 271;
26265|      0|                  } else {
26266|      0|                    tmp___8 = 272;
26267|      0|                  }
26268|      0|                  return (tmp___8);
26269|      0|                }
26270|      0|              }
26271|      0|            }
26272|      0|          }
26273|      0|        }
26274|      0|        { tmp___4 = __ctype_b_loc(); }
26275|      0|        if ((int const) * (*tmp___4 + (int)c) & 1024) {
26276|      0|          p___0 = buff;
26277|      0|          {
26278|      0|            while (1) {
26279|      0|            while_continue___5: /* CIL Label */;
26280|      0|              if ((unsigned long)p___0 <
26281|      0|                  (unsigned long)((buff + sizeof(buff)) - 1)) {
26282|      0|                tmp___2 = p___0;
26283|      0|                p___0++;
26284|      0|                *tmp___2 = (char)c;
26285|      0|              }
26286|      0|              {
26287|      0|                (pc->input)++;
26288|      0|                c = (unsigned char)*(pc->input);
26289|      0|                tmp___3 = __ctype_b_loc();
26290|      0|              }
26291|      0|              if (!((int const) * (*tmp___3 + (int)c) & 1024)) {
26292|      0|                if (!((int)c == 46)) {
26293|      0|                  goto while_break___5;
26294|      0|                }
26295|      0|              }
26296|      0|            }
26297|      0|          while_break___5: /* CIL Label */;
26298|      0|          }
26299|      0|          {
26300|      0|            *p___0 = (char)'\000';
26301|      0|            tp = lookup_word((parser_control const *)pc, buff);
26302|      0|          }
26303|      0|          if (!tp) {
26304|      0|            return ('?');
26305|      0|          }
26306|      0|          lvalp->intval = (long)tp->value;
26307|      0|          return ((int)tp->type);
26308|      0|        }
26309|      0|        if ((int)c != 40) {
26310|      0|          tmp___5 = pc->input;
26311|      0|          (pc->input)++;
26312|      0|          return ((int)*tmp___5);
26313|      0|        }
26314|      0|        count = (size_t)0;
26315|      0|        {
26316|      0|          while (1) {
26317|      0|          while_continue___6: /* CIL Label */;
26318|      0|            tmp___6 = pc->input;
26319|      0|            (pc->input)++;
26320|      0|            c = (unsigned char)*tmp___6;
26321|      0|            if ((int)c == 0) {
26322|      0|              return ((int)c);
26323|      0|            }
26324|      0|            if ((int)c == 40) {
26325|      0|              count++;
26326|      0|            } else {
26327|      0|              if ((int)c == 41) {
26328|      0|                count--;
26329|      0|              }
26330|      0|            }
26331|      0|            if (!(count != 0UL)) {
26332|      0|              goto while_break___6;
26333|      0|            }
26334|      0|          }
26335|      0|        while_break___6: /* CIL Label */;
26336|      0|        }
26337|      0|      __Cont:;
26338|      0|      }
26339|      0|    while_break: /* CIL Label */;
26340|      0|    }
26341|      0|  }
26342|      0|}
26343|      0|static int yyerror(char *s __attribute__((__unused__))) {
26344|       |
26345|      0|  { return (0); }
26346|      0|}
26347|       |_Bool get_date(struct timespec *result, char const *p,
26348|      0|               struct timespec const *now) {
26349|      0|  time_t Start;
26350|      0|  long Start_ns;
26351|      0|  struct tm const *tmp;
26352|      0|  struct tm tm;
26353|      0|  struct tm tm0;
26354|      0|  parser_control pc;
26355|      0|  struct timespec gettime_buffer;
26356|      0|  int tmp___0;
26357|      0|  struct tm *tmp___1;
26358|      0|  int quarter;
26359|      0|  time_t probe;
26360|      0|  struct tm const *probe_tm;
26361|      0|  struct tm *tmp___2;
26362|      0|  int tmp___3;
26363|      0|  int tmp___4;
26364|      0|  long tmp___5;
26365|      0|  long delta;
26366|      0|  time_t t1;
26367|      0|  long sum_ns;
26368|      0|  long normalized_ns;
26369|      0|  time_t t0;
26370|      0|  long d1;
26371|      0|  time_t t1___0;
26372|      0|  long d2;
26373|      0|  time_t t2;
26374|      0|  long d3;
26375|      0|  time_t t3;
26376|      0|  long d4;
26377|      0|  time_t t4;
26378|      0|  void *__cil_tmp33;
26379|      0|  int __cil_tmp34;
26380|       |
26381|      0|  {
26382|      0|    if (!now) {
26383|      0|      {
26384|      0|        tmp___0 = gettime(&gettime_buffer);
26385|      0|      }
26386|      0|      if (tmp___0 != 0) {
26387|      0|        return ((_Bool)0);
26388|      0|      }
26389|      0|      now = (struct timespec const *)(&gettime_buffer);
26390|      0|    }
26391|      0|    {
26392|      0|      Start = (time_t)now->tv_sec;
26393|      0|      Start_ns = (long)now->tv_nsec;
26394|      0|      tmp___1 = localtime(&now->tv_sec);
26395|      0|      tmp = (struct tm const *)tmp___1;
26396|      0|    }
26397|      0|    if (!tmp) {
26398|      0|      return ((_Bool)0);
26399|      0|    }
26400|      0|    pc.input = p;
26401|      0|    pc.year.value = (long)tmp->tm_year;
26402|      0|    pc.year.value += 1900L;
26403|      0|    pc.year.digits = (size_t)4;
26404|      0|    pc.month = (long)(tmp->tm_mon + 1);
26405|      0|    pc.day = (long)tmp->tm_mday;
26406|      0|    pc.hour = (long)tmp->tm_hour;
26407|      0|    pc.minutes = (long)tmp->tm_min;
26408|      0|    pc.seconds.tv_sec = (__time_t)tmp->tm_sec;
26409|      0|    pc.seconds.tv_nsec = Start_ns;
26410|      0|    tm.tm_isdst = (int)tmp->tm_isdst;
26411|      0|    pc.meridian = 2;
26412|      0|    pc.rel_ns = 0L;
26413|      0|    pc.rel_seconds = 0L;
26414|      0|    pc.rel_minutes = 0L;
26415|      0|    pc.rel_hour = 0L;
26416|      0|    pc.rel_day = 0L;
26417|      0|    pc.rel_month = 0L;
26418|      0|    pc.rel_year = 0L;
26419|      0|    pc.timespec_seen = (_Bool)0;
26420|      0|    pc.dates_seen = (size_t)0;
26421|      0|    pc.days_seen = (size_t)0;
26422|      0|    pc.rels_seen = (size_t)0;
26423|      0|    pc.times_seen = (size_t)0;
26424|      0|    pc.local_zones_seen = (size_t)0;
26425|      0|    pc.zones_seen = (size_t)0;
26426|      0|    pc.local_time_zone_table[0].name = (char const *)tmp->tm_zone;
26427|      0|    pc.local_time_zone_table[0].type = 263;
26428|      0|    pc.local_time_zone_table[0].value = (int)tmp->tm_isdst;
26429|      0|    pc.local_time_zone_table[1].name = (char const *)0;
26430|      0|    quarter = 1;
26431|      0|    {
26432|      0|      while (1) {
26433|      0|      while_continue: /* CIL Label */;
26434|      0|        if (!(quarter <= 3)) {
26435|      0|          goto while_break;
26436|      0|        }
26437|      0|        {
26438|      0|          probe = Start + (time_t)(quarter * 7776000);
26439|      0|          tmp___2 = localtime((time_t const *)(&probe));
26440|      0|          probe_tm = (struct tm const *)tmp___2;
26441|      0|        }
26442|      0|        if (probe_tm) {
26443|      0|          if (probe_tm->tm_zone) {
26444|      0|            if (probe_tm->tm_isdst !=
26445|      0|                (int const)pc.local_time_zone_table[0].value) {
26446|      0|              pc.local_time_zone_table[1].name =
26447|      0|                  (char const *)probe_tm->tm_zone;
26448|      0|              pc.local_time_zone_table[1].type = 263;
26449|      0|              pc.local_time_zone_table[1].value = (int)probe_tm->tm_isdst;
26450|      0|              pc.local_time_zone_table[2].name = (char const *)0;
26451|      0|              goto while_break;
26452|      0|            }
26453|      0|          }
26454|      0|        }
26455|      0|        quarter++;
26456|      0|      }
26457|      0|    while_break: /* CIL Label */;
26458|      0|    }
26459|      0|    if (pc.local_time_zone_table[0].name) {
26460|      0|      if (pc.local_time_zone_table[1].name) {
26461|      0|        {
26462|      0|          tmp___3 = strcmp(pc.local_time_zone_table[0].name,
26463|      0|                           pc.local_time_zone_table[1].name);
26464|      0|        }
26465|      0|        if (!tmp___3) {
26466|      0|          pc.local_time_zone_table[0].value = -1;
26467|      0|          pc.local_time_zone_table[1].name = (char const *)0;
26468|      0|        }
26469|      0|      }
26470|      0|    }
26471|      0|    { tmp___4 = yyparse((void *)(&pc)); }
26472|      0|    if (tmp___4 != 0) {
26473|      0|      return ((_Bool)0);
26474|      0|    }
26475|      0|    if (pc.timespec_seen) {
26476|      0|      *result = pc.seconds;
26477|      0|      return ((_Bool)1);
26478|      0|    }
26479|      0|    if (1UL < pc.times_seen) {
26480|      0|      return ((_Bool)0);
26481|      0|    } else {
26482|      0|      if (1UL < pc.dates_seen) {
26483|      0|        return ((_Bool)0);
26484|      0|      } else {
26485|      0|        if (1UL < pc.days_seen) {
26486|      0|          return ((_Bool)0);
26487|      0|        } else {
26488|      0|          if (1UL < pc.local_zones_seen + pc.zones_seen) {
26489|      0|            return ((_Bool)0);
26490|      0|          } else {
26491|      0|            if (pc.local_zones_seen) {
26492|      0|              if (1 < pc.local_isdst) {
26493|      0|                return ((_Bool)0);
26494|      0|              }
26495|      0|            }
26496|      0|          }
26497|      0|        }
26498|      0|      }
26499|      0|    }
26500|      0|    {
26501|      0|      tmp___5 = to_year(pc.year);
26502|      0|      tm.tm_year = (int)((tmp___5 - 1900L) + pc.rel_year);
26503|      0|      tm.tm_mon = (int)((pc.month - 1L) + pc.rel_month);
26504|      0|      tm.tm_mday = (int)(pc.day + pc.rel_day);
26505|      0|    }
26506|      0|    if (pc.times_seen) {
26507|      0|      goto _L___3;
26508|      0|    } else {
26509|      0|      if (pc.rels_seen) {
26510|      0|        if (!pc.dates_seen) {
26511|      0|          if (!pc.days_seen) {
26512|      0|          _L___3 : /* CIL Label */
26513|      0|          {
26514|      0|            tm.tm_hour = to_hour(pc.hour, pc.meridian);
26515|      0|          }
26516|      0|            if (tm.tm_hour < 0) {
26517|      0|              return ((_Bool)0);
26518|      0|            }
26519|      0|            tm.tm_min = (int)pc.minutes;
26520|      0|            tm.tm_sec = (int)pc.seconds.tv_sec;
26521|      0|          } else {
26522|      0|            tm.tm_sec = 0;
26523|      0|            tm.tm_min = tm.tm_sec;
26524|      0|            tm.tm_hour = tm.tm_min;
26525|      0|            pc.seconds.tv_nsec = (__syscall_slong_t)0;
26526|      0|          }
26527|      0|        } else {
26528|      0|          tm.tm_sec = 0;
26529|      0|          tm.tm_min = tm.tm_sec;
26530|      0|          tm.tm_hour = tm.tm_min;
26531|      0|          pc.seconds.tv_nsec = (__syscall_slong_t)0;
26532|      0|        }
26533|      0|      } else {
26534|      0|        tm.tm_sec = 0;
26535|      0|        tm.tm_min = tm.tm_sec;
26536|      0|        tm.tm_hour = tm.tm_min;
26537|      0|        pc.seconds.tv_nsec = (__syscall_slong_t)0;
26538|      0|      }
26539|      0|    }
26540|      0|    if (((((pc.dates_seen | pc.days_seen) | pc.times_seen) |
26541|      0|          (unsigned long)pc.rel_day) |
26542|      0|         (unsigned long)pc.rel_month) |
26543|      0|        (unsigned long)pc.rel_year) {
26544|      0|      tm.tm_isdst = -1;
26545|      0|    }
26546|      0|    if (pc.local_zones_seen) {
26547|      0|      tm.tm_isdst = pc.local_isdst;
26548|      0|    }
26549|      0|    {
26550|      0|      tm0 = tm;
26551|      0|      Start = rpl_mktime(&tm);
26552|      0|    }
26553|      0|    if (Start == -1L) {
26554|      0|      if (pc.zones_seen) {
26555|      0|        tm = tm0;
26556|      0|        if (tm.tm_year <= 70) {
26557|      0|          (tm.tm_mday)++;
26558|      0|          pc.time_zone += 1440L;
26559|      0|        } else {
26560|      0|          (tm.tm_mday)--;
26561|      0|          pc.time_zone -= 1440L;
26562|      0|        }
26563|      0|        { Start = rpl_mktime(&tm); }
26564|      0|      }
26565|      0|      if (Start == -1L) {
26566|      0|        return ((_Bool)0);
26567|      0|      }
26568|      0|    }
26569|      0|    if (pc.days_seen) {
26570|      0|      if (!pc.dates_seen) {
26571|      0|        {
26572|      0|          tm.tm_mday =
26573|      0|              (int)((long)tm.tm_mday +
26574|      0|                    ((long)(((pc.day_number - tm.tm_wday) + 7) % 7) +
26575|      0|                     7L * (pc.day_ordinal - (long)(0L < pc.day_ordinal))));
26576|      0|          tm.tm_isdst = -1;
26577|      0|          Start = rpl_mktime(&tm);
26578|      0|        }
26579|      0|        if (Start == -1L) {
26580|      0|          return ((_Bool)0);
26581|      0|        }
26582|      0|      }
26583|      0|    }
26584|      0|    if (pc.zones_seen) {
26585|      0|      delta = pc.time_zone * 60L;
26586|      0|      delta -= tm.tm_gmtoff;
26587|      0|      t1 = Start - delta;
26588|      0|      if ((Start < t1) != (delta < 0L)) {
26589|      0|        return ((_Bool)0);
26590|      0|      }
26591|      0|      Start = t1;
26592|      0|    }
26593|      0|    sum_ns = pc.seconds.tv_nsec + pc.rel_ns;
26594|      0|    normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
26595|      0|    t0 = Start;
26596|      0|    d1 = 3600L * pc.rel_hour;
26597|      0|    t1___0 = t0 + d1;
26598|      0|    d2 = 60L * pc.rel_minutes;
26599|      0|    t2 = t1___0 + d2;
26600|      0|    d3 = pc.rel_seconds;
26601|      0|    t3 = t2 + d3;
26602|      0|    d4 = (sum_ns - normalized_ns) / 1000000000L;
26603|      0|    t4 = t3 + d4;
26604|      0|    if ((((((d1 / 3600L ^ pc.rel_hour) | (d2 / 60L ^ pc.rel_minutes)) |
26605|      0|           (long)((t1___0 < t0) ^ (d1 < 0L))) |
26606|      0|          (long)((t2 < t1___0) ^ (d2 < 0L))) |
26607|      0|         (long)((t3 < t2) ^ (d3 < 0L))) |
26608|      0|        (long)((t4 < t3) ^ (d4 < 0L))) {
26609|      0|      return ((_Bool)0);
26610|      0|    }
26611|      0|    result->tv_sec = t4;
26612|      0|    result->tv_nsec = normalized_ns;
26613|      0|    return ((_Bool)1);
26614|      0|  }
26615|      0|}
26616|       |/* #pragma merger("0","01a.getopt1.o.i","") */
26617|       |/* #pragma merger("0","01b.getopt.o.i","") */
26618|       |/* #pragma merger("0","01c.gettime.o.i","") */
26619|       |extern __attribute__((__nothrow__)) int(
26620|       |    __attribute__((__nonnull__(1), __leaf__))
26621|       |    gettimeofday)(struct timeval *__restrict __tv, __timezone_ptr_t __tz);
26622|      0|int gettime(struct timespec *ts) {
26623|      0|  int tmp;
26624|      0|  struct timeval tv;
26625|      0|  int r;
26626|      0|  int tmp___0;
26627|       |
26628|      0|  {
26629|      0|    { tmp = clock_gettime(0, ts); }
26630|      0|    if (tmp == 0) {
26631|      0|      return (0);
26632|      0|    }
26633|      0|    {
26634|      0|      tmp___0 = gettimeofday((struct timeval * /* __restrict  */)(&tv),
26635|      0|                             (__timezone_ptr_t)0);
26636|      0|      r = tmp___0;
26637|      0|    }
26638|      0|    if (r == 0) {
26639|      0|      ts->tv_sec = tv.tv_sec;
26640|      0|      ts->tv_nsec = tv.tv_usec * 1000L;
26641|      0|    }
26642|      0|    return (r);
26643|      0|  }
26644|      0|}
26645|       |/* #pragma merger("0","01d.hash.o.i","") */
26646|       |_Bool hash_rehash(Hash_table *table___0, size_t candidate);
26647|       |static struct hash_tuning const default_tuning = {
26648|       |    (float)0.0, (float)1.0, (float)0.8, (float)1.414, (_Bool)0};
26649|      0|void *hash_lookup(Hash_table const *table___0, void const *entry) {
26650|      0|  struct hash_entry const *bucket;
26651|      0|  size_t tmp;
26652|      0|  struct hash_entry const *cursor;
26653|      0|  _Bool tmp___0;
26654|       |
26655|      0|  {
26656|      0|    {
26657|      0|      tmp = (*(table___0->hasher))(entry, (size_t)table___0->n_buckets);
26658|      0|      bucket = (struct hash_entry const *)(table___0->bucket + tmp);
26659|      0|    }
26660|      0|    if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
26661|      0|      {
26662|      0|        abort();
26663|      0|      }
26664|      0|    }
26665|      0|    if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
26666|      0|      return ((void *)0);
26667|      0|    }
26668|      0|    cursor = bucket;
26669|      0|    {
26670|      0|      while (1) {
26671|      0|      while_continue: /* CIL Label */;
26672|      0|        if (!cursor) {
26673|      0|          goto while_break;
26674|      0|        }
26675|      0|        {
26676|      0|          tmp___0 =
26677|      0|              (*(table___0->comparator))(entry, (void const *)cursor->data);
26678|      0|        }
26679|      0|        if (tmp___0) {
26680|      0|          return ((void *)cursor->data);
26681|      0|        }
26682|      0|        cursor = (struct hash_entry const *)cursor->next;
26683|      0|      }
26684|      0|    while_break: /* CIL Label */;
26685|      0|    }
26686|      0|    return ((void *)0);
26687|      0|  }
26688|      0|}
26689|      0|void *hash_get_first(Hash_table const *table___0) {
26690|      0|  struct hash_entry const *bucket;
26691|       |
26692|      0|  {
26693|      0|    if (table___0->n_entries == 0UL) {
26694|      0|      return ((void *)0);
26695|      0|    }
26696|      0|    bucket = (struct hash_entry const *)table___0->bucket;
26697|      0|    {
26698|      0|      while (1) {
26699|      0|      while_continue: /* CIL Label */;
26700|      0|        if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
26701|      0|          {
26702|      0|            abort();
26703|      0|          }
26704|      0|        } else {
26705|      0|          if (bucket->data) {
26706|      0|            return ((void *)bucket->data);
26707|      0|          }
26708|      0|        }
26709|      0|        bucket++;
26710|      0|      }
26711|      0|    while_break: /* CIL Label */;
26712|      0|    }
26713|      0|  }
26714|      0|}
26715|      0|void *hash_get_next(Hash_table const *table___0, void const *entry) {
26716|      0|  struct hash_entry const *bucket;
26717|      0|  size_t tmp;
26718|      0|  struct hash_entry const *cursor;
26719|       |
26720|      0|  {
26721|      0|    {
26722|      0|      tmp = (*(table___0->hasher))(entry, (size_t)table___0->n_buckets);
26723|      0|      bucket = (struct hash_entry const *)(table___0->bucket + tmp);
26724|      0|    }
26725|      0|    if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
26726|      0|      {
26727|      0|        abort();
26728|      0|      }
26729|      0|    }
26730|      0|    cursor = bucket;
26731|      0|    {
26732|      0|      while (1) {
26733|      0|      while_continue: /* CIL Label */;
26734|      0|        if (!cursor) {
26735|      0|          goto while_break;
26736|      0|        }
26737|      0|        if ((unsigned long)cursor->data == (unsigned long)entry) {
26738|      0|          if (cursor->next) {
26739|      0|            return ((cursor->next)->data);
26740|      0|          }
26741|      0|        }
26742|      0|        cursor = (struct hash_entry const *)cursor->next;
26743|      0|      }
26744|      0|    while_break: /* CIL Label */;
26745|      0|    }
26746|      0|    {
26747|      0|      while (1) {
26748|      0|      while_continue___0: /* CIL Label */;
26749|      0|        bucket++;
26750|      0|        if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
26751|      0|          goto while_break___0;
26752|      0|        }
26753|      0|        if (bucket->data) {
26754|      0|          return ((void *)bucket->data);
26755|      0|        }
26756|      0|      }
26757|      0|    while_break___0: /* CIL Label */;
26758|      0|    }
26759|      0|    return ((void *)0);
26760|      0|  }
26761|      0|}
26762|       |size_t hash_do_for_each(Hash_table const *table___0,
26763|       |                        _Bool (*processor)(void *, void *),
26764|      0|                        void *processor_data) {
26765|      0|  size_t counter;
26766|      0|  struct hash_entry const *bucket;
26767|      0|  struct hash_entry const *cursor;
26768|      0|  _Bool tmp;
26769|       |
26770|      0|  {
26771|      0|    counter = (size_t)0;
26772|      0|    bucket = (struct hash_entry const *)table___0->bucket;
26773|      0|    {
26774|      0|      while (1) {
26775|      0|      while_continue: /* CIL Label */;
26776|      0|        if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
26777|      0|          goto while_break;
26778|      0|        }
26779|      0|        if (bucket->data) {
26780|      0|          cursor = bucket;
26781|      0|          {
26782|      0|            while (1) {
26783|      0|            while_continue___0: /* CIL Label */;
26784|      0|              if (!cursor) {
26785|      0|                goto while_break___0;
26786|      0|              }
26787|      0|              { tmp = (*processor)((void *)cursor->data, processor_data); }
26788|      0|              if (!tmp) {
26789|      0|                return (counter);
26790|      0|              }
26791|      0|              counter++;
26792|      0|              cursor = (struct hash_entry const *)cursor->next;
26793|      0|            }
26794|      0|          while_break___0: /* CIL Label */;
26795|      0|          }
26796|      0|        }
26797|      0|        bucket++;
26798|      0|      }
26799|      0|    while_break: /* CIL Label */;
26800|      0|    }
26801|      0|    return (counter);
26802|      0|  }
26803|      0|}
26804|      0|size_t hash_string(char const *string, size_t n_buckets) {
26805|      0|  size_t value;
26806|      0|  char const *tmp;
26807|       |
26808|      0|  {
26809|      0|    value = (size_t)0;
26810|      0|    {
26811|      0|      while (1) {
26812|      0|      while_continue: /* CIL Label */;
26813|      0|        if (!*string) {
26814|      0|          goto while_break;
26815|      0|        }
26816|      0|        tmp = string;
26817|      0|        string++;
26818|      0|        value = (value * 31UL + (size_t)((unsigned char)*tmp)) % n_buckets;
26819|      0|      }
26820|      0|    while_break: /* CIL Label */;
26821|      0|    }
26822|      0|    return (value);
26823|      0|  }
26824|      0|}
26825|      0|static _Bool is_prime(size_t candidate) {
26826|      0|  size_t divisor;
26827|      0|  size_t square;
26828|      0|  int tmp;
26829|       |
26830|      0|  {
26831|      0|    divisor = (size_t)3;
26832|      0|    square = divisor * divisor;
26833|      0|    {
26834|      0|      while (1) {
26835|      0|      while_continue: /* CIL Label */;
26836|      0|        if (square < candidate) {
26837|      0|          if (!(candidate % divisor)) {
26838|      0|            goto while_break;
26839|      0|          }
26840|      0|        } else {
26841|      0|          goto while_break;
26842|      0|        }
26843|      0|        divisor++;
26844|      0|        square += 4UL * divisor;
26845|      0|        divisor++;
26846|      0|      }
26847|      0|    while_break: /* CIL Label */;
26848|      0|    }
26849|      0|    if (candidate % divisor) {
26850|      0|      tmp = 1;
26851|      0|    } else {
26852|      0|      tmp = 0;
26853|      0|    }
26854|      0|    return ((_Bool)tmp);
26855|      0|  }
26856|      0|}
26857|      0|static size_t next_prime(size_t candidate) {
26858|      0|  _Bool tmp;
26859|       |
26860|      0|  {
26861|      0|    if (candidate < 10UL) {
26862|      0|      candidate = (size_t)10;
26863|      0|    }
26864|      0|    candidate |= 1UL;
26865|      0|    {
26866|      0|      while (1) {
26867|      0|      while_continue: /* CIL Label */;
26868|      0|        { tmp = is_prime(candidate); }
26869|      0|        if (tmp) {
26870|      0|          goto while_break;
26871|      0|        }
26872|      0|        candidate += 2UL;
26873|      0|      }
26874|      0|    while_break: /* CIL Label */;
26875|      0|    }
26876|      0|    return (candidate);
26877|      0|  }
26878|      0|}
26879|      0|static _Bool check_tuning(Hash_table *table___0) {
26880|      0|  Hash_tuning const *tuning;
26881|      0|  float epsilon;
26882|       |
26883|      0|  {
26884|      0|    tuning = table___0->tuning;
26885|      0|    epsilon = 0.1f;
26886|      0|    if (epsilon < (float)tuning->growth_threshold) {
26887|      0|      if (tuning->growth_threshold < (float const)((float)1 - epsilon)) {
26888|      0|        if ((float)1 + epsilon < (float)tuning->growth_factor) {
26889|      0|          if ((float const)0 <= tuning->shrink_threshold) {
26890|      0|            if (tuning->shrink_threshold + (float const)epsilon <
26891|      0|                tuning->shrink_factor) {
26892|      0|              if (tuning->shrink_factor <= (float const)1) {
26893|      0|                if (tuning->shrink_threshold + (float const)epsilon <
26894|      0|                    tuning->growth_threshold) {
26895|      0|                  return ((_Bool)1);
26896|      0|                }
26897|      0|              }
26898|      0|            }
26899|      0|          }
26900|      0|        }
26901|      0|      }
26902|      0|    }
26903|      0|    table___0->tuning = &default_tuning;
26904|      0|    return ((_Bool)0);
26905|      0|  }
26906|      0|}
26907|       |Hash_table *hash_initialize(size_t candidate, Hash_tuning const *tuning,
26908|       |                            size_t (*hasher)(void const *, size_t),
26909|       |                            _Bool (*comparator)(void const *, void const *),
26910|      0|                            void (*data_freer)(void *)) {
26911|      0|  Hash_table *table___0;
26912|      0|  void *tmp;
26913|      0|  _Bool tmp___0;
26914|      0|  float new_candidate;
26915|      0|  void *tmp___1;
26916|      0|  int tmp___2;
26917|      0|  int tmp___3;
26918|       |
26919|      0|  {
26920|      0|    if ((unsigned long)hasher == (unsigned long)((void *)0)) {
26921|      0|      return ((Hash_table *)((void *)0));
26922|      0|    } else {
26923|      0|      if ((unsigned long)comparator == (unsigned long)((void *)0)) {
26924|      0|        return ((Hash_table *)((void *)0));
26925|      0|      }
26926|      0|    }
26927|      0|    {
26928|      0|      tmp = malloc(sizeof(*table___0));
26929|      0|      table___0 = (Hash_table *)tmp;
26930|      0|    }
26931|      0|    if ((unsigned long)table___0 == (unsigned long)((void *)0)) {
26932|      0|      return ((Hash_table *)((void *)0));
26933|      0|    }
26934|      0|    if (!tuning) {
26935|      0|      tuning = &default_tuning;
26936|      0|    }
26937|      0|    {
26938|      0|      table___0->tuning = tuning;
26939|      0|      tmp___0 = check_tuning(table___0);
26940|      0|    }
26941|      0|    if (!tmp___0) {
26942|      0|      goto fail;
26943|      0|    }
26944|      0|    if (!tuning->is_n_buckets) {
26945|      0|      new_candidate =
26946|      0|          (float)((float const)candidate / tuning->growth_threshold);
26947|      0|      if ((float)0xffffffffffffffffUL <= new_candidate) {
26948|      0|        goto fail;
26949|      0|      }
26950|      0|      candidate = (size_t)new_candidate;
26951|      0|    }
26952|      0|    if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
26953|      0|      tmp___2 = -1;
26954|      0|    } else {
26955|      0|      tmp___2 = -2;
26956|      0|    }
26957|      0|    if ((size_t)tmp___2 / sizeof(*(table___0->bucket)) < candidate) {
26958|      0|      goto fail;
26959|      0|    }
26960|      0|    { table___0->n_buckets = next_prime(candidate); }
26961|      0|    if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
26962|      0|      tmp___3 = -1;
26963|      0|    } else {
26964|      0|      tmp___3 = -2;
26965|      0|    }
26966|      0|    if ((size_t)tmp___3 / sizeof(*(table___0->bucket)) < table___0->n_buckets) {
26967|      0|      goto fail;
26968|      0|    }
26969|      0|    {
26970|      0|      tmp___1 = calloc(table___0->n_buckets, sizeof(*(table___0->bucket)));
26971|      0|      table___0->bucket = (struct hash_entry *)tmp___1;
26972|      0|      table___0->bucket_limit =
26973|      0|          (struct hash_entry const *)(table___0->bucket + table___0->n_buckets);
26974|      0|      table___0->n_buckets_used = (size_t)0;
26975|      0|      table___0->n_entries = (size_t)0;
26976|      0|      table___0->hasher = hasher;
26977|      0|      table___0->comparator = comparator;
26978|      0|      table___0->data_freer = data_freer;
26979|      0|      table___0->free_entry_list = (struct hash_entry *)((void *)0);
26980|      0|    }
26981|      0|    return (table___0);
26982|      0|  fail : { free((void *)table___0); }
26983|      0|    return ((Hash_table *)((void *)0));
26984|      0|  }
26985|      0|}
26986|      0|static struct hash_entry *allocate_entry(Hash_table *table___0) {
26987|      0|  struct hash_entry *new;
26988|      0|  void *tmp;
26989|       |
26990|      0|  {
26991|      0|    if (table___0->free_entry_list) {
26992|      0|      new = table___0->free_entry_list;
26993|      0|      table___0->free_entry_list = new->next;
26994|      0|    } else {
26995|      0|      {
26996|      0|        tmp = malloc(sizeof(*new));
26997|      0|        new = (struct hash_entry *)tmp;
26998|      0|      }
26999|      0|    }
27000|      0|    return (new);
27001|      0|  }
27002|      0|}
27003|      0|static void free_entry(Hash_table *table___0, struct hash_entry *entry) {
27004|       |
27005|      0|  {
27006|      0|    entry->data = (void *)0;
27007|      0|    entry->next = table___0->free_entry_list;
27008|      0|    table___0->free_entry_list = entry;
27009|      0|    return;
27010|      0|  }
27011|      0|}
27012|       |static void *hash_find_entry(Hash_table *table___0, void const *entry,
27013|      0|                             struct hash_entry **bucket_head, _Bool delete) {
27014|      0|  struct hash_entry *bucket;
27015|      0|  size_t tmp;
27016|      0|  struct hash_entry *cursor;
27017|      0|  void *data;
27018|      0|  struct hash_entry *next;
27019|      0|  _Bool tmp___0;
27020|      0|  void *data___0;
27021|      0|  struct hash_entry *next___0;
27022|      0|  _Bool tmp___1;
27023|       |
27024|      0|  {
27025|      0|    {
27026|      0|      tmp = (*(table___0->hasher))(entry, table___0->n_buckets);
27027|      0|      bucket = table___0->bucket + tmp;
27028|      0|    }
27029|      0|    if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
27030|      0|      {
27031|      0|        abort();
27032|      0|      }
27033|      0|    }
27034|      0|    *bucket_head = bucket;
27035|      0|    if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
27036|      0|      return ((void *)0);
27037|      0|    }
27038|      0|    { tmp___0 = (*(table___0->comparator))(entry, (void const *)bucket->data); }
27039|      0|    if (tmp___0) {
27040|      0|      data = bucket->data;
27041|      0|      if (delete) {
27042|      0|        if (bucket->next) {
27043|      0|          {
27044|      0|            next = bucket->next;
27045|      0|            *bucket = *next;
27046|      0|            free_entry(table___0, next);
27047|      0|          }
27048|      0|        } else {
27049|      0|          bucket->data = (void *)0;
27050|      0|        }
27051|      0|      }
27052|      0|      return (data);
27053|      0|    }
27054|      0|    cursor = bucket;
27055|      0|    {
27056|      0|      while (1) {
27057|      0|      while_continue: /* CIL Label */;
27058|      0|        if (!cursor->next) {
27059|      0|          goto while_break;
27060|      0|        }
27061|      0|        {
27062|      0|          tmp___1 = (*(table___0->comparator))(
27063|      0|              entry, (void const *)(cursor->next)->data);
27064|      0|        }
27065|      0|        if (tmp___1) {
27066|      0|          data___0 = (cursor->next)->data;
27067|      0|          if (delete) {
27068|      0|            {
27069|      0|              next___0 = cursor->next;
27070|      0|              cursor->next = next___0->next;
27071|      0|              free_entry(table___0, next___0);
27072|      0|            }
27073|      0|          }
27074|      0|          return (data___0);
27075|      0|        }
27076|      0|        cursor = cursor->next;
27077|      0|      }
27078|      0|    while_break: /* CIL Label */;
27079|      0|    }
27080|      0|    return ((void *)0);
27081|      0|  }
27082|      0|}
27083|      0|_Bool hash_rehash(Hash_table *table___0, size_t candidate) {
27084|      0|  Hash_table *new_table;
27085|      0|  struct hash_entry *bucket;
27086|      0|  struct hash_entry *cursor;
27087|      0|  struct hash_entry *next;
27088|      0|  void *data;
27089|      0|  struct hash_entry *new_bucket;
27090|      0|  size_t tmp;
27091|      0|  struct hash_entry *new_entry;
27092|      0|  struct hash_entry *tmp___0;
27093|       |
27094|      0|  {
27095|      0|    {
27096|      0|      new_table =
27097|      0|          hash_initialize(candidate, table___0->tuning, table___0->hasher,
27098|      0|                          table___0->comparator, table___0->data_freer);
27099|      0|    }
27100|      0|    if ((unsigned long)new_table == (unsigned long)((void *)0)) {
27101|      0|      return ((_Bool)0);
27102|      0|    }
27103|      0|    new_table->free_entry_list = table___0->free_entry_list;
27104|      0|    bucket = table___0->bucket;
27105|      0|    {
27106|      0|      while (1) {
27107|      0|      while_continue: /* CIL Label */;
27108|      0|        if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
27109|      0|          goto while_break;
27110|      0|        }
27111|      0|        if (bucket->data) {
27112|      0|          cursor = bucket;
27113|      0|          {
27114|      0|            while (1) {
27115|      0|            while_continue___0: /* CIL Label */;
27116|      0|              if (!cursor) {
27117|      0|                goto while_break___0;
27118|      0|              }
27119|      0|              {
27120|      0|                data = cursor->data;
27121|      0|                tmp = (*(new_table->hasher))((void const *)data,
27122|      0|                                             new_table->n_buckets);
27123|      0|                new_bucket = new_table->bucket + tmp;
27124|      0|              }
27125|      0|              if (!((unsigned long)new_bucket <
27126|      0|                    (unsigned long)new_table->bucket_limit)) {
27127|      0|                {
27128|      0|                  abort();
27129|      0|                }
27130|      0|              }
27131|      0|              next = cursor->next;
27132|      0|              if (new_bucket->data) {
27133|      0|                if ((unsigned long)cursor == (unsigned long)bucket) {
27134|      0|                  {
27135|      0|                    tmp___0 = allocate_entry(new_table);
27136|      0|                    new_entry = tmp___0;
27137|      0|                  }
27138|      0|                  if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
27139|      0|                    return ((_Bool)0);
27140|      0|                  }
27141|      0|                  new_entry->data = data;
27142|      0|                  new_entry->next = new_bucket->next;
27143|      0|                  new_bucket->next = new_entry;
27144|      0|                } else {
27145|      0|                  cursor->next = new_bucket->next;
27146|      0|                  new_bucket->next = cursor;
27147|      0|                }
27148|      0|              } else {
27149|      0|                new_bucket->data = data;
27150|      0|                (new_table->n_buckets_used)++;
27151|      0|                if ((unsigned long)cursor != (unsigned long)bucket) {
27152|      0|                  {
27153|      0|                    free_entry(new_table, cursor);
27154|      0|                  }
27155|      0|                }
27156|      0|              }
27157|      0|              cursor = next;
27158|      0|            }
27159|      0|          while_break___0: /* CIL Label */;
27160|      0|          }
27161|      0|        }
27162|      0|        bucket++;
27163|      0|      }
27164|      0|    while_break: /* CIL Label */;
27165|      0|    }
27166|      0|    {
27167|      0|      free((void *)table___0->bucket);
27168|      0|      table___0->bucket = new_table->bucket;
27169|      0|      table___0->bucket_limit = new_table->bucket_limit;
27170|      0|      table___0->n_buckets = new_table->n_buckets;
27171|      0|      table___0->n_buckets_used = new_table->n_buckets_used;
27172|      0|      table___0->free_entry_list = new_table->free_entry_list;
27173|      0|      free((void *)new_table);
27174|      0|    }
27175|      0|    return ((_Bool)1);
27176|      0|  }
27177|      0|}
27178|      0|void *hash_insert(Hash_table *table___0, void const *entry) {
27179|      0|  void *data;
27180|      0|  struct hash_entry *bucket;
27181|      0|  struct hash_entry *new_entry;
27182|      0|  struct hash_entry *tmp;
27183|      0|  Hash_tuning const *tuning;
27184|      0|  float candidate;
27185|      0|  _Bool tmp___0;
27186|      0|  float tmp___1;
27187|       |
27188|      0|  {
27189|      0|    if (!entry) {
27190|      0|      {
27191|      0|        abort();
27192|      0|      }
27193|      0|    }
27194|      0|    { data = hash_find_entry(table___0, entry, &bucket, (_Bool)0); }
27195|      0|    if ((unsigned long)data != (unsigned long)((void *)0)) {
27196|      0|      return (data);
27197|      0|    }
27198|      0|    if (bucket->data) {
27199|      0|      {
27200|      0|        tmp = allocate_entry(table___0);
27201|      0|        new_entry = tmp;
27202|      0|      }
27203|      0|      if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
27204|      0|        return ((void *)0);
27205|      0|      }
27206|      0|      new_entry->data = (void *)entry;
27207|      0|      new_entry->next = bucket->next;
27208|      0|      bucket->next = new_entry;
27209|      0|      (table___0->n_entries)++;
27210|      0|      return ((void *)entry);
27211|      0|    }
27212|      0|    bucket->data = (void *)entry;
27213|      0|    (table___0->n_entries)++;
27214|      0|    (table___0->n_buckets_used)++;
27215|      0|    if ((float const)table___0->n_buckets_used >
27216|      0|        (table___0->tuning)->growth_threshold *
27217|      0|            (float const)table___0->n_buckets) {
27218|      0|      {
27219|      0|        check_tuning(table___0);
27220|      0|      }
27221|      0|      if ((float const)table___0->n_buckets_used >
27222|      0|          (table___0->tuning)->growth_threshold *
27223|      0|              (float const)table___0->n_buckets) {
27224|      0|        tuning = table___0->tuning;
27225|      0|        if (tuning->is_n_buckets) {
27226|      0|          tmp___1 = (float const)table___0->n_buckets * tuning->growth_factor;
27227|      0|        } else {
27228|      0|          tmp___1 =
27229|      0|              ((float const)table___0->n_buckets * tuning->growth_factor) *
27230|      0|              tuning->growth_threshold;
27231|      0|        }
27232|      0|        candidate = (float)tmp___1;
27233|      0|        if ((float)0xffffffffffffffffUL <= candidate) {
27234|      0|          return ((void *)0);
27235|      0|        }
27236|      0|        { tmp___0 = hash_rehash(table___0, (size_t)candidate); }
27237|      0|        if (!tmp___0) {
27238|      0|          entry = (void const *)((void *)0);
27239|      0|        }
27240|      0|      }
27241|      0|    }
27242|      0|    return ((void *)entry);
27243|      0|  }
27244|      0|}
27245|       |/* #pragma merger("0","01e.human.o.i","") */
27246|       |extern __attribute__((__nothrow__)) struct lconv *(__attribute__((__leaf__))
27247|       |                                                   localeconv)(void);
27248|       |extern __attribute__((__nothrow__)) void *(
27249|       |    __attribute__((__nonnull__(1, 2), __leaf__))
27250|       |    memmove)(void *__dest, void const *__src, size_t __n);
27251|       |static char const power_letter[9] = {
27252|       |    (char const)0,   (char const)'K', (char const)'M',
27253|       |    (char const)'G', (char const)'T', (char const)'P',
27254|       |    (char const)'E', (char const)'Z', (char const)'Y'};
27255|      0|static long double adjust_value(int inexact_style, long double value) {
27256|      0|  uintmax_t u;
27257|      0|  int tmp;
27258|       |
27259|      0|  {
27260|      0|    if (inexact_style != 1) {
27261|      0|      if (value < (long double)0xffffffffffffffffUL) {
27262|      0|        u = (uintmax_t)value;
27263|      0|        if (inexact_style == 0) {
27264|      0|          if ((long double)u != value) {
27265|      0|            tmp = 1;
27266|      0|          } else {
27267|      0|            tmp = 0;
27268|      0|          }
27269|      0|        } else {
27270|      0|          tmp = 0;
27271|      0|        }
27272|      0|        value = (long double)(u + (uintmax_t)tmp);
27273|      0|      }
27274|      0|    }
27275|      0|    return (value);
27276|      0|  }
27277|      0|}
27278|       |static char *group_number(char *number, size_t numberlen, char const *grouping,
27279|      0|                          char const *thousands_sep) {
27280|      0|  register char *d;
27281|      0|  size_t grouplen;
27282|      0|  size_t thousands_seplen;
27283|      0|  size_t tmp;
27284|      0|  size_t i;
27285|      0|  char buf[(((2UL * sizeof(uintmax_t)) * 8UL) * 302UL) / 1000UL + 1UL];
27286|      0|  unsigned char g;
27287|      0|  void *__cil_tmp12;
27288|       |
27289|      0|  {
27290|      0|    {
27291|      0|      grouplen = 0xffffffffffffffffUL;
27292|      0|      tmp = strlen(thousands_sep);
27293|      0|      thousands_seplen = tmp;
27294|      0|      i = numberlen;
27295|      0|      memcpy((void * /* __restrict  */)(buf),
27296|      0|             (void const * /* __restrict  */)number, numberlen);
27297|      0|      d = number + numberlen;
27298|      0|    }
27299|      0|    {
27300|      0|      while (1) {
27301|      0|      while_continue: /* CIL Label */;
27302|      0|        g = (unsigned char)*grouping;
27303|      0|        if (g) {
27304|      0|          if ((int)g < 127) {
27305|      0|            grouplen = (size_t)g;
27306|      0|          } else {
27307|      0|            grouplen = i;
27308|      0|          }
27309|      0|          grouping++;
27310|      0|        }
27311|      0|        if (i < grouplen) {
27312|      0|          grouplen = i;
27313|      0|        }
27314|      0|        {
27315|      0|          d -= grouplen;
27316|      0|          i -= grouplen;
27317|      0|          memcpy((void * /* __restrict  */)d,
27318|      0|                 (void const * /* __restrict  */)(buf + i), grouplen);
27319|      0|        }
27320|      0|        if (i == 0UL) {
27321|      0|          return (d);
27322|      0|        }
27323|      0|        {
27324|      0|          d -= thousands_seplen;
27325|      0|          memcpy((void * /* __restrict  */)d,
27326|      0|                 (void const * /* __restrict  */)thousands_sep,
27327|      0|                 thousands_seplen);
27328|      0|        }
27329|      0|      }
27330|      0|    while_break: /* CIL Label */;
27331|      0|    }
27332|      0|  }
27333|      0|}
27334|       |char *human_readable(uintmax_t n, char *buf, int opts,
27335|      0|                     uintmax_t from_block_size, uintmax_t to_block_size) {
27336|      0|  int inexact_style;
27337|      0|  unsigned int base;
27338|      0|  uintmax_t amt;
27339|      0|  int tenths;
27340|      0|  int exponent;
27341|      0|  int exponent_max;
27342|      0|  char *p;
27343|      0|  char *psuffix;
27344|      0|  char const *integerlim;
27345|      0|  int rounding;
27346|      0|  char const *decimal_point;
27347|      0|  size_t decimal_pointlen;
27348|      0|  char const *grouping;
27349|      0|  char const *thousands_sep;
27350|      0|  struct lconv const *l;
27351|      0|  struct lconv *tmp;
27352|      0|  size_t pointlen;
27353|      0|  size_t tmp___0;
27354|      0|  size_t tmp___1;
27355|      0|  uintmax_t multiplier;
27356|      0|  uintmax_t divisor;
27357|      0|  uintmax_t r10;
27358|      0|  uintmax_t r2;
27359|      0|  long double dto_block_size;
27360|      0|  long double damt;
27361|      0|  size_t buflen;
27362|      0|  size_t nonintegerlen;
27363|      0|  long double tmp___2;
27364|      0|  long double e;
27365|      0|  long double tmp___3;
27366|      0|  long double tmp___4;
27367|      0|  unsigned int r10___0;
27368|      0|  unsigned int r2___0;
27369|      0|  int digit;
27370|      0|  uintmax_t power;
27371|      0|  char *tmp___5;
27372|      0|  char *tmp___6;
27373|      0|  char *tmp___7;
27374|      0|  int tmp___8;
27375|      0|  int tmp___9;
27376|      0|  int tmp___10;
27377|      0|  int tmp___11;
27378|      0|  int tmp___12;
27379|      0|  int tmp___13;
27380|      0|  char *__cil_tmp50;
27381|      0|  char *__cil_tmp51;
27382|      0|  char *__cil_tmp52;
27383|      0|  char *__cil_tmp53;
27384|      0|  char *__cil_tmp54;
27385|      0|  char *__cil_tmp55;
27386|      0|  char *__cil_tmp56;
27387|       |
27388|      0|  {
27389|      0|    inexact_style = opts & 3;
27390|      0|    if (opts & 32) {
27391|      0|      tmp___8 = 1024;
27392|      0|    } else {
27393|      0|      tmp___8 = 1000;
27394|      0|    }
27395|      0|    {
27396|      0|      base = (unsigned int)tmp___8;
27397|      0|      exponent = -1;
27398|      0|      exponent_max = (int)(sizeof(power_letter) - 1UL);
27399|      0|      decimal_point = ".";
27400|      0|      decimal_pointlen = (size_t)1;
27401|      0|      grouping = "";
27402|      0|      thousands_sep = "";
27403|      0|      tmp = localeconv();
27404|      0|      l = (struct lconv const *)tmp;
27405|      0|      tmp___0 = strlen((char const *)l->decimal_point);
27406|      0|      pointlen = tmp___0;
27407|      0|    }
27408|      0|    if (0UL < pointlen) {
27409|      0|      if (pointlen <= 16UL) {
27410|      0|        decimal_point = (char const *)l->decimal_point;
27411|      0|        decimal_pointlen = pointlen;
27412|      0|      }
27413|      0|    }
27414|      0|    {
27415|      0|      grouping = (char const *)l->grouping;
27416|      0|      tmp___1 = strlen((char const *)l->thousands_sep);
27417|      0|    }
27418|      0|    if (tmp___1 <= 16UL) {
27419|      0|      thousands_sep = (char const *)l->thousands_sep;
27420|      0|    }
27421|      0|    psuffix =
27422|      0|        (buf +
27423|      0|         ((((((2UL * sizeof(uintmax_t)) * 8UL) * 302UL) / 1000UL + 1UL) * 17UL -
27424|      0|           16UL) +
27425|      0|          3UL)) -
27426|      0|        3;
27427|      0|    p = psuffix;
27428|      0|    if (to_block_size <= from_block_size) {
27429|      0|      if (from_block_size % to_block_size == 0UL) {
27430|      0|        multiplier = from_block_size / to_block_size;
27431|      0|        amt = n * multiplier;
27432|      0|        if (amt / multiplier == n) {
27433|      0|          tenths = 0;
27434|      0|          rounding = 0;
27435|      0|          goto use_integer_arithmetic;
27436|      0|        }
27437|      0|      }
27438|      0|    } else {
27439|      0|      if (from_block_size != 0UL) {
27440|      0|        if (to_block_size % from_block_size == 0UL) {
27441|      0|          divisor = to_block_size / from_block_size;
27442|      0|          r10 = (n % divisor) * 10UL;
27443|      0|          r2 = (r10 % divisor) * 2UL;
27444|      0|          amt = n / divisor;
27445|      0|          tenths = (int)(r10 / divisor);
27446|      0|          if (r2 < divisor) {
27447|      0|            rounding = 0UL < r2;
27448|      0|          } else {
27449|      0|            rounding = 2 + (divisor < r2);
27450|      0|          }
27451|      0|          goto use_integer_arithmetic;
27452|      0|        }
27453|      0|      }
27454|      0|    }
27455|      0|    dto_block_size = (long double)to_block_size;
27456|      0|    damt = (long double)n * ((long double)from_block_size / dto_block_size);
27457|      0|    if (!(opts & 16)) {
27458|      0|      {
27459|      0|        tmp___2 = adjust_value(inexact_style, damt);
27460|      0|        sprintf((char * /* __restrict  */)buf,
27461|      0|                (char const * /* __restrict  */) "%.0Lf", tmp___2);
27462|      0|        buflen = strlen((char const *)buf);
27463|      0|        nonintegerlen = (size_t)0;
27464|      0|      }
27465|      0|    } else {
27466|      0|      e = (long double)1;
27467|      0|      exponent = 0;
27468|      0|      {
27469|      0|        while (1) {
27470|      0|        while_continue: /* CIL Label */;
27471|      0|          e *= (long double)base;
27472|      0|          exponent++;
27473|      0|          if (e * (long double)base <= damt) {
27474|      0|            if (!(exponent < exponent_max)) {
27475|      0|              goto while_break;
27476|      0|            }
27477|      0|          } else {
27478|      0|            goto while_break;
27479|      0|          }
27480|      0|        }
27481|      0|      while_break: /* CIL Label */;
27482|      0|      }
27483|      0|      {
27484|      0|        damt /= e;
27485|      0|        tmp___3 = adjust_value(inexact_style, damt);
27486|      0|        sprintf((char * /* __restrict  */)buf,
27487|      0|                (char const * /* __restrict  */) "%.1Lf", tmp___3);
27488|      0|        buflen = strlen((char const *)buf);
27489|      0|        nonintegerlen = decimal_pointlen + 1UL;
27490|      0|      }
27491|      0|      if ((1UL + nonintegerlen) + (size_t)(!(opts & 32)) < buflen) {
27492|      0|        {
27493|      0|          tmp___4 = adjust_value(inexact_style, damt * (long double)10);
27494|      0|          sprintf((char * /* __restrict  */)buf,
27495|      0|                  (char const * /* __restrict  */) "%.0Lf",
27496|      0|                  tmp___4 / (long double)10);
27497|      0|          buflen = strlen((char const *)buf);
27498|      0|          nonintegerlen = (size_t)0;
27499|      0|        }
27500|      0|      } else {
27501|      0|        if (opts & 8) {
27502|      0|          if ((int)*(buf + (buflen - 1UL)) == 48) {
27503|      0|            {
27504|      0|              tmp___4 = adjust_value(inexact_style, damt * (long double)10);
27505|      0|              sprintf((char * /* __restrict  */)buf,
27506|      0|                      (char const * /* __restrict  */) "%.0Lf",
27507|      0|                      tmp___4 / (long double)10);
27508|      0|              buflen = strlen((char const *)buf);
27509|      0|              nonintegerlen = (size_t)0;
27510|      0|            }
27511|      0|          }
27512|      0|        }
27513|      0|      }
27514|      0|    }
27515|      0|    {
27516|      0|      p = psuffix - buflen;
27517|      0|      memmove((void *)p, (void const *)buf, buflen);
27518|      0|      integerlim = (char const *)((p + buflen) - nonintegerlen);
27519|      0|    }
27520|      0|    goto do_grouping;
27521|      0|  use_integer_arithmetic:
27522|      0|    if (opts & 16) {
27523|      0|      exponent = 0;
27524|      0|      if ((uintmax_t)base <= amt) {
27525|      0|        {
27526|      0|          while (1) {
27527|      0|          while_continue___0: /* CIL Label */;
27528|      0|            r10___0 = (unsigned int)((amt % (unsigned long)base) * 10UL +
27529|      0|                                     (unsigned long)tenths);
27530|      0|            r2___0 = (r10___0 % base) * 2U + (unsigned int)(rounding >> 1);
27531|      0|            amt /= (uintmax_t)base;
27532|      0|            tenths = (int)(r10___0 / base);
27533|      0|            if (r2___0 < base) {
27534|      0|              rounding = r2___0 + (unsigned int)rounding != 0U;
27535|      0|            } else {
27536|      0|              rounding = 2 + (base < r2___0 + (unsigned int)rounding);
27537|      0|            }
27538|      0|            exponent++;
27539|      0|            if ((uintmax_t)base <= amt) {
27540|      0|              if (!(exponent < exponent_max)) {
27541|      0|                goto while_break___0;
27542|      0|              }
27543|      0|            } else {
27544|      0|              goto while_break___0;
27545|      0|            }
27546|      0|          }
27547|      0|        while_break___0: /* CIL Label */;
27548|      0|        }
27549|      0|        if (amt < 10UL) {
27550|      0|          if (inexact_style == 1) {
27551|      0|            tmp___10 = 2 < rounding + (tenths & 1);
27552|      0|          } else {
27553|      0|            if (inexact_style == 0) {
27554|      0|              if (0 < rounding) {
27555|      0|                tmp___9 = 1;
27556|      0|              } else {
27557|      0|                tmp___9 = 0;
27558|      0|              }
27559|      0|            } else {
27560|      0|              tmp___9 = 0;
27561|      0|            }
27562|      0|            tmp___10 = tmp___9;
27563|      0|          }
27564|      0|          if (tmp___10) {
27565|      0|            tenths++;
27566|      0|            rounding = 0;
27567|      0|            if (tenths == 10) {
27568|      0|              amt++;
27569|      0|              tenths = 0;
27570|      0|            }
27571|      0|          }
27572|      0|          if (amt < 10UL) {
27573|      0|            if (tenths) {
27574|      0|              goto _L___3;
27575|      0|            } else {
27576|      0|              if (!(opts & 8)) {
27577|      0|              _L___3 : /* CIL Label */
27578|      0|              {
27579|      0|                p--;
27580|      0|                *p = (char)(48 + tenths);
27581|      0|                p -= decimal_pointlen;
27582|      0|                memcpy((void * /* __restrict  */)p,
27583|      0|                       (void const * /* __restrict  */)decimal_point,
27584|      0|                       decimal_pointlen);
27585|      0|                rounding = 0;
27586|      0|                tenths = rounding;
27587|      0|              }
27588|      0|              }
27589|      0|            }
27590|      0|          }
27591|      0|        }
27592|      0|      }
27593|      0|    }
27594|      0|    if (inexact_style == 1) {
27595|      0|      tmp___12 = 5 < tenths + (0UL < (unsigned long)rounding + (amt & 1UL));
27596|      0|    } else {
27597|      0|      if (inexact_style == 0) {
27598|      0|        if (0 < tenths + rounding) {
27599|      0|          tmp___11 = 1;
27600|      0|        } else {
27601|      0|          tmp___11 = 0;
27602|      0|        }
27603|      0|      } else {
27604|      0|        tmp___11 = 0;
27605|      0|      }
27606|      0|      tmp___12 = tmp___11;
27607|      0|    }
27608|      0|    if (tmp___12) {
27609|      0|      amt++;
27610|      0|      if (opts & 16) {
27611|      0|        if (amt == (uintmax_t)base) {
27612|      0|          if (exponent < exponent_max) {
27613|      0|            exponent++;
27614|      0|            if (!(opts & 8)) {
27615|      0|              {
27616|      0|                p--;
27617|      0|                *p = (char)'0';
27618|      0|                p -= decimal_pointlen;
27619|      0|                memcpy((void * /* __restrict  */)p,
27620|      0|                       (void const * /* __restrict  */)decimal_point,
27621|      0|                       decimal_pointlen);
27622|      0|              }
27623|      0|            }
27624|      0|            amt = (uintmax_t)1;
27625|      0|          }
27626|      0|        }
27627|      0|      }
27628|      0|    }
27629|      0|    integerlim = (char const *)p;
27630|      0|    {
27631|      0|      while (1) {
27632|      0|      while_continue___1: /* CIL Label */;
27633|      0|        digit = (int)(amt % 10UL);
27634|      0|        p--;
27635|      0|        *p = (char)(digit + 48);
27636|      0|        amt /= 10UL;
27637|      0|        if (!(amt != 0UL)) {
27638|      0|          goto while_break___1;
27639|      0|        }
27640|      0|      }
27641|      0|    while_break___1: /* CIL Label */;
27642|      0|    }
27643|      0|  do_grouping:
27644|      0|    if (opts & 4) {
27645|      0|      {
27646|      0|        p = group_number(p, (size_t)(integerlim - (char const *)p), grouping,
27647|      0|                         thousands_sep);
27648|      0|      }
27649|      0|    }
27650|      0|    if (opts & 64) {
27651|      0|      if (exponent < 0) {
27652|      0|        exponent = 0;
27653|      0|        power = (uintmax_t)1;
27654|      0|        {
27655|      0|          while (1) {
27656|      0|          while_continue___2: /* CIL Label */;
27657|      0|            if (!(power < to_block_size)) {
27658|      0|              goto while_break___2;
27659|      0|            }
27660|      0|            exponent++;
27661|      0|            if (exponent == exponent_max) {
27662|      0|              goto while_break___2;
27663|      0|            }
27664|      0|            power *= (uintmax_t)base;
27665|      0|          }
27666|      0|        while_break___2: /* CIL Label */;
27667|      0|        }
27668|      0|      }
27669|      0|      if (exponent) {
27670|      0|        tmp___5 = psuffix;
27671|      0|        psuffix++;
27672|      0|        if (!(opts & 32)) {
27673|      0|          if (exponent == 1) {
27674|      0|            tmp___13 = 'k';
27675|      0|          } else {
27676|      0|            tmp___13 = (int)power_letter[exponent];
27677|      0|          }
27678|      0|        } else {
27679|      0|          tmp___13 = (int)power_letter[exponent];
27680|      0|        }
27681|      0|        *tmp___5 = (char)tmp___13;
27682|      0|      }
27683|      0|      if (opts & 128) {
27684|      0|        if (opts & 32) {
27685|      0|          if (exponent) {
27686|      0|            tmp___6 = psuffix;
27687|      0|            psuffix++;
27688|      0|            *tmp___6 = (char)'i';
27689|      0|          }
27690|      0|        }
27691|      0|        tmp___7 = psuffix;
27692|      0|        psuffix++;
27693|      0|        *tmp___7 = (char)'B';
27694|      0|      }
27695|      0|    }
27696|      0|    *psuffix = (char)'\000';
27697|      0|    return (p);
27698|      0|  }
27699|      0|}
27700|       |static char const *const block_size_args[3] = {
27701|       |    (char const * /* const  */) "human-readable",
27702|       |    (char const * /* const  */) "si", (char const * /* const  */)0};
27703|       |static int const block_size_opts[2] = {(int const)112, (int const)80};
27704|       |/* #pragma merger("0","01f.mktime.o.i","") */
27705|       |extern __attribute__((__nothrow__)) struct tm *(
27706|       |    __attribute__((__leaf__))
27707|       |    localtime_r)(time_t const *__restrict __timer, struct tm *__restrict __tp);
27708|      0|__inline static int leapyear(int year) {
27709|      0|  int tmp;
27710|       |
27711|      0|  {
27712|      0|    if ((year & 3) == 0) {
27713|      0|      if (year % 100 != 0) {
27714|      0|        tmp = 1;
27715|      0|      } else {
27716|      0|        if ((year / 100 & 3) == 1) {
27717|      0|          tmp = 1;
27718|      0|        } else {
27719|      0|          tmp = 0;
27720|      0|        }
27721|      0|      }
27722|      0|    } else {
27723|      0|      tmp = 0;
27724|      0|    }
27725|      0|    return (tmp);
27726|      0|  }
27727|      0|}
27728|       |static unsigned short const __mon_yday[2][13] = {
27729|       |    {(unsigned short const)0, (unsigned short const)31,
27730|       |     (unsigned short const)59, (unsigned short const)90,
27731|       |     (unsigned short const)120, (unsigned short const)151,
27732|       |     (unsigned short const)181, (unsigned short const)212,
27733|       |     (unsigned short const)243, (unsigned short const)273,
27734|       |     (unsigned short const)304, (unsigned short const)334,
27735|       |     (unsigned short const)365},
27736|       |    {(unsigned short const)0, (unsigned short const)31,
27737|       |     (unsigned short const)60, (unsigned short const)91,
27738|       |     (unsigned short const)121, (unsigned short const)152,
27739|       |     (unsigned short const)182, (unsigned short const)213,
27740|       |     (unsigned short const)244, (unsigned short const)274,
27741|       |     (unsigned short const)305, (unsigned short const)335,
27742|       |     (unsigned short const)366}};
27743|       |__inline static time_t ydhms_diff(long year1, long yday1, int hour1, int min1,
27744|       |                                  int sec1, int year0, int yday0, int hour0,
27745|      0|                                  int min0, int sec0) {
27746|      0|  int a4;
27747|      0|  int b4;
27748|      0|  int a100;
27749|      0|  int b100;
27750|      0|  int a400;
27751|      0|  int b400;
27752|      0|  int intervening_leap_days;
27753|      0|  time_t tyear1;
27754|      0|  time_t years;
27755|      0|  time_t days;
27756|      0|  time_t hours;
27757|      0|  time_t minutes;
27758|      0|  time_t seconds;
27759|       |
27760|      0|  {
27761|      0|    a4 = (int)(((year1 >> 2) + (long)(1900 >> 2)) - (long)(!(year1 & 3L)));
27762|      0|    b4 = ((year0 >> 2) + (1900 >> 2)) - !(year0 & 3);
27763|      0|    a100 = a4 / 25 - (a4 % 25 < 0);
27764|      0|    b100 = b4 / 25 - (b4 % 25 < 0);
27765|      0|    a400 = a100 >> 2;
27766|      0|    b400 = b100 >> 2;
27767|      0|    intervening_leap_days = ((a4 - b4) - (a100 - b100)) + (a400 - b400);
27768|      0|    tyear1 = year1;
27769|      0|    years = tyear1 - (time_t)year0;
27770|      0|    days = ((365L * years + yday1) - (time_t)yday0) +
27771|      0|           (time_t)intervening_leap_days;
27772|      0|    hours = (24L * days + (time_t)hour1) - (time_t)hour0;
27773|      0|    minutes = (60L * hours + (time_t)min1) - (time_t)min0;
27774|      0|    seconds = (60L * minutes + (time_t)sec1) - (time_t)sec0;
27775|      0|    return (seconds);
27776|      0|  }
27777|      0|}
27778|       |static time_t guess_time_tm(long year, long yday, int hour, int min, int sec,
27779|      0|                            time_t const *t, struct tm const *tp) {
27780|      0|  time_t d;
27781|      0|  time_t tmp;
27782|      0|  time_t t1;
27783|      0|  long tmp___0;
27784|       |
27785|      0|  {
27786|      0|    if (tp) {
27787|      0|      {
27788|      0|        tmp = ydhms_diff(year, yday, hour, min, sec, (int)tp->tm_year,
27789|      0|                         (int)tp->tm_yday, (int)tp->tm_hour, (int)tp->tm_min,
27790|      0|                         (int)tp->tm_sec);
27791|      0|        d = tmp;
27792|      0|        t1 = (time_t)(*t + (time_t const)d);
27793|      0|      }
27794|      0|      if ((t1 < (time_t)*t) == (d < 0L)) {
27795|      0|        return (t1);
27796|      0|      }
27797|      0|    }
27798|      0|    if (*t < (time_t const)((((-1L << (sizeof(time_t) * 8UL - 1UL)) +
27799|      0|                              (-1L - (-1L << (sizeof(time_t) * 8UL - 1UL)))) >>
27800|      0|                             1) +
27801|      0|                            1L)) {
27802|      0|      tmp___0 =
27803|      0|          (-1L << (sizeof(time_t) * 8UL - 1UL)) +
27804|      0|          (time_t)(*t == (time_t const)(-1L << (sizeof(time_t) * 8UL - 1UL)));
27805|      0|    } else {
27806|      0|      tmp___0 =
27807|      0|          (-1L - (-1L << (sizeof(time_t) * 8UL - 1UL))) -
27808|      0|          (time_t)(*t ==
27809|      0|                   (time_t const)(-1L - (-1L << (sizeof(time_t) * 8UL - 1UL))));
27810|      0|    }
27811|      0|    return (tmp___0);
27812|      0|  }
27813|      0|}
27814|       |static struct tm *ranged_convert(struct tm *(*convert)(time_t const *,
27815|       |                                                       struct tm *),
27816|      0|                                 time_t *t, struct tm *tp) {
27817|      0|  struct tm *r;
27818|      0|  time_t bad;
27819|      0|  time_t ok;
27820|      0|  struct tm tm;
27821|      0|  time_t mid;
27822|      0|  time_t tmp;
27823|      0|  int tmp___0;
27824|       |
27825|      0|  {
27826|      0|    { r = (*convert)((time_t const *)t, tp); }
27827|      0|    if (!r) {
27828|      0|      if (*t) {
27829|      0|        bad = *t;
27830|      0|        ok = (time_t)0;
27831|      0|        {
27832|      0|          while (1) {
27833|      0|          while_continue: /* CIL Label */;
27834|      0|            if (bad < 0L) {
27835|      0|              tmp___0 = -1;
27836|      0|            } else {
27837|      0|              tmp___0 = 1;
27838|      0|            }
27839|      0|            if (!(bad != ok + (time_t)tmp___0)) {
27840|      0|              goto while_break;
27841|      0|            }
27842|      0|            if (bad < 0L) {
27843|      0|              tmp = bad + ((ok - bad) >> 1);
27844|      0|            } else {
27845|      0|              tmp = ok + ((bad - ok) >> 1);
27846|      0|            }
27847|      0|            {
27848|      0|              *t = tmp;
27849|      0|              mid = tmp;
27850|      0|              r = (*convert)((time_t const *)t, tp);
27851|      0|            }
27852|      0|            if (r) {
27853|      0|              tm = *r;
27854|      0|              ok = mid;
27855|      0|            } else {
27856|      0|              bad = mid;
27857|      0|            }
27858|      0|          }
27859|      0|        while_break: /* CIL Label */;
27860|      0|        }
27861|      0|        if (!r) {
27862|      0|          if (ok) {
27863|      0|            *t = ok;
27864|      0|            *tp = tm;
27865|      0|            r = tp;
27866|      0|          }
27867|      0|        }
27868|      0|      }
27869|      0|    }
27870|      0|    return (r);
27871|      0|  }
27872|      0|}
27873|       |time_t mktime_internal(struct tm *tp,
27874|       |                       struct tm *(*convert)(time_t const *, struct tm *),
27875|      0|                       time_t *offset) {
27876|      0|  time_t t;
27877|      0|  time_t gt;
27878|      0|  time_t t0;
27879|      0|  time_t t1;
27880|      0|  time_t t2;
27881|      0|  struct tm tm;
27882|      0|  int remaining_probes;
27883|      0|  int sec;
27884|      0|  int min;
27885|      0|  int hour;
27886|      0|  int mday;
27887|      0|  int mon;
27888|      0|  int year_requested;
27889|      0|  int isdst;
27890|      0|  int dst2;
27891|      0|  int mon_remainder;
27892|      0|  int negative_mon_remainder;
27893|      0|  int mon_years;
27894|      0|  long lyear_requested;
27895|      0|  long year;
27896|      0|  int mon_yday;
27897|      0|  int tmp;
27898|      0|  long lmday;
27899|      0|  long yday;
27900|      0|  time_t guessed_offset;
27901|      0|  int sec_requested;
27902|      0|  int ALOG2_SECONDS_PER_BIENNIUM;
27903|      0|  int ALOG2_MINUTES_PER_BIENNIUM;
27904|      0|  int ALOG2_HOURS_PER_BIENNIUM;
27905|      0|  int ALOG2_DAYS_PER_BIENNIUM;
27906|      0|  int LOG2_YEARS_PER_BIENNIUM;
27907|      0|  int approx_requested_biennia;
27908|      0|  int approx_biennia;
27909|      0|  int diff;
27910|      0|  int abs_diff;
27911|      0|  time_t time_t_max;
27912|      0|  time_t time_t_min;
27913|      0|  time_t overflow_threshold;
27914|      0|  time_t repaired_t0;
27915|      0|  struct tm *tmp___0;
27916|      0|  int stride;
27917|      0|  int duration_max;
27918|      0|  int delta_bound;
27919|      0|  int delta;
27920|      0|  int direction;
27921|      0|  time_t ot;
27922|      0|  struct tm otm;
27923|      0|  int sec_adjustment;
27924|      0|  struct tm *tmp___1;
27925|      0|  int tmp___2;
27926|      0|  int tmp___3;
27927|      0|  int tmp___4;
27928|       |
27929|      0|  {
27930|      0|    {
27931|      0|      remaining_probes = 6;
27932|      0|      sec = tp->tm_sec;
27933|      0|      min = tp->tm_min;
27934|      0|      hour = tp->tm_hour;
27935|      0|      mday = tp->tm_mday;
27936|      0|      mon = tp->tm_mon;
27937|      0|      year_requested = tp->tm_year;
27938|      0|      isdst = tp->tm_isdst;
27939|      0|      mon_remainder = mon % 12;
27940|      0|      negative_mon_remainder = mon_remainder < 0;
27941|      0|      mon_years = mon / 12 - negative_mon_remainder;
27942|      0|      lyear_requested = (long)year_requested;
27943|      0|      year = lyear_requested + (long)mon_years;
27944|      0|      tmp = leapyear((int)year);
27945|      0|      mon_yday = (int)((int const)__mon_yday[tmp][mon_remainder +
27946|      0|                                                  12 * negative_mon_remainder] -
27947|      0|                       1);
27948|      0|      lmday = (long)mday;
27949|      0|      yday = (long)mon_yday + lmday;
27950|      0|      guessed_offset = *offset;
27951|      0|      sec_requested = sec;
27952|      0|    }
27953|      0|    if (sec < 0) {
27954|      0|      sec = 0;
27955|      0|    }
27956|      0|    if (59 < sec) {
27957|      0|      sec = 59;
27958|      0|    }
27959|      0|    {
27960|      0|      t0 = ydhms_diff(year, yday, hour, min, sec, 70, 0, 0, 0,
27961|      0|                      (int)(-guessed_offset));
27962|      0|    }
27963|      0|    if ((((((-1L - (-1L << (sizeof(time_t) * 8UL - 1UL))) / 2147483647L) /
27964|      0|           366L) /
27965|      0|          24L) /
27966|      0|         60L) /
27967|      0|            60L <
27968|      0|        3L) {
27969|      0|      ALOG2_SECONDS_PER_BIENNIUM = 26;
27970|      0|      ALOG2_MINUTES_PER_BIENNIUM = 20;
27971|      0|      ALOG2_HOURS_PER_BIENNIUM = 14;
27972|      0|      ALOG2_DAYS_PER_BIENNIUM = 10;
27973|      0|      LOG2_YEARS_PER_BIENNIUM = 1;
27974|      0|      approx_requested_biennia =
27975|      0|          ((((year_requested >> LOG2_YEARS_PER_BIENNIUM) -
27976|      0|             (70 >> LOG2_YEARS_PER_BIENNIUM)) +
27977|      0|            (mday >> ALOG2_DAYS_PER_BIENNIUM)) +
27978|      0|           (hour >> ALOG2_HOURS_PER_BIENNIUM)) +
27979|      0|          (min >> ALOG2_MINUTES_PER_BIENNIUM);
27980|      0|      approx_biennia = (int)(t0 >> ALOG2_SECONDS_PER_BIENNIUM);
27981|      0|      diff = approx_biennia - approx_requested_biennia;
27982|      0|      if (diff < 0) {
27983|      0|        abs_diff = -diff;
27984|      0|      } else {
27985|      0|        abs_diff = diff;
27986|      0|      }
27987|      0|      time_t_max = -1L - (-1L << (sizeof(time_t) * 8UL - 1UL));
27988|      0|      time_t_min = -1L << (sizeof(time_t) * 8UL - 1UL);
27989|      0|      overflow_threshold =
27990|      0|          (time_t_max / 3L - time_t_min / 3L) >> ALOG2_SECONDS_PER_BIENNIUM;
27991|      0|      if (overflow_threshold < (time_t)abs_diff) {
27992|      0|        repaired_t0 = -1L - t0;
27993|      0|        approx_biennia = (int)(repaired_t0 >> ALOG2_SECONDS_PER_BIENNIUM);
27994|      0|        diff = approx_biennia - approx_requested_biennia;
27995|      0|        if (diff < 0) {
27996|      0|          abs_diff = -diff;
27997|      0|        } else {
27998|      0|          abs_diff = diff;
27999|      0|        }
28000|      0|        if (overflow_threshold < (time_t)abs_diff) {
28001|      0|          return ((time_t)-1);
28002|      0|        }
28003|      0|        guessed_offset += repaired_t0 - t0;
28004|      0|        t0 = repaired_t0;
28005|      0|      }
28006|      0|    }
28007|      0|    t2 = t0;
28008|      0|    t1 = t2;
28009|      0|    t = t1;
28010|      0|    dst2 = 0;
28011|      0|    {
28012|      0|      while (1) {
28013|      0|      while_continue: /* CIL Label */;
28014|      0|        {
28015|      0|          tmp___0 = ranged_convert(convert, &t, &tm);
28016|      0|          gt = guess_time_tm(year, yday, hour, min, sec, (time_t const *)(&t),
28017|      0|                             (struct tm const *)tmp___0);
28018|      0|        }
28019|      0|        if (!(t != gt)) {
28020|      0|          goto while_break;
28021|      0|        }
28022|      0|        if (t == t1) {
28023|      0|          if (t != t2) {
28024|      0|            if (tm.tm_isdst < 0) {
28025|      0|              goto offset_found;
28026|      0|            } else {
28027|      0|              if (isdst < 0) {
28028|      0|                tmp___3 = dst2 <= (tm.tm_isdst != 0);
28029|      0|              } else {
28030|      0|                tmp___3 = (isdst != 0) != (tm.tm_isdst != 0);
28031|      0|              }
28032|      0|              if (tmp___3) {
28033|      0|                goto offset_found;
28034|      0|              } else {
28035|      0|                goto _L___4;
28036|      0|              }
28037|      0|            }
28038|      0|          } else {
28039|      0|            goto _L___4;
28040|      0|          }
28041|      0|        } else {
28042|      0|        _L___4: /* CIL Label */
28043|      0|          remaining_probes--;
28044|      0|          if (remaining_probes == 0) {
28045|      0|            return ((time_t)-1);
28046|      0|          }
28047|      0|        }
28048|      0|        t1 = t2;
28049|      0|        t2 = t;
28050|      0|        t = gt;
28051|      0|        dst2 = tm.tm_isdst != 0;
28052|      0|      }
28053|      0|    while_break: /* CIL Label */;
28054|      0|    }
28055|      0|    if (isdst != tm.tm_isdst) {
28056|      0|      if (0 <= isdst) {
28057|      0|        if (0 <= tm.tm_isdst) {
28058|      0|          stride = 601200;
28059|      0|          duration_max = 536454000;
28060|      0|          delta_bound = duration_max / 2 + stride;
28061|      0|          delta = stride;
28062|      0|          {
28063|      0|            while (1) {
28064|      0|            while_continue___0: /* CIL Label */;
28065|      0|              if (!(delta < delta_bound)) {
28066|      0|                goto while_break___0;
28067|      0|              }
28068|      0|              direction = -1;
28069|      0|              {
28070|      0|                while (1) {
28071|      0|                while_continue___1: /* CIL Label */;
28072|      0|                  if (!(direction <= 1)) {
28073|      0|                    goto while_break___1;
28074|      0|                  }
28075|      0|                  ot = t + (time_t)(delta * direction);
28076|      0|                  if ((ot < t) == (direction < 0)) {
28077|      0|                    {
28078|      0|                      ranged_convert(convert, &ot, &otm);
28079|      0|                    }
28080|      0|                    if (otm.tm_isdst == isdst) {
28081|      0|                      {
28082|      0|                        t = guess_time_tm(year, yday, hour, min, sec,
28083|      0|                                          (time_t const *)(&ot),
28084|      0|                                          (struct tm const *)(&otm));
28085|      0|                        ranged_convert(convert, &t, &tm);
28086|      0|                      }
28087|      0|                      goto offset_found;
28088|      0|                    }
28089|      0|                  }
28090|      0|                  direction += 2;
28091|      0|                }
28092|      0|              while_break___1: /* CIL Label */;
28093|      0|              }
28094|      0|              delta += stride;
28095|      0|            }
28096|      0|          while_break___0: /* CIL Label */;
28097|      0|          }
28098|      0|        }
28099|      0|      }
28100|      0|    }
28101|      0|  offset_found:
28102|      0|    *offset = (guessed_offset + t) - t0;
28103|      0|    if (sec_requested != tm.tm_sec) {
28104|      0|      if (sec == 0) {
28105|      0|        if (tm.tm_sec == 60) {
28106|      0|          tmp___4 = 1;
28107|      0|        } else {
28108|      0|          tmp___4 = 0;
28109|      0|        }
28110|      0|      } else {
28111|      0|        tmp___4 = 0;
28112|      0|      }
28113|      0|      {
28114|      0|        sec_adjustment = tmp___4 - sec;
28115|      0|        t1 = t + (time_t)sec_requested;
28116|      0|        t2 = t1 + (time_t)sec_adjustment;
28117|      0|        tmp___1 = (*convert)((time_t const *)(&t), &tm);
28118|      0|      }
28119|      0|      if (tmp___1) {
28120|      0|        tmp___2 = 0;
28121|      0|      } else {
28122|      0|        tmp___2 = 1;
28123|      0|      }
28124|      0|      if ((((t1 < t) != (sec_requested < 0)) |
28125|      0|           ((t2 < t1) != (sec_adjustment < 0))) |
28126|      0|          tmp___2) {
28127|      0|        return ((time_t)-1);
28128|      0|      }
28129|      0|    }
28130|      0|    *tp = tm;
28131|      0|    return (t);
28132|      0|  }
28133|      0|}
28134|       |static time_t localtime_offset;
28135|       |__attribute__((__nothrow__))
28136|       |time_t(__attribute__((__leaf__)) rpl_mktime)(struct tm *tp);
28137|      0|time_t(__attribute__((__leaf__)) rpl_mktime)(struct tm *tp) {
28138|      0|  time_t tmp;
28139|       |
28140|      0|  {
28141|      0|    {
28142|      0|      tmp = mktime_internal(
28143|      0|          tp, (struct tm * (*)(time_t const *, struct tm *))(&localtime_r),
28144|      0|          &localtime_offset);
28145|      0|    }
28146|      0|    return (tmp);
28147|      0|  }
28148|      0|}
28149|       |/* #pragma merger("0","020.modechange.o.i","") */
28150|       |void mode_free(struct mode_change *changes);
28151|       |strtol_error xstrtoul(char const *s, char **ptr, int strtol_base,
28152|       |                      unsigned long *val, char const *valid_suffixes);
28153|      0|static struct mode_change *make_node_op_equals(mode_t new_mode) {
28154|      0|  struct mode_change *p;
28155|      0|  void *tmp;
28156|       |
28157|      0|  {
28158|      0|    {
28159|      0|      tmp = malloc(sizeof(struct mode_change));
28160|      0|      p = (struct mode_change *)tmp;
28161|      0|    }
28162|      0|    if ((unsigned long)p == (unsigned long)((void *)0)) {
28163|      0|      return (p);
28164|      0|    }
28165|      0|    p->next = (struct mode_change *)((void *)0);
28166|      0|    p->op = (char)'=';
28167|      0|    p->flags = (char)0;
28168|      0|    p->value = new_mode;
28169|      0|    p->affected = (mode_t)((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
28170|      0|    return (p);
28171|      0|  }
28172|      0|}
28173|       |static void mode_append_entry(struct mode_change **head,
28174|       |                              struct mode_change **tail,
28175|      0|                              struct mode_change *e) {
28176|      0|  struct mode_change *tmp;
28177|       |
28178|      0|  {
28179|      0|    if ((unsigned long)*head == (unsigned long)((void *)0)) {
28180|      0|      tmp = e;
28181|      0|      *tail = tmp;
28182|      0|      *head = tmp;
28183|      0|    } else {
28184|      0|      (*tail)->next = e;
28185|      0|      *tail = e;
28186|      0|    }
28187|      0|    return;
28188|      0|  }
28189|      0|}
28190|       |struct mode_change *mode_compile(char const *mode_string,
28191|      0|                                 unsigned int masked_ops) {
28192|      0|  struct mode_change *head;
28193|      0|  struct mode_change *tail;
28194|      0|  unsigned long octal_value;
28195|      0|  mode_t umask_value;
28196|      0|  struct mode_change *p;
28197|      0|  mode_t mode;
28198|      0|  strtol_error tmp;
28199|      0|  mode_t affected_bits;
28200|      0|  mode_t affected_masked;
28201|      0|  unsigned int ops_to_mask;
28202|      0|  int who_specified_p;
28203|      0|  struct mode_change *change;
28204|      0|  void *tmp___0;
28205|      0|  struct mode_change *p___0;
28206|      0|  struct mode_change *tmp___1;
28207|      0|  int tmp___2;
28208|      0|  int tmp___3;
28209|      0|  int tmp___4;
28210|      0|  int tmp___5;
28211|      0|  int tmp___6;
28212|      0|  int tmp___7;
28213|      0|  int tmp___8;
28214|      0|  int tmp___9;
28215|      0|  int tmp___10;
28216|      0|  int tmp___11;
28217|      0|  int tmp___12;
28218|      0|  int tmp___13;
28219|      0|  unsigned long tmp___14;
28220|      0|  int tmp___15;
28221|      0|  int tmp___16;
28222|      0|  int tmp___17;
28223|      0|  char *__cil_tmp34;
28224|       |
28225|      0|  {
28226|      0|    {
28227|      0|      head = (struct mode_change *)((void *)0);
28228|      0|      tmp = xstrtoul(mode_string, (char **)((void *)0), 8, &octal_value, "");
28229|      0|    }
28230|      0|    if ((unsigned int)tmp == 0U) {
28231|      0|      if (octal_value != (octal_value & 4095UL)) {
28232|      0|        return ((struct mode_change *)0);
28233|      0|      }
28234|      0|      if (256 >> 3 == 32) {
28235|      0|        if (128 >> 3 == 16) {
28236|      0|          if (64 >> 3 == 8) {
28237|      0|            if ((256 >> 3) >> 3 == 4) {
28238|      0|              if ((128 >> 3) >> 3 == 2) {
28239|      0|                if ((64 >> 3) >> 3 == 1) {
28240|      0|                  tmp___14 = octal_value;
28241|      0|                } else {
28242|      0|                  goto _L___7;
28243|      0|                }
28244|      0|              } else {
28245|      0|                goto _L___7;
28246|      0|              }
28247|      0|            } else {
28248|      0|              goto _L___7;
28249|      0|            }
28250|      0|          } else {
28251|      0|            goto _L___7;
28252|      0|          }
28253|      0|        } else {
28254|      0|          goto _L___7;
28255|      0|        }
28256|      0|      } else {
28257|      0|      _L___7: /* CIL Label */
28258|      0|        if (octal_value & 2048UL) {
28259|      0|          tmp___2 = 2048;
28260|      0|        } else {
28261|      0|          tmp___2 = 0;
28262|      0|        }
28263|      0|        if (octal_value & 1024UL) {
28264|      0|          tmp___3 = 1024;
28265|      0|        } else {
28266|      0|          tmp___3 = 0;
28267|      0|        }
28268|      0|        if (octal_value & 512UL) {
28269|      0|          tmp___4 = 512;
28270|      0|        } else {
28271|      0|          tmp___4 = 0;
28272|      0|        }
28273|      0|        if (octal_value & 256UL) {
28274|      0|          tmp___5 = 256;
28275|      0|        } else {
28276|      0|          tmp___5 = 0;
28277|      0|        }
28278|      0|        if (octal_value & 128UL) {
28279|      0|          tmp___6 = 128;
28280|      0|        } else {
28281|      0|          tmp___6 = 0;
28282|      0|        }
28283|      0|        if (octal_value & 64UL) {
28284|      0|          tmp___7 = 64;
28285|      0|        } else {
28286|      0|          tmp___7 = 0;
28287|      0|        }
28288|      0|        if (octal_value & 32UL) {
28289|      0|          tmp___8 = 256 >> 3;
28290|      0|        } else {
28291|      0|          tmp___8 = 0;
28292|      0|        }
28293|      0|        if (octal_value & 16UL) {
28294|      0|          tmp___9 = 128 >> 3;
28295|      0|        } else {
28296|      0|          tmp___9 = 0;
28297|      0|        }
28298|      0|        if (octal_value & 8UL) {
28299|      0|          tmp___10 = 64 >> 3;
28300|      0|        } else {
28301|      0|          tmp___10 = 0;
28302|      0|        }
28303|      0|        if (octal_value & 4UL) {
28304|      0|          tmp___11 = (256 >> 3) >> 3;
28305|      0|        } else {
28306|      0|          tmp___11 = 0;
28307|      0|        }
28308|      0|        if (octal_value & 2UL) {
28309|      0|          tmp___12 = (128 >> 3) >> 3;
28310|      0|        } else {
28311|      0|          tmp___12 = 0;
28312|      0|        }
28313|      0|        if (octal_value & 1UL) {
28314|      0|          tmp___13 = (64 >> 3) >> 3;
28315|      0|        } else {
28316|      0|          tmp___13 = 0;
28317|      0|        }
28318|      0|        tmp___14 = (unsigned long)((mode_t)(
28319|      0|            ((((((((((tmp___2 | tmp___3) | tmp___4) | tmp___5) | tmp___6) |
28320|      0|                  tmp___7) |
28321|      0|                 tmp___8) |
28322|      0|                tmp___9) |
28323|      0|               tmp___10) |
28324|      0|              tmp___11) |
28325|      0|             tmp___12) |
28326|      0|            tmp___13));
28327|      0|      }
28328|      0|      {
28329|      0|        mode = (mode_t)tmp___14;
28330|      0|        p = make_node_op_equals(mode);
28331|      0|      }
28332|      0|      if ((unsigned long)p == (unsigned long)((void *)0)) {
28333|      0|        return ((struct mode_change *)1);
28334|      0|      }
28335|      0|      { mode_append_entry(&head, &tail, p); }
28336|      0|      return (head);
28337|      0|    }
28338|      0|    {
28339|      0|      umask_value = umask((__mode_t)0);
28340|      0|      umask(umask_value);
28341|      0|      mode_string--;
28342|      0|    }
28343|      0|    {
28344|      0|      while (1) {
28345|      0|      while_continue: /* CIL Label */;
28346|      0|        affected_bits = (mode_t)0;
28347|      0|        ops_to_mask = 0U;
28348|      0|        affected_bits = (mode_t)0;
28349|      0|        ops_to_mask = 0U;
28350|      0|        mode_string++;
28351|      0|        {
28352|      0|          while (1) {
28353|      0|          while_continue___0: /* CIL Label */;
28354|      0|            {
28355|      0|              if ((int const) * mode_string == 117) {
28356|      0|                goto case_117;
28357|      0|              }
28358|      0|              if ((int const) * mode_string == 103) {
28359|      0|                goto case_103;
28360|      0|              }
28361|      0|              if ((int const) * mode_string == 111) {
28362|      0|                goto case_111;
28363|      0|              }
28364|      0|              if ((int const) * mode_string == 97) {
28365|      0|                goto case_97;
28366|      0|              }
28367|      0|              goto switch_default;
28368|      0|            case_117: /* CIL Label */
28369|      0|              affected_bits |= 2496U;
28370|      0|              goto switch_break;
28371|      0|            case_103: /* CIL Label */
28372|      0|              affected_bits |= (unsigned int)(1024 | (448 >> 3));
28373|      0|              goto switch_break;
28374|      0|            case_111: /* CIL Label */
28375|      0|              affected_bits |= (unsigned int)(512 | ((448 >> 3) >> 3));
28376|      0|              goto switch_break;
28377|      0|            case_97: /* CIL Label */
28378|      0|              affected_bits |=
28379|      0|                  (unsigned int)((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
28380|      0|              goto switch_break;
28381|      0|            switch_default: /* CIL Label */
28382|      0|              goto no_more_affected;
28383|      0|            switch_break: /* CIL Label */;
28384|      0|            }
28385|      0|            mode_string++;
28386|      0|          }
28387|      0|        while_break___0: /* CIL Label */;
28388|      0|        }
28389|      0|      no_more_affected:
28390|      0|        if (affected_bits) {
28391|      0|          who_specified_p = 1;
28392|      0|        } else {
28393|      0|          who_specified_p = 0;
28394|      0|          affected_bits = (mode_t)((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
28395|      0|          ops_to_mask = masked_ops;
28396|      0|        }
28397|      0|        {
28398|      0|          while (1) {
28399|      0|          while_continue___1: /* CIL Label */;
28400|      0|            if (!((int const) * mode_string == 61)) {
28401|      0|              if (!((int const) * mode_string == 43)) {
28402|      0|                if (!((int const) * mode_string == 45)) {
28403|      0|                  goto while_break___1;
28404|      0|                }
28405|      0|              }
28406|      0|            }
28407|      0|            {
28408|      0|              tmp___0 = malloc(sizeof(struct mode_change));
28409|      0|              change = (struct mode_change *)tmp___0;
28410|      0|            }
28411|      0|            if ((unsigned long)change == (unsigned long)((void *)0)) {
28412|      0|              {
28413|      0|                mode_free(head);
28414|      0|              }
28415|      0|              return ((struct mode_change *)1);
28416|      0|            }
28417|      0|            change->next = (struct mode_change *)((void *)0);
28418|      0|            change->op = (char)*mode_string;
28419|      0|            affected_masked = affected_bits;
28420|      0|            if (!who_specified_p) {
28421|      0|              if ((int const) * mode_string == 61) {
28422|      0|                tmp___15 = 1;
28423|      0|              } else {
28424|      0|                tmp___15 = 0;
28425|      0|              }
28426|      0|              if (ops_to_mask & (unsigned int)tmp___15) {
28427|      0|                {
28428|      0|                  tmp___1 = make_node_op_equals((mode_t)0);
28429|      0|                  p___0 = tmp___1;
28430|      0|                }
28431|      0|                if ((unsigned long)p___0 == (unsigned long)((void *)0)) {
28432|      0|                  return ((struct mode_change *)1);
28433|      0|                }
28434|      0|                { mode_append_entry(&head, &tail, p___0); }
28435|      0|              }
28436|      0|            }
28437|      0|            if ((int const) * mode_string == 61) {
28438|      0|              tmp___17 = 1;
28439|      0|            } else {
28440|      0|              if ((int const) * mode_string == 43) {
28441|      0|                tmp___16 = 2;
28442|      0|              } else {
28443|      0|                tmp___16 = 4;
28444|      0|              }
28445|      0|              tmp___17 = tmp___16;
28446|      0|            }
28447|      0|            if (ops_to_mask & (unsigned int)tmp___17) {
28448|      0|              affected_masked &= ~umask_value;
28449|      0|            }
28450|      0|            {
28451|      0|              change->affected = affected_masked;
28452|      0|              change->value = (mode_t)0;
28453|      0|              change->flags = (char)0;
28454|      0|              mode_append_entry(&head, &tail, change);
28455|      0|              mode_string++;
28456|      0|            }
28457|      0|            {
28458|      0|              while (1) {
28459|      0|              while_continue___2: /* CIL Label */;
28460|      0|                {
28461|      0|                  if ((int const) * mode_string == 114) {
28462|      0|                    goto case_114;
28463|      0|                  }
28464|      0|                  if ((int const) * mode_string == 119) {
28465|      0|                    goto case_119;
28466|      0|                  }
28467|      0|                  if ((int const) * mode_string == 88) {
28468|      0|                    goto case_88;
28469|      0|                  }
28470|      0|                  if ((int const) * mode_string == 120) {
28471|      0|                    goto case_120;
28472|      0|                  }
28473|      0|                  if ((int const) * mode_string == 115) {
28474|      0|                    goto case_115;
28475|      0|                  }
28476|      0|                  if ((int const) * mode_string == 116) {
28477|      0|                    goto case_116;
28478|      0|                  }
28479|      0|                  if ((int const) * mode_string == 117) {
28480|      0|                    goto case_117___0;
28481|      0|                  }
28482|      0|                  if ((int const) * mode_string == 103) {
28483|      0|                    goto case_103___0;
28484|      0|                  }
28485|      0|                  if ((int const) * mode_string == 111) {
28486|      0|                    goto case_111___0;
28487|      0|                  }
28488|      0|                  goto switch_default___0;
28489|      0|                case_114: /* CIL Label */
28490|      0|                  change->value |=
28491|      0|                      (unsigned int)((256 | (256 >> 3)) | ((256 >> 3) >> 3)) &
28492|      0|                      affected_masked;
28493|      0|                  goto switch_break___0;
28494|      0|                case_119: /* CIL Label */
28495|      0|                  change->value |=
28496|      0|                      (unsigned int)((128 | (128 >> 3)) | ((128 >> 3) >> 3)) &
28497|      0|                      affected_masked;
28498|      0|                  goto switch_break___0;
28499|      0|                case_88: /* CIL Label */
28500|      0|                  change->flags = (char)((int)change->flags | 1);
28501|      0|                case_120: /* CIL Label */
28502|      0|                  change->value |=
28503|      0|                      (unsigned int)((64 | (64 >> 3)) | ((64 >> 3) >> 3)) &
28504|      0|                      affected_masked;
28505|      0|                  goto switch_break___0;
28506|      0|                case_115: /* CIL Label */
28507|      0|                  change->value |= 3072U & affected_masked;
28508|      0|                  goto switch_break___0;
28509|      0|                case_116: /* CIL Label */
28510|      0|                  change->value |= 512U & affected_masked;
28511|      0|                  goto switch_break___0;
28512|      0|                case_117___0: /* CIL Label */
28513|      0|                  if (change->value) {
28514|      0|                    goto invalid;
28515|      0|                  }
28516|      0|                  change->value = (mode_t)448;
28517|      0|                  change->flags = (char)((int)change->flags | 2);
28518|      0|                  goto switch_break___0;
28519|      0|                case_103___0: /* CIL Label */
28520|      0|                  if (change->value) {
28521|      0|                    goto invalid;
28522|      0|                  }
28523|      0|                  change->value = (mode_t)(448 >> 3);
28524|      0|                  change->flags = (char)((int)change->flags | 2);
28525|      0|                  goto switch_break___0;
28526|      0|                case_111___0: /* CIL Label */
28527|      0|                  if (change->value) {
28528|      0|                    goto invalid;
28529|      0|                  }
28530|      0|                  change->value = (mode_t)((448 >> 3) >> 3);
28531|      0|                  change->flags = (char)((int)change->flags | 2);
28532|      0|                  goto switch_break___0;
28533|      0|                switch_default___0: /* CIL Label */
28534|      0|                  goto no_more_values;
28535|      0|                switch_break___0: /* CIL Label */;
28536|      0|                }
28537|      0|                mode_string++;
28538|      0|              }
28539|      0|            while_break___2: /* CIL Label */;
28540|      0|            }
28541|      0|          no_more_values:;
28542|      0|          }
28543|      0|        while_break___1: /* CIL Label */;
28544|      0|        }
28545|      0|        if (!((int const) * mode_string == 44)) {
28546|      0|          goto while_break;
28547|      0|        }
28548|      0|      }
28549|      0|    while_break: /* CIL Label */;
28550|      0|    }
28551|      0|    if ((int const) * mode_string == 0) {
28552|      0|      return (head);
28553|      0|    }
28554|      0|  invalid : { mode_free(head); }
28555|      0|    return ((struct mode_change *)0);
28556|      0|  }
28557|      0|}
28558|      0|mode_t mode_adjust(mode_t oldmode, struct mode_change const *changes) {
28559|      0|  mode_t newmode;
28560|      0|  mode_t value;
28561|      0|  int tmp;
28562|      0|  int tmp___0;
28563|      0|  int tmp___1;
28564|      0|  int tmp___2;
28565|      0|  int tmp___3;
28566|      0|  int tmp___4;
28567|      0|  int tmp___5;
28568|      0|  int tmp___6;
28569|      0|  int tmp___7;
28570|       |
28571|      0|  {
28572|      0|    newmode = oldmode & (unsigned int)((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
28573|      0|    {
28574|      0|      while (1) {
28575|      0|      while_continue: /* CIL Label */;
28576|      0|        if (!changes) {
28577|      0|          goto while_break;
28578|      0|        }
28579|      0|        if ((int const)changes->flags & 2) {
28580|      0|          value = newmode & (unsigned int)changes->value;
28581|      0|          if (changes->value & 448U) {
28582|      0|            if (value & 256U) {
28583|      0|              tmp = (256 >> 3) | ((256 >> 3) >> 3);
28584|      0|            } else {
28585|      0|              tmp = 0;
28586|      0|            }
28587|      0|            if (value & 128U) {
28588|      0|              tmp___0 = (128 >> 3) | ((128 >> 3) >> 3);
28589|      0|            } else {
28590|      0|              tmp___0 = 0;
28591|      0|            }
28592|      0|            if (value & 64U) {
28593|      0|              tmp___1 = (64 >> 3) | ((64 >> 3) >> 3);
28594|      0|            } else {
28595|      0|              tmp___1 = 0;
28596|      0|            }
28597|      0|            value |= (unsigned int)((tmp | tmp___0) | tmp___1);
28598|      0|          } else {
28599|      0|            if (changes->value & (unsigned int const)(448 >> 3)) {
28600|      0|              if (value & (unsigned int)(256 >> 3)) {
28601|      0|                tmp___2 = 256 | ((256 >> 3) >> 3);
28602|      0|              } else {
28603|      0|                tmp___2 = 0;
28604|      0|              }
28605|      0|              if (value & (unsigned int)(128 >> 3)) {
28606|      0|                tmp___3 = 128 | ((128 >> 3) >> 3);
28607|      0|              } else {
28608|      0|                tmp___3 = 0;
28609|      0|              }
28610|      0|              if (value & (unsigned int)(64 >> 3)) {
28611|      0|                tmp___4 = 64 | ((64 >> 3) >> 3);
28612|      0|              } else {
28613|      0|                tmp___4 = 0;
28614|      0|              }
28615|      0|              value |= (unsigned int)((tmp___2 | tmp___3) | tmp___4);
28616|      0|            } else {
28617|      0|              if (value & (unsigned int)((256 >> 3) >> 3)) {
28618|      0|                tmp___5 = 256 | (256 >> 3);
28619|      0|              } else {
28620|      0|                tmp___5 = 0;
28621|      0|              }
28622|      0|              if (value & (unsigned int)((128 >> 3) >> 3)) {
28623|      0|                tmp___6 = 128 | (128 >> 3);
28624|      0|              } else {
28625|      0|                tmp___6 = 0;
28626|      0|              }
28627|      0|              if (value & (unsigned int)((64 >> 3) >> 3)) {
28628|      0|                tmp___7 = 64 | (64 >> 3);
28629|      0|              } else {
28630|      0|                tmp___7 = 0;
28631|      0|              }
28632|      0|              value |= (unsigned int)((tmp___5 | tmp___6) | tmp___7);
28633|      0|            }
28634|      0|          }
28635|      0|          value &= (unsigned int)changes->affected;
28636|      0|        } else {
28637|      0|          value = (mode_t)changes->value;
28638|      0|          if ((int const)changes->flags & 1) {
28639|      0|            if (!((oldmode & 61440U) == 16384U)) {
28640|      0|              if ((newmode &
28641|      0|                   (unsigned int)((64 | (64 >> 3)) | ((64 >> 3) >> 3))) == 0U) {
28642|      0|                value &= (unsigned int)(~((64 | (64 >> 3)) | ((64 >> 3) >> 3)));
28643|      0|              }
28644|      0|            }
28645|      0|          }
28646|      0|        }
28647|      0|        {
28648|      0|          if ((int const)changes->op == 61) {
28649|      0|            goto case_61;
28650|      0|          }
28651|      0|          if ((int const)changes->op == 43) {
28652|      0|            goto case_43;
28653|      0|          }
28654|      0|          if ((int const)changes->op == 45) {
28655|      0|            goto case_45;
28656|      0|          }
28657|      0|          goto switch_break;
28658|      0|        case_61: /* CIL Label */
28659|      0|          newmode = (newmode & (unsigned int)(~changes->affected)) | value;
28660|      0|          goto switch_break;
28661|      0|        case_43: /* CIL Label */
28662|      0|          newmode |= value;
28663|      0|          goto switch_break;
28664|      0|        case_45: /* CIL Label */
28665|      0|          newmode &= ~value;
28666|      0|          goto switch_break;
28667|      0|        switch_break: /* CIL Label */;
28668|      0|        }
28669|      0|        changes = (struct mode_change const *)changes->next;
28670|      0|      }
28671|      0|    while_break: /* CIL Label */;
28672|      0|    }
28673|      0|    return (newmode);
28674|      0|  }
28675|      0|}
28676|      0|void mode_free(struct mode_change *changes) {
28677|      0|  register struct mode_change *next;
28678|       |
28679|      0|  {
28680|      0|    {
28681|      0|      while (1) {
28682|      0|      while_continue: /* CIL Label */;
28683|      0|        if (!changes) {
28684|      0|          goto while_break;
28685|      0|        }
28686|      0|        {
28687|      0|          next = changes->next;
28688|      0|          free((void *)changes);
28689|      0|          changes = next;
28690|      0|        }
28691|      0|      }
28692|      0|    while_break: /* CIL Label */;
28693|      0|    }
28694|      0|    return;
28695|      0|  }
28696|      0|}
28697|       |/* #pragma merger("0","021.prepargs.o.i","") */
28698|      0|static int prepend_args(char const *options, char *buf, char **argv) {
28699|      0|  char const *o___0;
28700|      0|  char *b;
28701|      0|  int n;
28702|      0|  unsigned short const **tmp;
28703|      0|  char const *tmp___0;
28704|      0|  char *tmp___1;
28705|      0|  char tmp___2;
28706|      0|  char const *tmp___3;
28707|      0|  unsigned short const **tmp___4;
28708|      0|  char *tmp___5;
28709|       |
28710|      0|  {
28711|      0|    o___0 = options;
28712|      0|    b = buf;
28713|      0|    n = 0;
28714|      0|    {
28715|      0|      while (1) {
28716|      0|      while_continue: /* CIL Label */;
28717|      0|        {
28718|      0|          while (1) {
28719|      0|          while_continue___0: /* CIL Label */;
28720|      0|            { tmp = __ctype_b_loc(); }
28721|      0|            if (!((int const) * (*tmp + (int)((unsigned char)*o___0)) & 8192)) {
28722|      0|              goto while_break___0;
28723|      0|            }
28724|      0|            o___0++;
28725|      0|          }
28726|      0|        while_break___0: /* CIL Label */;
28727|      0|        }
28728|      0|        if (!*o___0) {
28729|      0|          return (n);
28730|      0|        }
28731|      0|        if (argv) {
28732|      0|          *(argv + n) = b;
28733|      0|        }
28734|      0|        n++;
28735|      0|        {
28736|      0|          while (1) {
28737|      0|          while_continue___1: /* CIL Label */;
28738|      0|            tmp___1 = b;
28739|      0|            b++;
28740|      0|            tmp___3 = o___0;
28741|      0|            o___0++;
28742|      0|            tmp___2 = (char)*tmp___3;
28743|      0|            *tmp___1 = tmp___2;
28744|      0|            if ((int)tmp___2 == 92) {
28745|      0|              if (*o___0) {
28746|      0|                tmp___0 = o___0;
28747|      0|                o___0++;
28748|      0|                *(b + -1) = (char)*tmp___0;
28749|      0|              }
28750|      0|            }
28751|      0|            if (*o___0) {
28752|      0|              {
28753|      0|                tmp___4 = __ctype_b_loc();
28754|      0|              }
28755|      0|              if ((int const) * (*tmp___4 + (int)((unsigned char)*o___0)) &
28756|      0|                  8192) {
28757|      0|                goto while_break___1;
28758|      0|              }
28759|      0|            } else {
28760|      0|              goto while_break___1;
28761|      0|            }
28762|      0|          }
28763|      0|        while_break___1: /* CIL Label */;
28764|      0|        }
28765|      0|        tmp___5 = b;
28766|      0|        b++;
28767|      0|        *tmp___5 = (char)'\000';
28768|      0|      }
28769|      0|    while_break: /* CIL Label */;
28770|      0|    }
28771|      0|  }
28772|      0|}
28773|      0|void prepend_default_options(char const *options, int *pargc, char ***pargv) {
28774|      0|  char *buf;
28775|      0|  size_t tmp;
28776|      0|  void *tmp___0;
28777|      0|  int prepended;
28778|      0|  int tmp___1;
28779|      0|  int argc;
28780|      0|  char *const *argv;
28781|      0|  char **pp;
28782|      0|  void *tmp___2;
28783|      0|  char **tmp___3;
28784|      0|  char *const *tmp___4;
28785|      0|  int tmp___5;
28786|      0|  char **tmp___6;
28787|      0|  char *tmp___7;
28788|      0|  char *const *tmp___8;
28789|       |
28790|      0|  {
28791|      0|    if (options) {
28792|      0|      {
28793|      0|        tmp = strlen(options);
28794|      0|        tmp___0 = xmalloc(tmp + 1UL);
28795|      0|        buf = (char *)tmp___0;
28796|      0|        tmp___1 = prepend_args(options, buf, (char **)0);
28797|      0|        prepended = tmp___1;
28798|      0|        argc = *pargc;
28799|      0|        argv = (char *const *)*pargv;
28800|      0|        tmp___2 =
28801|      0|            xmalloc((unsigned long)((prepended + argc) + 1) * sizeof(*pp));
28802|      0|        pp = (char **)tmp___2;
28803|      0|        *pargc = prepended + argc;
28804|      0|        *pargv = pp;
28805|      0|        tmp___3 = pp;
28806|      0|        pp++;
28807|      0|        tmp___4 = argv;
28808|      0|        argv++;
28809|      0|        *tmp___3 = (char *)*tmp___4;
28810|      0|        tmp___5 = prepend_args(options, buf, pp);
28811|      0|        pp += tmp___5;
28812|      0|      }
28813|      0|      {
28814|      0|        while (1) {
28815|      0|        while_continue: /* CIL Label */;
28816|      0|          tmp___6 = pp;
28817|      0|          pp++;
28818|      0|          tmp___8 = argv;
28819|      0|          argv++;
28820|      0|          tmp___7 = (char *)*tmp___8;
28821|      0|          *tmp___6 = tmp___7;
28822|      0|          if (!tmp___7) {
28823|      0|            goto while_break;
28824|      0|          }
28825|      0|          goto while_continue;
28826|      0|        }
28827|      0|      while_break: /* CIL Label */;
28828|      0|      }
28829|      0|    }
28830|      0|    return;
28831|      0|  }
28832|      0|}
28833|       |/* #pragma merger("0","022.quotearg.o.i","") */
28834|       |char const *const quoting_style_args[8];
28835|       |enum quoting_style const quoting_style_vals[7];
28836|       |int set_char_quoting(struct quoting_options *o___0, char c, int i);
28837|       |char *quotearg_n(int n, char const *arg);
28838|       |char *quotearg_char(char const *arg, char ch);
28839|       |extern __attribute__((__nothrow__))
28840|       |size_t(__attribute__((__leaf__)) __ctype_get_mb_cur_max)(void);
28841|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
28842|       |                                        mbsinit)(mbstate_t const *__ps)
28843|       |    __attribute__((__pure__));
28844|       |extern __attribute__((__nothrow__))
28845|       |size_t(__attribute__((__leaf__))
28846|       |       mbrtowc)(wchar_t *__restrict __pwc, char const *__restrict __s,
28847|       |                size_t __n, mbstate_t *__restrict __p);
28848|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
28849|       |                                        iswprint)(wint_t __wc);
28850|       |char const *const quoting_style_args[8] = {
28851|       |    (char const * /* const  */) "literal",
28852|       |    (char const * /* const  */) "shell",
28853|       |    (char const * /* const  */) "shell-always",
28854|       |    (char const * /* const  */) "c",
28855|       |    (char const * /* const  */) "escape",
28856|       |    (char const * /* const  */) "locale",
28857|       |    (char const * /* const  */) "clocale",
28858|       |    (char const * /* const  */)0};
28859|       |enum quoting_style const quoting_style_vals[7] = {
28860|       |    (enum quoting_style const)0, (enum quoting_style const)1,
28861|       |    (enum quoting_style const)2, (enum quoting_style const)3,
28862|       |    (enum quoting_style const)4, (enum quoting_style const)5,
28863|       |    (enum quoting_style const)6};
28864|       |static struct quoting_options default_quoting_options;
28865|      0|struct quoting_options *clone_quoting_options(struct quoting_options *o___0) {
28866|      0|  int e;
28867|      0|  int *tmp;
28868|      0|  struct quoting_options *p;
28869|      0|  void *tmp___0;
28870|      0|  int *tmp___1;
28871|      0|  struct quoting_options *tmp___2;
28872|       |
28873|      0|  {
28874|      0|    {
28875|      0|      tmp = __errno_location();
28876|      0|      e = *tmp;
28877|      0|      tmp___0 = xmalloc(sizeof(*p));
28878|      0|      p = (struct quoting_options *)tmp___0;
28879|      0|    }
28880|      0|    if (o___0) {
28881|      0|      tmp___2 = o___0;
28882|      0|    } else {
28883|      0|      tmp___2 = &default_quoting_options;
28884|      0|    }
28885|      0|    {
28886|      0|      *p = *tmp___2;
28887|      0|      tmp___1 = __errno_location();
28888|      0|      *tmp___1 = e;
28889|      0|    }
28890|      0|    return (p);
28891|      0|  }
28892|      0|}
28893|      0|void set_quoting_style(struct quoting_options *o___0, enum quoting_style s) {
28894|      0|  struct quoting_options *tmp;
28895|       |
28896|      0|  {
28897|      0|    if (o___0) {
28898|      0|      tmp = o___0;
28899|      0|    } else {
28900|      0|      tmp = &default_quoting_options;
28901|      0|    }
28902|      0|    tmp->style = s;
28903|      0|    return;
28904|      0|  }
28905|      0|}
28906|      0|int set_char_quoting(struct quoting_options *o___0, char c, int i) {
28907|      0|  unsigned char uc;
28908|      0|  int *p;
28909|      0|  int shift;
28910|      0|  int r;
28911|      0|  struct quoting_options *tmp;
28912|       |
28913|      0|  {
28914|      0|    uc = (unsigned char)c;
28915|      0|    if (o___0) {
28916|      0|      tmp = o___0;
28917|      0|    } else {
28918|      0|      tmp = &default_quoting_options;
28919|      0|    }
28920|      0|    p = tmp->quote_these_too + (unsigned long)uc / (sizeof(int) * 8UL);
28921|      0|    shift = (int)((unsigned long)uc % (sizeof(int) * 8UL));
28922|      0|    r = (*p >> shift) & 1;
28923|      0|    *p ^= ((i & 1) ^ r) << shift;
28924|      0|    return (r);
28925|      0|  }
28926|      0|}
28927|      0|static char const *gettext_quote(char const *msgid, enum quoting_style s) {
28928|      0|  char const *translation;
28929|      0|  char *tmp;
28930|      0|  char *__cil_tmp5;
28931|       |
28932|      0|  {
28933|      0|    {
28934|      0|      tmp = gettext(msgid);
28935|      0|      translation = (char const *)tmp;
28936|      0|    }
28937|      0|    if ((unsigned long)translation == (unsigned long)msgid) {
28938|      0|      if ((unsigned int)s == 6U) {
28939|      0|        translation = "\"";
28940|      0|      }
28941|      0|    }
28942|      0|    return (translation);
28943|      0|  }
28944|      0|}
28945|       |static size_t quotearg_buffer_restyled(char *buffer___2, size_t buffersize,
28946|       |                                       char const *arg, size_t argsize,
28947|       |                                       enum quoting_style quoting_style,
28948|      0|                                       struct quoting_options const *o___0) {
28949|      0|  size_t i;
28950|      0|  size_t len;
28951|      0|  char const *quote_string;
28952|      0|  size_t quote_string_len;
28953|      0|  int backslash_escapes;
28954|      0|  int unibyte_locale;
28955|      0|  size_t tmp;
28956|      0|  char const *left;
28957|      0|  char const *tmp___0;
28958|      0|  char const *right;
28959|      0|  char const *tmp___1;
28960|      0|  unsigned char c;
28961|      0|  unsigned char esc;
28962|      0|  int tmp___2;
28963|      0|  size_t m;
28964|      0|  int printable;
28965|      0|  unsigned short const **tmp___3;
28966|      0|  mbstate_t mbstate;
28967|      0|  wchar_t w;
28968|      0|  size_t bytes;
28969|      0|  size_t tmp___4;
28970|      0|  size_t j;
28971|      0|  int tmp___5;
28972|      0|  int tmp___6;
28973|      0|  size_t ilim;
28974|      0|  size_t tmp___7;
28975|      0|  int tmp___8;
28976|      0|  int tmp___9;
28977|      0|  void *__cil_tmp35;
28978|      0|  char *__cil_tmp36;
28979|      0|  char *__cil_tmp37;
28980|      0|  char *__cil_tmp38;
28981|      0|  char *__cil_tmp39;
28982|       |
28983|      0|  {
28984|      0|    {
28985|      0|      len = (size_t)0;
28986|      0|      quote_string = (char const *)0;
28987|      0|      quote_string_len = (size_t)0;
28988|      0|      backslash_escapes = 0;
28989|      0|      tmp = __ctype_get_mb_cur_max();
28990|      0|      unibyte_locale = tmp == 1UL;
28991|      0|    }
28992|      0|    {
28993|      0|      if ((unsigned int)quoting_style == 3U) {
28994|      0|        goto case_3;
28995|      0|      }
28996|      0|      if ((unsigned int)quoting_style == 4U) {
28997|      0|        goto case_4;
28998|      0|      }
28999|      0|      if ((unsigned int)quoting_style == 5U) {
29000|      0|        goto case_5;
29001|      0|      }
29002|      0|      if ((unsigned int)quoting_style == 6U) {
29003|      0|        goto case_5;
29004|      0|      }
29005|      0|      if ((unsigned int)quoting_style == 2U) {
29006|      0|        goto case_2;
29007|      0|      }
29008|      0|      goto switch_default;
29009|      0|    case_3 : /* CIL Label */
29010|      0|    {
29011|      0|      while (1) {
29012|      0|      while_continue: /* CIL Label */;
29013|      0|        if (len < buffersize) {
29014|      0|          *(buffer___2 + len) = (char)'\"';
29015|      0|        }
29016|      0|        len++;
29017|      0|        goto while_break;
29018|      0|      }
29019|      0|    while_break: /* CIL Label */;
29020|      0|    }
29021|      0|      backslash_escapes = 1;
29022|      0|      quote_string = "\"";
29023|      0|      quote_string_len = (size_t)1;
29024|      0|      goto switch_break;
29025|      0|    case_4: /* CIL Label */
29026|      0|      backslash_escapes = 1;
29027|      0|      goto switch_break;
29028|      0|    case_5:  /* CIL Label */
29029|      0|    case_6 : /* CIL Label */
29030|      0|    {
29031|      0|      tmp___0 = gettext_quote("`", quoting_style);
29032|      0|      left = tmp___0;
29033|      0|      tmp___1 = gettext_quote("\'", quoting_style);
29034|      0|      right = tmp___1;
29035|      0|      quote_string = left;
29036|      0|    }
29037|      0|      {
29038|      0|        while (1) {
29039|      0|        while_continue___0: /* CIL Label */;
29040|      0|          if (!*quote_string) {
29041|      0|            goto while_break___0;
29042|      0|          }
29043|      0|          {
29044|      0|            while (1) {
29045|      0|            while_continue___1: /* CIL Label */;
29046|      0|              if (len < buffersize) {
29047|      0|                *(buffer___2 + len) = (char)*quote_string;
29048|      0|              }
29049|      0|              len++;
29050|      0|              goto while_break___1;
29051|      0|            }
29052|      0|          while_break___1: /* CIL Label */;
29053|      0|          }
29054|      0|          quote_string++;
29055|      0|        }
29056|      0|      while_break___0: /* CIL Label */;
29057|      0|      }
29058|      0|      {
29059|      0|        backslash_escapes = 1;
29060|      0|        quote_string = right;
29061|      0|        quote_string_len = strlen(quote_string);
29062|      0|      }
29063|      0|      goto switch_break;
29064|      0|    case_2 : /* CIL Label */
29065|      0|    {
29066|      0|      while (1) {
29067|      0|      while_continue___2: /* CIL Label */;
29068|      0|        if (len < buffersize) {
29069|      0|          *(buffer___2 + len) = (char)'\'';
29070|      0|        }
29071|      0|        len++;
29072|      0|        goto while_break___2;
29073|      0|      }
29074|      0|    while_break___2: /* CIL Label */;
29075|      0|    }
29076|      0|      quote_string = "\'";
29077|      0|      quote_string_len = (size_t)1;
29078|      0|      goto switch_break;
29079|      0|    switch_default: /* CIL Label */
29080|      0|      goto switch_break;
29081|      0|    switch_break: /* CIL Label */;
29082|      0|    }
29083|      0|    i = (size_t)0;
29084|      0|    {
29085|      0|      while (1) {
29086|      0|      while_continue___3: /* CIL Label */;
29087|      0|        if (argsize == 0xffffffffffffffffUL) {
29088|      0|          tmp___9 = (int const) * (arg + i) == 0;
29089|      0|        } else {
29090|      0|          tmp___9 = i == argsize;
29091|      0|        }
29092|      0|        if (tmp___9) {
29093|      0|          goto while_break___3;
29094|      0|        }
29095|      0|        if (backslash_escapes) {
29096|      0|          if (quote_string_len) {
29097|      0|            if (i + quote_string_len <= argsize) {
29098|      0|              {
29099|      0|                tmp___2 = memcmp((void const *)(arg + i),
29100|      0|                                 (void const *)quote_string, quote_string_len);
29101|      0|              }
29102|      0|              if (tmp___2 == 0) {
29103|      0|                {
29104|      0|                  while (1) {
29105|      0|                  while_continue___4: /* CIL Label */;
29106|      0|                    if (len < buffersize) {
29107|      0|                      *(buffer___2 + len) = (char)'\\';
29108|      0|                    }
29109|      0|                    len++;
29110|      0|                    goto while_break___4;
29111|      0|                  }
29112|      0|                while_break___4: /* CIL Label */;
29113|      0|                }
29114|      0|              }
29115|      0|            }
29116|      0|          }
29117|      0|        }
29118|      0|        c = (unsigned char)*(arg + i);
29119|      0|        {
29120|      0|          if ((int)c == 0) {
29121|      0|            goto case_0;
29122|      0|          }
29123|      0|          if ((int)c == 63) {
29124|      0|            goto case_63;
29125|      0|          }
29126|      0|          if ((int)c == 7) {
29127|      0|            goto case_7;
29128|      0|          }
29129|      0|          if ((int)c == 8) {
29130|      0|            goto case_8;
29131|      0|          }
29132|      0|          if ((int)c == 12) {
29133|      0|            goto case_12;
29134|      0|          }
29135|      0|          if ((int)c == 10) {
29136|      0|            goto case_10;
29137|      0|          }
29138|      0|          if ((int)c == 13) {
29139|      0|            goto case_13;
29140|      0|          }
29141|      0|          if ((int)c == 9) {
29142|      0|            goto case_9;
29143|      0|          }
29144|      0|          if ((int)c == 11) {
29145|      0|            goto case_11;
29146|      0|          }
29147|      0|          if ((int)c == 92) {
29148|      0|            goto case_92;
29149|      0|          }
29150|      0|          if ((int)c == 123) {
29151|      0|            goto case_123;
29152|      0|          }
29153|      0|          if ((int)c == 125) {
29154|      0|            goto case_123;
29155|      0|          }
29156|      0|          if ((int)c == 35) {
29157|      0|            goto case_35;
29158|      0|          }
29159|      0|          if ((int)c == 126) {
29160|      0|            goto case_35;
29161|      0|          }
29162|      0|          if ((int)c == 32) {
29163|      0|            goto case_32;
29164|      0|          }
29165|      0|          if ((int)c == 33) {
29166|      0|            goto case_32;
29167|      0|          }
29168|      0|          if ((int)c == 34) {
29169|      0|            goto case_32;
29170|      0|          }
29171|      0|          if ((int)c == 36) {
29172|      0|            goto case_32;
29173|      0|          }
29174|      0|          if ((int)c == 38) {
29175|      0|            goto case_32;
29176|      0|          }
29177|      0|          if ((int)c == 40) {
29178|      0|            goto case_32;
29179|      0|          }
29180|      0|          if ((int)c == 41) {
29181|      0|            goto case_32;
29182|      0|          }
29183|      0|          if ((int)c == 42) {
29184|      0|            goto case_32;
29185|      0|          }
29186|      0|          if ((int)c == 59) {
29187|      0|            goto case_32;
29188|      0|          }
29189|      0|          if ((int)c == 60) {
29190|      0|            goto case_32;
29191|      0|          }
29192|      0|          if ((int)c == 61) {
29193|      0|            goto case_32;
29194|      0|          }
29195|      0|          if ((int)c == 62) {
29196|      0|            goto case_32;
29197|      0|          }
29198|      0|          if ((int)c == 91) {
29199|      0|            goto case_32;
29200|      0|          }
29201|      0|          if ((int)c == 94) {
29202|      0|            goto case_32;
29203|      0|          }
29204|      0|          if ((int)c == 96) {
29205|      0|            goto case_32;
29206|      0|          }
29207|      0|          if ((int)c == 124) {
29208|      0|            goto case_32;
29209|      0|          }
29210|      0|          if ((int)c == 39) {
29211|      0|            goto case_39___0;
29212|      0|          }
29213|      0|          if ((int)c == 37) {
29214|      0|            goto case_37;
29215|      0|          }
29216|      0|          if ((int)c == 43) {
29217|      0|            goto case_37;
29218|      0|          }
29219|      0|          if ((int)c == 44) {
29220|      0|            goto case_37;
29221|      0|          }
29222|      0|          if ((int)c == 45) {
29223|      0|            goto case_37;
29224|      0|          }
29225|      0|          if ((int)c == 46) {
29226|      0|            goto case_37;
29227|      0|          }
29228|      0|          if ((int)c == 47) {
29229|      0|            goto case_37;
29230|      0|          }
29231|      0|          if ((int)c == 48) {
29232|      0|            goto case_37;
29233|      0|          }
29234|      0|          if ((int)c == 49) {
29235|      0|            goto case_37;
29236|      0|          }
29237|      0|          if ((int)c == 50) {
29238|      0|            goto case_37;
29239|      0|          }
29240|      0|          if ((int)c == 51) {
29241|      0|            goto case_37;
29242|      0|          }
29243|      0|          if ((int)c == 52) {
29244|      0|            goto case_37;
29245|      0|          }
29246|      0|          if ((int)c == 53) {
29247|      0|            goto case_37;
29248|      0|          }
29249|      0|          if ((int)c == 54) {
29250|      0|            goto case_37;
29251|      0|          }
29252|      0|          if ((int)c == 55) {
29253|      0|            goto case_37;
29254|      0|          }
29255|      0|          if ((int)c == 56) {
29256|      0|            goto case_37;
29257|      0|          }
29258|      0|          if ((int)c == 57) {
29259|      0|            goto case_37;
29260|      0|          }
29261|      0|          if ((int)c == 58) {
29262|      0|            goto case_37;
29263|      0|          }
29264|      0|          if ((int)c == 65) {
29265|      0|            goto case_37;
29266|      0|          }
29267|      0|          if ((int)c == 66) {
29268|      0|            goto case_37;
29269|      0|          }
29270|      0|          if ((int)c == 67) {
29271|      0|            goto case_37;
29272|      0|          }
29273|      0|          if ((int)c == 68) {
29274|      0|            goto case_37;
29275|      0|          }
29276|      0|          if ((int)c == 69) {
29277|      0|            goto case_37;
29278|      0|          }
29279|      0|          if ((int)c == 70) {
29280|      0|            goto case_37;
29281|      0|          }
29282|      0|          if ((int)c == 71) {
29283|      0|            goto case_37;
29284|      0|          }
29285|      0|          if ((int)c == 72) {
29286|      0|            goto case_37;
29287|      0|          }
29288|      0|          if ((int)c == 73) {
29289|      0|            goto case_37;
29290|      0|          }
29291|      0|          if ((int)c == 74) {
29292|      0|            goto case_37;
29293|      0|          }
29294|      0|          if ((int)c == 75) {
29295|      0|            goto case_37;
29296|      0|          }
29297|      0|          if ((int)c == 76) {
29298|      0|            goto case_37;
29299|      0|          }
29300|      0|          if ((int)c == 77) {
29301|      0|            goto case_37;
29302|      0|          }
29303|      0|          if ((int)c == 78) {
29304|      0|            goto case_37;
29305|      0|          }
29306|      0|          if ((int)c == 79) {
29307|      0|            goto case_37;
29308|      0|          }
29309|      0|          if ((int)c == 80) {
29310|      0|            goto case_37;
29311|      0|          }
29312|      0|          if ((int)c == 81) {
29313|      0|            goto case_37;
29314|      0|          }
29315|      0|          if ((int)c == 82) {
29316|      0|            goto case_37;
29317|      0|          }
29318|      0|          if ((int)c == 83) {
29319|      0|            goto case_37;
29320|      0|          }
29321|      0|          if ((int)c == 84) {
29322|      0|            goto case_37;
29323|      0|          }
29324|      0|          if ((int)c == 85) {
29325|      0|            goto case_37;
29326|      0|          }
29327|      0|          if ((int)c == 86) {
29328|      0|            goto case_37;
29329|      0|          }
29330|      0|          if ((int)c == 87) {
29331|      0|            goto case_37;
29332|      0|          }
29333|      0|          if ((int)c == 88) {
29334|      0|            goto case_37;
29335|      0|          }
29336|      0|          if ((int)c == 89) {
29337|      0|            goto case_37;
29338|      0|          }
29339|      0|          if ((int)c == 90) {
29340|      0|            goto case_37;
29341|      0|          }
29342|      0|          if ((int)c == 93) {
29343|      0|            goto case_37;
29344|      0|          }
29345|      0|          if ((int)c == 95) {
29346|      0|            goto case_37;
29347|      0|          }
29348|      0|          if ((int)c == 97) {
29349|      0|            goto case_37;
29350|      0|          }
29351|      0|          if ((int)c == 98) {
29352|      0|            goto case_37;
29353|      0|          }
29354|      0|          if ((int)c == 99) {
29355|      0|            goto case_37;
29356|      0|          }
29357|      0|          if ((int)c == 100) {
29358|      0|            goto case_37;
29359|      0|          }
29360|      0|          if ((int)c == 101) {
29361|      0|            goto case_37;
29362|      0|          }
29363|      0|          if ((int)c == 102) {
29364|      0|            goto case_37;
29365|      0|          }
29366|      0|          if ((int)c == 103) {
29367|      0|            goto case_37;
29368|      0|          }
29369|      0|          if ((int)c == 104) {
29370|      0|            goto case_37;
29371|      0|          }
29372|      0|          if ((int)c == 105) {
29373|      0|            goto case_37;
29374|      0|          }
29375|      0|          if ((int)c == 106) {
29376|      0|            goto case_37;
29377|      0|          }
29378|      0|          if ((int)c == 107) {
29379|      0|            goto case_37;
29380|      0|          }
29381|      0|          if ((int)c == 108) {
29382|      0|            goto case_37;
29383|      0|          }
29384|      0|          if ((int)c == 109) {
29385|      0|            goto case_37;
29386|      0|          }
29387|      0|          if ((int)c == 110) {
29388|      0|            goto case_37;
29389|      0|          }
29390|      0|          if ((int)c == 111) {
29391|      0|            goto case_37;
29392|      0|          }
29393|      0|          if ((int)c == 112) {
29394|      0|            goto case_37;
29395|      0|          }
29396|      0|          if ((int)c == 113) {
29397|      0|            goto case_37;
29398|      0|          }
29399|      0|          if ((int)c == 114) {
29400|      0|            goto case_37;
29401|      0|          }
29402|      0|          if ((int)c == 115) {
29403|      0|            goto case_37;
29404|      0|          }
29405|      0|          if ((int)c == 116) {
29406|      0|            goto case_37;
29407|      0|          }
29408|      0|          if ((int)c == 117) {
29409|      0|            goto case_37;
29410|      0|          }
29411|      0|          if ((int)c == 118) {
29412|      0|            goto case_37;
29413|      0|          }
29414|      0|          if ((int)c == 119) {
29415|      0|            goto case_37;
29416|      0|          }
29417|      0|          if ((int)c == 120) {
29418|      0|            goto case_37;
29419|      0|          }
29420|      0|          if ((int)c == 121) {
29421|      0|            goto case_37;
29422|      0|          }
29423|      0|          if ((int)c == 122) {
29424|      0|            goto case_37;
29425|      0|          }
29426|      0|          goto switch_default___2;
29427|      0|        case_0: /* CIL Label */
29428|      0|          if (backslash_escapes) {
29429|      0|            {
29430|      0|              while (1) {
29431|      0|              while_continue___5: /* CIL Label */;
29432|      0|                if (len < buffersize) {
29433|      0|                  *(buffer___2 + len) = (char)'\\';
29434|      0|                }
29435|      0|                len++;
29436|      0|                goto while_break___5;
29437|      0|              }
29438|      0|            while_break___5: /* CIL Label */;
29439|      0|            }
29440|      0|            {
29441|      0|              while (1) {
29442|      0|              while_continue___6: /* CIL Label */;
29443|      0|                if (len < buffersize) {
29444|      0|                  *(buffer___2 + len) = (char)'0';
29445|      0|                }
29446|      0|                len++;
29447|      0|                goto while_break___6;
29448|      0|              }
29449|      0|            while_break___6: /* CIL Label */;
29450|      0|            }
29451|      0|            {
29452|      0|              while (1) {
29453|      0|              while_continue___7: /* CIL Label */;
29454|      0|                if (len < buffersize) {
29455|      0|                  *(buffer___2 + len) = (char)'0';
29456|      0|                }
29457|      0|                len++;
29458|      0|                goto while_break___7;
29459|      0|              }
29460|      0|            while_break___7: /* CIL Label */;
29461|      0|            }
29462|      0|            c = (unsigned char)'0';
29463|      0|          }
29464|      0|          goto switch_break___0;
29465|      0|        case_63 : /* CIL Label */
29466|      0|        {
29467|      0|          if ((unsigned int)quoting_style == 1U) {
29468|      0|            goto case_1;
29469|      0|          }
29470|      0|          if ((unsigned int)quoting_style == 3U) {
29471|      0|            goto case_3___0;
29472|      0|          }
29473|      0|          goto switch_default___0;
29474|      0|        case_1: /* CIL Label */
29475|      0|          goto use_shell_always_quoting_style;
29476|      0|        case_3___0: /* CIL Label */
29477|      0|          if (i + 2UL < argsize) {
29478|      0|            if ((int const) * (arg + (i + 1UL)) == 63) {
29479|      0|              {
29480|      0|                if ((int const) * (arg + (i + 2UL)) == 33) {
29481|      0|                  goto case_33;
29482|      0|                }
29483|      0|                if ((int const) * (arg + (i + 2UL)) == 39) {
29484|      0|                  goto case_33;
29485|      0|                }
29486|      0|                if ((int const) * (arg + (i + 2UL)) == 40) {
29487|      0|                  goto case_33;
29488|      0|                }
29489|      0|                if ((int const) * (arg + (i + 2UL)) == 41) {
29490|      0|                  goto case_33;
29491|      0|                }
29492|      0|                if ((int const) * (arg + (i + 2UL)) == 45) {
29493|      0|                  goto case_33;
29494|      0|                }
29495|      0|                if ((int const) * (arg + (i + 2UL)) == 47) {
29496|      0|                  goto case_33;
29497|      0|                }
29498|      0|                if ((int const) * (arg + (i + 2UL)) == 60) {
29499|      0|                  goto case_33;
29500|      0|                }
29501|      0|                if ((int const) * (arg + (i + 2UL)) == 61) {
29502|      0|                  goto case_33;
29503|      0|                }
29504|      0|                if ((int const) * (arg + (i + 2UL)) == 62) {
29505|      0|                  goto case_33;
29506|      0|                }
29507|      0|                goto switch_break___2;
29508|      0|              case_33: /* CIL Label */
29509|      0|              case_39: /* CIL Label */
29510|      0|              case_40: /* CIL Label */
29511|      0|              case_41: /* CIL Label */
29512|      0|              case_45: /* CIL Label */
29513|      0|              case_47: /* CIL Label */
29514|      0|              case_60: /* CIL Label */
29515|      0|              case_61: /* CIL Label */
29516|      0|              case_62: /* CIL Label */
29517|      0|                c = (unsigned char)*(arg + (i + 2UL));
29518|      0|                i += 2UL;
29519|      0|                {
29520|      0|                  while (1) {
29521|      0|                  while_continue___8: /* CIL Label */;
29522|      0|                    if (len < buffersize) {
29523|      0|                      *(buffer___2 + len) = (char)'?';
29524|      0|                    }
29525|      0|                    len++;
29526|      0|                    goto while_break___8;
29527|      0|                  }
29528|      0|                while_break___8: /* CIL Label */;
29529|      0|                }
29530|      0|                {
29531|      0|                  while (1) {
29532|      0|                  while_continue___9: /* CIL Label */;
29533|      0|                    if (len < buffersize) {
29534|      0|                      *(buffer___2 + len) = (char)'\\';
29535|      0|                    }
29536|      0|                    len++;
29537|      0|                    goto while_break___9;
29538|      0|                  }
29539|      0|                while_break___9: /* CIL Label */;
29540|      0|                }
29541|      0|                {
29542|      0|                  while (1) {
29543|      0|                  while_continue___10: /* CIL Label */;
29544|      0|                    if (len < buffersize) {
29545|      0|                      *(buffer___2 + len) = (char)'?';
29546|      0|                    }
29547|      0|                    len++;
29548|      0|                    goto while_break___10;
29549|      0|                  }
29550|      0|                while_break___10: /* CIL Label */;
29551|      0|                }
29552|      0|                goto switch_break___2;
29553|      0|              switch_break___2: /* CIL Label */;
29554|      0|              }
29555|      0|            }
29556|      0|          }
29557|      0|          goto switch_break___1;
29558|      0|        switch_default___0: /* CIL Label */
29559|      0|          goto switch_break___1;
29560|      0|        switch_break___1: /* CIL Label */;
29561|      0|        }
29562|      0|          goto switch_break___0;
29563|      0|        case_7: /* CIL Label */
29564|      0|          esc = (unsigned char)'a';
29565|      0|          goto c_escape;
29566|      0|        case_8: /* CIL Label */
29567|      0|          esc = (unsigned char)'b';
29568|      0|          goto c_escape;
29569|      0|        case_12: /* CIL Label */
29570|      0|          esc = (unsigned char)'f';
29571|      0|          goto c_escape;
29572|      0|        case_10: /* CIL Label */
29573|      0|          esc = (unsigned char)'n';
29574|      0|          goto c_and_shell_escape;
29575|      0|        case_13: /* CIL Label */
29576|      0|          esc = (unsigned char)'r';
29577|      0|          goto c_and_shell_escape;
29578|      0|        case_9: /* CIL Label */
29579|      0|          esc = (unsigned char)'t';
29580|      0|          goto c_and_shell_escape;
29581|      0|        case_11: /* CIL Label */
29582|      0|          esc = (unsigned char)'v';
29583|      0|          goto c_escape;
29584|      0|        case_92: /* CIL Label */
29585|      0|          esc = c;
29586|      0|          goto c_and_shell_escape;
29587|      0|        c_and_shell_escape:
29588|      0|          if ((unsigned int)quoting_style == 1U) {
29589|      0|            goto use_shell_always_quoting_style;
29590|      0|          }
29591|      0|        c_escape:
29592|      0|          if (backslash_escapes) {
29593|      0|            c = esc;
29594|      0|            goto store_escape;
29595|      0|          }
29596|      0|          goto switch_break___0;
29597|      0|        case_123: /* CIL Label */
29598|      0|        case_125: /* CIL Label */
29599|      0|          if (argsize == 0xffffffffffffffffUL) {
29600|      0|            tmp___8 = (int const) * (arg + 1) == 0;
29601|      0|          } else {
29602|      0|            tmp___8 = argsize == 1UL;
29603|      0|          }
29604|      0|          if (!tmp___8) {
29605|      0|            goto switch_break___0;
29606|      0|          }
29607|      0|        case_35:  /* CIL Label */
29608|      0|        case_126: /* CIL Label */
29609|      0|          if (i != 0UL) {
29610|      0|            goto switch_break___0;
29611|      0|          }
29612|      0|        case_32:     /* CIL Label */
29613|      0|        case_33___0: /* CIL Label */
29614|      0|        case_34:     /* CIL Label */
29615|      0|        case_36:     /* CIL Label */
29616|      0|        case_38:     /* CIL Label */
29617|      0|        case_40___0: /* CIL Label */
29618|      0|        case_41___0: /* CIL Label */
29619|      0|        case_42:     /* CIL Label */
29620|      0|        case_59:     /* CIL Label */
29621|      0|        case_60___0: /* CIL Label */
29622|      0|        case_61___0: /* CIL Label */
29623|      0|        case_62___0: /* CIL Label */
29624|      0|        case_91:     /* CIL Label */
29625|      0|        case_94:     /* CIL Label */
29626|      0|        case_96:     /* CIL Label */
29627|      0|        case_124:    /* CIL Label */
29628|      0|          if ((unsigned int)quoting_style == 1U) {
29629|      0|            goto use_shell_always_quoting_style;
29630|      0|          }
29631|      0|          goto switch_break___0;
29632|      0|        case_39___0 : /* CIL Label */
29633|      0|        {
29634|      0|          if ((unsigned int)quoting_style == 1U) {
29635|      0|            goto case_1___0;
29636|      0|          }
29637|      0|          if ((unsigned int)quoting_style == 2U) {
29638|      0|            goto case_2___0;
29639|      0|          }
29640|      0|          goto switch_default___1;
29641|      0|        case_1___0: /* CIL Label */
29642|      0|          goto use_shell_always_quoting_style;
29643|      0|        case_2___0 : /* CIL Label */
29644|      0|        {
29645|      0|          while (1) {
29646|      0|          while_continue___11: /* CIL Label */;
29647|      0|            if (len < buffersize) {
29648|      0|              *(buffer___2 + len) = (char)'\'';
29649|      0|            }
29650|      0|            len++;
29651|      0|            goto while_break___11;
29652|      0|          }
29653|      0|        while_break___11: /* CIL Label */;
29654|      0|        }
29655|      0|          {
29656|      0|            while (1) {
29657|      0|            while_continue___12: /* CIL Label */;
29658|      0|              if (len < buffersize) {
29659|      0|                *(buffer___2 + len) = (char)'\\';
29660|      0|              }
29661|      0|              len++;
29662|      0|              goto while_break___12;
29663|      0|            }
29664|      0|          while_break___12: /* CIL Label */;
29665|      0|          }
29666|      0|          {
29667|      0|            while (1) {
29668|      0|            while_continue___13: /* CIL Label */;
29669|      0|              if (len < buffersize) {
29670|      0|                *(buffer___2 + len) = (char)'\'';
29671|      0|              }
29672|      0|              len++;
29673|      0|              goto while_break___13;
29674|      0|            }
29675|      0|          while_break___13: /* CIL Label */;
29676|      0|          }
29677|      0|          goto switch_break___3;
29678|      0|        switch_default___1: /* CIL Label */
29679|      0|          goto switch_break___3;
29680|      0|        switch_break___3: /* CIL Label */;
29681|      0|        }
29682|      0|          goto switch_break___0;
29683|      0|        case_37:     /* CIL Label */
29684|      0|        case_43:     /* CIL Label */
29685|      0|        case_44:     /* CIL Label */
29686|      0|        case_45___0: /* CIL Label */
29687|      0|        case_46:     /* CIL Label */
29688|      0|        case_47___0: /* CIL Label */
29689|      0|        case_48:     /* CIL Label */
29690|      0|        case_49:     /* CIL Label */
29691|      0|        case_50:     /* CIL Label */
29692|      0|        case_51:     /* CIL Label */
29693|      0|        case_52:     /* CIL Label */
29694|      0|        case_53:     /* CIL Label */
29695|      0|        case_54:     /* CIL Label */
29696|      0|        case_55:     /* CIL Label */
29697|      0|        case_56:     /* CIL Label */
29698|      0|        case_57:     /* CIL Label */
29699|      0|        case_58:     /* CIL Label */
29700|      0|        case_65:     /* CIL Label */
29701|      0|        case_66:     /* CIL Label */
29702|      0|        case_67:     /* CIL Label */
29703|      0|        case_68:     /* CIL Label */
29704|      0|        case_69:     /* CIL Label */
29705|      0|        case_70:     /* CIL Label */
29706|      0|        case_71:     /* CIL Label */
29707|      0|        case_72:     /* CIL Label */
29708|      0|        case_73:     /* CIL Label */
29709|      0|        case_74:     /* CIL Label */
29710|      0|        case_75:     /* CIL Label */
29711|      0|        case_76:     /* CIL Label */
29712|      0|        case_77:     /* CIL Label */
29713|      0|        case_78:     /* CIL Label */
29714|      0|        case_79:     /* CIL Label */
29715|      0|        case_80:     /* CIL Label */
29716|      0|        case_81:     /* CIL Label */
29717|      0|        case_82:     /* CIL Label */
29718|      0|        case_83:     /* CIL Label */
29719|      0|        case_84:     /* CIL Label */
29720|      0|        case_85:     /* CIL Label */
29721|      0|        case_86:     /* CIL Label */
29722|      0|        case_87:     /* CIL Label */
29723|      0|        case_88:     /* CIL Label */
29724|      0|        case_89:     /* CIL Label */
29725|      0|        case_90:     /* CIL Label */
29726|      0|        case_93:     /* CIL Label */
29727|      0|        case_95:     /* CIL Label */
29728|      0|        case_97:     /* CIL Label */
29729|      0|        case_98:     /* CIL Label */
29730|      0|        case_99:     /* CIL Label */
29731|      0|        case_100:    /* CIL Label */
29732|      0|        case_101:    /* CIL Label */
29733|      0|        case_102:    /* CIL Label */
29734|      0|        case_103:    /* CIL Label */
29735|      0|        case_104:    /* CIL Label */
29736|      0|        case_105:    /* CIL Label */
29737|      0|        case_106:    /* CIL Label */
29738|      0|        case_107:    /* CIL Label */
29739|      0|        case_108:    /* CIL Label */
29740|      0|        case_109:    /* CIL Label */
29741|      0|        case_110:    /* CIL Label */
29742|      0|        case_111:    /* CIL Label */
29743|      0|        case_112:    /* CIL Label */
29744|      0|        case_113:    /* CIL Label */
29745|      0|        case_114:    /* CIL Label */
29746|      0|        case_115:    /* CIL Label */
29747|      0|        case_116:    /* CIL Label */
29748|      0|        case_117:    /* CIL Label */
29749|      0|        case_118:    /* CIL Label */
29750|      0|        case_119:    /* CIL Label */
29751|      0|        case_120:    /* CIL Label */
29752|      0|        case_121:    /* CIL Label */
29753|      0|        case_122:    /* CIL Label */
29754|      0|          goto switch_break___0;
29755|      0|        switch_default___2: /* CIL Label */
29756|      0|          if (unibyte_locale) {
29757|      0|            {
29758|      0|              m = (size_t)1;
29759|      0|              tmp___3 = __ctype_b_loc();
29760|      0|              printable = (int)((int const) * (*tmp___3 + (int)c) & 16384);
29761|      0|            }
29762|      0|          } else {
29763|      0|            {
29764|      0|              memset((void *)(&mbstate), 0, sizeof(mbstate));
29765|      0|              m = (size_t)0;
29766|      0|              printable = 1;
29767|      0|            }
29768|      0|            if (argsize == 0xffffffffffffffffUL) {
29769|      0|              {
29770|      0|                argsize = strlen(arg);
29771|      0|              }
29772|      0|            }
29773|      0|            {
29774|      0|              while (1) {
29775|      0|              while_continue___14: /* CIL Label */;
29776|      0|                {
29777|      0|                  tmp___4 =
29778|      0|                      mbrtowc((wchar_t * /* __restrict  */)(&w),
29779|      0|                              (char const * /* __restrict  */)(arg + (i + m)),
29780|      0|                              argsize - (i + m),
29781|      0|                              (mbstate_t * /* __restrict  */)(&mbstate));
29782|      0|                  bytes = tmp___4;
29783|      0|                }
29784|      0|                if (bytes == 0UL) {
29785|      0|                  goto while_break___14;
29786|      0|                } else {
29787|      0|                  if (bytes == 0xffffffffffffffffUL) {
29788|      0|                    printable = 0;
29789|      0|                    goto while_break___14;
29790|      0|                  } else {
29791|      0|                    if (bytes == 0xfffffffffffffffeUL) {
29792|      0|                      printable = 0;
29793|      0|                      {
29794|      0|                        while (1) {
29795|      0|                        while_continue___15: /* CIL Label */;
29796|      0|                          if (i + m < argsize) {
29797|      0|                            if (!*(arg + (i + m))) {
29798|      0|                              goto while_break___15;
29799|      0|                            }
29800|      0|                          } else {
29801|      0|                            goto while_break___15;
29802|      0|                          }
29803|      0|                          m++;
29804|      0|                        }
29805|      0|                      while_break___15: /* CIL Label */;
29806|      0|                      }
29807|      0|                      goto while_break___14;
29808|      0|                    } else {
29809|      0|                      if ((unsigned int)quoting_style == 1U) {
29810|      0|                        j = (size_t)1;
29811|      0|                        {
29812|      0|                          while (1) {
29813|      0|                          while_continue___16: /* CIL Label */;
29814|      0|                            if (!(j < bytes)) {
29815|      0|                              goto while_break___16;
29816|      0|                            }
29817|      0|                            {
29818|      0|                              if ((int const) * (arg + ((i + m) + j)) == 91) {
29819|      0|                                goto case_91___0;
29820|      0|                              }
29821|      0|                              if ((int const) * (arg + ((i + m) + j)) == 92) {
29822|      0|                                goto case_91___0;
29823|      0|                              }
29824|      0|                              if ((int const) * (arg + ((i + m) + j)) == 94) {
29825|      0|                                goto case_91___0;
29826|      0|                              }
29827|      0|                              if ((int const) * (arg + ((i + m) + j)) == 96) {
29828|      0|                                goto case_91___0;
29829|      0|                              }
29830|      0|                              if ((int const) * (arg + ((i + m) + j)) == 124) {
29831|      0|                                goto case_91___0;
29832|      0|                              }
29833|      0|                              goto switch_break___4;
29834|      0|                            case_91___0:  /* CIL Label */
29835|      0|                            case_92___0:  /* CIL Label */
29836|      0|                            case_94___0:  /* CIL Label */
29837|      0|                            case_96___0:  /* CIL Label */
29838|      0|                            case_124___0: /* CIL Label */
29839|      0|                              goto use_shell_always_quoting_style;
29840|      0|                            switch_break___4: /* CIL Label */;
29841|      0|                            }
29842|      0|                            j++;
29843|      0|                          }
29844|      0|                        while_break___16: /* CIL Label */;
29845|      0|                        }
29846|      0|                      }
29847|      0|                      { tmp___5 = iswprint((wint_t)w); }
29848|      0|                      if (!tmp___5) {
29849|      0|                        printable = 0;
29850|      0|                      }
29851|      0|                      m += bytes;
29852|      0|                    }
29853|      0|                  }
29854|      0|                }
29855|      0|                { tmp___6 = mbsinit((mbstate_t const *)(&mbstate)); }
29856|      0|                if (tmp___6) {
29857|      0|                  goto while_break___14;
29858|      0|                }
29859|      0|              }
29860|      0|            while_break___14: /* CIL Label */;
29861|      0|            }
29862|      0|          }
29863|      0|          if (1UL < m) {
29864|      0|            goto _L___3;
29865|      0|          } else {
29866|      0|            if (backslash_escapes) {
29867|      0|              if (!printable) {
29868|      0|              _L___3: /* CIL Label */
29869|      0|                ilim = i + m;
29870|      0|                {
29871|      0|                  while (1) {
29872|      0|                  while_continue___17: /* CIL Label */;
29873|      0|                    if (backslash_escapes) {
29874|      0|                      if (!printable) {
29875|      0|                        {
29876|      0|                          while (1) {
29877|      0|                          while_continue___18: /* CIL Label */;
29878|      0|                            if (len < buffersize) {
29879|      0|                              *(buffer___2 + len) = (char)'\\';
29880|      0|                            }
29881|      0|                            len++;
29882|      0|                            goto while_break___18;
29883|      0|                          }
29884|      0|                        while_break___18: /* CIL Label */;
29885|      0|                        }
29886|      0|                        {
29887|      0|                          while (1) {
29888|      0|                          while_continue___19: /* CIL Label */;
29889|      0|                            if (len < buffersize) {
29890|      0|                              *(buffer___2 + len) = (char)(48 + ((int)c >> 6));
29891|      0|                            }
29892|      0|                            len++;
29893|      0|                            goto while_break___19;
29894|      0|                          }
29895|      0|                        while_break___19: /* CIL Label */;
29896|      0|                        }
29897|      0|                        {
29898|      0|                          while (1) {
29899|      0|                          while_continue___20: /* CIL Label */;
29900|      0|                            if (len < buffersize) {
29901|      0|                              *(buffer___2 + len) =
29902|      0|                                  (char)(48 + (((int)c >> 3) & 7));
29903|      0|                            }
29904|      0|                            len++;
29905|      0|                            goto while_break___20;
29906|      0|                          }
29907|      0|                        while_break___20: /* CIL Label */;
29908|      0|                        }
29909|      0|                        c = (unsigned char)(48 + ((int)c & 7));
29910|      0|                      }
29911|      0|                    }
29912|      0|                    if (ilim <= i + 1UL) {
29913|      0|                      goto while_break___17;
29914|      0|                    }
29915|      0|                    {
29916|      0|                      while (1) {
29917|      0|                      while_continue___21: /* CIL Label */;
29918|      0|                        if (len < buffersize) {
29919|      0|                          *(buffer___2 + len) = (char)c;
29920|      0|                        }
29921|      0|                        len++;
29922|      0|                        goto while_break___21;
29923|      0|                      }
29924|      0|                    while_break___21: /* CIL Label */;
29925|      0|                    }
29926|      0|                    i++;
29927|      0|                    c = (unsigned char)*(arg + i);
29928|      0|                  }
29929|      0|                while_break___17: /* CIL Label */;
29930|      0|                }
29931|      0|                goto store_c;
29932|      0|              }
29933|      0|            }
29934|      0|          }
29935|      0|        switch_break___0: /* CIL Label */;
29936|      0|        }
29937|      0|        if (backslash_escapes) {
29938|      0|          if (!(o___0->quote_these_too[(unsigned long)c / (sizeof(int) * 8UL)] &
29939|      0|                (1 << (unsigned long)c % (sizeof(int) * 8UL)))) {
29940|      0|            goto store_c;
29941|      0|          }
29942|      0|        } else {
29943|      0|          goto store_c;
29944|      0|        }
29945|      0|      store_escape : {
29946|      0|        while (1) {
29947|      0|        while_continue___22: /* CIL Label */;
29948|      0|          if (len < buffersize) {
29949|      0|            *(buffer___2 + len) = (char)'\\';
29950|      0|          }
29951|      0|          len++;
29952|      0|          goto while_break___22;
29953|      0|        }
29954|      0|      while_break___22: /* CIL Label */;
29955|      0|      }
29956|      0|      store_c : {
29957|      0|        while (1) {
29958|      0|        while_continue___23: /* CIL Label */;
29959|      0|          if (len < buffersize) {
29960|      0|            *(buffer___2 + len) = (char)c;
29961|      0|          }
29962|      0|          len++;
29963|      0|          goto while_break___23;
29964|      0|        }
29965|      0|      while_break___23: /* CIL Label */;
29966|      0|      }
29967|      0|        i++;
29968|      0|      }
29969|      0|    while_break___3: /* CIL Label */;
29970|      0|    }
29971|      0|    if (i == 0UL) {
29972|      0|      if ((unsigned int)quoting_style == 1U) {
29973|      0|        goto use_shell_always_quoting_style;
29974|      0|      }
29975|      0|    }
29976|      0|    if (quote_string) {
29977|      0|      {
29978|      0|        while (1) {
29979|      0|        while_continue___24: /* CIL Label */;
29980|      0|          if (!*quote_string) {
29981|      0|            goto while_break___24;
29982|      0|          }
29983|      0|          {
29984|      0|            while (1) {
29985|      0|            while_continue___25: /* CIL Label */;
29986|      0|              if (len < buffersize) {
29987|      0|                *(buffer___2 + len) = (char)*quote_string;
29988|      0|              }
29989|      0|              len++;
29990|      0|              goto while_break___25;
29991|      0|            }
29992|      0|          while_break___25: /* CIL Label */;
29993|      0|          }
29994|      0|          quote_string++;
29995|      0|        }
29996|      0|      while_break___24: /* CIL Label */;
29997|      0|      }
29998|      0|    }
29999|      0|    if (len < buffersize) {
30000|      0|      *(buffer___2 + len) = (char)'\000';
30001|      0|    }
30002|      0|    return (len);
30003|      0|  use_shell_always_quoting_style : {
30004|      0|    tmp___7 = quotearg_buffer_restyled(buffer___2, buffersize, arg, argsize,
30005|      0|                                       (enum quoting_style)2, o___0);
30006|      0|  }
30007|      0|    return (tmp___7);
30008|      0|  }
30009|      0|}
30010|       |size_t quotearg_buffer(char *buffer___2, size_t buffersize, char const *arg,
30011|      0|                       size_t argsize, struct quoting_options const *o___0) {
30012|      0|  struct quoting_options const *p;
30013|      0|  int e;
30014|      0|  int *tmp;
30015|      0|  size_t r;
30016|      0|  size_t tmp___0;
30017|      0|  int *tmp___1;
30018|       |
30019|      0|  {
30020|      0|    if (o___0) {
30021|      0|      p = o___0;
30022|      0|    } else {
30023|      0|      p = (struct quoting_options const *)(&default_quoting_options);
30024|      0|    }
30025|      0|    {
30026|      0|      tmp = __errno_location();
30027|      0|      e = *tmp;
30028|      0|      tmp___0 = quotearg_buffer_restyled(buffer___2, buffersize, arg, argsize,
30029|      0|                                         (enum quoting_style)p->style, p);
30030|      0|      r = tmp___0;
30031|      0|      tmp___1 = __errno_location();
30032|      0|      *tmp___1 = e;
30033|      0|    }
30034|      0|    return (r);
30035|      0|  }
30036|      0|}
30037|       |static char slot0[256];
30038|       |static char *quotearg_n_options(int n, char const *arg, size_t argsize,
30039|       |                                struct quoting_options const *options);
30040|       |static unsigned int nslots = 1U;
30041|       |static struct slotvec slotvec0 = {sizeof(slot0), slot0};
30042|       |static struct slotvec *slotvec = &slotvec0;
30043|       |static char *quotearg_n_options(int n, char const *arg, size_t argsize,
30044|      0|                                struct quoting_options const *options) {
30045|      0|  int e;
30046|      0|  int *tmp;
30047|      0|  unsigned int n0;
30048|      0|  unsigned int n1;
30049|      0|  void *tmp___0;
30050|      0|  void *tmp___1;
30051|      0|  size_t size;
30052|      0|  char *val;
30053|      0|  size_t qsize;
30054|      0|  size_t tmp___2;
30055|      0|  void *tmp___3;
30056|      0|  int *tmp___4;
30057|      0|  int tmp___5;
30058|       |
30059|      0|  {
30060|      0|    {
30061|      0|      tmp = __errno_location();
30062|      0|      e = *tmp;
30063|      0|      n0 = (unsigned int)n;
30064|      0|    }
30065|      0|    if (n < 0) {
30066|      0|      {
30067|      0|        abort();
30068|      0|      }
30069|      0|    }
30070|      0|    if (nslots <= n0) {
30071|      0|      n1 = n0 + 1U;
30072|      0|      if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
30073|      0|        tmp___5 = -1;
30074|      0|      } else {
30075|      0|        tmp___5 = -2;
30076|      0|      }
30077|      0|      if ((size_t)tmp___5 / sizeof(*slotvec) < (size_t)n1) {
30078|      0|        {
30079|      0|          xalloc_die();
30080|      0|        }
30081|      0|      }
30082|      0|      if ((unsigned long)slotvec == (unsigned long)(&slotvec0)) {
30083|      0|        {
30084|      0|          tmp___0 = xmalloc(sizeof(*slotvec));
30085|      0|          slotvec = (struct slotvec *)tmp___0;
30086|      0|          *slotvec = slotvec0;
30087|      0|        }
30088|      0|      }
30089|      0|      {
30090|      0|        tmp___1 =
30091|      0|            xrealloc((void *)slotvec, (unsigned long)n1 * sizeof(*slotvec));
30092|      0|        slotvec = (struct slotvec *)tmp___1;
30093|      0|        memset((void *)(slotvec + nslots), 0,
30094|      0|               (unsigned long)(n1 - nslots) * sizeof(*slotvec));
30095|      0|        nslots = n1;
30096|      0|      }
30097|      0|    }
30098|      0|    {
30099|      0|      size = (slotvec + n)->size;
30100|      0|      val = (slotvec + n)->val;
30101|      0|      tmp___2 = quotearg_buffer(val, size, arg, argsize, options);
30102|      0|      qsize = tmp___2;
30103|      0|    }
30104|      0|    if (size <= qsize) {
30105|      0|      size = qsize + 1UL;
30106|      0|      (slotvec + n)->size = size;
30107|      0|      if ((unsigned long)val != (unsigned long)(slot0)) {
30108|      0|        {
30109|      0|          free((void *)val);
30110|      0|        }
30111|      0|      }
30112|      0|      {
30113|      0|        tmp___3 = xmalloc(size);
30114|      0|        val = (char *)tmp___3;
30115|      0|        (slotvec + n)->val = val;
30116|      0|        quotearg_buffer(val, size, arg, argsize, options);
30117|      0|      }
30118|      0|    }
30119|      0|    {
30120|      0|      tmp___4 = __errno_location();
30121|      0|      *tmp___4 = e;
30122|      0|    }
30123|      0|    return (val);
30124|      0|  }
30125|      0|}
30126|      0|char *quotearg_n(int n, char const *arg) {
30127|      0|  char *tmp;
30128|       |
30129|      0|  {
30130|      0|    {
30131|      0|      tmp = quotearg_n_options(
30132|      0|          n, arg, (size_t)-1,
30133|      0|          (struct quoting_options const *)(&default_quoting_options));
30134|      0|    }
30135|      0|    return (tmp);
30136|      0|  }
30137|      0|}
30138|      0|char *quotearg(char const *arg) {
30139|      0|  char *tmp;
30140|       |
30141|      0|  {
30142|      0|    { tmp = quotearg_n(0, arg); }
30143|      0|    return (tmp);
30144|      0|  }
30145|      0|}
30146|       |static struct quoting_options
30147|      0|quoting_options_from_style(enum quoting_style style) {
30148|      0|  struct quoting_options o___0;
30149|      0|  void *__cil_tmp3;
30150|       |
30151|      0|  {
30152|      0|    {
30153|      0|      o___0.style = style;
30154|      0|      memset((void *)(o___0.quote_these_too), 0, sizeof(o___0.quote_these_too));
30155|      0|    }
30156|      0|    return (o___0);
30157|      0|  }
30158|      0|}
30159|      0|char *quotearg_n_style(int n, enum quoting_style s, char const *arg) {
30160|      0|  struct quoting_options o___0;
30161|      0|  struct quoting_options tmp;
30162|      0|  char *tmp___0;
30163|      0|  void *__cil_tmp7;
30164|      0|  void *__cil_tmp8;
30165|       |
30166|      0|  {
30167|      0|    {
30168|      0|      tmp = quoting_options_from_style(s);
30169|      0|      o___0 = tmp;
30170|      0|      tmp___0 = quotearg_n_options(n, arg, (size_t)-1,
30171|      0|                                   (struct quoting_options const *)(&o___0));
30172|      0|    }
30173|      0|    return (tmp___0);
30174|      0|  }
30175|      0|}
30176|      0|char *quotearg_char(char const *arg, char ch) {
30177|      0|  struct quoting_options options;
30178|      0|  char *tmp;
30179|      0|  void *__cil_tmp5;
30180|       |
30181|      0|  {
30182|      0|    {
30183|      0|      options = default_quoting_options;
30184|      0|      set_char_quoting(&options, ch, 1);
30185|      0|      tmp = quotearg_n_options(0, arg, (size_t)-1,
30186|      0|                               (struct quoting_options const *)(&options));
30187|      0|    }
30188|      0|    return (tmp);
30189|      0|  }
30190|      0|}
30191|      0|char *quotearg_colon(char const *arg) {
30192|      0|  char *tmp;
30193|       |
30194|      0|  {
30195|      0|    { tmp = quotearg_char(arg, (char)':'); }
30196|      0|    return (tmp);
30197|      0|  }
30198|      0|}
30199|       |/* #pragma merger("0","023.quote.o.i","") */
30200|       |/* #pragma merger("0","024.safe-read.o.i","") */
30201|       |extern ssize_t read(int __fd, void *__buf, size_t __nbytes);
30202|      0|size_t safe_read(int fd, void *buf, size_t count) {
30203|      0|  ssize_t result;
30204|      0|  int *tmp;
30205|       |
30206|      0|  {
30207|      0|    if (count > 2147483647UL) {
30208|      0|      count = (size_t)2147475456;
30209|      0|    }
30210|      0|    {
30211|      0|      while (1) {
30212|      0|      while_continue: /* CIL Label */;
30213|      0|        { result = read(fd, buf, count); }
30214|      0|        if (result < 0L) {
30215|      0|          {
30216|      0|            tmp = __errno_location();
30217|      0|          }
30218|      0|          if (!(*tmp == 4)) {
30219|      0|            goto while_break;
30220|      0|          }
30221|      0|        } else {
30222|      0|          goto while_break;
30223|      0|        }
30224|      0|      }
30225|      0|    while_break: /* CIL Label */;
30226|      0|    }
30227|      0|    return ((size_t)result);
30228|      0|  }
30229|      0|}
30230|       |/* #pragma merger("0","025.safe-write.o.i","") */
30231|       |extern ssize_t write(int __fd, void const *__buf, size_t __n);
30232|      0|size_t safe_write(int fd, void const *buf, size_t count) {
30233|      0|  ssize_t result;
30234|      0|  int *tmp;
30235|       |
30236|      0|  {
30237|      0|    if (count > 2147483647UL) {
30238|      0|      count = (size_t)2147475456;
30239|      0|    }
30240|      0|    {
30241|      0|      while (1) {
30242|      0|      while_continue: /* CIL Label */;
30243|      0|        { result = write(fd, buf, count); }
30244|      0|        if (result < 0L) {
30245|      0|          {
30246|      0|            tmp = __errno_location();
30247|      0|          }
30248|      0|          if (!(*tmp == 4)) {
30249|      0|            goto while_break;
30250|      0|          }
30251|      0|        } else {
30252|      0|          goto while_break;
30253|      0|        }
30254|      0|      }
30255|      0|    while_break: /* CIL Label */;
30256|      0|    }
30257|      0|    return ((size_t)result);
30258|      0|  }
30259|      0|}
30260|       |/* #pragma merger("0","026.save-cwd.o.i","") */
30261|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
30262|       |                                        fchdir)(int __fd);
30263|       |char *xgetcwd(void);
30264|       |static int have_working_fchdir = 1;
30265|      0|int save_cwd(struct saved_cwd *cwd) {
30266|       |
30267|      0|  {
30268|      0|    cwd->desc = -1;
30269|      0|    cwd->name = (char *)((void *)0);
30270|      0|    if (have_working_fchdir) {
30271|      0|      {
30272|      0|        cwd->desc = open(".", 65536);
30273|      0|      }
30274|      0|      if (cwd->desc < 0) {
30275|      0|        return (1);
30276|      0|      }
30277|      0|    }
30278|      0|    if (!have_working_fchdir) {
30279|      0|      {
30280|      0|        cwd->name = xgetcwd();
30281|      0|      }
30282|      0|      if ((unsigned long)cwd->name == (unsigned long)((void *)0)) {
30283|      0|        return (1);
30284|      0|      }
30285|      0|    }
30286|      0|    return (0);
30287|      0|  }
30288|      0|}
30289|      0|int restore_cwd(struct saved_cwd const *cwd) {
30290|      0|  int tmp;
30291|      0|  int tmp___0;
30292|       |
30293|      0|  {
30294|      0|    if (0 <= (int)cwd->desc) {
30295|      0|      {
30296|      0|        tmp = fchdir((int)cwd->desc);
30297|      0|      }
30298|      0|      return (tmp < 0);
30299|      0|    } else {
30300|      0|      { tmp___0 = chdir((char const *)cwd->name); }
30301|      0|      return (tmp___0 < 0);
30302|      0|    }
30303|      0|  }
30304|      0|}
30305|       |/* #pragma merger("0","027.savedir.o.i","") */
30306|      0|char *savedir(char const *dir) {
30307|      0|  DIR *dirp;
30308|      0|  struct dirent *dp;
30309|      0|  char *name_space;
30310|      0|  size_t allocated;
30311|      0|  size_t used;
30312|      0|  int save_errno;
30313|      0|  void *tmp;
30314|      0|  int *tmp___0;
30315|      0|  char const *entry;
30316|      0|  size_t entry_size;
30317|      0|  size_t tmp___1;
30318|      0|  void *tmp___2;
30319|      0|  int *tmp___3;
30320|      0|  int *tmp___4;
30321|      0|  int tmp___5;
30322|      0|  int *tmp___6;
30323|      0|  int tmp___7;
30324|      0|  int tmp___8;
30325|       |
30326|      0|  {
30327|      0|    {
30328|      0|      allocated = (size_t)512;
30329|      0|      used = (size_t)0;
30330|      0|      dirp = opendir(dir);
30331|      0|    }
30332|      0|    if ((unsigned long)dirp == (unsigned long)((void *)0)) {
30333|      0|      return ((char *)((void *)0));
30334|      0|    }
30335|      0|    {
30336|      0|      tmp = xmalloc(allocated);
30337|      0|      name_space = (char *)tmp;
30338|      0|      tmp___0 = __errno_location();
30339|      0|      *tmp___0 = 0;
30340|      0|    }
30341|      0|    {
30342|      0|      while (1) {
30343|      0|      while_continue: /* CIL Label */;
30344|      0|        { dp = readdir(dirp); }
30345|      0|        if (!((unsigned long)dp != (unsigned long)((void *)0))) {
30346|      0|          goto while_break;
30347|      0|        }
30348|      0|        entry = (char const *)(dp->d_name);
30349|      0|        if ((int const) * (entry + 0) != 46) {
30350|      0|          tmp___8 = 0;
30351|      0|        } else {
30352|      0|          if ((int const) * (entry + 1) != 46) {
30353|      0|            tmp___7 = 1;
30354|      0|          } else {
30355|      0|            tmp___7 = 2;
30356|      0|          }
30357|      0|          tmp___8 = tmp___7;
30358|      0|        }
30359|      0|        if ((int const) * (entry + tmp___8) != 0) {
30360|      0|          {
30361|      0|            tmp___1 = strlen(entry);
30362|      0|            entry_size = tmp___1 + 1UL;
30363|      0|          }
30364|      0|          if (used + entry_size < used) {
30365|      0|            {
30366|      0|              xalloc_die();
30367|      0|            }
30368|      0|          }
30369|      0|          if (allocated <= used + entry_size) {
30370|      0|            {
30371|      0|              while (1) {
30372|      0|              while_continue___0: /* CIL Label */;
30373|      0|                if (2UL * allocated < allocated) {
30374|      0|                  {
30375|      0|                    xalloc_die();
30376|      0|                  }
30377|      0|                }
30378|      0|                allocated *= 2UL;
30379|      0|                if (!(allocated <= used + entry_size)) {
30380|      0|                  goto while_break___0;
30381|      0|                }
30382|      0|              }
30383|      0|            while_break___0: /* CIL Label */;
30384|      0|            }
30385|      0|            {
30386|      0|              tmp___2 = xrealloc((void *)name_space, allocated);
30387|      0|              name_space = (char *)tmp___2;
30388|      0|            }
30389|      0|          }
30390|      0|          {
30391|      0|            memcpy((void * /* __restrict  */)(name_space + used),
30392|      0|                   (void const * /* __restrict  */)entry, entry_size);
30393|      0|            used += entry_size;
30394|      0|          }
30395|      0|        }
30396|      0|      }
30397|      0|    while_break: /* CIL Label */;
30398|      0|    }
30399|      0|    {
30400|      0|      *(name_space + used) = (char)'\000';
30401|      0|      tmp___3 = __errno_location();
30402|      0|      save_errno = *tmp___3;
30403|      0|      tmp___5 = closedir(dirp);
30404|      0|    }
30405|      0|    if (tmp___5 != 0) {
30406|      0|      {
30407|      0|        tmp___4 = __errno_location();
30408|      0|        save_errno = *tmp___4;
30409|      0|      }
30410|      0|    }
30411|      0|    if (save_errno != 0) {
30412|      0|      {
30413|      0|        free((void *)name_space);
30414|      0|        tmp___6 = __errno_location();
30415|      0|        *tmp___6 = save_errno;
30416|      0|      }
30417|      0|      return ((char *)((void *)0));
30418|      0|    }
30419|      0|    return (name_space);
30420|      0|  }
30421|      0|}
30422|       |/* #pragma merger("0","028.stripslash.o.i","") */
30423|      0|int strip_trailing_slashes(char *path) {
30424|      0|  char *base;
30425|      0|  char *tmp;
30426|      0|  char *base_lim;
30427|      0|  size_t tmp___0;
30428|      0|  int had_slash;
30429|       |
30430|      0|  {
30431|      0|    {
30432|      0|      tmp = base_name((char const *)path);
30433|      0|      base = tmp;
30434|      0|      tmp___0 = base_len((char const *)base);
30435|      0|      base_lim = base + tmp___0;
30436|      0|      had_slash = (int)*base_lim;
30437|      0|      *base_lim = (char)'\000';
30438|      0|    }
30439|      0|    return (had_slash);
30440|      0|  }
30441|      0|}
30442|       |/* #pragma merger("0","029.xgetcwd.o.i","") */
30443|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
30444|       |                                           getcwd)(char *__buf, size_t __size);
30445|      0|char *xgetcwd(void) {
30446|      0|  char *cwd;
30447|      0|  char *tmp;
30448|      0|  int *tmp___0;
30449|       |
30450|      0|  {
30451|      0|    {
30452|      0|      tmp = getcwd((char *)((void *)0), (size_t)0);
30453|      0|      cwd = tmp;
30454|      0|    }
30455|      0|    if (!cwd) {
30456|      0|      {
30457|      0|        tmp___0 = __errno_location();
30458|      0|      }
30459|      0|      if (*tmp___0 == 12) {
30460|      0|        {
30461|      0|          xalloc_die();
30462|      0|        }
30463|      0|      }
30464|      0|    }
30465|      0|    return (cwd);
30466|      0|  }
30467|      0|}
30468|       |/* #pragma merger("0","02a.xmalloc.o.i","") */
30469|       |char const xalloc_msg_memory_exhausted[17];
30470|       |void *xclone(void const *p, size_t s);
30471|       |extern
30472|       |    __attribute__((__nothrow__)) void *(__attribute__((__warn_unused_result__,
30473|       |                                                       __leaf__))
30474|       |                                        realloc)(void *__ptr, size_t __size);
30475|       |void (*xalloc_fail_func)(void) = (void (*)(void))0;
30476|       |char const xalloc_msg_memory_exhausted[17] = {
30477|       |    (char const)'m',   (char const)'e', (char const)'m', (char const)'o',
30478|       |    (char const)'r',   (char const)'y', (char const)' ', (char const)'e',
30479|       |    (char const)'x',   (char const)'h', (char const)'a', (char const)'u',
30480|       |    (char const)'s',   (char const)'t', (char const)'e', (char const)'d',
30481|       |    (char const)'\000'};
30482|       |__attribute__((__noreturn__)) void xalloc_die(void);
30483|      0|void xalloc_die(void) {
30484|      0|  char *tmp;
30485|       |
30486|      0|  {
30487|      0|    if (xalloc_fail_func) {
30488|      0|      {
30489|      0|        (*xalloc_fail_func)();
30490|      0|      }
30491|      0|    }
30492|      0|    {
30493|      0|      tmp = gettext(xalloc_msg_memory_exhausted);
30494|      0|      error((int)exit_failure, 0, "%s", tmp);
30495|      0|      abort();
30496|      0|    }
30497|      0|  }
30498|      0|}
30499|      0|__inline static void *xnmalloc_inline(size_t n, size_t s) {
30500|      0|  void *p;
30501|      0|  int tmp;
30502|       |
30503|      0|  {
30504|      0|    if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
30505|      0|      tmp = -1;
30506|      0|    } else {
30507|      0|      tmp = -2;
30508|      0|    }
30509|      0|    if ((size_t)tmp / s < n) {
30510|      0|      {
30511|      0|        xalloc_die();
30512|      0|      }
30513|      0|    } else {
30514|      0|      { p = malloc(n * s); }
30515|      0|      if (!p) {
30516|      0|        {
30517|      0|          xalloc_die();
30518|      0|        }
30519|      0|      }
30520|      0|    }
30521|      0|    return (p);
30522|      0|  }
30523|      0|}
30524|      0|void *xmalloc(size_t n) {
30525|      0|  void *tmp;
30526|       |
30527|      0|  {
30528|      0|    { tmp = xnmalloc_inline(n, (size_t)1); }
30529|      0|    return (tmp);
30530|      0|  }
30531|      0|}
30532|      0|__inline static void *xnrealloc_inline(void *p, size_t n, size_t s) {
30533|      0|  int tmp;
30534|       |
30535|      0|  {
30536|      0|    if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
30537|      0|      tmp = -1;
30538|      0|    } else {
30539|      0|      tmp = -2;
30540|      0|    }
30541|      0|    if ((size_t)tmp / s < n) {
30542|      0|      {
30543|      0|        xalloc_die();
30544|      0|      }
30545|      0|    } else {
30546|      0|      { p = realloc(p, n * s); }
30547|      0|      if (!p) {
30548|      0|        {
30549|      0|          xalloc_die();
30550|      0|        }
30551|      0|      }
30552|      0|    }
30553|      0|    return (p);
30554|      0|  }
30555|      0|}
30556|      0|void *xrealloc(void *p, size_t n) {
30557|      0|  void *tmp;
30558|       |
30559|      0|  {
30560|      0|    { tmp = xnrealloc_inline(p, n, (size_t)1); }
30561|      0|    return (tmp);
30562|      0|  }
30563|      0|}
30564|      0|__inline static void *x2nrealloc_inline(void *p, size_t *pn, size_t s) {
30565|      0|  size_t n;
30566|      0|  void *tmp;
30567|       |
30568|      0|  {
30569|      0|    n = *pn;
30570|      0|    if (!p) {
30571|      0|      if (!n) {
30572|      0|        n = 64UL / s;
30573|      0|        n += (size_t)(!n);
30574|      0|      }
30575|      0|    } else {
30576|      0|      if (9223372036854775807UL / s < n) {
30577|      0|        {
30578|      0|          xalloc_die();
30579|      0|        }
30580|      0|      }
30581|      0|      n *= 2UL;
30582|      0|    }
30583|      0|    {
30584|      0|      *pn = n;
30585|      0|      tmp = xrealloc(p, n * s);
30586|      0|    }
30587|      0|    return (tmp);
30588|      0|  }
30589|      0|}
30590|      0|void *x2nrealloc(void *p, size_t *pn, size_t s) {
30591|      0|  void *tmp;
30592|       |
30593|      0|  {
30594|      0|    { tmp = x2nrealloc_inline(p, pn, s); }
30595|      0|    return (tmp);
30596|      0|  }
30597|      0|}
30598|      0|void *x2realloc(void *p, size_t *pn) {
30599|      0|  void *tmp;
30600|       |
30601|      0|  {
30602|      0|    { tmp = x2nrealloc_inline(p, pn, (size_t)1); }
30603|      0|    return (tmp);
30604|      0|  }
30605|      0|}
30606|      0|void *xzalloc(size_t s) {
30607|      0|  void *tmp;
30608|      0|  void *tmp___0;
30609|       |
30610|      0|  {
30611|      0|    {
30612|      0|      tmp = xmalloc(s);
30613|      0|      tmp___0 = memset(tmp, 0, s);
30614|      0|    }
30615|      0|    return (tmp___0);
30616|      0|  }
30617|      0|}
30618|      0|void *xclone(void const *p, size_t s) {
30619|      0|  void *tmp;
30620|      0|  void *tmp___0;
30621|       |
30622|      0|  {
30623|      0|    {
30624|      0|      tmp = xmalloc(s);
30625|      0|      tmp___0 = memcpy((void * /* __restrict  */)tmp,
30626|      0|                       (void const * /* __restrict  */)p, s);
30627|      0|    }
30628|      0|    return (tmp___0);
30629|      0|  }
30630|      0|}
30631|       |/* #pragma merger("0","02b.xstrdup.o.i","") */
30632|      0|char *xstrdup(char const *string) {
30633|      0|  size_t tmp;
30634|      0|  void *tmp___0;
30635|       |
30636|      0|  {
30637|      0|    {
30638|      0|      tmp = strlen(string);
30639|      0|      tmp___0 = xclone((void const *)string, tmp + 1UL);
30640|      0|    }
30641|      0|    return ((char *)tmp___0);
30642|      0|  }
30643|      0|}
30644|       |/* #pragma merger("0","02c.xstrtol.o.i","") */
30645|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((
30646|       |    __leaf__)) __assert_fail)(char const *__assertion, char const *__file,
30647|       |                              unsigned int __line, char const *__function);
30648|       |extern
30649|       |    __attribute__((__nothrow__)) long(__attribute__((__nonnull__(1), __leaf__))
30650|       |                                      strtol)(char const *__restrict __nptr,
30651|       |                                              char **__restrict __endptr,
30652|       |                                              int __base);
30653|       |/* #pragma merger("0","02d.xstrtoul.o.i","") */
30654|      0|static strtol_error bkm_scale___0(unsigned long *x, int scale_factor) {
30655|       |
30656|      0|  {
30657|      0|    if (0xffffffffffffffffUL / (unsigned long)scale_factor < *x) {
30658|      0|      *x = 0xffffffffffffffffUL;
30659|      0|      return ((strtol_error)1);
30660|      0|    }
30661|      0|    *x *= (unsigned long)scale_factor;
30662|      0|    return ((strtol_error)0);
30663|      0|  }
30664|      0|}
30665|       |static strtol_error bkm_scale_by_power___0(unsigned long *x, int base,
30666|      0|                                           int power) {
30667|      0|  strtol_error err;
30668|      0|  strtol_error tmp;
30669|      0|  int tmp___0;
30670|       |
30671|      0|  {
30672|      0|    err = (strtol_error)0;
30673|      0|    {
30674|      0|      while (1) {
30675|      0|      while_continue: /* CIL Label */;
30676|      0|        tmp___0 = power;
30677|      0|        power--;
30678|      0|        if (!tmp___0) {
30679|      0|          goto while_break;
30680|      0|        }
30681|      0|        {
30682|      0|          tmp = bkm_scale___0(x, base);
30683|      0|          err = (strtol_error)((unsigned int)err | (unsigned int)tmp);
30684|      0|        }
30685|      0|      }
30686|      0|    while_break: /* CIL Label */;
30687|      0|    }
30688|      0|    return (err);
30689|      0|  }
30690|      0|}
30691|       |strtol_error xstrtoul(char const *s, char **ptr, int strtol_base,
30692|      0|                      unsigned long *val, char const *valid_suffixes) {
30693|      0|  char *t_ptr;
30694|      0|  char **p;
30695|      0|  unsigned long tmp;
30696|      0|  strtol_error err;
30697|      0|  char const *q;
30698|      0|  unsigned short const **tmp___0;
30699|      0|  int *tmp___1;
30700|      0|  char *tmp___2;
30701|      0|  int *tmp___3;
30702|      0|  int *tmp___4;
30703|      0|  int base;
30704|      0|  int suffixes;
30705|      0|  strtol_error overflow;
30706|      0|  char *tmp___5;
30707|      0|  char *tmp___6;
30708|       |
30709|      0|  {
30710|      0|    err = (strtol_error)0;
30711|      0|    if (0 <= strtol_base) {
30712|      0|      if (!(strtol_base <= 36)) {
30713|      0|        {
30714|      0|          __assert_fail(
30715|      0|              "0 <= strtol_base && strtol_base <= 36",
30716|      0|              "/home/wslee/project/cbenchmarks/tar-1.14/lib/xstrtol.c", 117U,
30717|      0|              "xstrtoul");
30718|      0|        }
30719|      0|      }
30720|      0|    } else {
30721|      0|      {
30722|      0|        __assert_fail("0 <= strtol_base && strtol_base <= 36",
30723|      0|                      "/home/wslee/project/cbenchmarks/tar-1.14/lib/xstrtol.c",
30724|      0|                      117U, "xstrtoul");
30725|      0|      }
30726|      0|    }
30727|      0|    if (ptr) {
30728|      0|      p = ptr;
30729|      0|    } else {
30730|      0|      p = &t_ptr;
30731|      0|    }
30732|      0|    q = s;
30733|      0|    {
30734|      0|      while (1) {
30735|      0|      while_continue: /* CIL Label */;
30736|      0|        { tmp___0 = __ctype_b_loc(); }
30737|      0|        if (!((int const) * (*tmp___0 + (int)((unsigned char)*q)) & 8192)) {
30738|      0|          goto while_break;
30739|      0|        }
30740|      0|        q++;
30741|      0|      }
30742|      0|    while_break: /* CIL Label */;
30743|      0|    }
30744|      0|    if ((int const) * q == 45) {
30745|      0|      return ((strtol_error)4);
30746|      0|    }
30747|      0|    {
30748|      0|      tmp___1 = __errno_location();
30749|      0|      *tmp___1 = 0;
30750|      0|      tmp = strtoul((char const * /* __restrict  */)s,
30751|      0|                    (char ** /* __restrict  */)p, strtol_base);
30752|      0|    }
30753|      0|    if ((unsigned long)*p == (unsigned long)s) {
30754|      0|      if (valid_suffixes) {
30755|      0|        if (*(*p)) {
30756|      0|          {
30757|      0|            tmp___2 = strchr(valid_suffixes, (int)*(*p));
30758|      0|          }
30759|      0|          if (tmp___2) {
30760|      0|            tmp = 1UL;
30761|      0|          } else {
30762|      0|            return ((strtol_error)4);
30763|      0|          }
30764|      0|        } else {
30765|      0|          return ((strtol_error)4);
30766|      0|        }
30767|      0|      } else {
30768|      0|        return ((strtol_error)4);
30769|      0|      }
30770|      0|    } else {
30771|      0|      { tmp___4 = __errno_location(); }
30772|      0|      if (*tmp___4 != 0) {
30773|      0|        {
30774|      0|          tmp___3 = __errno_location();
30775|      0|        }
30776|      0|        if (*tmp___3 != 34) {
30777|      0|          return ((strtol_error)4);
30778|      0|        }
30779|      0|        err = (strtol_error)1;
30780|      0|      }
30781|      0|    }
30782|      0|    if (!valid_suffixes) {
30783|      0|      *val = tmp;
30784|      0|      return (err);
30785|      0|    }
30786|      0|    if ((int)*(*p) != 0) {
30787|      0|      {
30788|      0|        base = 1024;
30789|      0|        suffixes = 1;
30790|      0|        tmp___5 = strchr(valid_suffixes, (int)*(*p));
30791|      0|      }
30792|      0|      if (!tmp___5) {
30793|      0|        *val = tmp;
30794|      0|        return ((strtol_error)((unsigned int)err | 2U));
30795|      0|      }
30796|      0|      { tmp___6 = strchr(valid_suffixes, '0'); }
30797|      0|      if (tmp___6) {
30798|      0|        {
30799|      0|          if ((int)*(*(p + 0) + 1) == 105) {
30800|      0|            goto case_105;
30801|      0|          }
30802|      0|          if ((int)*(*(p + 0) + 1) == 66) {
30803|      0|            goto case_66;
30804|      0|          }
30805|      0|          if ((int)*(*(p + 0) + 1) == 68) {
30806|      0|            goto case_66;
30807|      0|          }
30808|      0|          goto switch_break;
30809|      0|        case_105: /* CIL Label */
30810|      0|          if ((int)*(*(p + 0) + 2) == 66) {
30811|      0|            suffixes += 2;
30812|      0|          }
30813|      0|          goto switch_break;
30814|      0|        case_66: /* CIL Label */
30815|      0|        case_68: /* CIL Label */
30816|      0|          base = 1000;
30817|      0|          suffixes++;
30818|      0|          goto switch_break;
30819|      0|        switch_break: /* CIL Label */;
30820|      0|        }
30821|      0|      }
30822|      0|      {
30823|      0|        if ((int)*(*p) == 98) {
30824|      0|          goto case_98;
30825|      0|        }
30826|      0|        if ((int)*(*p) == 66) {
30827|      0|          goto case_66___0;
30828|      0|        }
30829|      0|        if ((int)*(*p) == 99) {
30830|      0|          goto case_99;
30831|      0|        }
30832|      0|        if ((int)*(*p) == 69) {
30833|      0|          goto case_69;
30834|      0|        }
30835|      0|        if ((int)*(*p) == 71) {
30836|      0|          goto case_71;
30837|      0|        }
30838|      0|        if ((int)*(*p) == 103) {
30839|      0|          goto case_71;
30840|      0|        }
30841|      0|        if ((int)*(*p) == 107) {
30842|      0|          goto case_107;
30843|      0|        }
30844|      0|        if ((int)*(*p) == 75) {
30845|      0|          goto case_107;
30846|      0|        }
30847|      0|        if ((int)*(*p) == 77) {
30848|      0|          goto case_77;
30849|      0|        }
30850|      0|        if ((int)*(*p) == 109) {
30851|      0|          goto case_77;
30852|      0|        }
30853|      0|        if ((int)*(*p) == 80) {
30854|      0|          goto case_80;
30855|      0|        }
30856|      0|        if ((int)*(*p) == 84) {
30857|      0|          goto case_84;
30858|      0|        }
30859|      0|        if ((int)*(*p) == 116) {
30860|      0|          goto case_84;
30861|      0|        }
30862|      0|        if ((int)*(*p) == 119) {
30863|      0|          goto case_119;
30864|      0|        }
30865|      0|        if ((int)*(*p) == 89) {
30866|      0|          goto case_89;
30867|      0|        }
30868|      0|        if ((int)*(*p) == 90) {
30869|      0|          goto case_90;
30870|      0|        }
30871|      0|        goto switch_default;
30872|      0|      case_98 : /* CIL Label */
30873|      0|      {
30874|      0|        overflow = bkm_scale___0(&tmp, 512);
30875|      0|      }
30876|      0|        goto switch_break___0;
30877|      0|      case_66___0 : /* CIL Label */
30878|      0|      {
30879|      0|        overflow = bkm_scale___0(&tmp, 1024);
30880|      0|      }
30881|      0|        goto switch_break___0;
30882|      0|      case_99: /* CIL Label */
30883|      0|        overflow = (strtol_error)0;
30884|      0|        goto switch_break___0;
30885|      0|      case_69 : /* CIL Label */
30886|      0|      {
30887|      0|        overflow = bkm_scale_by_power___0(&tmp, base, 6);
30888|      0|      }
30889|      0|        goto switch_break___0;
30890|      0|      case_71:   /* CIL Label */
30891|      0|      case_103 : /* CIL Label */
30892|      0|      {
30893|      0|        overflow = bkm_scale_by_power___0(&tmp, base, 3);
30894|      0|      }
30895|      0|        goto switch_break___0;
30896|      0|      case_107: /* CIL Label */
30897|      0|      case_75 : /* CIL Label */
30898|      0|      {
30899|      0|        overflow = bkm_scale_by_power___0(&tmp, base, 1);
30900|      0|      }
30901|      0|        goto switch_break___0;
30902|      0|      case_77:   /* CIL Label */
30903|      0|      case_109 : /* CIL Label */
30904|      0|      {
30905|      0|        overflow = bkm_scale_by_power___0(&tmp, base, 2);
30906|      0|      }
30907|      0|        goto switch_break___0;
30908|      0|      case_80 : /* CIL Label */
30909|      0|      {
30910|      0|        overflow = bkm_scale_by_power___0(&tmp, base, 5);
30911|      0|      }
30912|      0|        goto switch_break___0;
30913|      0|      case_84:   /* CIL Label */
30914|      0|      case_116 : /* CIL Label */
30915|      0|      {
30916|      0|        overflow = bkm_scale_by_power___0(&tmp, base, 4);
30917|      0|      }
30918|      0|        goto switch_break___0;
30919|      0|      case_119 : /* CIL Label */
30920|      0|      {
30921|      0|        overflow = bkm_scale___0(&tmp, 2);
30922|      0|      }
30923|      0|        goto switch_break___0;
30924|      0|      case_89 : /* CIL Label */
30925|      0|      {
30926|      0|        overflow = bkm_scale_by_power___0(&tmp, base, 8);
30927|      0|      }
30928|      0|        goto switch_break___0;
30929|      0|      case_90 : /* CIL Label */
30930|      0|      {
30931|      0|        overflow = bkm_scale_by_power___0(&tmp, base, 7);
30932|      0|      }
30933|      0|        goto switch_break___0;
30934|      0|      switch_default: /* CIL Label */
30935|      0|        *val = tmp;
30936|      0|        return ((strtol_error)((unsigned int)err | 2U));
30937|      0|      switch_break___0: /* CIL Label */;
30938|      0|      }
30939|      0|      err = (strtol_error)((unsigned int)err | (unsigned int)overflow);
30940|      0|      *p += suffixes;
30941|      0|      if (*(*p)) {
30942|      0|        err = (strtol_error)((unsigned int)err | 2U);
30943|      0|      }
30944|      0|    }
30945|      0|    *val = tmp;
30946|      0|    return (err);
30947|      0|  }
30948|      0|}
30949|       |/* #pragma merger("0","02e.xstrtoumax.o.i","") */
30950|       |extern __attribute__((__nothrow__))
30951|       |uintmax_t(__attribute__((__leaf__)) strtoumax)(char const *__restrict __nptr,
30952|       |                                               char **__restrict __endptr,
30953|       |                                               int __base);
30954|      0|static strtol_error bkm_scale___1(uintmax_t *x, int scale_factor) {
30955|       |
30956|      0|  {
30957|      0|    if (0xffffffffffffffffUL / (unsigned long)scale_factor < *x) {
30958|      0|      *x = 0xffffffffffffffffUL;
30959|      0|      return ((strtol_error)1);
30960|      0|    }
30961|      0|    *x *= (uintmax_t)scale_factor;
30962|      0|    return ((strtol_error)0);
30963|      0|  }
30964|      0|}
30965|      0|static strtol_error bkm_scale_by_power___1(uintmax_t *x, int base, int power) {
30966|      0|  strtol_error err;
30967|      0|  strtol_error tmp;
30968|      0|  int tmp___0;
30969|       |
30970|      0|  {
30971|      0|    err = (strtol_error)0;
30972|      0|    {
30973|      0|      while (1) {
30974|      0|      while_continue: /* CIL Label */;
30975|      0|        tmp___0 = power;
30976|      0|        power--;
30977|      0|        if (!tmp___0) {
30978|      0|          goto while_break;
30979|      0|        }
30980|      0|        {
30981|      0|          tmp = bkm_scale___1(x, base);
30982|      0|          err = (strtol_error)((unsigned int)err | (unsigned int)tmp);
30983|      0|        }
30984|      0|      }
30985|      0|    while_break: /* CIL Label */;
30986|      0|    }
30987|      0|    return (err);
30988|      0|  }
30989|      0|}
30990|       |strtol_error xstrtoumax(char const *s, char **ptr, int strtol_base,
30991|      0|                        uintmax_t *val, char const *valid_suffixes) {
30992|      0|  char *t_ptr;
30993|      0|  char **p;
30994|      0|  uintmax_t tmp;
30995|      0|  strtol_error err;
30996|      0|  char const *q;
30997|      0|  unsigned short const **tmp___0;
30998|      0|  int *tmp___1;
30999|      0|  char *tmp___2;
31000|      0|  int *tmp___3;
31001|      0|  int *tmp___4;
31002|      0|  int base;
31003|      0|  int suffixes;
31004|      0|  strtol_error overflow;
31005|      0|  char *tmp___5;
31006|      0|  char *tmp___6;
31007|       |
31008|      0|  {
31009|      0|    err = (strtol_error)0;
31010|      0|    if (0 <= strtol_base) {
31011|      0|      if (!(strtol_base <= 36)) {
31012|      0|        {
31013|      0|          __assert_fail(
31014|      0|              "0 <= strtol_base && strtol_base <= 36",
31015|      0|              "/home/wslee/project/cbenchmarks/tar-1.14/lib/xstrtol.c", 117U,
31016|      0|              "xstrtoumax");
31017|      0|        }
31018|      0|      }
31019|      0|    } else {
31020|      0|      {
31021|      0|        __assert_fail("0 <= strtol_base && strtol_base <= 36",
31022|      0|                      "/home/wslee/project/cbenchmarks/tar-1.14/lib/xstrtol.c",
31023|      0|                      117U, "xstrtoumax");
31024|      0|      }
31025|      0|    }
31026|      0|    if (ptr) {
31027|      0|      p = ptr;
31028|      0|    } else {
31029|      0|      p = &t_ptr;
31030|      0|    }
31031|      0|    q = s;
31032|      0|    {
31033|      0|      while (1) {
31034|      0|      while_continue: /* CIL Label */;
31035|      0|        { tmp___0 = __ctype_b_loc(); }
31036|      0|        if (!((int const) * (*tmp___0 + (int)((unsigned char)*q)) & 8192)) {
31037|      0|          goto while_break;
31038|      0|        }
31039|      0|        q++;
31040|      0|      }
31041|      0|    while_break: /* CIL Label */;
31042|      0|    }
31043|      0|    if ((int const) * q == 45) {
31044|      0|      return ((strtol_error)4);
31045|      0|    }
31046|      0|    {
31047|      0|      tmp___1 = __errno_location();
31048|      0|      *tmp___1 = 0;
31049|      0|      tmp = strtoumax((char const * /* __restrict  */)s,
31050|      0|                      (char ** /* __restrict  */)p, strtol_base);
31051|      0|    }
31052|      0|    if ((unsigned long)*p == (unsigned long)s) {
31053|      0|      if (valid_suffixes) {
31054|      0|        if (*(*p)) {
31055|      0|          {
31056|      0|            tmp___2 = strchr(valid_suffixes, (int)*(*p));
31057|      0|          }
31058|      0|          if (tmp___2) {
31059|      0|            tmp = (uintmax_t)1;
31060|      0|          } else {
31061|      0|            return ((strtol_error)4);
31062|      0|          }
31063|      0|        } else {
31064|      0|          return ((strtol_error)4);
31065|      0|        }
31066|      0|      } else {
31067|      0|        return ((strtol_error)4);
31068|      0|      }
31069|      0|    } else {
31070|      0|      { tmp___4 = __errno_location(); }
31071|      0|      if (*tmp___4 != 0) {
31072|      0|        {
31073|      0|          tmp___3 = __errno_location();
31074|      0|        }
31075|      0|        if (*tmp___3 != 34) {
31076|      0|          return ((strtol_error)4);
31077|      0|        }
31078|      0|        err = (strtol_error)1;
31079|      0|      }
31080|      0|    }
31081|      0|    if (!valid_suffixes) {
31082|      0|      *val = tmp;
31083|      0|      return (err);
31084|      0|    }
31085|      0|    if ((int)*(*p) != 0) {
31086|      0|      {
31087|      0|        base = 1024;
31088|      0|        suffixes = 1;
31089|      0|        tmp___5 = strchr(valid_suffixes, (int)*(*p));
31090|      0|      }
31091|      0|      if (!tmp___5) {
31092|      0|        *val = tmp;
31093|      0|        return ((strtol_error)((unsigned int)err | 2U));
31094|      0|      }
31095|      0|      { tmp___6 = strchr(valid_suffixes, '0'); }
31096|      0|      if (tmp___6) {
31097|      0|        {
31098|      0|          if ((int)*(*(p + 0) + 1) == 105) {
31099|      0|            goto case_105;
31100|      0|          }
31101|      0|          if ((int)*(*(p + 0) + 1) == 66) {
31102|      0|            goto case_66;
31103|      0|          }
31104|      0|          if ((int)*(*(p + 0) + 1) == 68) {
31105|      0|            goto case_66;
31106|      0|          }
31107|      0|          goto switch_break;
31108|      0|        case_105: /* CIL Label */
31109|      0|          if ((int)*(*(p + 0) + 2) == 66) {
31110|      0|            suffixes += 2;
31111|      0|          }
31112|      0|          goto switch_break;
31113|      0|        case_66: /* CIL Label */
31114|      0|        case_68: /* CIL Label */
31115|      0|          base = 1000;
31116|      0|          suffixes++;
31117|      0|          goto switch_break;
31118|      0|        switch_break: /* CIL Label */;
31119|      0|        }
31120|      0|      }
31121|      0|      {
31122|      0|        if ((int)*(*p) == 98) {
31123|      0|          goto case_98;
31124|      0|        }
31125|      0|        if ((int)*(*p) == 66) {
31126|      0|          goto case_66___0;
31127|      0|        }
31128|      0|        if ((int)*(*p) == 99) {
31129|      0|          goto case_99;
31130|      0|        }
31131|      0|        if ((int)*(*p) == 69) {
31132|      0|          goto case_69;
31133|      0|        }
31134|      0|        if ((int)*(*p) == 71) {
31135|      0|          goto case_71;
31136|      0|        }
31137|      0|        if ((int)*(*p) == 103) {
31138|      0|          goto case_71;
31139|      0|        }
31140|      0|        if ((int)*(*p) == 107) {
31141|      0|          goto case_107;
31142|      0|        }
31143|      0|        if ((int)*(*p) == 75) {
31144|      0|          goto case_107;
31145|      0|        }
31146|      0|        if ((int)*(*p) == 77) {
31147|      0|          goto case_77;
31148|      0|        }
31149|      0|        if ((int)*(*p) == 109) {
31150|      0|          goto case_77;
31151|      0|        }
31152|      0|        if ((int)*(*p) == 80) {
31153|      0|          goto case_80;
31154|      0|        }
31155|      0|        if ((int)*(*p) == 84) {
31156|      0|          goto case_84;
31157|      0|        }
31158|      0|        if ((int)*(*p) == 116) {
31159|      0|          goto case_84;
31160|      0|        }
31161|      0|        if ((int)*(*p) == 119) {
31162|      0|          goto case_119;
31163|      0|        }
31164|      0|        if ((int)*(*p) == 89) {
31165|      0|          goto case_89;
31166|      0|        }
31167|      0|        if ((int)*(*p) == 90) {
31168|      0|          goto case_90;
31169|      0|        }
31170|      0|        goto switch_default;
31171|      0|      case_98 : /* CIL Label */
31172|      0|      {
31173|      0|        overflow = bkm_scale___1(&tmp, 512);
31174|      0|      }
31175|      0|        goto switch_break___0;
31176|      0|      case_66___0 : /* CIL Label */
31177|      0|      {
31178|      0|        overflow = bkm_scale___1(&tmp, 1024);
31179|      0|      }
31180|      0|        goto switch_break___0;
31181|      0|      case_99: /* CIL Label */
31182|      0|        overflow = (strtol_error)0;
31183|      0|        goto switch_break___0;
31184|      0|      case_69 : /* CIL Label */
31185|      0|      {
31186|      0|        overflow = bkm_scale_by_power___1(&tmp, base, 6);
31187|      0|      }
31188|      0|        goto switch_break___0;
31189|      0|      case_71:   /* CIL Label */
31190|      0|      case_103 : /* CIL Label */
31191|      0|      {
31192|      0|        overflow = bkm_scale_by_power___1(&tmp, base, 3);
31193|      0|      }
31194|      0|        goto switch_break___0;
31195|      0|      case_107: /* CIL Label */
31196|      0|      case_75 : /* CIL Label */
31197|      0|      {
31198|      0|        overflow = bkm_scale_by_power___1(&tmp, base, 1);
31199|      0|      }
31200|      0|        goto switch_break___0;
31201|      0|      case_77:   /* CIL Label */
31202|      0|      case_109 : /* CIL Label */
31203|      0|      {
31204|      0|        overflow = bkm_scale_by_power___1(&tmp, base, 2);
31205|      0|      }
31206|      0|        goto switch_break___0;
31207|      0|      case_80 : /* CIL Label */
31208|      0|      {
31209|      0|        overflow = bkm_scale_by_power___1(&tmp, base, 5);
31210|      0|      }
31211|      0|        goto switch_break___0;
31212|      0|      case_84:   /* CIL Label */
31213|      0|      case_116 : /* CIL Label */
31214|      0|      {
31215|      0|        overflow = bkm_scale_by_power___1(&tmp, base, 4);
31216|      0|      }
31217|      0|        goto switch_break___0;
31218|      0|      case_119 : /* CIL Label */
31219|      0|      {
31220|      0|        overflow = bkm_scale___1(&tmp, 2);
31221|      0|      }
31222|      0|        goto switch_break___0;
31223|      0|      case_89 : /* CIL Label */
31224|      0|      {
31225|      0|        overflow = bkm_scale_by_power___1(&tmp, base, 8);
31226|      0|      }
31227|      0|        goto switch_break___0;
31228|      0|      case_90 : /* CIL Label */
31229|      0|      {
31230|      0|        overflow = bkm_scale_by_power___1(&tmp, base, 7);
31231|      0|      }
31232|      0|        goto switch_break___0;
31233|      0|      switch_default: /* CIL Label */
31234|      0|        *val = tmp;
31235|      0|        return ((strtol_error)((unsigned int)err | 2U));
31236|      0|      switch_break___0: /* CIL Label */;
31237|      0|      }
31238|      0|      err = (strtol_error)((unsigned int)err | (unsigned int)overflow);
31239|      0|      *p += suffixes;
31240|      0|      if (*(*p)) {
31241|      0|        err = (strtol_error)((unsigned int)err | 2U);
31242|      0|      }
31243|      0|    }
31244|      0|    *val = tmp;
31245|      0|    return (err);
31246|      0|  }
31247|      0|}
31248|       |/* #pragma merger("0","../../lib/addext.o.i","") */
31249|       |/* #pragma merger("0","../../lib/argmatch.o.i","") */
31250|       |/* #pragma merger("0","../../lib/backupfile.o.i","") */
31251|       |/* #pragma merger("0","../../lib/basename.o.i","") */
31252|       |/* #pragma merger("0","../../lib/dirname.o.i","") */
31253|       |/* #pragma merger("0","../../lib/exclude.o.i","") */
31254|       |/* #pragma merger("0","../../lib/exitfail.o.i","") */
31255|       |/* #pragma merger("0","../../lib/full-write.o.i","") */
31256|       |/* #pragma merger("0","../../lib/getdate.o.i","") */
31257|       |/* #pragma merger("0","../../lib/getopt1.o.i","") */
31258|       |/* #pragma merger("0","../../lib/getopt.o.i","") */
31259|       |/* #pragma merger("0","../../lib/gettime.o.i","") */
31260|       |/* #pragma merger("0","../../lib/hash.o.i","") */
31261|       |/* #pragma merger("0","../../lib/human.o.i","") */
31262|       |/* #pragma merger("0","../../lib/mktime.o.i","") */
31263|       |/* #pragma merger("0","../../lib/modechange.o.i","") */
31264|       |/* #pragma merger("0","../../lib/prepargs.o.i","") */
31265|       |/* #pragma merger("0","../../lib/quotearg.o.i","") */
31266|       |/* #pragma merger("0","../../lib/quote.o.i","") */
31267|       |/* #pragma merger("0","../../lib/safe-read.o.i","") */
31268|       |/* #pragma merger("0","../../lib/safe-write.o.i","") */
31269|       |/* #pragma merger("0","../../lib/save-cwd.o.i","") */
31270|       |/* #pragma merger("0","../../lib/savedir.o.i","") */
31271|       |/* #pragma merger("0","../../lib/stripslash.o.i","") */
31272|       |/* #pragma merger("0","../../lib/xgetcwd.o.i","") */
31273|       |/* #pragma merger("0","../../lib/xmalloc.o.i","") */
31274|       |/* #pragma merger("0","../../lib/xstrdup.o.i","") */
31275|       |/* #pragma merger("0","../../lib/xstrtol.o.i","") */
31276|       |/* #pragma merger("0","../../lib/xstrtoul.o.i","") */
31277|       |/* #pragma merger("0","../../lib/xstrtoumax.o.i","") */


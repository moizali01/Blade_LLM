    1|       |typedef long __time_t;
    2|       |typedef long __syscall_slong_t;
    3|       |typedef __time_t time_t;
    4|       |struct timespec {
    5|       |    __time_t tv_sec;
    6|       |    __syscall_slong_t tv_nsec;
    7|       |};
    8|       |typedef unsigned long size_t;
    9|       |typedef unsigned long __dev_t;
   10|       |typedef unsigned int __uid_t;
   11|       |typedef unsigned int __gid_t;
   12|       |typedef unsigned long __ino_t;
   13|       |typedef unsigned int __mode_t;
   14|       |typedef unsigned long __nlink_t;
   15|       |typedef long __off_t;
   16|       |typedef long __blksize_t;
   17|       |typedef long __blkcnt_t;
   18|       |typedef __uid_t uid_t;
   19|       |struct stat {
   20|       |    __dev_t st_dev;
   21|       |    __ino_t st_ino;
   22|       |    __nlink_t st_nlink;
   23|       |    __mode_t st_mode;
   24|       |    __uid_t st_uid;
   25|       |    __gid_t st_gid;
   26|       |    int __pad0;
   27|       |    __dev_t st_rdev;
   28|       |    __off_t st_size;
   29|       |    __blksize_t st_blksize;
   30|       |    __blkcnt_t st_blocks;
   31|       |    struct timespec st_atim;
   32|       |    struct timespec st_mtim;
   33|       |    struct timespec st_ctim;
   34|       |    __syscall_slong_t __glibc_reserved[3];
   35|       |};
   36|       |typedef __ino_t ino_t;
   37|       |typedef __dev_t dev_t;
   38|       |struct hash_tuning {
   39|       |    float shrink_threshold;
   40|       |    float shrink_factor;
   41|       |    float growth_threshold;
   42|       |    float growth_factor;
   43|       |    _Bool is_n_buckets;
   44|       |};
   45|       |typedef struct hash_tuning Hash_tuning;
   46|       |struct hash_table;
   47|       |struct hash_table;
   48|       |struct hash_table;
   49|       |typedef struct hash_table Hash_table;
   50|       |typedef unsigned long uintmax_t;
   51|       |typedef long __off64_t;
   52|       |struct _IO_FILE;
   53|       |struct _IO_FILE;
   54|       |struct _IO_FILE;
   55|       |typedef struct _IO_FILE FILE;
   56|       |typedef void _IO_lock_t;
   57|       |struct _IO_marker {
   58|       |    struct _IO_marker *_next;
   59|       |    struct _IO_FILE *_sbuf;
   60|       |    int _pos;
   61|       |};
   62|       |struct _IO_FILE {
   63|       |    int _flags;
   64|       |    char *_IO_read_ptr;
   65|       |    char *_IO_read_end;
   66|       |    char *_IO_read_base;
   67|       |    char *_IO_write_base;
   68|       |    char *_IO_write_ptr;
   69|       |    char *_IO_write_end;
   70|       |    char *_IO_buf_base;
   71|       |    char *_IO_buf_end;
   72|       |    char *_IO_save_base;
   73|       |    char *_IO_backup_base;
   74|       |    char *_IO_save_end;
   75|       |    struct _IO_marker *_markers;
   76|       |    struct _IO_FILE *_chain;
   77|       |    int _fileno;
   78|       |    int _flags2;
   79|       |    __off_t _old_offset;
   80|       |    unsigned short _cur_column;
   81|       |    signed char _vtable_offset;
   82|       |    char _shortbuf[1];
   83|       |    _IO_lock_t *_lock;
   84|       |    __off64_t _offset;
   85|       |    void *__pad1;
   86|       |    void *__pad2;
   87|       |    void *__pad3;
   88|       |    void *__pad4;
   89|       |    size_t __pad5;
   90|       |    int _mode;
   91|       |    char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
   92|       |};
   93|       |typedef __off_t off_t;
   94|       |typedef long __ssize_t;
   95|       |typedef __ssize_t ssize_t;
   96|       |struct allocator;
   97|       |struct allocator;
   98|       |struct allocator;
   99|       |struct allocator {
  100|       |    void *(*allocate)(size_t);
  101|       |    void *(*reallocate)(void *, size_t);
  102|       |    void (*free)(void *);
  103|       |    void (*die)(size_t);
  104|       |};
  105|       |typedef long ptrdiff_t;
  106|       |typedef __builtin_va_list __gnuc_va_list;
  107|       |typedef __gnuc_va_list va_list;
  108|       |enum quoting_style {
  109|       |    literal_quoting_style = 0,
  110|       |    shell_quoting_style = 1,
  111|       |    shell_always_quoting_style = 2,
  112|       |    c_quoting_style = 3,
  113|       |    c_maybe_quoting_style = 4,
  114|       |    escape_quoting_style = 5,
  115|       |    locale_quoting_style = 6,
  116|       |    clocale_quoting_style = 7,
  117|       |    custom_quoting_style = 8
  118|       |};
  119|       |enum strtol_error {
  120|       |    LONGINT_OK = 0,
  121|       |    LONGINT_OVERFLOW = 1,
  122|       |    LONGINT_INVALID_SUFFIX_CHAR = 2,
  123|       |    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
  124|       |    LONGINT_INVALID = 4
  125|       |};
  126|       |typedef enum strtol_error strtol_error;
  127|       |struct option {
  128|       |    char const *name;
  129|       |    int has_arg;
  130|       |    int *flag;
  131|       |    int val;
  132|       |};
  133|       |typedef unsigned int uint32_t;
  134|       |typedef int __pid_t;
  135|       |typedef __pid_t pid_t;
  136|       |typedef int wchar_t;
  137|       |typedef int nl_item;
  138|       |typedef unsigned int wint_t;
  139|       |typedef long __suseconds_t;
  140|       |struct timeval {
  141|       |    __time_t tv_sec;
  142|       |    __suseconds_t tv_usec;
  143|       |};
  144|       |union __anonunion___value_23 {
  145|       |    unsigned int __wch;
  146|       |    char __wchb[4];
  147|       |};
  148|       |struct __anonstruct___mbstate_t_22 {
  149|       |    int __count;
  150|       |    union __anonunion___value_23 __value;
  151|       |};
  152|       |typedef struct __anonstruct___mbstate_t_22 __mbstate_t;
  153|       |typedef __mbstate_t mbstate_t;
  154|       |struct mbchar {
  155|       |    char const *ptr;
  156|       |    size_t bytes;
  157|       |    _Bool wc_valid;
  158|       |    wchar_t wc;
  159|       |    char buf[24];
  160|       |};
  161|       |struct __anonstruct___sigset_t_9 {
  162|       |    unsigned long __val[1024UL / (8UL * sizeof(unsigned long))];
  163|       |};
  164|       |typedef struct __anonstruct___sigset_t_9 __sigset_t;
  165|       |typedef __sigset_t sigset_t;
  166|       |struct timezone {
  167|       |    int tz_minuteswest;
  168|       |    int tz_dsttime;
  169|       |};
  170|       |struct obstack;
  171|       |struct obstack;
  172|       |struct obstack;
  173|       |struct _obstack_chunk {
  174|       |    char *limit;
  175|       |    struct _obstack_chunk *prev;
  176|       |    char contents[4];
  177|       |};
  178|       |union __anonunion_temp_26 {
  179|       |    long tempint;
  180|       |    void *tempptr;
  181|       |};
  182|       |struct obstack {
  183|       |    long chunk_size;
  184|       |    struct _obstack_chunk *chunk;
  185|       |    char *object_base;
  186|       |    char *next_free;
  187|       |    char *chunk_limit;
  188|       |    union __anonunion_temp_26 temp;
  189|       |    int alignment_mask;
  190|       |    struct _obstack_chunk *(*chunkfun)(void *, long);
  191|       |    void (*freefun)(void *, struct _obstack_chunk *);
  192|       |    void *extra_arg;
  193|       |    unsigned int use_extra_arg : 1;
  194|       |    unsigned int maybe_empty_object : 1;
  195|       |    unsigned int alloc_failed : 1;
  196|       |};
  197|       |struct Tokens {
  198|       |    size_t n_tok;
  199|       |    char **tok;
  200|       |    size_t *tok_len;
  201|       |    struct obstack o_data;
  202|       |    struct obstack o_tok;
  203|       |    struct obstack o_tok_len;
  204|       |};
  205|       |struct randread_source;
  206|       |struct randread_source;
  207|       |struct randread_source;
  208|       |typedef unsigned long uint_least64_t;
  209|       |typedef struct timezone *__restrict __timezone_ptr_t;
  210|       |typedef uint_least64_t isaac_word;
  211|       |struct isaac_state {
  212|       |    isaac_word m[1 << 8];
  213|       |    isaac_word a;
  214|       |    isaac_word b;
  215|       |    isaac_word c;
  216|       |};
  217|       |union __anonunion_data_31 {
  218|       |    isaac_word w[1 << 8];
  219|       |    unsigned char b[(unsigned long)(1 << 8) * sizeof(isaac_word)];
  220|       |};
  221|       |struct isaac {
  222|       |    size_t buffered;
  223|       |    struct isaac_state state;
  224|       |    union __anonunion_data_31 data;
  225|       |};
  226|       |union __anonunion_buf_30 {
  227|       |    char c[2UL * ((unsigned long)(1 << 8) * sizeof(isaac_word))];
  228|       |    struct isaac isaac;
  229|       |};
  230|       |struct randread_source {
  231|       |    FILE *source;
  232|       |    void (*handler)(void const *);
  233|       |    void const *handler_arg;
  234|       |    union __anonunion_buf_30 buf;
  235|       |};
  236|       |struct quoting_options;
  237|       |struct quoting_options;
  238|       |struct quoting_options;
  239|       |struct quoting_options {
  240|       |    enum quoting_style style;
  241|       |    int flags;
  242|       |    unsigned int quote_these_too[255UL / (sizeof(int) * 8UL) + 1UL];
  243|       |    char const *left_quote;
  244|       |    char const *right_quote;
  245|       |};
  246|       |struct slotvec {
  247|       |    size_t size;
  248|       |    char *val;
  249|       |};
  250|       |struct mbuiter_multi {
  251|       |    _Bool in_shift;
  252|       |    mbstate_t state;
  253|       |    _Bool next_done;
  254|       |    struct mbchar cur;
  255|       |};
  256|       |typedef struct mbuiter_multi mbui_iterator_t;
  257|       |enum nproc_query {
  258|       |    NPROC_ALL = 0,
  259|       |    NPROC_CURRENT = 1,
  260|       |    NPROC_CURRENT_OVERRIDABLE = 2
  261|       |};
  262|       |typedef unsigned long __cpu_mask;
  263|       |struct __anonstruct_cpu_set_t_24 {
  264|       |    __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask))];
  265|       |};
  266|       |typedef struct __anonstruct_cpu_set_t_24 cpu_set_t;
  267|       |struct md5_ctx {
  268|       |    uint32_t A;
  269|       |    uint32_t B;
  270|       |    uint32_t C;
  271|       |    uint32_t D;
  272|       |    uint32_t total[2];
  273|       |    uint32_t buflen;
  274|       |    uint32_t buffer[32];
  275|       |};
  276|       |struct __pthread_internal_list {
  277|       |    struct __pthread_internal_list *__prev;
  278|       |    struct __pthread_internal_list *__next;
  279|       |};
  280|       |typedef struct __pthread_internal_list __pthread_list_t;
  281|       |struct __pthread_mutex_s {
  282|       |    int __lock;
  283|       |    unsigned int __count;
  284|       |    int __owner;
  285|       |    unsigned int __nusers;
  286|       |    int __kind;
  287|       |    short __spins;
  288|       |    short __elision;
  289|       |    __pthread_list_t __list;
  290|       |};
  291|       |union __anonunion_pthread_mutex_t_11 {
  292|       |    struct __pthread_mutex_s __data;
  293|       |    char __size[40];
  294|       |    long __align;
  295|       |};
  296|       |typedef union __anonunion_pthread_mutex_t_11 pthread_mutex_t;
  297|       |union __anonunion_pthread_mutexattr_t_12 {
  298|       |    char __size[4];
  299|       |    int __align;
  300|       |};
  301|       |typedef union __anonunion_pthread_mutexattr_t_12 pthread_mutexattr_t;
  302|       |struct lconv {
  303|       |    char *decimal_point;
  304|       |    char *thousands_sep;
  305|       |    char *grouping;
  306|       |    char *int_curr_symbol;
  307|       |    char *currency_symbol;
  308|       |    char *mon_decimal_point;
  309|       |    char *mon_thousands_sep;
  310|       |    char *mon_grouping;
  311|       |    char *positive_sign;
  312|       |    char *negative_sign;
  313|       |    char int_frac_digits;
  314|       |    char frac_digits;
  315|       |    char p_cs_precedes;
  316|       |    char p_sep_by_space;
  317|       |    char n_cs_precedes;
  318|       |    char n_sep_by_space;
  319|       |    char p_sign_posn;
  320|       |    char n_sign_posn;
  321|       |    char int_p_cs_precedes;
  322|       |    char int_p_sep_by_space;
  323|       |    char int_n_cs_precedes;
  324|       |    char int_n_sep_by_space;
  325|       |    char int_p_sign_posn;
  326|       |    char int_n_sign_posn;
  327|       |};
  328|       |struct heap;
  329|       |struct heap;
  330|       |struct heap;
  331|       |struct heap {
  332|       |    void **array;
  333|       |    size_t capacity;
  334|       |    size_t count;
  335|       |    int (*compare)(void const *, void const *);
  336|       |};
  337|       |struct hash_entry {
  338|       |    void *data;
  339|       |    struct hash_entry *next;
  340|       |};
  341|       |struct hash_table {
  342|       |    struct hash_entry *bucket;
  343|       |    struct hash_entry const *bucket_limit;
  344|       |    size_t n_buckets;
  345|       |    size_t n_buckets_used;
  346|       |    size_t n_entries;
  347|       |    Hash_tuning const *tuning;
  348|       |    size_t (*hasher)(void const *, size_t);
  349|       |    _Bool (*comparator)(void const *, void const *);
  350|       |    void (*data_freer)(void *);
  351|       |    struct hash_entry *free_entry_list;
  352|       |};
  353|       |struct F_triple {
  354|       |    char *name;
  355|       |    ino_t st_ino;
  356|       |    dev_t st_dev;
  357|       |};
  358|       |typedef long __clock_t;
  359|       |union sigval {
  360|       |    int sival_int;
  361|       |    void *sival_ptr;
  362|       |};
  363|       |typedef union sigval sigval_t;
  364|       |typedef __clock_t __sigchld_clock_t;
  365|       |struct __anonstruct__kill_23 {
  366|       |    __pid_t si_pid;
  367|       |    __uid_t si_uid;
  368|       |};
  369|       |struct __anonstruct__timer_24 {
  370|       |    int si_tid;
  371|       |    int si_overrun;
  372|       |    sigval_t si_sigval;
  373|       |};
  374|       |struct __anonstruct__rt_25 {
  375|       |    __pid_t si_pid;
  376|       |    __uid_t si_uid;
  377|       |    sigval_t si_sigval;
  378|       |};
  379|       |struct __anonstruct__sigchld_26 {
  380|       |    __pid_t si_pid;
  381|       |    __uid_t si_uid;
  382|       |    int si_status;
  383|       |    __sigchld_clock_t si_utime;
  384|       |    __sigchld_clock_t si_stime;
  385|       |};
  386|       |struct __anonstruct__sigfault_27 {
  387|       |    void *si_addr;
  388|       |    short si_addr_lsb;
  389|       |};
  390|       |struct __anonstruct__sigpoll_28 {
  391|       |    long si_band;
  392|       |    int si_fd;
  393|       |};
  394|       |struct __anonstruct__sigsys_29 {
  395|       |    void *_call_addr;
  396|       |    int _syscall;
  397|       |    unsigned int _arch;
  398|       |};
  399|       |union __anonunion__sifields_22 {
  400|       |    int _pad[128UL / sizeof(int) - 4UL];
  401|       |    struct __anonstruct__kill_23 _kill;
  402|       |    struct __anonstruct__timer_24 _timer;
  403|       |    struct __anonstruct__rt_25 _rt;
  404|       |    struct __anonstruct__sigchld_26 _sigchld;
  405|       |    struct __anonstruct__sigfault_27 _sigfault;
  406|       |    struct __anonstruct__sigpoll_28 _sigpoll;
  407|       |    struct __anonstruct__sigsys_29 _sigsys;
  408|       |};
  409|       |struct __anonstruct_siginfo_t_21 {
  410|       |    int si_signo;
  411|       |    int si_errno;
  412|       |    int si_code;
  413|       |    union __anonunion__sifields_22 _sifields;
  414|       |};
  415|       |typedef struct __anonstruct_siginfo_t_21 siginfo_t;
  416|       |union __anonunion___sigaction_handler_41 {
  417|       |    void (*sa_handler)(int);
  418|       |    void (*sa_sigaction)(int, siginfo_t *, void *);
  419|       |};
  420|       |struct sigaction {
  421|       |    union __anonunion___sigaction_handler_41 __sigaction_handler;
  422|       |    __sigset_t sa_mask;
  423|       |    int sa_flags;
  424|       |    void (*sa_restorer)(void);
  425|       |};
  426|       |enum __anonenum_fadvice_t_19 {
  427|       |    FADVISE_NORMAL = 0,
  428|       |    FADVISE_SEQUENTIAL = 2,
  429|       |    FADVISE_NOREUSE = 5,
  430|       |    FADVISE_DONTNEED = 4,
  431|       |    FADVISE_WILLNEED = 3,
  432|       |    FADVISE_RANDOM = 1
  433|       |};
  434|       |typedef enum __anonenum_fadvice_t_19 fadvice_t;
  435|       |typedef unsigned long __rlim_t;
  436|       |typedef unsigned long pthread_t;
  437|       |union pthread_attr_t {
  438|       |    char __size[56];
  439|       |    long __align;
  440|       |};
  441|       |typedef union pthread_attr_t pthread_attr_t;
  442|       |struct __anonstruct___data_7 {
  443|       |    int __lock;
  444|       |    unsigned int __futex;
  445|       |    unsigned long long __total_seq;
  446|       |    unsigned long long __wakeup_seq;
  447|       |    unsigned long long __woken_seq;
  448|       |    void *__mutex;
  449|       |    unsigned int __nwaiters;
  450|       |    unsigned int __broadcast_seq;
  451|       |};
  452|       |union __anonunion_pthread_cond_t_6 {
  453|       |    struct __anonstruct___data_7 __data;
  454|       |    char __size[48];
  455|       |    long long __align;
  456|       |};
  457|       |typedef union __anonunion_pthread_cond_t_6 pthread_cond_t;
  458|       |union __anonunion_pthread_condattr_t_8 {
  459|       |    char __size[4];
  460|       |    int __align;
  461|       |};
  462|       |typedef union __anonunion_pthread_condattr_t_8 pthread_condattr_t;
  463|       |typedef void (*__sighandler_t)(int);
  464|       |enum __rlimit_resource {
  465|       |    RLIMIT_CPU = 0,
  466|       |    RLIMIT_FSIZE = 1,
  467|       |    RLIMIT_DATA = 2,
  468|       |    RLIMIT_STACK = 3,
  469|       |    RLIMIT_CORE = 4,
  470|       |    __RLIMIT_RSS = 5,
  471|       |    RLIMIT_NOFILE = 7,
  472|       |    __RLIMIT_OFILE = 7,
  473|       |    RLIMIT_AS = 9,
  474|       |    __RLIMIT_NPROC = 6,
  475|       |    __RLIMIT_MEMLOCK = 8,
  476|       |    __RLIMIT_LOCKS = 10,
  477|       |    __RLIMIT_SIGPENDING = 11,
  478|       |    __RLIMIT_MSGQUEUE = 12,
  479|       |    __RLIMIT_NICE = 13,
  480|       |    __RLIMIT_RTPRIO = 14,
  481|       |    __RLIMIT_RTTIME = 15,
  482|       |    __RLIMIT_NLIMITS = 16,
  483|       |    __RLIM_NLIMITS = 16
  484|       |};
  485|       |typedef __rlim_t rlim_t;
  486|       |struct rlimit {
  487|       |    rlim_t rlim_cur;
  488|       |    rlim_t rlim_max;
  489|       |};
  490|       |typedef enum __rlimit_resource __rlimit_resource_t;
  491|       |enum blanktype { bl_start = 0, bl_end = 1, bl_both = 2 };
  492|       |struct line {
  493|       |    char *text;
  494|       |    size_t length;
  495|       |    char *keybeg;
  496|       |    char *keylim;
  497|       |};
  498|       |struct buffer {
  499|       |    char *buf;
  500|       |    size_t used;
  501|       |    size_t nlines;
  502|       |    size_t alloc;
  503|       |    size_t left;
  504|       |    size_t line_bytes;
  505|       |    _Bool eof;
  506|       |};
  507|       |struct keyfield {
  508|       |    size_t sword;
  509|       |    size_t schar;
  510|       |    size_t eword;
  511|       |    size_t echar;
  512|       |    _Bool const *ignore;
  513|       |    char const *translate;
  514|       |    _Bool skipsblanks;
  515|       |    _Bool skipeblanks;
  516|       |    _Bool numeric;
  517|       |    _Bool random;
  518|       |    _Bool general_numeric;
  519|       |    _Bool human_numeric;
  520|       |    _Bool month;
  521|       |    _Bool reverse;
  522|       |    _Bool version;
  523|       |    _Bool obsolete_used;
  524|       |    struct keyfield *next;
  525|       |};
  526|       |struct month {
  527|       |    char const *name;
  528|       |    int val;
  529|       |};
  530|       |struct merge_node {
  531|       |    struct line *lo;
  532|       |    struct line *hi;
  533|       |    struct line *end_lo;
  534|       |    struct line *end_hi;
  535|       |    struct line **dest;
  536|       |    size_t nlo;
  537|       |    size_t nhi;
  538|       |    struct merge_node *parent;
  539|       |    struct merge_node *lo_child;
  540|       |    struct merge_node *hi_child;
  541|       |    unsigned int level;
  542|       |    _Bool queued;
  543|       |    pthread_mutex_t lock;
  544|       |};
  545|       |struct merge_node_queue {
  546|       |    struct heap *priority_queue;
  547|       |    pthread_mutex_t mutex;
  548|       |    pthread_cond_t cond;
  549|       |};
  550|       |struct cs_status {
  551|       |    _Bool valid;
  552|       |    sigset_t sigs;
  553|       |};
  554|       |struct tempnode {
  555|       |    struct tempnode *volatile next;
  556|       |    pid_t pid;
  557|       |    char state;
  558|       |    char name[1];
  559|       |};
  560|       |struct sortfile {
  561|       |    char const *name;
  562|       |    struct tempnode *temp;
  563|       |};
  564|       |union __anonunion_101 {
  565|       |    int __in;
  566|       |    int __i;
  567|       |};
  568|       |union __anonunion_102 {
  569|       |    int __in;
  570|       |    int __i;
  571|       |};
  572|       |struct thread_args {
  573|       |    struct line *lines;
  574|       |    size_t nthreads;
  575|       |    size_t total_lines;
  576|       |    struct merge_node *node;
  577|       |    struct merge_node_queue *queue;
  578|       |    FILE *tfp;
  579|       |    char const *output_temp;
  580|       |};
  581|       |struct timespec dtotimespec(double sec);
  582|       |struct timespec dtotimespec(double sec)
  583|      0|{
  584|      0|    double min_representable;
  585|      0|    double max_representable;
  586|      0|    struct timespec r;
  587|      0|    time_t s;
  588|      0|    double frac;
  589|      0|    long ns;
  590|       |
  591|      0|    {
  592|      0|        min_representable =
  593|      0|            (double)(~(((1L << (sizeof(time_t) * 8UL - 2UL)) - 1L) * 2L + 1L));
  594|      0|        max_representable =
  595|      0|            ((double)(((1L << (sizeof(time_t) * 8UL - 2UL)) - 1L) * 2L + 1L) *
  596|      0|             (double)1000000000 +
  597|      0|             (double)999999999) /
  598|      0|            (double)1000000000;
  599|      0|        if (!(min_representable < sec)) {
  600|      0|            r.tv_sec = ~(((1L << (sizeof(time_t) * 8UL - 2UL)) - 1L) * 2L + 1L);
  601|      0|            r.tv_nsec = (__syscall_slong_t)0;
  602|      0|        }
  603|      0|        else {
  604|      0|            if (!(sec < max_representable)) {
  605|      0|                r.tv_sec = ((1L << (sizeof(time_t) * 8UL - 2UL)) - 1L) * 2L + 1L;
  606|      0|                r.tv_nsec = (__syscall_slong_t)999999999;
  607|      0|            }
  608|      0|            else {
  609|      0|                s = (time_t)sec;
  610|      0|                frac = (double)1000000000 * (sec - (double)s);
  611|      0|                ns = (long)frac;
  612|      0|                ns += (long)((double)ns < frac);
  613|      0|                s += ns / 1000000000L;
  614|      0|                ns %= 1000000000L;
  615|      0|                if (ns < 0L) {
  616|      0|                    s--;
  617|      0|                    ns += 1000000000L;
  618|      0|                }
  619|      0|                r.tv_sec = s;
  620|      0|                r.tv_nsec = ns;
  621|      0|            }
  622|      0|        }
  623|      0|        return (r);
  624|      0|    }
  625|      0|}
  626|       |__attribute__((__noreturn__)) void xalloc_die(void);
  627|       |char *last_component(char const *name) __attribute__((__pure__));
  628|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__)) malloc)(
  629|       |    size_t __size) __attribute__((__malloc__));
  630|       |extern __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1, 2),
  631|       |        __leaf__)) memcpy)(
  632|       |            void *__restrict __dest, void const *__restrict __src, size_t __n);
  633|       |extern __attribute__((__nothrow__)) int *(
  634|       |    __attribute__((__leaf__)) __errno_location)(void)__attribute__((__const__));
  635|       |extern __attribute__((__nothrow__)) int(__attribute__((
  636|       |        __nonnull__(1, 2), __leaf__)) stat)(char const *__restrict __file,
  637|       |                struct stat *__restrict __buf);
  638|       |extern __attribute__((__nothrow__)) int(__attribute__((
  639|       |        __nonnull__(2), __leaf__)) fstat)(int __fd, struct stat *__buf);
  640|       |extern int close(int __fd);
  641|       |char const diacrit_base[256];
  642|       |char const diacrit_diac[256];
  643|       |char const diacrit_base[256] = {
  644|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  645|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  646|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  647|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  648|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  649|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  650|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  651|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  652|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  653|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  654|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  655|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  656|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  657|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  658|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  659|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  660|       |    (char const)0,   (char const)'A', (char const)'B', (char const)'C',
  661|       |    (char const)'D', (char const)'E', (char const)'F', (char const)'G',
  662|       |    (char const)'H', (char const)'I', (char const)'J', (char const)'K',
  663|       |    (char const)'L', (char const)'M', (char const)'N', (char const)'O',
  664|       |    (char const)'P', (char const)'Q', (char const)'R', (char const)'S',
  665|       |    (char const)'T', (char const)'U', (char const)'V', (char const)'W',
  666|       |    (char const)'X', (char const)'Y', (char const)'Z', (char const)0,
  667|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  668|       |    (char const)0,   (char const)'a', (char const)'b', (char const)'c',
  669|       |    (char const)'d', (char const)'e', (char const)'f', (char const)'g',
  670|       |    (char const)'h', (char const)'i', (char const)'j', (char const)'k',
  671|       |    (char const)'l', (char const)'m', (char const)'n', (char const)'o',
  672|       |    (char const)'p', (char const)'q', (char const)'r', (char const)'s',
  673|       |    (char const)'t', (char const)'u', (char const)'v', (char const)'w',
  674|       |    (char const)'x', (char const)'y', (char const)'z', (char const)0,
  675|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  676|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  677|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  678|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  679|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  680|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  681|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  682|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  683|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  684|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  685|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  686|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  687|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  688|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  689|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  690|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  691|       |    (char const)0,   (char const)0,   (char const)0,   (char const)0,
  692|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'A',
  693|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'C',
  694|       |    (char const)'E', (char const)'E', (char const)'E', (char const)'E',
  695|       |    (char const)'I', (char const)'I', (char const)'I', (char const)'I',
  696|       |    (char const)0,   (char const)'N', (char const)'O', (char const)'O',
  697|       |    (char const)'O', (char const)'O', (char const)'O', (char const)0,
  698|       |    (char const)'O', (char const)'U', (char const)'U', (char const)'U',
  699|       |    (char const)'U', (char const)'Y', (char const)0,   (char const)0,
  700|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'a',
  701|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'c',
  702|       |    (char const)'e', (char const)'e', (char const)'e', (char const)'e',
  703|       |    (char const)'i', (char const)'i', (char const)'i', (char const)'i',
  704|       |    (char const)0,   (char const)'n', (char const)'o', (char const)'o',
  705|       |    (char const)'o', (char const)'o', (char const)'o', (char const)0,
  706|       |    (char const)'o', (char const)'u', (char const)'u', (char const)'u',
  707|       |    (char const)'u', (char const)'y', (char const)0,   (char const)'y'
  708|       |};
  709|       |char const diacrit_diac[256] = {
  710|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  711|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  712|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  713|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  714|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  715|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  716|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  717|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  718|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  719|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  720|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  721|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  722|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  723|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  724|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  725|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  726|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  727|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  728|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)4,
  729|       |    (char const)0, (char const)3, (char const)0, (char const)0, (char const)0,
  730|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  731|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  732|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  733|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  734|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  735|       |    (char const)0, (char const)6, (char const)0, (char const)0, (char const)0,
  736|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  737|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  738|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  739|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  740|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  741|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  742|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  743|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  744|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  745|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  746|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  747|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  748|       |    (char const)0, (char const)0, (char const)3, (char const)2, (char const)4,
  749|       |    (char const)6, (char const)5, (char const)8, (char const)1, (char const)7,
  750|       |    (char const)3, (char const)2, (char const)4, (char const)5, (char const)3,
  751|       |    (char const)2, (char const)4, (char const)5, (char const)0, (char const)6,
  752|       |    (char const)3, (char const)2, (char const)4, (char const)6, (char const)5,
  753|       |    (char const)0, (char const)9, (char const)3, (char const)2, (char const)4,
  754|       |    (char const)5, (char const)2, (char const)0, (char const)0, (char const)3,
  755|       |    (char const)2, (char const)4, (char const)6, (char const)5, (char const)8,
  756|       |    (char const)1, (char const)7, (char const)3, (char const)2, (char const)4,
  757|       |    (char const)5, (char const)3, (char const)2, (char const)4, (char const)5,
  758|       |    (char const)0, (char const)6, (char const)3, (char const)2, (char const)4,
  759|       |    (char const)6, (char const)5, (char const)0, (char const)9, (char const)3,
  760|       |    (char const)2, (char const)4, (char const)5, (char const)2, (char const)0,
  761|       |    (char const)0
  762|       |};
  763|       |Hash_table *(__attribute__((__warn_unused_result__)) hash_initialize)(
  764|       |    size_t candidate, Hash_tuning const *tuning,
  765|       |    size_t (*hasher)(void const *, size_t),
  766|       |    _Bool (*comparator)(void const *, void const *),
  767|       |    void (*data_freer)(void *));
  768|       |void *(__attribute__((__warn_unused_result__)) hash_insert)(
  769|       |    Hash_table *table___0, void const *entry);
  770|       |int hash_insert_if_absent(Hash_table *table___0, void const *entry,
  771|       |                          void const **matched_ent);
  772|       |extern __attribute__((__nothrow__)) void(__attribute__((__leaf__)) free)(
  773|       |    void *__ptr);
  774|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((
  775|       |            __leaf__)) __assert_fail)(char const *__assertion, char const *__file,
  776|       |                                      unsigned int __line, char const *__function);
  777|       |int fd_safer(int fd);
  778|       |extern void error(int __status, int __errnum, char const *__format, ...);
  779|       |char const *quote(char const *name);
  780|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) gettext)(
  781|       |    char const *__msgid) __attribute__((__format_arg__(1)));
  782|       |void close_stdout(void);
  783|       |extern struct _IO_FILE *stdout;
  784|       |extern struct _IO_FILE *stderr;
  785|       |extern __attribute__((__noreturn__)) void _exit(int __status);
  786|       |int close_stream(FILE *stream);
  787|       |int volatile exit_failure;
  788|       |char *quotearg_colon(char const *arg);
  789|       |static char const *file_name;
  790|       |static _Bool ignore_EPIPE;
  791|       |void close_stdout(void)
  792|      2|{
  793|      2|    char const *write_error;
  794|      2|    char const *tmp;
  795|      2|    char *tmp___0;
  796|      2|    int *tmp___1;
  797|      2|    int *tmp___2;
  798|      2|    int tmp___3;
  799|      2|    int *tmp___4;
  800|      2|    int tmp___5;
  801|       |
  802|      2|    {
  803|      2|        tmp___3 = close_stream(stdout);
  804|      2|        if (tmp___3 != 0) {
  805|      0|            if (ignore_EPIPE) {
  806|      0|                tmp___4 = __errno_location();
  807|      0|                if (!(*tmp___4 == 32)) {
  808|      0|                    goto _L;
  809|      0|                }
  810|      0|            }
  811|      0|            else {
  812|      0|_L:
  813|      0|                tmp = (char const *)gettext("write error");
  814|      0|                write_error = tmp;
  815|      0|                if (file_name) {
  816|      0|                    tmp___0 = quotearg_colon(file_name);
  817|      0|                    tmp___1 = __errno_location();
  818|      0|                    error(0, *tmp___1, "%s: %s", tmp___0, write_error);
  819|      0|                }
  820|      0|                else {
  821|      0|                    tmp___2 = __errno_location();
  822|      0|                    error(0, *tmp___2, "%s", write_error);
  823|      0|                }
  824|      0|                _exit((int)exit_failure);
  825|      0|            }
  826|      0|        }
  827|      2|        tmp___5 = close_stream(stderr);
  828|      2|        if (tmp___5 != 0) {
  829|      0|            _exit((int)exit_failure);
  830|      0|        }
  831|      2|        return;
  832|      2|    }
  833|      2|}
  834|       |extern struct _IO_FILE *stdin;
  835|       |int rpl_fflush(FILE *stream);
  836|       |int(__attribute__((__nonnull__(1))) rpl_fseeko)(FILE *fp, off_t offset,
  837|       |        int whence);
  838|       |extern __attribute__((__nothrow__)) int(
  839|       |    __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream);
  840|       |int(__attribute__((__nonnull__(1))) rpl_fclose)(FILE *fp);
  841|       |extern __attribute__((__nothrow__))
  842|       |size_t(__attribute__((__leaf__)) __fpending)(FILE *__fp);
  843|       |int close_stream(FILE *stream)
  844|      4|{
  845|      4|    _Bool some_pending;
  846|      4|    size_t tmp;
  847|      4|    _Bool prev_fail;
  848|      4|    int tmp___0;
  849|      4|    _Bool fclose_fail;
  850|      4|    int tmp___1;
  851|      4|    int *tmp___2;
  852|      4|    int *tmp___3;
  853|       |
  854|      4|    {
  855|      4|        tmp = __fpending(stream);
  856|      4|        some_pending = (_Bool)(tmp != 0UL);
  857|      4|        tmp___0 = ferror_unlocked(stream);
  858|      4|        prev_fail = (_Bool)(tmp___0 != 0);
  859|      4|        tmp___1 = rpl_fclose(stream);
  860|      4|        fclose_fail = (_Bool)(tmp___1 != 0);
  861|      4|        if (prev_fail) {
  862|      0|            goto _L___0;
  863|      0|        }
  864|      4|        else {
  865|      4|            if (fclose_fail) {
  866|      0|                if (some_pending) {
  867|      0|                    goto _L___0;
  868|      0|                }
  869|      0|                else {
  870|      0|                    tmp___3 = __errno_location();
  871|      0|                    if (*tmp___3 != 9) {
  872|      0|_L___0:
  873|      0|                        if (!fclose_fail) {
  874|      0|                            tmp___2 = __errno_location();
  875|      0|                            *tmp___2 = 0;
  876|      0|                        }
  877|      0|                        return (-1);
  878|      0|                    }
  879|      0|                }
  880|      0|            }
  881|      4|        }
  882|      4|        return (0);
  883|      4|    }
  884|      4|}
  885|       |int rpl_fcntl(int fd, int action, ...);
  886|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  887|       |            __nonnull__(1), __leaf__)) memchr)(void const *__s, int __c, size_t __n)
  888|       |__attribute__((__pure__));
  889|       |extern __attribute__((__nothrow__))
  890|       |size_t(__attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s)
  891|       |__attribute__((__pure__));
  892|       |extern
  893|       |__attribute__((__nothrow__,
  894|       |               __noreturn__)) void(__attribute__((__leaf__)) abort)(void);
  895|       |struct allocator const stdlib_allocator;
  896|       |extern __attribute__((__nothrow__)) void *(__attribute__((
  897|       |            __nonnull__(1, 2), __leaf__)) memmove)(void *__dest, void const *__src,
  898|       |                    size_t __n);
  899|       |extern __attribute__((__nothrow__)) char *(
  900|       |    __attribute__((__nonnull__(1), __leaf__)) strchr)(char const *__s, int __c)
  901|       |__attribute__((__pure__));
  902|       |size_t triple_hash(void const *x, size_t table_size) __attribute__((__pure__));
  903|       |_Bool triple_compare_ino_str(void const *x, void const *y)
  904|       |__attribute__((__pure__));
  905|       |void *xmalloc(size_t n) __attribute__((__malloc__, __alloc_size__(1)));
  906|       |void *xrealloc(void *p, size_t n) __attribute__((__alloc_size__(2)));
  907|       |extern __attribute__((__nothrow__)) char *(
  908|       |    __attribute__((__nonnull__(1), __leaf__)) strdup)(char const *__s)
  909|       |__attribute__((__malloc__));
  910|       |int c_tolower(int c) __attribute__((__const__));
  911|       |int c_strcasecmp(char const *s1, char const *s2) __attribute__((__pure__));
  912|       |int c_strcasecmp(char const *s1, char const *s2) __attribute__((__pure__));
  913|       |int c_strcasecmp(char const *s1, char const *s2)
  914|      0|{
  915|      0|    register unsigned char const *p1;
  916|      0|    register unsigned char const *p2;
  917|      0|    unsigned char c1;
  918|      0|    unsigned char c2;
  919|       |
  920|      0|    {
  921|      0|        p1 = (unsigned char const *)s1;
  922|      0|        p2 = (unsigned char const *)s2;
  923|      0|        if ((unsigned long)p1 == (unsigned long)p2) {
  924|      0|            return (0);
  925|      0|        }
  926|      0|        while (1) {
  927|      0|            c1 = (unsigned char)c_tolower((int)*p1);
  928|      0|            c2 = (unsigned char)c_tolower((int)*p2);
  929|      0|            if ((int)c1 == 0) {
  930|      0|                goto while_break;
  931|      0|            }
  932|      0|            p1++;
  933|      0|            p2++;
  934|      0|            if (!((int)c1 == (int)c2)) {
  935|      0|                goto while_break;
  936|      0|            }
  937|      0|        }
  938|      0|while_break:
  939|      0|        ;
  940|      0|        return ((int)c1 - (int)c2);
  941|      0|    }
  942|      0|}
  943|       |_Bool c_isalnum(int c) __attribute__((__const__));
  944|       |_Bool c_isalpha(int c) __attribute__((__const__));
  945|       |_Bool c_isdigit(int c) __attribute__((__const__));
  946|       |_Bool c_isspace(int c) __attribute__((__const__));
  947|       |_Bool c_isalnum(int c) __attribute__((__const__));
  948|       |_Bool c_isalnum(int c)
  949|      0|{
  950|      0|    int tmp;
  951|       |
  952|      0|    {
  953|      0|        if (c >= 48) {
  954|      0|            if (c <= 57) {
  955|      0|                tmp = 1;
  956|      0|            }
  957|      0|            else {
  958|      0|                goto _L;
  959|      0|            }
  960|      0|        }
  961|      0|        else {
  962|      0|_L:
  963|      0|            if ((c & -33) >= 65) {
  964|      0|                if ((c & -33) <= 90) {
  965|      0|                    tmp = 1;
  966|      0|                }
  967|      0|                else {
  968|      0|                    tmp = 0;
  969|      0|                }
  970|      0|            }
  971|      0|            else {
  972|      0|                tmp = 0;
  973|      0|            }
  974|      0|        }
  975|      0|        return ((_Bool)tmp);
  976|      0|    }
  977|      0|}
  978|       |_Bool c_isalpha(int c) __attribute__((__const__));
  979|       |_Bool c_isalpha(int c)
  980|      0|{
  981|      0|    int tmp;
  982|       |
  983|      0|    {
  984|      0|        if ((c & -33) >= 65) {
  985|      0|            if ((c & -33) <= 90) {
  986|      0|                tmp = 1;
  987|      0|            }
  988|      0|            else {
  989|      0|                tmp = 0;
  990|      0|            }
  991|      0|        }
  992|      0|        else {
  993|      0|            tmp = 0;
  994|      0|        }
  995|      0|        return ((_Bool)tmp);
  996|      0|    }
  997|      0|}
  998|       |_Bool c_isdigit(int c) __attribute__((__const__));
  999|       |_Bool c_isdigit(int c)
 1000|      0|{
 1001|      0|    int tmp;
 1002|       |
 1003|      0|    {
 1004|      0|        if (c >= 48) {
 1005|      0|            if (c <= 57) {
 1006|      0|                tmp = 1;
 1007|      0|            }
 1008|      0|            else {
 1009|      0|                tmp = 0;
 1010|      0|            }
 1011|      0|        }
 1012|      0|        else {
 1013|      0|            tmp = 0;
 1014|      0|        }
 1015|      0|        return ((_Bool)tmp);
 1016|      0|    }
 1017|      0|}
 1018|       |_Bool c_isspace(int c) __attribute__((__const__));
 1019|       |_Bool c_isspace(int c)
 1020|      0|{
 1021|      0|    int tmp;
 1022|       |
 1023|      0|    {
 1024|      0|        if (c == 32) {
 1025|      0|            tmp = 1;
 1026|      0|        }
 1027|      0|        else {
 1028|      0|            if (c == 9) {
 1029|      0|                tmp = 1;
 1030|      0|            }
 1031|      0|            else {
 1032|      0|                if (c == 10) {
 1033|      0|                    tmp = 1;
 1034|      0|                }
 1035|      0|                else {
 1036|      0|                    if (c == 11) {
 1037|      0|                        tmp = 1;
 1038|      0|                    }
 1039|      0|                    else {
 1040|      0|                        if (c == 12) {
 1041|      0|                            tmp = 1;
 1042|      0|                        }
 1043|      0|                        else {
 1044|      0|                            if (c == 13) {
 1045|      0|                                tmp = 1;
 1046|      0|                            }
 1047|      0|                            else {
 1048|      0|                                tmp = 0;
 1049|      0|                            }
 1050|      0|                        }
 1051|      0|                    }
 1052|      0|                }
 1053|      0|            }
 1054|      0|        }
 1055|      0|        return ((_Bool)tmp);
 1056|      0|    }
 1057|      0|}
 1058|       |int c_tolower(int c) __attribute__((__const__));
 1059|       |int c_tolower(int c)
 1060|      0|{
 1061|      0|    int tmp;
 1062|       |
 1063|      0|    {
 1064|      0|        if (c >= 65) {
 1065|      0|            if (c <= 90) {
 1066|      0|                tmp = (c - 65) + 97;
 1067|      0|            }
 1068|      0|            else {
 1069|      0|                tmp = c;
 1070|      0|            }
 1071|      0|        }
 1072|      0|        else {
 1073|      0|            tmp = c;
 1074|      0|        }
 1075|      0|        return (tmp);
 1076|      0|    }
 1077|      0|}
 1078|       |char *last_component(char const *name) __attribute__((__pure__));
 1079|       |char *last_component(char const *name)
 1080|      0|{
 1081|      0|    char const *base;
 1082|      0|    char const *p;
 1083|      0|    _Bool saw_slash;
 1084|       |
 1085|      0|    {
 1086|      0|        base = name + 0;
 1087|      0|        saw_slash = (_Bool)0;
 1088|      0|        while (1) {
 1089|       |
 1090|      0|            if (!((int const) * base == 47)) {
 1091|      0|                goto while_break;
 1092|      0|            }
 1093|      0|            base++;
 1094|      0|        }
 1095|      0|while_break:
 1096|      0|        p = base;
 1097|      0|        while (1) {
 1098|       |
 1099|      0|            if (!*p) {
 1100|      0|                goto while_break___0;
 1101|      0|            }
 1102|      0|            if ((int const) * p == 47) {
 1103|      0|                saw_slash = (_Bool)1;
 1104|      0|            }
 1105|      0|            else {
 1106|      0|                if (saw_slash) {
 1107|      0|                    base = p;
 1108|      0|                    saw_slash = (_Bool)0;
 1109|      0|                }
 1110|      0|            }
 1111|      0|            p++;
 1112|      0|        }
 1113|      0|while_break___0:
 1114|      0|        ;
 1115|      0|        return ((char *)base);
 1116|      0|    }
 1117|      0|}
 1118|       |__inline static unsigned char to_uchar(char ch)
 1119|  12.2M|{
 1120|       |
 1121|  12.2M|    {
 1122|  12.2M|        return ((unsigned char)ch);
 1123|  12.2M|    }
 1124|  12.2M|}
 1125|       |char const *simple_backup_suffix;
 1126|       |void (*argmatch_die)(void);
 1127|       |ptrdiff_t __xargmatch_internal(char const *context, char const *arg,
 1128|       |                               char const *const *arglist, char const *vallist,
 1129|       |                               size_t valsize, void (*exit_fn)(void));
 1130|       |extern __attribute__((__nothrow__)) char *(
 1131|       |    __attribute__((__nonnull__(1), __leaf__)) getenv)(char const *__name);
 1132|       |extern __attribute__((__nothrow__)) int(__attribute__((
 1133|       |        __nonnull__(1, 2), __leaf__)) memcmp)(void const *__s1, void const *__s2,
 1134|       |                size_t __n) __attribute__((__pure__));
 1135|       |extern __attribute__((__nothrow__)) char *(__attribute__((
 1136|       |            __nonnull__(1, 2), __leaf__)) strcpy)(char *__restrict __dest,
 1137|       |                    char const *__restrict __src);
 1138|       |char const *simple_backup_suffix = "~";
 1139|       |ptrdiff_t argmatch(char const *arg, char const *const *arglist,
 1140|       |                   char const *vallist, size_t valsize)
 1141|       |__attribute__((__pure__));
 1142|       |void argmatch_invalid(char const *context, char const *value,
 1143|       |                      ptrdiff_t problem);
 1144|       |void argmatch_valid(char const *const *arglist, char const *vallist,
 1145|       |                    size_t valsize);
 1146|       |extern int fprintf(FILE *__restrict __stream, char const *__restrict __format,
 1147|       |                   ...);
 1148|       |extern int putc_unlocked(int __c, FILE *__stream);
 1149|       |extern int fputs_unlocked(char const *__restrict __s,
 1150|       |                          FILE *__restrict __stream);
 1151|       |extern __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1, 2),
 1152|       |                                        __leaf__)) strncmp)(
 1153|       |                                                char const *__s1, char const *__s2, size_t __n) __attribute__((__pure__));
 1154|       |char *quotearg_n_style(int n, enum quoting_style s, char const *arg);
 1155|       |char const *quote_n(int n, char const *name);
 1156|       |__attribute__((__noreturn__)) void usage(int status);
 1157|       |static void __argmatch_die(void)
 1158|      0|{
 1159|       |
 1160|      0|    {
 1161|      0|        usage(1);
 1162|      0|        return;
 1163|      0|    }
 1164|      0|}
 1165|       |void (*argmatch_die)(void) = &__argmatch_die;
 1166|       |ptrdiff_t argmatch(char const *arg, char const *const *arglist,
 1167|       |                   char const *vallist, size_t valsize)
 1168|       |__attribute__((__pure__));
 1169|       |ptrdiff_t argmatch(char const *arg, char const *const *arglist,
 1170|       |                   char const *vallist, size_t valsize)
 1171|      0|{
 1172|      0|    size_t i;
 1173|      0|    size_t arglen;
 1174|      0|    ptrdiff_t matchind;
 1175|      0|    _Bool ambiguous;
 1176|      0|    int tmp;
 1177|      0|    size_t tmp___0;
 1178|      0|    int tmp___1;
 1179|       |
 1180|      0|    {
 1181|      0|        matchind = (ptrdiff_t)-1;
 1182|      0|        ambiguous = (_Bool)0;
 1183|      0|        arglen = strlen(arg);
 1184|      0|        i = (size_t)0;
 1185|      0|        while (1) {
 1186|       |
 1187|      0|            if (!*(arglist + i)) {
 1188|      0|                goto while_break;
 1189|      0|            }
 1190|      0|            tmp___1 = strncmp((char const *)*(arglist + i), arg, arglen);
 1191|      0|            if (!tmp___1) {
 1192|      0|                tmp___0 = strlen((char const *)*(arglist + i));
 1193|      0|                if (tmp___0 == arglen) {
 1194|      0|                    return ((ptrdiff_t)i);
 1195|      0|                }
 1196|      0|                else {
 1197|      0|                    if (matchind == -1L) {
 1198|      0|                        matchind = (ptrdiff_t)i;
 1199|      0|                    }
 1200|      0|                    else {
 1201|      0|                        if ((unsigned long)vallist == (unsigned long)((void *)0)) {
 1202|      0|                            ambiguous = (_Bool)1;
 1203|      0|                        }
 1204|      0|                        else {
 1205|      0|                            tmp = memcmp((void const *)(vallist + valsize * (size_t)matchind),
 1206|      0|                                         (void const *)(vallist + valsize * i), valsize);
 1207|      0|                            if (tmp) {
 1208|      0|                                ambiguous = (_Bool)1;
 1209|      0|                            }
 1210|      0|                        }
 1211|      0|                    }
 1212|      0|                }
 1213|      0|            }
 1214|      0|            i++;
 1215|      0|        }
 1216|      0|while_break:
 1217|      0|        ;
 1218|      0|        if (ambiguous) {
 1219|      0|            return ((ptrdiff_t)-2);
 1220|      0|        }
 1221|      0|        else {
 1222|      0|            return (matchind);
 1223|      0|        }
 1224|      0|    }
 1225|      0|}
 1226|       |void argmatch_invalid(char const *context, char const *value,
 1227|       |                      ptrdiff_t problem)
 1228|      0|{
 1229|      0|    char const *format;
 1230|      0|    char *tmp;
 1231|      0|    char *tmp___0;
 1232|      0|    char *tmp___1;
 1233|      0|    char const *tmp___2;
 1234|      0|    char *tmp___3;
 1235|       |
 1236|      0|    {
 1237|      0|        if (problem == -1L) {
 1238|      0|            tmp = gettext("invalid argument %s for %s");
 1239|      0|            tmp___1 = tmp;
 1240|      0|        }
 1241|      0|        else {
 1242|      0|            tmp___0 = gettext("ambiguous argument %s for %s");
 1243|      0|            tmp___1 = tmp___0;
 1244|      0|        }
 1245|      0|        format = (char const *)tmp___1;
 1246|      0|        tmp___2 = quote_n(1, context);
 1247|      0|        tmp___3 = quotearg_n_style(0, (enum quoting_style)6, value);
 1248|      0|        error(0, 0, format, tmp___3, tmp___2);
 1249|      0|        return;
 1250|      0|    }
 1251|      0|}
 1252|       |void argmatch_valid(char const *const *arglist, char const *vallist,
 1253|       |                    size_t valsize)
 1254|      0|{
 1255|      0|    size_t i;
 1256|      0|    char const *last_val;
 1257|      0|    char *tmp;
 1258|      0|    char const *tmp___0;
 1259|      0|    char const *tmp___1;
 1260|      0|    int tmp___2;
 1261|       |
 1262|      0|    {
 1263|      0|        last_val = (char const *)((void *)0);
 1264|      0|        tmp = gettext("Valid arguments are:");
 1265|      0|        fputs_unlocked((char const *)tmp, stderr);
 1266|      0|        i = (size_t)0;
 1267|      0|        while (1) {
 1268|       |
 1269|      0|            if (!*(arglist + i)) {
 1270|      0|                goto while_break;
 1271|      0|            }
 1272|      0|            if (i == 0UL) {
 1273|      0|                tmp___0 = quote((char const *)*(arglist + i));
 1274|      0|                fprintf(stderr, "\n  - %s", tmp___0);
 1275|      0|                last_val = vallist + valsize * i;
 1276|      0|            }
 1277|      0|            else {
 1278|      0|                tmp___2 = memcmp((void const *)last_val,
 1279|      0|                                 (void const *)(vallist + valsize * i), valsize);
 1280|      0|                if (tmp___2) {
 1281|      0|                    tmp___0 = quote((char const *)*(arglist + i));
 1282|      0|                    fprintf(stderr, "\n  - %s", tmp___0);
 1283|      0|                    last_val = vallist + valsize * i;
 1284|      0|                }
 1285|      0|                else {
 1286|      0|                    tmp___1 = quote((char const *)*(arglist + i));
 1287|      0|                    fprintf(stderr, ", %s", tmp___1);
 1288|      0|                }
 1289|      0|            }
 1290|      0|            i++;
 1291|      0|        }
 1292|      0|while_break:
 1293|      0|        putc_unlocked('\n', stderr);
 1294|      0|        return;
 1295|      0|    }
 1296|      0|}
 1297|       |ptrdiff_t __xargmatch_internal(char const *context, char const *arg,
 1298|       |                               char const *const *arglist, char const *vallist,
 1299|       |                               size_t valsize, void (*exit_fn)(void))
 1300|      0|{
 1301|      0|    ptrdiff_t res;
 1302|      0|    ptrdiff_t tmp;
 1303|       |
 1304|      0|    {
 1305|      0|        tmp = argmatch(arg, arglist, vallist, valsize);
 1306|      0|        res = tmp;
 1307|      0|        if (res >= 0L) {
 1308|      0|            return (res);
 1309|      0|        }
 1310|      0|        argmatch_invalid(context, arg, res);
 1311|      0|        argmatch_valid(arglist, vallist, valsize);
 1312|      0|        (*exit_fn)();
 1313|      0|        return ((ptrdiff_t)-1);
 1314|      0|    }
 1315|      0|}
 1316|       |extern __attribute__((__nothrow__)) void *(__attribute__((
 1317|       |            __warn_unused_result__, __leaf__)) realloc)(void *__ptr, size_t __size);
 1318|       |struct allocator const stdlib_allocator = {
 1319|       |    (void *(*)(size_t))(&malloc), (void *(*)(void *, size_t))(&realloc),
 1320|       |    (void (*)(void *))(&free), (void (*)(size_t))((void *)0)
 1321|       |};
 1322|       |__inline static void *xnmalloc(size_t n, size_t s)
 1323|       |__attribute__((__malloc__, __alloc_size__(1, 2)));
 1324|       |__inline static void *xnmalloc(size_t n, size_t s)
 1325|       |__attribute__((__malloc__, __alloc_size__(1, 2)));
 1326|       |__inline static void *xnmalloc(size_t n, size_t s)
 1327|      4|{
 1328|      4|    int tmp;
 1329|      4|    void *tmp___0;
 1330|       |
 1331|      4|    {
 1332|      4|        if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 1333|      4|            tmp = -1;
 1334|      4|        }
 1335|      0|        else {
 1336|      0|            tmp = -2;
 1337|      0|        }
 1338|      4|        if ((size_t)tmp / s < n) {
 1339|      0|            xalloc_die();
 1340|      0|        }
 1341|      4|        tmp___0 = xmalloc(n * s);
 1342|      4|        return (tmp___0);
 1343|      4|    }
 1344|      4|}
 1345|       |extern __attribute__((__nothrow__)) unsigned short const **(
 1346|       |    __attribute__((__leaf__)) __ctype_b_loc)(void)__attribute__((__const__));
 1347|       |extern __attribute__((__nothrow__))
 1348|       |uintmax_t(__attribute__((__leaf__)) strtoumax)(char const *__restrict __nptr,
 1349|       |        char **__restrict __endptr,
 1350|       |        int __base);
 1351|       |strtol_error xstrtoumax(char const *s, char **ptr, int strtol_base,
 1352|       |                        uintmax_t *val, char const *valid_suffixes);
 1353|       |static strtol_error bkm_scale(uintmax_t *x, int scale_factor)
 1354|      0|{
 1355|       |
 1356|      0|    {
 1357|      0|        if (0xffffffffffffffffUL / (unsigned long)scale_factor < *x) {
 1358|      0|            *x = 0xffffffffffffffffUL;
 1359|      0|            return ((strtol_error)1);
 1360|      0|        }
 1361|      0|        *x *= (uintmax_t)scale_factor;
 1362|      0|        return ((strtol_error)0);
 1363|      0|    }
 1364|      0|}
 1365|       |static strtol_error bkm_scale_by_power(uintmax_t *x, int base, int power)
 1366|      0|{
 1367|      0|    strtol_error err;
 1368|      0|    strtol_error tmp;
 1369|      0|    int tmp___0;
 1370|       |
 1371|      0|    {
 1372|      0|        err = (strtol_error)0;
 1373|      0|        while (1) {
 1374|      0|            tmp___0 = power;
 1375|      0|            power--;
 1376|      0|            if (!tmp___0) {
 1377|      0|                goto while_break;
 1378|      0|            }
 1379|      0|            tmp = bkm_scale(x, base);
 1380|      0|            err = (strtol_error)((unsigned int)err | (unsigned int)tmp);
 1381|      0|        }
 1382|      0|while_break:
 1383|      0|        ;
 1384|      0|        return (err);
 1385|      0|    }
 1386|      0|}
 1387|       |strtol_error xstrtoumax(char const *s, char **ptr, int strtol_base,
 1388|       |                        uintmax_t *val, char const *valid_suffixes)
 1389|      0|{
 1390|      0|    char *t_ptr;
 1391|      0|    char **p;
 1392|      0|    uintmax_t tmp;
 1393|      0|    strtol_error err;
 1394|      0|    char const *q;
 1395|      0|    unsigned char ch;
 1396|      0|    unsigned short const **tmp___0;
 1397|      0|    int *tmp___1;
 1398|      0|    char *tmp___2;
 1399|      0|    int *tmp___3;
 1400|      0|    int *tmp___4;
 1401|      0|    int base;
 1402|      0|    int suffixes;
 1403|      0|    strtol_error overflow;
 1404|      0|    char *tmp___5;
 1405|      0|    char *tmp___6;
 1406|       |
 1407|      0|    {
 1408|      0|        err = (strtol_error)0;
 1409|      0|        if (0 <= strtol_base) {
 1410|      0|            if (!(strtol_base <= 36)) {
 1411|      0|                __assert_fail("0 <= strtol_base && strtol_base <= 36",
 1412|      0|                              "/home/khheo/project/program-reduce/benchmark/"
 1413|      0|                              "coreutils-8.16/lib/xstrtol.c",
 1414|      0|                              96U, "xstrtoumax");
 1415|      0|            }
 1416|      0|        }
 1417|      0|        else {
 1418|      0|            __assert_fail("0 <= strtol_base && strtol_base <= 36",
 1419|      0|                          "/home/khheo/project/program-reduce/benchmark/"
 1420|      0|                          "coreutils-8.16/lib/xstrtol.c",
 1421|      0|                          96U, "xstrtoumax");
 1422|      0|        }
 1423|      0|        if (ptr) {
 1424|      0|            p = ptr;
 1425|      0|        }
 1426|      0|        else {
 1427|      0|            p = &t_ptr;
 1428|      0|        }
 1429|      0|        q = s;
 1430|      0|        ch = (unsigned char)*q;
 1431|      0|        while (1) {
 1432|      0|            tmp___0 = __ctype_b_loc();
 1433|      0|            if (!((int const) * (*tmp___0 + (int)ch) & 8192)) {
 1434|      0|                goto while_break;
 1435|      0|            }
 1436|      0|            q++;
 1437|      0|            ch = (unsigned char)*q;
 1438|      0|        }
 1439|      0|while_break:
 1440|      0|        ;
 1441|      0|        if ((int)ch == 45) {
 1442|      0|            return ((strtol_error)4);
 1443|      0|        }
 1444|      0|        tmp___1 = __errno_location();
 1445|      0|        *tmp___1 = 0;
 1446|      0|        tmp = strtoumax(s, p, strtol_base);
 1447|      0|        if ((unsigned long)*p == (unsigned long)s) {
 1448|      0|            if (valid_suffixes) {
 1449|      0|                if (*(*p)) {
 1450|      0|                    tmp___2 = strchr(valid_suffixes, (int)*(*p));
 1451|      0|                    if (tmp___2) {
 1452|      0|                        tmp = (uintmax_t)1;
 1453|      0|                    }
 1454|      0|                    else {
 1455|      0|                        return ((strtol_error)4);
 1456|      0|                    }
 1457|      0|                }
 1458|      0|                else {
 1459|      0|                    return ((strtol_error)4);
 1460|      0|                }
 1461|      0|            }
 1462|      0|            else {
 1463|      0|                return ((strtol_error)4);
 1464|      0|            }
 1465|      0|        }
 1466|      0|        else {
 1467|      0|            tmp___4 = __errno_location();
 1468|      0|            if (*tmp___4 != 0) {
 1469|      0|                tmp___3 = __errno_location();
 1470|      0|                if (*tmp___3 != 34) {
 1471|      0|                    return ((strtol_error)4);
 1472|      0|                }
 1473|      0|                err = (strtol_error)1;
 1474|      0|            }
 1475|      0|        }
 1476|      0|        if (!valid_suffixes) {
 1477|      0|            *val = tmp;
 1478|      0|            return (err);
 1479|      0|        }
 1480|      0|        if ((int)*(*p) != 0) {
 1481|      0|            base = 1024;
 1482|      0|            suffixes = 1;
 1483|      0|            tmp___5 = strchr(valid_suffixes, (int)*(*p));
 1484|      0|            if (!tmp___5) {
 1485|      0|                *val = tmp;
 1486|      0|                return ((strtol_error)((unsigned int)err | 2U));
 1487|      0|            }
 1488|      0|            tmp___6 = strchr(valid_suffixes, '0');
 1489|      0|            if (tmp___6) {
 1490|      0|                if ((int)*(*(p + 0) + 1) == 105) {
 1491|      0|                    goto case_105;
 1492|      0|                }
 1493|      0|                if ((int)*(*(p + 0) + 1) == 66) {
 1494|      0|                    goto case_66;
 1495|      0|                }
 1496|      0|                if ((int)*(*(p + 0) + 1) == 68) {
 1497|      0|                    goto case_66;
 1498|      0|                }
 1499|      0|                goto switch_break;
 1500|      0|case_105:
 1501|      0|                if ((int)*(*(p + 0) + 2) == 66) {
 1502|      0|                    suffixes += 2;
 1503|      0|                }
 1504|      0|                goto switch_break;
 1505|      0|case_66:
 1506|      0|                base = 1000;
 1507|      0|                suffixes++;
 1508|      0|                goto switch_break;
 1509|      0|switch_break:
 1510|      0|                ;
 1511|      0|            }
 1512|      0|            if ((int)*(*p) == 98) {
 1513|      0|                goto case_98;
 1514|      0|            }
 1515|      0|            if ((int)*(*p) == 66) {
 1516|      0|                goto case_66___0;
 1517|      0|            }
 1518|      0|            if ((int)*(*p) == 99) {
 1519|      0|                goto case_99;
 1520|      0|            }
 1521|      0|            if ((int)*(*p) == 69) {
 1522|      0|                goto case_69;
 1523|      0|            }
 1524|      0|            if ((int)*(*p) == 71) {
 1525|      0|                goto case_71;
 1526|      0|            }
 1527|      0|            if ((int)*(*p) == 103) {
 1528|      0|                goto case_71;
 1529|      0|            }
 1530|      0|            if ((int)*(*p) == 107) {
 1531|      0|                goto case_107;
 1532|      0|            }
 1533|      0|            if ((int)*(*p) == 75) {
 1534|      0|                goto case_107;
 1535|      0|            }
 1536|      0|            if ((int)*(*p) == 77) {
 1537|      0|                goto case_77;
 1538|      0|            }
 1539|      0|            if ((int)*(*p) == 109) {
 1540|      0|                goto case_77;
 1541|      0|            }
 1542|      0|            if ((int)*(*p) == 80) {
 1543|      0|                goto case_80;
 1544|      0|            }
 1545|      0|            if ((int)*(*p) == 84) {
 1546|      0|                goto case_84;
 1547|      0|            }
 1548|      0|            if ((int)*(*p) == 116) {
 1549|      0|                goto case_84;
 1550|      0|            }
 1551|      0|            if ((int)*(*p) == 119) {
 1552|      0|                goto case_119;
 1553|      0|            }
 1554|      0|            if ((int)*(*p) == 89) {
 1555|      0|                goto case_89;
 1556|      0|            }
 1557|      0|            if ((int)*(*p) == 90) {
 1558|      0|                goto case_90;
 1559|      0|            }
 1560|      0|            goto switch_default;
 1561|      0|case_98:
 1562|      0|            overflow = bkm_scale(&tmp, 512);
 1563|      0|            goto switch_break___0;
 1564|      0|case_66___0:
 1565|      0|            overflow = bkm_scale(&tmp, 1024);
 1566|      0|            goto switch_break___0;
 1567|      0|case_99:
 1568|      0|            overflow = (strtol_error)0;
 1569|      0|            goto switch_break___0;
 1570|      0|case_69:
 1571|      0|            overflow = bkm_scale_by_power(&tmp, base, 6);
 1572|      0|            goto switch_break___0;
 1573|      0|case_71:
 1574|      0|            overflow = bkm_scale_by_power(&tmp, base, 3);
 1575|      0|            goto switch_break___0;
 1576|      0|case_107:
 1577|      0|            overflow = bkm_scale_by_power(&tmp, base, 1);
 1578|      0|            goto switch_break___0;
 1579|      0|case_77:
 1580|      0|            overflow = bkm_scale_by_power(&tmp, base, 2);
 1581|      0|            goto switch_break___0;
 1582|      0|case_80:
 1583|      0|            overflow = bkm_scale_by_power(&tmp, base, 5);
 1584|      0|            goto switch_break___0;
 1585|      0|case_84:
 1586|      0|            overflow = bkm_scale_by_power(&tmp, base, 4);
 1587|      0|            goto switch_break___0;
 1588|      0|case_119:
 1589|      0|            overflow = bkm_scale(&tmp, 2);
 1590|      0|            goto switch_break___0;
 1591|      0|case_89:
 1592|      0|            overflow = bkm_scale_by_power(&tmp, base, 8);
 1593|      0|            goto switch_break___0;
 1594|      0|case_90:
 1595|      0|            overflow = bkm_scale_by_power(&tmp, base, 7);
 1596|      0|            goto switch_break___0;
 1597|      0|switch_default:
 1598|      0|            *val = tmp;
 1599|      0|            return ((strtol_error)((unsigned int)err | 2U));
 1600|      0|switch_break___0:
 1601|      0|            err = (strtol_error)((unsigned int)err | (unsigned int)overflow);
 1602|      0|            *p += suffixes;
 1603|      0|            if (*(*p)) {
 1604|      0|                err = (strtol_error)((unsigned int)err | 2U);
 1605|      0|            }
 1606|      0|        }
 1607|      0|        *val = tmp;
 1608|      0|        return (err);
 1609|      0|    }
 1610|      0|}
 1611|       |strtol_error xstrtoul(char const *s, char **ptr, int strtol_base,
 1612|       |                      unsigned long *val, char const *valid_suffixes);
 1613|       |extern __attribute__((__nothrow__)) unsigned long(__attribute__((
 1614|       |            __nonnull__(1), __leaf__)) strtoul)(char const *__restrict __nptr,
 1615|       |                    char **__restrict __endptr, int __base);
 1616|       |static strtol_error bkm_scale___0(unsigned long *x, int scale_factor)
 1617|      0|{
 1618|       |
 1619|      0|    {
 1620|      0|        if (0xffffffffffffffffUL / (unsigned long)scale_factor < *x) {
 1621|      0|            *x = 0xffffffffffffffffUL;
 1622|      0|            return ((strtol_error)1);
 1623|      0|        }
 1624|      0|        *x *= (unsigned long)scale_factor;
 1625|      0|        return ((strtol_error)0);
 1626|      0|    }
 1627|      0|}
 1628|       |static strtol_error bkm_scale_by_power___0(unsigned long *x, int base,
 1629|       |        int power)
 1630|      0|{
 1631|      0|    strtol_error err;
 1632|      0|    strtol_error tmp;
 1633|      0|    int tmp___0;
 1634|       |
 1635|      0|    {
 1636|      0|        err = (strtol_error)0;
 1637|      0|        while (1) {
 1638|      0|            tmp___0 = power;
 1639|      0|            power--;
 1640|      0|            if (!tmp___0) {
 1641|      0|                goto while_break;
 1642|      0|            }
 1643|      0|            tmp = bkm_scale___0(x, base);
 1644|      0|            err = (strtol_error)((unsigned int)err | (unsigned int)tmp);
 1645|      0|        }
 1646|      0|while_break:
 1647|      0|        ;
 1648|      0|        return (err);
 1649|      0|    }
 1650|      0|}
 1651|       |strtol_error xstrtoul(char const *s, char **ptr, int strtol_base,
 1652|       |                      unsigned long *val, char const *valid_suffixes)
 1653|      0|{
 1654|      0|    char *t_ptr;
 1655|      0|    char **p;
 1656|      0|    unsigned long tmp;
 1657|      0|    strtol_error err;
 1658|      0|    char const *q;
 1659|      0|    unsigned char ch;
 1660|      0|    unsigned short const **tmp___0;
 1661|      0|    int *tmp___1;
 1662|      0|    char *tmp___2;
 1663|      0|    int *tmp___3;
 1664|      0|    int *tmp___4;
 1665|      0|    int base;
 1666|      0|    int suffixes;
 1667|      0|    strtol_error overflow;
 1668|      0|    char *tmp___5;
 1669|      0|    char *tmp___6;
 1670|       |
 1671|      0|    {
 1672|      0|        err = (strtol_error)0;
 1673|      0|        if (0 <= strtol_base) {
 1674|      0|            if (!(strtol_base <= 36)) {
 1675|      0|                __assert_fail("0 <= strtol_base && strtol_base <= 36",
 1676|      0|                              "/home/khheo/project/program-reduce/benchmark/"
 1677|      0|                              "coreutils-8.16/lib/xstrtol.c",
 1678|      0|                              96U, "xstrtoul");
 1679|      0|            }
 1680|      0|        }
 1681|      0|        else {
 1682|      0|            __assert_fail("0 <= strtol_base && strtol_base <= 36",
 1683|      0|                          "/home/khheo/project/program-reduce/benchmark/"
 1684|      0|                          "coreutils-8.16/lib/xstrtol.c",
 1685|      0|                          96U, "xstrtoul");
 1686|      0|        }
 1687|      0|        if (ptr) {
 1688|      0|            p = ptr;
 1689|      0|        }
 1690|      0|        else {
 1691|      0|            p = &t_ptr;
 1692|      0|        }
 1693|      0|        q = s;
 1694|      0|        ch = (unsigned char)*q;
 1695|      0|        while (1) {
 1696|      0|            tmp___0 = __ctype_b_loc();
 1697|      0|            if (!((int const) * (*tmp___0 + (int)ch) & 8192)) {
 1698|      0|                goto while_break;
 1699|      0|            }
 1700|      0|            q++;
 1701|      0|            ch = (unsigned char)*q;
 1702|      0|        }
 1703|      0|while_break:
 1704|      0|        ;
 1705|      0|        if ((int)ch == 45) {
 1706|      0|            return ((strtol_error)4);
 1707|      0|        }
 1708|      0|        tmp___1 = __errno_location();
 1709|      0|        *tmp___1 = 0;
 1710|      0|        tmp = strtoul(s, p, strtol_base);
 1711|      0|        if ((unsigned long)*p == (unsigned long)s) {
 1712|      0|            if (valid_suffixes) {
 1713|      0|                if (*(*p)) {
 1714|      0|                    tmp___2 = strchr(valid_suffixes, (int)*(*p));
 1715|      0|                    if (tmp___2) {
 1716|      0|                        tmp = 1UL;
 1717|      0|                    }
 1718|      0|                    else {
 1719|      0|                        return ((strtol_error)4);
 1720|      0|                    }
 1721|      0|                }
 1722|      0|                else {
 1723|      0|                    return ((strtol_error)4);
 1724|      0|                }
 1725|      0|            }
 1726|      0|            else {
 1727|      0|                return ((strtol_error)4);
 1728|      0|            }
 1729|      0|        }
 1730|      0|        else {
 1731|      0|            tmp___4 = __errno_location();
 1732|      0|            if (*tmp___4 != 0) {
 1733|      0|                tmp___3 = __errno_location();
 1734|      0|                if (*tmp___3 != 34) {
 1735|      0|                    return ((strtol_error)4);
 1736|      0|                }
 1737|      0|                err = (strtol_error)1;
 1738|      0|            }
 1739|      0|        }
 1740|      0|        if (!valid_suffixes) {
 1741|      0|            *val = tmp;
 1742|      0|            return (err);
 1743|      0|        }
 1744|      0|        if ((int)*(*p) != 0) {
 1745|      0|            base = 1024;
 1746|      0|            suffixes = 1;
 1747|      0|            tmp___5 = strchr(valid_suffixes, (int)*(*p));
 1748|      0|            if (!tmp___5) {
 1749|      0|                *val = tmp;
 1750|      0|                return ((strtol_error)((unsigned int)err | 2U));
 1751|      0|            }
 1752|      0|            tmp___6 = strchr(valid_suffixes, '0');
 1753|      0|            if (tmp___6) {
 1754|      0|                if ((int)*(*(p + 0) + 1) == 105) {
 1755|      0|                    goto case_105;
 1756|      0|                }
 1757|      0|                if ((int)*(*(p + 0) + 1) == 66) {
 1758|      0|                    goto case_66;
 1759|      0|                }
 1760|      0|                if ((int)*(*(p + 0) + 1) == 68) {
 1761|      0|                    goto case_66;
 1762|      0|                }
 1763|      0|                goto switch_break;
 1764|      0|case_105:
 1765|      0|                if ((int)*(*(p + 0) + 2) == 66) {
 1766|      0|                    suffixes += 2;
 1767|      0|                }
 1768|      0|                goto switch_break;
 1769|      0|case_66:
 1770|      0|                base = 1000;
 1771|      0|                suffixes++;
 1772|      0|                goto switch_break;
 1773|      0|switch_break:
 1774|      0|                ;
 1775|      0|            }
 1776|      0|            if ((int)*(*p) == 98) {
 1777|      0|                goto case_98;
 1778|      0|            }
 1779|      0|            if ((int)*(*p) == 66) {
 1780|      0|                goto case_66___0;
 1781|      0|            }
 1782|      0|            if ((int)*(*p) == 99) {
 1783|      0|                goto case_99;
 1784|      0|            }
 1785|      0|            if ((int)*(*p) == 69) {
 1786|      0|                goto case_69;
 1787|      0|            }
 1788|      0|            if ((int)*(*p) == 71) {
 1789|      0|                goto case_71;
 1790|      0|            }
 1791|      0|            if ((int)*(*p) == 103) {
 1792|      0|                goto case_71;
 1793|      0|            }
 1794|      0|            if ((int)*(*p) == 107) {
 1795|      0|                goto case_107;
 1796|      0|            }
 1797|      0|            if ((int)*(*p) == 75) {
 1798|      0|                goto case_107;
 1799|      0|            }
 1800|      0|            if ((int)*(*p) == 77) {
 1801|      0|                goto case_77;
 1802|      0|            }
 1803|      0|            if ((int)*(*p) == 109) {
 1804|      0|                goto case_77;
 1805|      0|            }
 1806|      0|            if ((int)*(*p) == 80) {
 1807|      0|                goto case_80;
 1808|      0|            }
 1809|      0|            if ((int)*(*p) == 84) {
 1810|      0|                goto case_84;
 1811|      0|            }
 1812|      0|            if ((int)*(*p) == 116) {
 1813|      0|                goto case_84;
 1814|      0|            }
 1815|      0|            if ((int)*(*p) == 119) {
 1816|      0|                goto case_119;
 1817|      0|            }
 1818|      0|            if ((int)*(*p) == 89) {
 1819|      0|                goto case_89;
 1820|      0|            }
 1821|      0|            if ((int)*(*p) == 90) {
 1822|      0|                goto case_90;
 1823|      0|            }
 1824|      0|            goto switch_default;
 1825|      0|case_98:
 1826|      0|            overflow = bkm_scale___0(&tmp, 512);
 1827|      0|            goto switch_break___0;
 1828|      0|case_66___0:
 1829|      0|            overflow = bkm_scale___0(&tmp, 1024);
 1830|      0|            goto switch_break___0;
 1831|      0|case_99:
 1832|      0|            overflow = (strtol_error)0;
 1833|      0|            goto switch_break___0;
 1834|      0|case_69:
 1835|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 6);
 1836|      0|            goto switch_break___0;
 1837|      0|case_71:
 1838|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 3);
 1839|      0|            goto switch_break___0;
 1840|      0|case_107:
 1841|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 1);
 1842|      0|            goto switch_break___0;
 1843|      0|case_77:
 1844|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 2);
 1845|      0|            goto switch_break___0;
 1846|      0|case_80:
 1847|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 5);
 1848|      0|            goto switch_break___0;
 1849|      0|case_84:
 1850|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 4);
 1851|      0|            goto switch_break___0;
 1852|      0|case_119:
 1853|      0|            overflow = bkm_scale___0(&tmp, 2);
 1854|      0|            goto switch_break___0;
 1855|      0|case_89:
 1856|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 8);
 1857|      0|            goto switch_break___0;
 1858|      0|case_90:
 1859|      0|            overflow = bkm_scale_by_power___0(&tmp, base, 7);
 1860|      0|            goto switch_break___0;
 1861|      0|switch_default:
 1862|      0|            *val = tmp;
 1863|      0|            return ((strtol_error)((unsigned int)err | 2U));
 1864|      0|switch_break___0:
 1865|      0|            err = (strtol_error)((unsigned int)err | (unsigned int)overflow);
 1866|      0|            *p += suffixes;
 1867|      0|            if (*(*p)) {
 1868|      0|                err = (strtol_error)((unsigned int)err | 2U);
 1869|      0|            }
 1870|      0|        }
 1871|      0|        *val = tmp;
 1872|      0|        return (err);
 1873|      0|    }
 1874|      0|}
 1875|       |extern __attribute__((__nothrow__)) long(__attribute__((
 1876|       |            __nonnull__(1), __leaf__)) strtol)(char const *__restrict __nptr,
 1877|       |                    char **__restrict __endptr, int __base);
 1878|       |__attribute__((__noreturn__)) void
 1879|       |xstrtol_fatal(enum strtol_error err, int opt_idx, char c,
 1880|       |              struct option const *long_options___2, char const *arg);
 1881|       |static void xstrtol_error(enum strtol_error err, int opt_idx, char c,
 1882|       |                          struct option const *long_options___2,
 1883|       |                          char const *arg, int exit_status)
 1884|      0|{
 1885|      0|    char const *hyphens;
 1886|      0|    char const *msgid;
 1887|      0|    char const *option;
 1888|      0|    char option_buffer[2];
 1889|      0|    char *tmp;
 1890|       |
 1891|      0|    {
 1892|      0|        hyphens = "--";
 1893|      0|        if ((unsigned int)err == 4U) {
 1894|      0|            goto case_4;
 1895|      0|        }
 1896|      0|        if ((unsigned int)err == 2U) {
 1897|      0|            goto case_2;
 1898|      0|        }
 1899|      0|        if ((unsigned int)err == 3U) {
 1900|      0|            goto case_2;
 1901|      0|        }
 1902|      0|        if ((unsigned int)err == 1U) {
 1903|      0|            goto case_1;
 1904|      0|        }
 1905|      0|        goto switch_default;
 1906|      0|switch_default:
 1907|      0|        abort();
 1908|      0|case_4:
 1909|      0|        msgid = "invalid %s%s argument \'%s\'";
 1910|      0|        goto switch_break;
 1911|      0|case_2:
 1912|      0|        msgid = "invalid suffix in %s%s argument \'%s\'";
 1913|      0|        goto switch_break;
 1914|      0|case_1:
 1915|      0|        msgid = "%s%s argument \'%s\' too large";
 1916|      0|        goto switch_break;
 1917|      0|switch_break:
 1918|      0|        ;
 1919|      0|        if (opt_idx < 0) {
 1920|      0|            hyphens -= opt_idx;
 1921|      0|            option_buffer[0] = c;
 1922|      0|            option_buffer[1] = (char)'\000';
 1923|      0|            option = (char const *)(option_buffer);
 1924|      0|        }
 1925|      0|        else {
 1926|      0|            option = (char const *)(long_options___2 + opt_idx)->name;
 1927|      0|        }
 1928|      0|        tmp = gettext(msgid);
 1929|      0|        error(exit_status, 0, (char const *)tmp, hyphens, option, arg);
 1930|      0|        return;
 1931|      0|    }
 1932|      0|}
 1933|       |__attribute__((__noreturn__)) void
 1934|       |xstrtol_fatal(enum strtol_error err, int opt_idx, char c,
 1935|       |              struct option const *long_options___2, char const *arg);
 1936|       |void xstrtol_fatal(enum strtol_error err, int opt_idx, char c,
 1937|       |                   struct option const *long_options___2, char const *arg)
 1938|      0|{
 1939|       |
 1940|      0|    {
 1941|      0|        xstrtol_error(err, opt_idx, c, long_options___2, arg, (int)exit_failure);
 1942|      0|        abort();
 1943|      0|    }
 1944|      0|}
 1945|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) ferror)(
 1946|       |    FILE *__stream);
 1947|       |int xnanosleep(double seconds);
 1948|       |int(__attribute__((__nonnull__(1))) rpl_nanosleep)(
 1949|       |    struct timespec const *requested_delay, struct timespec *remaining_delay);
 1950|       |int xnanosleep(double seconds)
 1951|      0|{
 1952|      0|    struct timespec ts_sleep;
 1953|      0|    struct timespec tmp;
 1954|      0|    int *tmp___0;
 1955|      0|    int tmp___1;
 1956|      0|    int *tmp___2;
 1957|      0|    int *tmp___3;
 1958|       |
 1959|      0|    {
 1960|      0|        tmp = dtotimespec(seconds);
 1961|      0|        ts_sleep = tmp;
 1962|      0|        while (1) {
 1963|      0|            tmp___0 = __errno_location();
 1964|      0|            *tmp___0 = 0;
 1965|      0|            tmp___1 = rpl_nanosleep((struct timespec const *)(&ts_sleep),
 1966|      0|                                    (struct timespec *)((void *)0));
 1967|      0|            if (tmp___1 == 0) {
 1968|      0|                goto while_break;
 1969|      0|            }
 1970|      0|            tmp___2 = __errno_location();
 1971|      0|            if (*tmp___2 != 4) {
 1972|      0|                tmp___3 = __errno_location();
 1973|      0|                if (*tmp___3 != 0) {
 1974|      0|                    return (-1);
 1975|      0|                }
 1976|      0|            }
 1977|      0|        }
 1978|      0|while_break:
 1979|      0|        ;
 1980|      0|        return (0);
 1981|      0|    }
 1982|      0|}
 1983|       |int memcoll0(char const *s1, size_t s1size, char const *s2, size_t s2size);
 1984|       |char *quotearg_n_style_mem(int n, enum quoting_style s, char const *arg,
 1985|       |                           size_t argsize);
 1986|       |int xmemcoll0(char const *s1, size_t s1size, char const *s2, size_t s2size);
 1987|       |static void collate_error(int collation_errno, char const *s1, size_t s1len,
 1988|       |                          char const *s2, size_t s2len)
 1989|      0|{
 1990|      0|    char *tmp;
 1991|      0|    char *tmp___0;
 1992|      0|    char *tmp___1;
 1993|      0|    char *tmp___2;
 1994|      0|    char *tmp___3;
 1995|       |
 1996|      0|    {
 1997|      0|        tmp = gettext("string comparison failed");
 1998|      0|        error(0, collation_errno, (char const *)tmp);
 1999|      0|        tmp___0 = gettext("Set LC_ALL=\'C\' to work around the problem.");
 2000|      0|        error(0, 0, (char const *)tmp___0);
 2001|      0|        tmp___1 = quotearg_n_style_mem(1, (enum quoting_style)6, s2, s2len);
 2002|      0|        tmp___2 = quotearg_n_style_mem(0, (enum quoting_style)6, s1, s1len);
 2003|      0|        tmp___3 = gettext("The strings compared were %s and %s.");
 2004|      0|        error((int)exit_failure, 0, (char const *)tmp___3, tmp___2, tmp___1);
 2005|      0|        return;
 2006|      0|    }
 2007|      0|}
 2008|       |int xmemcoll0(char const *s1, size_t s1size, char const *s2, size_t s2size)
 2009|   215k|{
 2010|   215k|    int diff;
 2011|   215k|    int tmp;
 2012|   215k|    int collation_errno;
 2013|   215k|    int *tmp___0;
 2014|       |
 2015|   215k|    {
 2016|   215k|        tmp = memcoll0(s1, s1size, s2, s2size);
 2017|   215k|        diff = tmp;
 2018|   215k|        tmp___0 = __errno_location();
 2019|   215k|        collation_errno = *tmp___0;
 2020|   215k|        if (collation_errno) {
 2021|      0|            collate_error(collation_errno, s1, s1size - 1UL, s2, s2size - 1UL);
 2022|      0|        }
 2023|   215k|        return (diff);
 2024|   215k|    }
 2025|   215k|}
 2026|       |void *xcalloc(size_t n, size_t s)
 2027|       |__attribute__((__malloc__, __alloc_size__(1, 2)));
 2028|       |void *xmemdup(void const *p, size_t s)
 2029|       |__attribute__((__malloc__, __alloc_size__(2)));
 2030|       |__inline static void *x2nrealloc(void *p, size_t *pn, size_t s)
 2031|      2|{
 2032|      2|    size_t n;
 2033|      2|    void *tmp;
 2034|       |
 2035|      2|    {
 2036|      2|        n = *pn;
 2037|      2|        if (!p) {
 2038|      2|            if (!n) {
 2039|      2|                n = 128UL / s;
 2040|      2|                n += (size_t)(!n);
 2041|      2|            }
 2042|      2|        }
 2043|      0|        else {
 2044|      0|            if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
 2045|      0|                xalloc_die();
 2046|      0|            }
 2047|      0|            n += (n + 1UL) / 2UL;
 2048|      0|        }
 2049|      2|        *pn = n;
 2050|      2|        tmp = xrealloc(p, n * s);
 2051|      2|        return (tmp);
 2052|      2|    }
 2053|      2|}
 2054|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__)) calloc)(
 2055|       |    size_t __nmemb, size_t __size) __attribute__((__malloc__));
 2056|       |extern __attribute__((__nothrow__)) void *(__attribute__((
 2057|       |            __nonnull__(1), __leaf__)) memset)(void *__s, int __c, size_t __n);
 2058|       |void *xmalloc(size_t n) __attribute__((__malloc__, __alloc_size__(1)));
 2059|       |void *xmalloc(size_t n)
 2060|     34|{
 2061|     34|    void *p;
 2062|     34|    void *tmp;
 2063|       |
 2064|     34|    {
 2065|     34|        tmp = malloc(n);
 2066|     34|        p = tmp;
 2067|     34|        if (!p) {
 2068|      0|            if (n != 0UL) {
 2069|      0|                xalloc_die();
 2070|      0|            }
 2071|      0|        }
 2072|     34|        return (p);
 2073|     34|    }
 2074|     34|}
 2075|       |void *xrealloc(void *p, size_t n) __attribute__((__alloc_size__(2)));
 2076|       |void *xrealloc(void *p, size_t n)
 2077|      2|{
 2078|       |
 2079|      2|    {
 2080|      2|        if (!n) {
 2081|      0|            if (p) {
 2082|      0|                free(p);
 2083|      0|                return ((void *)0);
 2084|      0|            }
 2085|      0|        }
 2086|      2|        p = realloc(p, n);
 2087|      2|        if (!p) {
 2088|      0|            if (n) {
 2089|      0|                xalloc_die();
 2090|      0|            }
 2091|      0|        }
 2092|      2|        return (p);
 2093|      2|    }
 2094|      2|}
 2095|       |void *xcalloc(size_t n, size_t s)
 2096|       |__attribute__((__malloc__, __alloc_size__(1, 2)));
 2097|       |void *xcalloc(size_t n, size_t s)
 2098|      0|{
 2099|      0|    void *p;
 2100|       |
 2101|      0|    {
 2102|      0|        p = calloc(n, s);
 2103|      0|        if (!p) {
 2104|      0|            xalloc_die();
 2105|      0|        }
 2106|      0|        return (p);
 2107|      0|    }
 2108|      0|}
 2109|       |void *xmemdup(void const *p, size_t s)
 2110|       |__attribute__((__malloc__, __alloc_size__(2)));
 2111|       |void *xmemdup(void const *p, size_t s)
 2112|      2|{
 2113|      2|    void *tmp;
 2114|      2|    void *tmp___0;
 2115|       |
 2116|      2|    {
 2117|      2|        tmp = xmalloc(s);
 2118|      2|        tmp___0 = memcpy(tmp, p, s);
 2119|      2|        return (tmp___0);
 2120|      2|    }
 2121|      2|}
 2122|       |__attribute__((__noreturn__)) void xalloc_die(void);
 2123|       |void xalloc_die(void)
 2124|      0|{
 2125|      0|    char *tmp;
 2126|       |
 2127|      0|    {
 2128|      0|        tmp = gettext("memory exhausted");
 2129|      0|        error((int)exit_failure, 0, "%s", tmp);
 2130|      0|        abort();
 2131|      0|    }
 2132|      0|}
 2133|       |extern __attribute__((__nothrow__)) int(__attribute__((
 2134|       |        __nonnull__(1, 2), __leaf__)) strcmp)(char const *__s1, char const *__s2)
 2135|       |__attribute__((__pure__));
 2136|       |extern __attribute__((__nothrow__)) int(
 2137|       |    __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void));
 2138|       |extern __pid_t waitpid(__pid_t __pid, int *__stat_loc, int __options);
 2139|       |extern int printf(char const *__restrict __format, ...);
 2140|       |char const version_etc_copyright[47];
 2141|       |void version_etc_arn(FILE *stream, char const *command_name,
 2142|       |                     char const *package, char const *version,
 2143|       |                     char const *const *authors, size_t n_authors);
 2144|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 2145|       |                    char const *version, va_list authors);
 2146|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 2147|       |                 char const *version, ...) __attribute__((__sentinel__));
 2148|       |void version_etc_arn(FILE *stream, char const *command_name,
 2149|       |                     char const *package, char const *version,
 2150|       |                     char const *const *authors, size_t n_authors)
 2151|      0|{
 2152|      0|    char *tmp;
 2153|      0|    char *tmp___0;
 2154|      0|    char *tmp___1;
 2155|      0|    char *tmp___2;
 2156|      0|    char *tmp___3;
 2157|      0|    char *tmp___4;
 2158|      0|    char *tmp___5;
 2159|      0|    char *tmp___6;
 2160|      0|    char *tmp___7;
 2161|      0|    char *tmp___8;
 2162|      0|    char *tmp___9;
 2163|      0|    char *tmp___10;
 2164|       |
 2165|      0|    {
 2166|      0|        if (command_name) {
 2167|      0|            fprintf(stream, "%s (%s) %s\n", command_name, package, version);
 2168|      0|        }
 2169|      0|        else {
 2170|      0|            fprintf(stream, "%s %s\n", package, version);
 2171|      0|        }
 2172|      0|        tmp = gettext("(C)");
 2173|      0|        fprintf(stream, version_etc_copyright, tmp, 2012);
 2174|      0|        tmp___0 =
 2175|      0|            gettext("\nLicense GPLv3+: GNU GPL version 3 or later "
 2176|      0|                    "<http://gnu.org/licenses/gpl.html>.\nThis is free software: "
 2177|      0|                    "you are free to change and redistribute it.\nThere is NO "
 2178|      0|                    "WARRANTY, to the extent permitted by law.\n\n");
 2179|      0|        fputs_unlocked((char const *)tmp___0, stream);
 2180|      0|        if (n_authors == 0UL) {
 2181|      0|            goto case_0;
 2182|      0|        }
 2183|      0|        if (n_authors == 1UL) {
 2184|      0|            goto case_1;
 2185|      0|        }
 2186|      0|        if (n_authors == 2UL) {
 2187|      0|            goto case_2;
 2188|      0|        }
 2189|      0|        if (n_authors == 3UL) {
 2190|      0|            goto case_3;
 2191|      0|        }
 2192|      0|        if (n_authors == 4UL) {
 2193|      0|            goto case_4;
 2194|      0|        }
 2195|      0|        if (n_authors == 5UL) {
 2196|      0|            goto case_5;
 2197|      0|        }
 2198|      0|        if (n_authors == 6UL) {
 2199|      0|            goto case_6;
 2200|      0|        }
 2201|      0|        if (n_authors == 7UL) {
 2202|      0|            goto case_7;
 2203|      0|        }
 2204|      0|        if (n_authors == 8UL) {
 2205|      0|            goto case_8;
 2206|      0|        }
 2207|      0|        if (n_authors == 9UL) {
 2208|      0|            goto case_9;
 2209|      0|        }
 2210|      0|        goto switch_default;
 2211|      0|case_0:
 2212|      0|        abort();
 2213|      0|case_1:
 2214|      0|        tmp___1 = gettext("Written by %s.\n");
 2215|      0|        fprintf(stream, (char const *)tmp___1, *(authors + 0));
 2216|      0|        goto switch_break;
 2217|      0|case_2:
 2218|      0|        tmp___2 = gettext("Written by %s and %s.\n");
 2219|      0|        fprintf(stream, (char const *)tmp___2, *(authors + 0), *(authors + 1));
 2220|      0|        goto switch_break;
 2221|      0|case_3:
 2222|      0|        tmp___3 = gettext("Written by %s, %s, and %s.\n");
 2223|      0|        fprintf(stream, (char const *)tmp___3, *(authors + 0), *(authors + 1),
 2224|      0|                *(authors + 2));
 2225|      0|        goto switch_break;
 2226|      0|case_4:
 2227|      0|        tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
 2228|      0|        fprintf(stream, (char const *)tmp___4, *(authors + 0), *(authors + 1),
 2229|      0|                *(authors + 2), *(authors + 3));
 2230|      0|        goto switch_break;
 2231|      0|case_5:
 2232|      0|        tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
 2233|      0|        fprintf(stream, (char const *)tmp___5, *(authors + 0), *(authors + 1),
 2234|      0|                *(authors + 2), *(authors + 3), *(authors + 4));
 2235|      0|        goto switch_break;
 2236|      0|case_6:
 2237|      0|        tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
 2238|      0|        fprintf(stream, (char const *)tmp___6, *(authors + 0), *(authors + 1),
 2239|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5));
 2240|      0|        goto switch_break;
 2241|      0|case_7:
 2242|      0|        tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
 2243|      0|        fprintf(stream, (char const *)tmp___7, *(authors + 0), *(authors + 1),
 2244|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 2245|      0|                *(authors + 6));
 2246|      0|        goto switch_break;
 2247|      0|case_8:
 2248|      0|        tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
 2249|      0|        fprintf(stream, (char const *)tmp___8, *(authors + 0), *(authors + 1),
 2250|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 2251|      0|                *(authors + 6), *(authors + 7));
 2252|      0|        goto switch_break;
 2253|      0|case_9:
 2254|      0|        tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
 2255|      0|        fprintf(stream, (char const *)tmp___9, *(authors + 0), *(authors + 1),
 2256|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 2257|      0|                *(authors + 6), *(authors + 7), *(authors + 8));
 2258|      0|        goto switch_break;
 2259|      0|switch_default:
 2260|      0|        tmp___10 = gettext(
 2261|      0|                       "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
 2262|      0|        fprintf(stream, (char const *)tmp___10, *(authors + 0), *(authors + 1),
 2263|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 2264|      0|                *(authors + 6), *(authors + 7), *(authors + 8));
 2265|      0|        goto switch_break;
 2266|      0|switch_break:
 2267|      0|        ;
 2268|      0|        return;
 2269|      0|    }
 2270|      0|}
 2271|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 2272|       |                    char const *version, va_list authors)
 2273|      0|{
 2274|      0|    size_t n_authors;
 2275|      0|    char const *authtab[10];
 2276|      0|    char const *tmp;
 2277|       |
 2278|      0|    {
 2279|      0|        n_authors = (size_t)0;
 2280|      0|        while (1) {
 2281|       |
 2282|      0|            if (n_authors < 10UL) {
 2283|      0|                tmp = __builtin_va_arg(authors, char const *);
 2284|      0|                authtab[n_authors] = tmp;
 2285|      0|                if (!((unsigned long)tmp != (unsigned long)((void *)0))) {
 2286|      0|                    goto while_break;
 2287|      0|                }
 2288|      0|            }
 2289|      0|            else {
 2290|      0|                goto while_break;
 2291|      0|            }
 2292|      0|            n_authors++;
 2293|      0|        }
 2294|      0|while_break:
 2295|      0|        version_etc_arn(stream, command_name, package, version,
 2296|      0|                        (char const *const *)(authtab), n_authors);
 2297|      0|        return;
 2298|      0|    }
 2299|      0|}
 2300|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 2301|       |                 char const *version, ...) __attribute__((__sentinel__));
 2302|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 2303|       |                 char const *version, ...)
 2304|      0|{
 2305|      0|    va_list authors;
 2306|       |
 2307|      0|    {
 2308|      0|        __builtin_va_start(authors, version);
 2309|      0|        version_etc_va(stream, command_name, package, version, authors);
 2310|      0|        __builtin_va_end(authors);
 2311|      0|        return;
 2312|      0|    }
 2313|      0|}
 2314|       |char const version_etc_copyright[47] = {
 2315|       |    (char const)'C', (char const)'o', (char const)'p',   (char const)'y',
 2316|       |    (char const)'r', (char const)'i', (char const)'g',   (char const)'h',
 2317|       |    (char const)'t', (char const)' ', (char const)'%',   (char const)'s',
 2318|       |    (char const)' ', (char const)'%', (char const)'d',   (char const)' ',
 2319|       |    (char const)'F', (char const)'r', (char const)'e',   (char const)'e',
 2320|       |    (char const)' ', (char const)'S', (char const)'o',   (char const)'f',
 2321|       |    (char const)'t', (char const)'w', (char const)'a',   (char const)'r',
 2322|       |    (char const)'e', (char const)' ', (char const)'F',   (char const)'o',
 2323|       |    (char const)'u', (char const)'n', (char const)'d',   (char const)'a',
 2324|       |    (char const)'t', (char const)'i', (char const)'o',   (char const)'n',
 2325|       |    (char const)',', (char const)' ', (char const)'I',   (char const)'n',
 2326|       |    (char const)'c', (char const)'.', (char const)'\000'
 2327|       |};
 2328|       |extern __attribute__((__nothrow__)) char *(
 2329|       |    __attribute__((__leaf__)) nl_langinfo)(nl_item __item);
 2330|       |char *(__attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i,
 2331|       |        char *buf___1);
 2332|       |char const *locale_charset(void);
 2333|       |#pragma GCC diagnostic ignored "-Wtype-limits"
 2334|       |char *(__attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i,
 2335|       |        char *buf___1)
 2336|      0|{
 2337|      0|    char *p;
 2338|       |
 2339|      0|    {
 2340|      0|        p = buf___1 + ((sizeof(uintmax_t) * 8UL) * 146UL + 484UL) / 485UL;
 2341|      0|        *p = (char)0;
 2342|      0|        if (i < 0UL) {
 2343|      0|            while (1) {
 2344|      0|                p--;
 2345|      0|                *p = (char)(48UL - i % 10UL);
 2346|      0|                i /= 10UL;
 2347|      0|                if (!(i != 0UL)) {
 2348|      0|                    goto while_break;
 2349|      0|                }
 2350|      0|            }
 2351|      0|while_break:
 2352|      0|            p--;
 2353|      0|            *p = (char)'-';
 2354|      0|        }
 2355|      0|        else {
 2356|      0|            while (1) {
 2357|      0|                p--;
 2358|      0|                *p = (char)(48UL + i % 10UL);
 2359|      0|                i /= 10UL;
 2360|      0|                if (!(i != 0UL)) {
 2361|      0|                    goto while_break___0;
 2362|      0|                }
 2363|      0|            }
 2364|      0|while_break___0:
 2365|      0|            ;
 2366|      0|        }
 2367|      0|        return (p);
 2368|      0|    }
 2369|      0|}
 2370|       |#pragma GCC diagnostic ignored "-Wtype-limits"
 2371|       |char *(__attribute__((__warn_unused_result__)) uinttostr)(unsigned int i,
 2372|       |        char *buf___1);
 2373|       |char *(__attribute__((__warn_unused_result__)) uinttostr)(unsigned int i,
 2374|       |        char *buf___1)
 2375|      0|{
 2376|      0|    char *p;
 2377|       |
 2378|      0|    {
 2379|      0|        p = buf___1 + ((sizeof(unsigned int) * 8UL) * 146UL + 484UL) / 485UL;
 2380|      0|        *p = (char)0;
 2381|      0|        if (i < 0U) {
 2382|      0|            while (1) {
 2383|      0|                p--;
 2384|      0|                *p = (char)(48U - i % 10U);
 2385|      0|                i /= 10U;
 2386|      0|                if (!(i != 0U)) {
 2387|      0|                    goto while_break;
 2388|      0|                }
 2389|      0|            }
 2390|      0|while_break:
 2391|      0|            p--;
 2392|      0|            *p = (char)'-';
 2393|      0|        }
 2394|      0|        else {
 2395|      0|            while (1) {
 2396|      0|                p--;
 2397|      0|                *p = (char)(48U + i % 10U);
 2398|      0|                i /= 10U;
 2399|      0|                if (!(i != 0U)) {
 2400|      0|                    goto while_break___0;
 2401|      0|                }
 2402|      0|            }
 2403|      0|while_break___0:
 2404|      0|            ;
 2405|      0|        }
 2406|      0|        return (p);
 2407|      0|    }
 2408|      0|}
 2409|       |extern __attribute__((__nothrow__))
 2410|       |size_t(__attribute__((__leaf__)) __ctype_get_mb_cur_max)(void);
 2411|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) mbsinit)(
 2412|       |    mbstate_t const *__ps) __attribute__((__pure__));
 2413|       |extern __attribute__((__nothrow__)) size_t(__attribute__((__leaf__)) mbrtowc)(
 2414|       |    wchar_t *__restrict __pwc, char const *__restrict __s, size_t __n,
 2415|       |    mbstate_t *__restrict __p);
 2416|       |unsigned int const is_basic_table[8];
 2417|       |__inline static _Bool is_basic(char c)
 2418|      0|{
 2419|       |
 2420|      0|    {
 2421|      0|        return ((_Bool)((is_basic_table[(int)((unsigned char)c) >> 5] >>
 2422|      0|                         ((int)((unsigned char)c) & 31)) &
 2423|      0|                        1U));
 2424|      0|    }
 2425|      0|}
 2426|       |#pragma weak pthread_key_create
 2427|       |#pragma weak pthread_getspecific
 2428|       |#pragma weak pthread_setspecific
 2429|       |#pragma weak pthread_key_delete
 2430|       |#pragma weak pthread_self
 2431|       |#pragma weak pthread_cancel
 2432|       |extern int(__attribute__((__nonnull__(1))) open)(char const *__file,
 2433|       |        int __oflag, ...);
 2434|       |int __attribute__((__pure__)) strnumcmp(char const *a, char const *b,
 2435|       |                                        int decimal_point___0,
 2436|       |                                        int thousands_sep___0);
 2437|       |__inline static int __attribute__((__pure__))
 2438|       |fraccompare(char const *a, char const *b, char decimal_point___0)
 2439|      0|{
 2440|      0|    char const *tmp;
 2441|      0|    char const *tmp___0;
 2442|       |
 2443|      0|    {
 2444|      0|        if ((int const) * a == (int const)decimal_point___0) {
 2445|      0|            if ((int const) * b == (int const)decimal_point___0) {
 2446|      0|                while (1) {
 2447|      0|                    a++;
 2448|      0|                    b++;
 2449|      0|                    if (!((int const) * a == (int const) * b)) {
 2450|      0|                        goto while_break;
 2451|      0|                    }
 2452|      0|                    if (!((unsigned int)*a - 48U <= 9U)) {
 2453|      0|                        return ((int __attribute__((__pure__)))0);
 2454|      0|                    }
 2455|      0|                }
 2456|      0|while_break:
 2457|      0|                ;
 2458|      0|                if ((unsigned int)*a - 48U <= 9U) {
 2459|      0|                    if ((unsigned int)*b - 48U <= 9U) {
 2460|      0|                        return ((int __attribute__((__pure__)))((int const) * a -
 2461|      0|                                                                (int const) * b));
 2462|      0|                    }
 2463|      0|                }
 2464|      0|                if ((unsigned int)*a - 48U <= 9U) {
 2465|      0|                    goto a_trailing_nonzero;
 2466|      0|                }
 2467|      0|                if ((unsigned int)*b - 48U <= 9U) {
 2468|      0|                    goto b_trailing_nonzero;
 2469|      0|                }
 2470|      0|                return ((int __attribute__((__pure__)))0);
 2471|      0|            }
 2472|      0|            else {
 2473|      0|                goto _L;
 2474|      0|            }
 2475|      0|        }
 2476|      0|        else {
 2477|      0|_L:
 2478|      0|            tmp___0 = a;
 2479|      0|            a++;
 2480|      0|            if ((int const) * tmp___0 == (int const)decimal_point___0) {
 2481|      0|a_trailing_nonzero:
 2482|      0|                while (1) {
 2483|       |
 2484|      0|                    if (!((int const) * a == 48)) {
 2485|      0|                        goto while_break___0;
 2486|      0|                    }
 2487|      0|                    a++;
 2488|      0|                }
 2489|      0|while_break___0:
 2490|      0|                ;
 2491|      0|                return ((int __attribute__((__pure__)))((unsigned int)*a - 48U <= 9U));
 2492|      0|            }
 2493|      0|            else {
 2494|      0|                tmp = b;
 2495|      0|                b++;
 2496|      0|                if ((int const) * tmp == (int const)decimal_point___0) {
 2497|      0|b_trailing_nonzero:
 2498|      0|                    while (1) {
 2499|       |
 2500|      0|                        if (!((int const) * b == 48)) {
 2501|      0|                            goto while_break___1;
 2502|      0|                        }
 2503|      0|                        b++;
 2504|      0|                    }
 2505|      0|while_break___1:
 2506|      0|                    ;
 2507|      0|                    return (
 2508|      0|                               (int __attribute__((__pure__)))(-((unsigned int)*b - 48U <= 9U)));
 2509|      0|                }
 2510|      0|            }
 2511|      0|        }
 2512|      0|        return ((int __attribute__((__pure__)))0);
 2513|      0|    }
 2514|      0|}
 2515|       |__inline static int __attribute__((__pure__))
 2516|       |numcompare(char const *a, char const *b, int decimal_point___0,
 2517|       |           int thousands_sep___0)
 2518|    231|{
 2519|    231|    unsigned char tmpa;
 2520|    231|    unsigned char tmpb;
 2521|    231|    int tmp;
 2522|    231|    size_t log_a;
 2523|    231|    size_t log_b;
 2524|    231|    int __attribute__((__pure__)) tmp___0;
 2525|    231|    int tmp___1;
 2526|    231|    int __attribute__((__pure__)) tmp___2;
 2527|    231|    int tmp___3;
 2528|       |
 2529|    231|    {
 2530|    231|        tmpa = (unsigned char)*a;
 2531|    231|        tmpb = (unsigned char)*b;
 2532|    231|        if ((int)tmpa == 45) {
 2533|     73|            while (1) {
 2534|     73|                a++;
 2535|     73|                tmpa = (unsigned char)*a;
 2536|     73|                if (!((int)tmpa == 48)) {
 2537|     73|                    if (!((int)tmpa == thousands_sep___0)) {
 2538|     73|                        goto while_break;
 2539|     73|                    }
 2540|     73|                }
 2541|     73|            }
 2542|     73|while_break:
 2543|     73|            ;
 2544|     73|            if ((int)tmpb != 45) {
 2545|     16|                if ((int)tmpa == decimal_point___0) {
 2546|      0|                    while (1) {
 2547|      0|                        a++;
 2548|      0|                        tmpa = (unsigned char)*a;
 2549|      0|                        if (!((int)tmpa == 48)) {
 2550|      0|                            goto while_break___0;
 2551|      0|                        }
 2552|      0|                    }
 2553|      0|while_break___0:
 2554|      0|                    ;
 2555|      0|                }
 2556|     16|                if ((unsigned int)tmpa - 48U <= 9U) {
 2557|     16|                    return ((int __attribute__((__pure__))) - 1);
 2558|     16|                }
 2559|      0|                while (1) {
 2560|       |
 2561|      0|                    if (!((int)tmpb == 48)) {
 2562|      0|                        if (!((int)tmpb == thousands_sep___0)) {
 2563|      0|                            goto while_break___1;
 2564|      0|                        }
 2565|      0|                    }
 2566|      0|                    b++;
 2567|      0|                    tmpb = (unsigned char)*b;
 2568|      0|                }
 2569|      0|while_break___1:
 2570|      0|                ;
 2571|      0|                if ((int)tmpb == decimal_point___0) {
 2572|      0|                    while (1) {
 2573|      0|                        b++;
 2574|      0|                        tmpb = (unsigned char)*b;
 2575|      0|                        if (!((int)tmpb == 48)) {
 2576|      0|                            goto while_break___2;
 2577|      0|                        }
 2578|      0|                    }
 2579|      0|while_break___2:
 2580|      0|                    ;
 2581|      0|                }
 2582|      0|                return (
 2583|      0|                           (int __attribute__((__pure__)))(-((unsigned int)tmpb - 48U <= 9U)));
 2584|      0|            }
 2585|     57|            while (1) {
 2586|     57|                b++;
 2587|     57|                tmpb = (unsigned char)*b;
 2588|     57|                if (!((int)tmpb == 48)) {
 2589|     57|                    if (!((int)tmpb == thousands_sep___0)) {
 2590|     57|                        goto while_break___3;
 2591|     57|                    }
 2592|     57|                }
 2593|     57|            }
 2594|     57|while_break___3:
 2595|     57|            ;
 2596|     82|            while (1) {
 2597|       |
 2598|     82|                if ((int)tmpa == (int)tmpb) {
 2599|     25|                    if (!((unsigned int)tmpa - 48U <= 9U)) {
 2600|      0|                        goto while_break___4;
 2601|      0|                    }
 2602|     25|                }
 2603|     57|                else {
 2604|     57|                    goto while_break___4;
 2605|     57|                }
 2606|     25|                while (1) {
 2607|     25|                    a++;
 2608|     25|                    tmpa = (unsigned char)*a;
 2609|     25|                    if (!((int)tmpa == thousands_sep___0)) {
 2610|     25|                        goto while_break___5;
 2611|     25|                    }
 2612|     25|                }
 2613|     25|while_break___5:
 2614|     25|                ;
 2615|     25|                while (1) {
 2616|     25|                    b++;
 2617|     25|                    tmpb = (unsigned char)*b;
 2618|     25|                    if (!((int)tmpb == thousands_sep___0)) {
 2619|     25|                        goto while_break___6;
 2620|     25|                    }
 2621|     25|                }
 2622|     25|while_break___6:
 2623|     25|                ;
 2624|     25|            }
 2625|     57|while_break___4:
 2626|     57|            ;
 2627|     57|            if ((int)tmpa == decimal_point___0) {
 2628|      0|                if (!((unsigned int)tmpb - 48U <= 9U)) {
 2629|      0|                    tmp___0 = fraccompare(b, a, (char)decimal_point___0);
 2630|      0|                    return (tmp___0);
 2631|      0|                }
 2632|      0|                else {
 2633|      0|                    goto _L;
 2634|      0|                }
 2635|      0|            }
 2636|     57|            else {
 2637|     57|_L:
 2638|     57|                if ((int)tmpb == decimal_point___0) {
 2639|      0|                    if (!((unsigned int)tmpa - 48U <= 9U)) {
 2640|      0|                        tmp___0 = fraccompare(b, a, (char)decimal_point___0);
 2641|      0|                        return (tmp___0);
 2642|      0|                    }
 2643|      0|                }
 2644|     57|            }
 2645|     57|            tmp = (int)tmpb - (int)tmpa;
 2646|     57|            log_a = (size_t)0;
 2647|    312|            while (1) {
 2648|       |
 2649|    312|                if (!((unsigned int)tmpa - 48U <= 9U)) {
 2650|     57|                    goto while_break___7;
 2651|     57|                }
 2652|    255|                while (1) {
 2653|    255|                    a++;
 2654|    255|                    tmpa = (unsigned char)*a;
 2655|    255|                    if (!((int)tmpa == thousands_sep___0)) {
 2656|    255|                        goto while_break___8;
 2657|    255|                    }
 2658|    255|                }
 2659|    255|while_break___8:
 2660|    255|                log_a++;
 2661|    255|            }
 2662|     57|while_break___7:
 2663|     57|            log_b = (size_t)0;
 2664|    304|            while (1) {
 2665|       |
 2666|    304|                if (!((unsigned int)tmpb - 48U <= 9U)) {
 2667|     57|                    goto while_break___9;
 2668|     57|                }
 2669|    247|                while (1) {
 2670|    247|                    b++;
 2671|    247|                    tmpb = (unsigned char)*b;
 2672|    247|                    if (!((int)tmpb == thousands_sep___0)) {
 2673|    247|                        goto while_break___10;
 2674|    247|                    }
 2675|    247|                }
 2676|    247|while_break___10:
 2677|    247|                log_b++;
 2678|    247|            }
 2679|     57|while_break___9:
 2680|     57|            ;
 2681|     57|            if (log_a != log_b) {
 2682|      8|                if (log_a < log_b) {
 2683|      0|                    tmp___1 = 1;
 2684|      0|                }
 2685|      8|                else {
 2686|      8|                    tmp___1 = -1;
 2687|      8|                }
 2688|      8|                return ((int __attribute__((__pure__)))tmp___1);
 2689|      8|            }
 2690|     49|            if (!log_a) {
 2691|      0|                return ((int __attribute__((__pure__)))0);
 2692|      0|            }
 2693|     49|            return ((int __attribute__((__pure__)))tmp);
 2694|     49|        }
 2695|    158|        else {
 2696|    158|            if ((int)tmpb == 45) {
 2697|     19|                while (1) {
 2698|     19|                    b++;
 2699|     19|                    tmpb = (unsigned char)*b;
 2700|     19|                    if (!((int)tmpb == 48)) {
 2701|     19|                        if (!((int)tmpb == thousands_sep___0)) {
 2702|     19|                            goto while_break___11;
 2703|     19|                        }
 2704|     19|                    }
 2705|     19|                }
 2706|     19|while_break___11:
 2707|     19|                ;
 2708|     19|                if ((int)tmpb == decimal_point___0) {
 2709|      0|                    while (1) {
 2710|      0|                        b++;
 2711|      0|                        tmpb = (unsigned char)*b;
 2712|      0|                        if (!((int)tmpb == 48)) {
 2713|      0|                            goto while_break___12;
 2714|      0|                        }
 2715|      0|                    }
 2716|      0|while_break___12:
 2717|      0|                    ;
 2718|      0|                }
 2719|     19|                if ((unsigned int)tmpb - 48U <= 9U) {
 2720|     19|                    return ((int __attribute__((__pure__)))1);
 2721|     19|                }
 2722|      0|                while (1) {
 2723|       |
 2724|      0|                    if (!((int)tmpa == 48)) {
 2725|      0|                        if (!((int)tmpa == thousands_sep___0)) {
 2726|      0|                            goto while_break___13;
 2727|      0|                        }
 2728|      0|                    }
 2729|      0|                    a++;
 2730|      0|                    tmpa = (unsigned char)*a;
 2731|      0|                }
 2732|      0|while_break___13:
 2733|      0|                ;
 2734|      0|                if ((int)tmpa == decimal_point___0) {
 2735|      0|                    while (1) {
 2736|      0|                        a++;
 2737|      0|                        tmpa = (unsigned char)*a;
 2738|      0|                        if (!((int)tmpa == 48)) {
 2739|      0|                            goto while_break___14;
 2740|      0|                        }
 2741|      0|                    }
 2742|      0|while_break___14:
 2743|      0|                    ;
 2744|      0|                }
 2745|      0|                return (
 2746|      0|                           (int __attribute__((__pure__)))((unsigned int)tmpa - 48U <= 9U));
 2747|      0|            }
 2748|    139|            else {
 2749|    139|                while (1) {
 2750|       |
 2751|    139|                    if (!((int)tmpa == 48)) {
 2752|    139|                        if (!((int)tmpa == thousands_sep___0)) {
 2753|    139|                            goto while_break___15;
 2754|    139|                        }
 2755|    139|                    }
 2756|      0|                    a++;
 2757|      0|                    tmpa = (unsigned char)*a;
 2758|      0|                }
 2759|    139|while_break___15:
 2760|    139|                ;
 2761|    139|                while (1) {
 2762|       |
 2763|    139|                    if (!((int)tmpb == 48)) {
 2764|    139|                        if (!((int)tmpb == thousands_sep___0)) {
 2765|    139|                            goto while_break___16;
 2766|    139|                        }
 2767|    139|                    }
 2768|      0|                    b++;
 2769|      0|                    tmpb = (unsigned char)*b;
 2770|      0|                }
 2771|    139|while_break___16:
 2772|    139|                ;
 2773|    165|                while (1) {
 2774|       |
 2775|    165|                    if ((int)tmpa == (int)tmpb) {
 2776|     26|                        if (!((unsigned int)tmpa - 48U <= 9U)) {
 2777|      0|                            goto while_break___17;
 2778|      0|                        }
 2779|     26|                    }
 2780|    139|                    else {
 2781|    139|                        goto while_break___17;
 2782|    139|                    }
 2783|     26|                    while (1) {
 2784|     26|                        a++;
 2785|     26|                        tmpa = (unsigned char)*a;
 2786|     26|                        if (!((int)tmpa == thousands_sep___0)) {
 2787|     26|                            goto while_break___18;
 2788|     26|                        }
 2789|     26|                    }
 2790|     26|while_break___18:
 2791|     26|                    ;
 2792|     26|                    while (1) {
 2793|     26|                        b++;
 2794|     26|                        tmpb = (unsigned char)*b;
 2795|     26|                        if (!((int)tmpb == thousands_sep___0)) {
 2796|     26|                            goto while_break___19;
 2797|     26|                        }
 2798|     26|                    }
 2799|     26|while_break___19:
 2800|     26|                    ;
 2801|     26|                }
 2802|    139|while_break___17:
 2803|    139|                ;
 2804|    139|                if ((int)tmpa == decimal_point___0) {
 2805|      0|                    if (!((unsigned int)tmpb - 48U <= 9U)) {
 2806|      0|                        tmp___2 = fraccompare(a, b, (char)decimal_point___0);
 2807|      0|                        return (tmp___2);
 2808|      0|                    }
 2809|      0|                    else {
 2810|      0|                        goto _L___0;
 2811|      0|                    }
 2812|      0|                }
 2813|    139|                else {
 2814|    139|_L___0:
 2815|    139|                    if ((int)tmpb == decimal_point___0) {
 2816|      0|                        if (!((unsigned int)tmpa - 48U <= 9U)) {
 2817|      0|                            tmp___2 = fraccompare(a, b, (char)decimal_point___0);
 2818|      0|                            return (tmp___2);
 2819|      0|                        }
 2820|      0|                    }
 2821|    139|                }
 2822|    139|                tmp = (int)tmpa - (int)tmpb;
 2823|    139|                log_a = (size_t)0;
 2824|    446|                while (1) {
 2825|       |
 2826|    446|                    if (!((unsigned int)tmpa - 48U <= 9U)) {
 2827|    139|                        goto while_break___20;
 2828|    139|                    }
 2829|    307|                    while (1) {
 2830|    307|                        a++;
 2831|    307|                        tmpa = (unsigned char)*a;
 2832|    307|                        if (!((int)tmpa == thousands_sep___0)) {
 2833|    307|                            goto while_break___21;
 2834|    307|                        }
 2835|    307|                    }
 2836|    307|while_break___21:
 2837|    307|                    log_a++;
 2838|    307|                }
 2839|    139|while_break___20:
 2840|    139|                log_b = (size_t)0;
 2841|    361|                while (1) {
 2842|       |
 2843|    361|                    if (!((unsigned int)tmpb - 48U <= 9U)) {
 2844|    139|                        goto while_break___22;
 2845|    139|                    }
 2846|    222|                    while (1) {
 2847|    222|                        b++;
 2848|    222|                        tmpb = (unsigned char)*b;
 2849|    222|                        if (!((int)tmpb == thousands_sep___0)) {
 2850|    222|                            goto while_break___23;
 2851|    222|                        }
 2852|    222|                    }
 2853|    222|while_break___23:
 2854|    222|                    log_b++;
 2855|    222|                }
 2856|    139|while_break___22:
 2857|    139|                ;
 2858|    139|                if (log_a != log_b) {
 2859|     25|                    if (log_a < log_b) {
 2860|      0|                        tmp___3 = -1;
 2861|      0|                    }
 2862|     25|                    else {
 2863|     25|                        tmp___3 = 1;
 2864|     25|                    }
 2865|     25|                    return ((int __attribute__((__pure__)))tmp___3);
 2866|     25|                }
 2867|    114|                if (!log_a) {
 2868|     67|                    return ((int __attribute__((__pure__)))0);
 2869|     67|                }
 2870|     47|                return ((int __attribute__((__pure__)))tmp);
 2871|    114|            }
 2872|    158|        }
 2873|    231|    }
 2874|    231|}
 2875|       |int __attribute__((__pure__)) strnumcmp(char const *a, char const *b,
 2876|       |                                        int decimal_point___0,
 2877|       |                                        int thousands_sep___0)
 2878|    231|{
 2879|    231|    int __attribute__((__pure__)) tmp;
 2880|       |
 2881|    231|    {
 2882|    231|        tmp = numcompare(a, b, decimal_point___0, thousands_sep___0);
 2883|    231|        return (tmp);
 2884|    231|    }
 2885|    231|}
 2886|       |size_t strnlen1(char const *string, size_t maxlen) __attribute__((__pure__));
 2887|       |size_t strnlen1(char const *string, size_t maxlen) __attribute__((__pure__));
 2888|       |size_t strnlen1(char const *string, size_t maxlen)
 2889|      0|{
 2890|      0|    char const *end;
 2891|      0|    char const *tmp;
 2892|       |
 2893|      0|    {
 2894|      0|        tmp = (char const *)memchr((void const *)string, '\000', maxlen);
 2895|      0|        end = tmp;
 2896|      0|        if ((unsigned long)end != (unsigned long)((void *)0)) {
 2897|      0|            return ((size_t)((end - string) + 1L));
 2898|      0|        }
 2899|      0|        else {
 2900|      0|            return (maxlen);
 2901|      0|        }
 2902|      0|    }
 2903|      0|}
 2904|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) tolower)(
 2905|       |    int __c);
 2906|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) toupper)(
 2907|       |    int __c);
 2908|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) sigprocmask)(
 2909|       |    int __how, sigset_t const *__restrict __set, sigset_t *__restrict __oset);
 2910|       |extern size_t fread_unlocked(void *__restrict __ptr, size_t __size, size_t __n,
 2911|       |                             FILE *__restrict __stream);
 2912|       |extern __attribute__((__nothrow__)) int(
 2913|       |    __attribute__((__leaf__)) feof_unlocked)(FILE *__stream);
 2914|       |__inline static void set_uint32(char *cp, uint32_t v)
 2915|      0|{
 2916|       |
 2917|      0|    {
 2918|      0|        memcpy((void *)cp, (void const *)(&v), sizeof(v));
 2919|      0|        return;
 2920|      0|    }
 2921|      0|}
 2922|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) raise)(
 2923|       |    int __sig);
 2924|       |extern __attribute__((__nothrow__)) __pid_t fork(void);
 2925|       |extern ssize_t read(int __fd, void *__buf, size_t __nbytes);
 2926|       |extern __attribute__((__nothrow__)) int(
 2927|       |    __attribute__((__nonnull__(1), __leaf__)) unlink)(char const *__name);
 2928|       |extern int fgetc(FILE *__stream);
 2929|       |extern void _obstack_newchunk(struct obstack *, int);
 2930|       |extern int _obstack_begin(struct obstack *, int, int, void *(*)(long),
 2931|       |                          void (*)(void *));
 2932|       |void readtokens0_init(struct Tokens *t);
 2933|       |_Bool readtokens0(FILE *in, struct Tokens *t);
 2934|       |void readtokens0_init(struct Tokens *t)
 2935|      0|{
 2936|       |
 2937|      0|    {
 2938|      0|        t->n_tok = (size_t)0;
 2939|      0|        t->tok = (char **)((void *)0);
 2940|      0|        t->tok_len = (size_t *)((void *)0);
 2941|      0|        _obstack_begin(&t->o_data, 0, 0, (void *(*)(long))(&malloc),
 2942|      0|                       (void (*)(void *))(&free));
 2943|      0|        _obstack_begin(&t->o_tok, 0, 0, (void *(*)(long))(&malloc),
 2944|      0|                       (void (*)(void *))(&free));
 2945|      0|        _obstack_begin(&t->o_tok_len, 0, 0, (void *(*)(long))(&malloc),
 2946|      0|                       (void (*)(void *))(&free));
 2947|      0|        return;
 2948|      0|    }
 2949|      0|}
 2950|       |static void save_token(struct Tokens *t)
 2951|      0|{
 2952|      0|    size_t len;
 2953|      0|    struct obstack const *__o;
 2954|      0|    char const *s;
 2955|      0|    struct obstack *__o1;
 2956|      0|    void *__value;
 2957|      0|    char *tmp;
 2958|      0|    char *tmp___0;
 2959|      0|    struct obstack *__o___0;
 2960|      0|    struct obstack *__o1___0;
 2961|      0|    struct obstack *__o___1;
 2962|      0|    int __len;
 2963|       |
 2964|      0|    {
 2965|      0|        __o = (struct obstack const *)(&t->o_data);
 2966|      0|        len = (size_t)((unsigned int)(__o->next_free - __o->object_base) - 1U);
 2967|      0|        __o1 = &t->o_data;
 2968|      0|        __value = (void *)__o1->object_base;
 2969|      0|        if ((unsigned long)__o1->next_free == (unsigned long)__value) {
 2970|      0|            __o1->maybe_empty_object = 1U;
 2971|      0|        }
 2972|      0|        if (sizeof(long) < sizeof(void *)) {
 2973|      0|            tmp = __o1->object_base;
 2974|      0|        }
 2975|      0|        else {
 2976|      0|            tmp = (char *)0;
 2977|      0|        }
 2978|      0|        if (sizeof(long) < sizeof(void *)) {
 2979|      0|            tmp___0 = __o1->object_base;
 2980|      0|        }
 2981|      0|        else {
 2982|      0|            tmp___0 = (char *)0;
 2983|      0|        }
 2984|      0|        __o1->next_free =
 2985|      0|            tmp + (((__o1->next_free - tmp___0) + (long)__o1->alignment_mask) &
 2986|      0|                   (long)(~__o1->alignment_mask));
 2987|      0|        if (__o1->next_free - (char *)__o1->chunk >
 2988|      0|                __o1->chunk_limit - (char *)__o1->chunk) {
 2989|      0|            __o1->next_free = __o1->chunk_limit;
 2990|      0|        }
 2991|      0|        __o1->object_base = __o1->next_free;
 2992|      0|        s = (char const *)__value;
 2993|      0|        __o___0 = &t->o_tok;
 2994|      0|        if ((unsigned long)(__o___0->next_free + sizeof(void *)) >
 2995|      0|                (unsigned long)__o___0->chunk_limit) {
 2996|      0|            _obstack_newchunk(__o___0, (int)sizeof(void *));
 2997|      0|        }
 2998|      0|        __o1___0 = __o___0;
 2999|      0|        *((void const **)__o1___0->next_free) = (void const *)s;
 3000|      0|        __o1___0->next_free += sizeof(void const *);
 3001|      0|        __o___1 = &t->o_tok_len;
 3002|      0|        __len = (int)sizeof(len);
 3003|      0|        if ((unsigned long)(__o___1->next_free + __len) >
 3004|      0|                (unsigned long)__o___1->chunk_limit) {
 3005|      0|            _obstack_newchunk(__o___1, __len);
 3006|      0|        }
 3007|      0|        memcpy((void *)__o___1->next_free, (void const *)(&len), (size_t)__len);
 3008|      0|        __o___1->next_free += __len;
 3009|      0|        (t->n_tok)++;
 3010|      0|        return;
 3011|      0|    }
 3012|      0|}
 3013|       |_Bool readtokens0(FILE *in, struct Tokens *t)
 3014|      0|{
 3015|      0|    int c;
 3016|      0|    int tmp;
 3017|      0|    size_t len;
 3018|      0|    struct obstack const *__o;
 3019|      0|    struct obstack *__o___0;
 3020|      0|    char *tmp___0;
 3021|      0|    struct obstack *__o___1;
 3022|      0|    char *tmp___1;
 3023|      0|    struct obstack *__o___2;
 3024|      0|    struct obstack *__o1;
 3025|      0|    struct obstack *__o1___0;
 3026|      0|    void *__value;
 3027|      0|    char *tmp___2;
 3028|      0|    char *tmp___3;
 3029|      0|    struct obstack *__o1___1;
 3030|      0|    void *__value___0;
 3031|      0|    char *tmp___4;
 3032|      0|    char *tmp___5;
 3033|      0|    int tmp___6;
 3034|      0|    int tmp___7;
 3035|       |
 3036|      0|    {
 3037|      0|        while (1) {
 3038|      0|            tmp = fgetc(in);
 3039|      0|            c = tmp;
 3040|      0|            if (c == -1) {
 3041|      0|                __o = (struct obstack const *)(&t->o_data);
 3042|      0|                len = (size_t)((unsigned int)(__o->next_free - __o->object_base));
 3043|      0|                if (len) {
 3044|      0|                    __o___0 = &t->o_data;
 3045|      0|                    if ((unsigned long)(__o___0->next_free + 1) >
 3046|      0|                            (unsigned long)__o___0->chunk_limit) {
 3047|      0|                        _obstack_newchunk(__o___0, 1);
 3048|      0|                    }
 3049|      0|                    tmp___0 = __o___0->next_free;
 3050|      0|                    (__o___0->next_free)++;
 3051|      0|                    *tmp___0 = (char)'\000';
 3052|      0|                    save_token(t);
 3053|      0|                }
 3054|      0|                goto while_break;
 3055|      0|            }
 3056|      0|            __o___1 = &t->o_data;
 3057|      0|            if ((unsigned long)(__o___1->next_free + 1) >
 3058|      0|                    (unsigned long)__o___1->chunk_limit) {
 3059|      0|                _obstack_newchunk(__o___1, 1);
 3060|      0|            }
 3061|      0|            tmp___1 = __o___1->next_free;
 3062|      0|            (__o___1->next_free)++;
 3063|      0|            *tmp___1 = (char)c;
 3064|      0|            if (c == 0) {
 3065|      0|                save_token(t);
 3066|      0|            }
 3067|      0|        }
 3068|      0|while_break:
 3069|      0|        __o___2 = &t->o_tok;
 3070|      0|        if ((unsigned long)(__o___2->next_free + sizeof(void *)) >
 3071|      0|                (unsigned long)__o___2->chunk_limit) {
 3072|      0|            _obstack_newchunk(__o___2, (int)sizeof(void *));
 3073|      0|        }
 3074|      0|        __o1 = __o___2;
 3075|      0|        *((void const **)__o1->next_free) = (void const *)((void *)0);
 3076|      0|        __o1->next_free += sizeof(void const *);
 3077|      0|        __o1___0 = &t->o_tok;
 3078|      0|        __value = (void *)__o1___0->object_base;
 3079|      0|        if ((unsigned long)__o1___0->next_free == (unsigned long)__value) {
 3080|      0|            __o1___0->maybe_empty_object = 1U;
 3081|      0|        }
 3082|      0|        if (sizeof(long) < sizeof(void *)) {
 3083|      0|            tmp___2 = __o1___0->object_base;
 3084|      0|        }
 3085|      0|        else {
 3086|      0|            tmp___2 = (char *)0;
 3087|      0|        }
 3088|      0|        if (sizeof(long) < sizeof(void *)) {
 3089|      0|            tmp___3 = __o1___0->object_base;
 3090|      0|        }
 3091|      0|        else {
 3092|      0|            tmp___3 = (char *)0;
 3093|      0|        }
 3094|      0|        __o1___0->next_free =
 3095|      0|            tmp___2 +
 3096|      0|            (((__o1___0->next_free - tmp___3) + (long)__o1___0->alignment_mask) &
 3097|      0|             (long)(~__o1___0->alignment_mask));
 3098|      0|        if (__o1___0->next_free - (char *)__o1___0->chunk >
 3099|      0|                __o1___0->chunk_limit - (char *)__o1___0->chunk) {
 3100|      0|            __o1___0->next_free = __o1___0->chunk_limit;
 3101|      0|        }
 3102|      0|        __o1___0->object_base = __o1___0->next_free;
 3103|      0|        t->tok = (char **)__value;
 3104|      0|        __o1___1 = &t->o_tok_len;
 3105|      0|        __value___0 = (void *)__o1___1->object_base;
 3106|      0|        if ((unsigned long)__o1___1->next_free == (unsigned long)__value___0) {
 3107|      0|            __o1___1->maybe_empty_object = 1U;
 3108|      0|        }
 3109|      0|        if (sizeof(long) < sizeof(void *)) {
 3110|      0|            tmp___4 = __o1___1->object_base;
 3111|      0|        }
 3112|      0|        else {
 3113|      0|            tmp___4 = (char *)0;
 3114|      0|        }
 3115|      0|        if (sizeof(long) < sizeof(void *)) {
 3116|      0|            tmp___5 = __o1___1->object_base;
 3117|      0|        }
 3118|      0|        else {
 3119|      0|            tmp___5 = (char *)0;
 3120|      0|        }
 3121|      0|        __o1___1->next_free =
 3122|      0|            tmp___4 +
 3123|      0|            (((__o1___1->next_free - tmp___5) + (long)__o1___1->alignment_mask) &
 3124|      0|             (long)(~__o1___1->alignment_mask));
 3125|      0|        if (__o1___1->next_free - (char *)__o1___1->chunk >
 3126|      0|                __o1___1->chunk_limit - (char *)__o1___1->chunk) {
 3127|      0|            __o1___1->next_free = __o1___1->chunk_limit;
 3128|      0|        }
 3129|      0|        __o1___1->object_base = __o1___1->next_free;
 3130|      0|        t->tok_len = (size_t *)__value___0;
 3131|      0|        tmp___6 = ferror(in);
 3132|      0|        if (tmp___6) {
 3133|      0|            tmp___7 = 0;
 3134|      0|        }
 3135|      0|        else {
 3136|      0|            tmp___7 = 1;
 3137|      0|        }
 3138|      0|        return ((_Bool)tmp___7);
 3139|      0|    }
 3140|      0|}
 3141|       |extern int getc_unlocked(FILE *__stream);
 3142|       |
 3143|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) fileno)(
 3144|       |    FILE *__stream);
 3145|       |struct randread_source *randread_new(char const *name, size_t bytes_bound);
 3146|       |void randread(struct randread_source *s, void *buf___1, size_t size);
 3147|       |int randread_free(struct randread_source *s);
 3148|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) setvbuf)(
 3149|       |    FILE *__restrict __stream, char *__restrict __buf, int __modes, size_t __n);
 3150|       |extern __attribute__((__nothrow__)) int(__attribute__((
 3151|       |        __nonnull__(1), __leaf__)) gettimeofday)(struct timeval *__restrict __tv,
 3152|       |                __timezone_ptr_t __tz);
 3153|       |extern __attribute__((__nothrow__))
 3154|       |__pid_t(__attribute__((__leaf__)) getpid)(void);
 3155|       |extern __attribute__((__nothrow__))
 3156|       |__pid_t(__attribute__((__leaf__)) getppid)(void);
 3157|       |extern __attribute__((__nothrow__))
 3158|       |__uid_t(__attribute__((__leaf__)) getuid)(void);
 3159|       |extern __attribute__((__nothrow__))
 3160|       |__gid_t(__attribute__((__leaf__)) getgid)(void);
 3161|       |void isaac_seed(struct isaac_state *s);
 3162|       |void isaac_refill(struct isaac_state *s, isaac_word *result);
 3163|       |FILE *fopen_safer(char const *file, char const *mode);
 3164|       |static void randread_error(void const *file_name___3)
 3165|      0|{
 3166|      0|    char *tmp;
 3167|      0|    char const *tmp___1;
 3168|      0|    int *tmp___2;
 3169|      0|    char *tmp___3;
 3170|      0|    int *tmp___4;
 3171|       |
 3172|      0|    {
 3173|      0|        if (file_name___3) {
 3174|      0|            tmp = quotearg_colon(file_name___3);
 3175|      0|            tmp___2 = __errno_location();
 3176|      0|            if (*tmp___2 == 0) {
 3177|      0|                tmp___1 = "%s: end of file";
 3178|      0|            }
 3179|      0|            else {
 3180|      0|                tmp___1 = "%s: read error";
 3181|      0|            }
 3182|      0|            tmp___3 = gettext(tmp___1);
 3183|      0|            tmp___4 = __errno_location();
 3184|      0|            error(exit_failure, *tmp___4, tmp___3, tmp);
 3185|      0|        }
 3186|      0|        abort();
 3187|      0|    }
 3188|      0|}
 3189|       |static struct randread_source *simple_new(FILE *source,
 3190|       |        void const *handler_arg)
 3191|      0|{
 3192|      0|    struct randread_source *s;
 3193|      0|    struct randread_source *tmp;
 3194|       |
 3195|      0|    {
 3196|      0|        tmp = (struct randread_source *)xmalloc(sizeof(*s));
 3197|      0|        s = tmp;
 3198|      0|        s->source = source;
 3199|      0|        s->handler = &randread_error;
 3200|      0|        s->handler_arg = handler_arg;
 3201|      0|        return (s);
 3202|      0|    }
 3203|      0|}
 3204|       |static void get_nonce(void *buffer, size_t bufsize___1, size_t bytes_bound)
 3205|      0|{
 3206|      0|    char *buf___1;
 3207|      0|    ssize_t seeded;
 3208|      0|    int fd;
 3209|      0|    int tmp;
 3210|      0|    size_t tmp___0;
 3211|      0|    struct timeval v;
 3212|      0|    size_t nbytes;
 3213|      0|    unsigned long tmp___1;
 3214|      0|    pid_t v___0;
 3215|      0|    size_t nbytes___0;
 3216|      0|    unsigned long tmp___2;
 3217|      0|    pid_t v___1;
 3218|      0|    size_t nbytes___1;
 3219|      0|    unsigned long tmp___3;
 3220|      0|    uid_t v___2;
 3221|      0|    size_t nbytes___2;
 3222|      0|    unsigned long tmp___4;
 3223|      0|    uid_t v___3;
 3224|      0|    size_t nbytes___3;
 3225|      0|    unsigned long tmp___5;
 3226|       |
 3227|      0|    {
 3228|      0|        buf___1 = (char *)buffer;
 3229|      0|        seeded = (ssize_t)0;
 3230|      0|        tmp = open("/dev/urandom", 0);
 3231|      0|        fd = tmp;
 3232|      0|        if (0 <= fd) {
 3233|      0|            if (bufsize___1 < bytes_bound) {
 3234|      0|                tmp___0 = bufsize___1;
 3235|      0|            }
 3236|      0|            else {
 3237|      0|                tmp___0 = bytes_bound;
 3238|      0|            }
 3239|      0|            seeded = read(fd, (void *)buf___1, tmp___0);
 3240|      0|            if (seeded < 0L) {
 3241|      0|                seeded = (ssize_t)0;
 3242|      0|            }
 3243|      0|            close(fd);
 3244|      0|        }
 3245|      0|        if ((size_t)seeded < bufsize___1) {
 3246|      0|            if (sizeof(v) < bufsize___1 - (size_t)seeded) {
 3247|      0|                tmp___1 = sizeof(v);
 3248|      0|            }
 3249|      0|            else {
 3250|      0|                tmp___1 = bufsize___1 - (size_t)seeded;
 3251|      0|            }
 3252|      0|            nbytes = tmp___1;
 3253|      0|            gettimeofday(&v, (__timezone_ptr_t)((void *)0));
 3254|      0|            memcpy((void *)(buf___1 + seeded), (void const *)(&v), nbytes);
 3255|      0|            seeded = (ssize_t)((size_t)seeded + nbytes);
 3256|      0|        }
 3257|      0|        if ((size_t)seeded < bufsize___1) {
 3258|      0|            if (sizeof(v___0) < bufsize___1 - (size_t)seeded) {
 3259|      0|                tmp___2 = sizeof(v___0);
 3260|      0|            }
 3261|      0|            else {
 3262|      0|                tmp___2 = bufsize___1 - (size_t)seeded;
 3263|      0|            }
 3264|      0|            nbytes___0 = tmp___2;
 3265|      0|            v___0 = getpid();
 3266|      0|            memcpy((void *)(buf___1 + seeded), (void const *)(&v___0), nbytes___0);
 3267|      0|            seeded = (ssize_t)((size_t)seeded + nbytes___0);
 3268|      0|        }
 3269|      0|        if ((size_t)seeded < bufsize___1) {
 3270|      0|            if (sizeof(v___1) < bufsize___1 - (size_t)seeded) {
 3271|      0|                tmp___3 = sizeof(v___1);
 3272|      0|            }
 3273|      0|            else {
 3274|      0|                tmp___3 = bufsize___1 - (size_t)seeded;
 3275|      0|            }
 3276|      0|            nbytes___1 = tmp___3;
 3277|      0|            v___1 = getppid();
 3278|      0|            memcpy((void *)(buf___1 + seeded), (void const *)(&v___1), nbytes___1);
 3279|      0|            seeded = (ssize_t)((size_t)seeded + nbytes___1);
 3280|      0|        }
 3281|      0|        if ((size_t)seeded < bufsize___1) {
 3282|      0|            if (sizeof(v___2) < bufsize___1 - (size_t)seeded) {
 3283|      0|                tmp___4 = sizeof(v___2);
 3284|      0|            }
 3285|      0|            else {
 3286|      0|                tmp___4 = bufsize___1 - (size_t)seeded;
 3287|      0|            }
 3288|      0|            nbytes___2 = tmp___4;
 3289|      0|            v___2 = getuid();
 3290|      0|            memcpy((void *)(buf___1 + seeded), (void const *)(&v___2), nbytes___2);
 3291|      0|            seeded = (ssize_t)((size_t)seeded + nbytes___2);
 3292|      0|        }
 3293|      0|        if ((size_t)seeded < bufsize___1) {
 3294|      0|            if (sizeof(v___3) < bufsize___1 - (size_t)seeded) {
 3295|      0|                tmp___5 = sizeof(v___3);
 3296|      0|            }
 3297|      0|            else {
 3298|      0|                tmp___5 = bufsize___1 - (size_t)seeded;
 3299|      0|            }
 3300|      0|            nbytes___3 = tmp___5;
 3301|      0|            v___3 = getgid();
 3302|      0|            memcpy((void *)(buf___1 + seeded), (void const *)(&v___3), nbytes___3);
 3303|      0|            seeded = (ssize_t)((size_t)seeded + nbytes___3);
 3304|      0|        }
 3305|      0|        return;
 3306|      0|    }
 3307|      0|}
 3308|       |struct randread_source *randread_new(char const *name, size_t bytes_bound)
 3309|      0|{
 3310|      0|    struct randread_source *tmp;
 3311|      0|    FILE *source;
 3312|      0|    struct randread_source *s;
 3313|      0|    unsigned long tmp___0;
 3314|       |
 3315|      0|    {
 3316|      0|        if (bytes_bound == 0UL) {
 3317|      0|            tmp = simple_new((FILE *)((void *)0), (void const *)((void *)0));
 3318|      0|            return (tmp);
 3319|      0|        }
 3320|      0|        else {
 3321|      0|            source = (FILE *)((void *)0);
 3322|      0|            if (name) {
 3323|      0|                source = fopen_safer(name, "rb");
 3324|      0|                if (!source) {
 3325|      0|                    return ((struct randread_source *)((void *)0));
 3326|      0|                }
 3327|      0|            }
 3328|      0|            s = simple_new(source, (void const *)name);
 3329|      0|            if (source) {
 3330|      0|                if (sizeof(s->buf.c) < bytes_bound) {
 3331|      0|                    tmp___0 = sizeof(s->buf.c);
 3332|      0|                }
 3333|      0|                else {
 3334|      0|                    tmp___0 = bytes_bound;
 3335|      0|                }
 3336|      0|                setvbuf(source, s->buf.c, 0, tmp___0);
 3337|      0|            }
 3338|      0|            else {
 3339|      0|                s->buf.isaac.buffered = (size_t)0;
 3340|      0|                get_nonce((void *)(s->buf.isaac.state.m), sizeof(s->buf.isaac.state.m),
 3341|      0|                          bytes_bound);
 3342|      0|                isaac_seed(&s->buf.isaac.state);
 3343|      0|            }
 3344|      0|            return (s);
 3345|      0|        }
 3346|      0|    }
 3347|      0|}
 3348|       |static void readsource(struct randread_source *s, unsigned char *p,
 3349|       |                       size_t size)
 3350|      0|{
 3351|      0|    size_t inbytes;
 3352|      0|    size_t tmp;
 3353|      0|    int fread_errno;
 3354|      0|    int *tmp___0;
 3355|      0|    int *tmp___1;
 3356|      0|    int tmp___3;
 3357|       |
 3358|      0|    {
 3359|      0|        while (1) {
 3360|      0|            tmp = fread_unlocked((void *)p, sizeof(*p), size, s->source);
 3361|      0|            inbytes = tmp;
 3362|      0|            tmp___0 = __errno_location();
 3363|      0|            fread_errno = *tmp___0;
 3364|      0|            p += inbytes;
 3365|      0|            size -= inbytes;
 3366|      0|            if (size == 0UL) {
 3367|      0|                goto while_break;
 3368|      0|            }
 3369|      0|            tmp___1 = __errno_location();
 3370|      0|            tmp___3 = ferror_unlocked(s->source);
 3371|      0|            if (tmp___3) {
 3372|      0|                *tmp___1 = fread_errno;
 3373|      0|            }
 3374|      0|            else {
 3375|      0|                *tmp___1 = 0;
 3376|      0|            }
 3377|      0|            (*(s->handler))(s->handler_arg);
 3378|      0|        }
 3379|      0|while_break:
 3380|      0|        ;
 3381|      0|        return;
 3382|      0|    }
 3383|      0|}
 3384|       |static void readisaac(struct isaac *isaac, unsigned char *p, size_t size)
 3385|      0|{
 3386|      0|    size_t inbytes;
 3387|      0|    isaac_word *wp;
 3388|       |
 3389|      0|    {
 3390|      0|        inbytes = isaac->buffered;
 3391|      0|        while (1) {
 3392|       |
 3393|      0|            if (size <= inbytes) {
 3394|      0|                memcpy((void *)p,
 3395|      0|                       (void const *)((isaac->data.b +
 3396|      0|                                       (unsigned long)(1 << 8) * sizeof(isaac_word)) -
 3397|      0|                                      inbytes),
 3398|      0|                       size);
 3399|      0|                isaac->buffered = inbytes - size;
 3400|      0|                return;
 3401|      0|            }
 3402|      0|            memcpy((void *)p,
 3403|      0|                   (void const *)((isaac->data.b +
 3404|      0|                                   (unsigned long)(1 << 8) * sizeof(isaac_word)) -
 3405|      0|                                  inbytes),
 3406|      0|                   inbytes);
 3407|      0|            p += inbytes;
 3408|      0|            size -= inbytes;
 3409|      0|            wp = (isaac_word *)p;
 3410|      0|            while (1) {
 3411|       |
 3412|      0|                if (!((unsigned long)(1 << 8) * sizeof(isaac_word) <= size)) {
 3413|      0|                    goto while_break___0;
 3414|      0|                }
 3415|      0|                isaac_refill(&isaac->state, wp);
 3416|      0|                wp += 1 << 8;
 3417|      0|                size -= (unsigned long)(1 << 8) * sizeof(isaac_word);
 3418|      0|                if (size == 0UL) {
 3419|      0|                    isaac->buffered = (size_t)0;
 3420|      0|                    return;
 3421|      0|                }
 3422|      0|            }
 3423|      0|while_break___0:
 3424|      0|            p = (unsigned char *)wp;
 3425|      0|            isaac_refill(&isaac->state, isaac->data.w);
 3426|      0|            inbytes = (unsigned long)(1 << 8) * sizeof(isaac_word);
 3427|      0|        }
 3428|       |
 3429|      0|        return;
 3430|      0|    }
 3431|      0|}
 3432|       |void randread(struct randread_source *s, void *buf___1, size_t size)
 3433|      0|{
 3434|       |
 3435|      0|    {
 3436|      0|        if (s->source) {
 3437|      0|            readsource(s, (unsigned char *)buf___1, size);
 3438|      0|        }
 3439|      0|        else {
 3440|      0|            readisaac(&s->buf.isaac, (unsigned char *)buf___1, size);
 3441|      0|        }
 3442|      0|        return;
 3443|      0|    }
 3444|      0|}
 3445|       |int randread_free(struct randread_source *s)
 3446|      0|{
 3447|      0|    FILE *source;
 3448|      0|    int tmp;
 3449|      0|    int tmp___0;
 3450|       |
 3451|      0|    {
 3452|      0|        source = s->source;
 3453|      0|        memset((void *)s, 0, sizeof(*s));
 3454|      0|        free((void *)s);
 3455|      0|        if (source) {
 3456|      0|            tmp = rpl_fclose(source);
 3457|      0|            tmp___0 = tmp;
 3458|      0|        }
 3459|      0|        else {
 3460|      0|            tmp___0 = 0;
 3461|      0|        }
 3462|      0|        return (tmp___0);
 3463|      0|    }
 3464|      0|}
 3465|       |void *hash_delete(Hash_table *table___0, void const *entry);
 3466|       |__inline static isaac_word just(isaac_word a)
 3467|      0|{
 3468|      0|    isaac_word desired_bits;
 3469|       |
 3470|      0|    {
 3471|      0|        desired_bits = ((1UL << 1) << ((1 << 6) - 1)) - 1UL;
 3472|      0|        return (a & desired_bits);
 3473|      0|    }
 3474|      0|}
 3475|       |__inline static isaac_word ind(isaac_word const *m, isaac_word x)
 3476|      0|{
 3477|      0|    isaac_word tmp;
 3478|       |
 3479|      0|    {
 3480|      0|        if (sizeof(*m) * 8UL == (unsigned long)(1 << 6)) {
 3481|      0|            tmp = *((isaac_word *)((char *)m +
 3482|      0|                                   (x & (unsigned long)((1 << 8) - 1) * sizeof(*m))));
 3483|      0|        }
 3484|      0|        else {
 3485|      0|            tmp = (isaac_word) * (m + (x / (isaac_word)((1 << 6) / 8) &
 3486|      0|                                       (unsigned long)((1 << 8) - 1)));
 3487|      0|        }
 3488|      0|        return (tmp);
 3489|      0|    }
 3490|      0|}
 3491|       |void isaac_refill(struct isaac_state *s, isaac_word *result)
 3492|      0|{
 3493|      0|    isaac_word a;
 3494|      0|    isaac_word b;
 3495|      0|    isaac_word *m;
 3496|      0|    isaac_word *r;
 3497|      0|    isaac_word x;
 3498|      0|    isaac_word y;
 3499|      0|    isaac_word tmp;
 3500|      0|    isaac_word tmp___0;
 3501|      0|    isaac_word tmp___1;
 3502|      0|    isaac_word tmp___2;
 3503|      0|    isaac_word x___0;
 3504|      0|    isaac_word y___0;
 3505|      0|    isaac_word tmp___3;
 3506|      0|    isaac_word tmp___4;
 3507|      0|    isaac_word tmp___5;
 3508|      0|    isaac_word tmp___6;
 3509|      0|    isaac_word tmp___7;
 3510|      0|    isaac_word tmp___8;
 3511|      0|    isaac_word x___1;
 3512|      0|    isaac_word y___1;
 3513|      0|    isaac_word tmp___9;
 3514|      0|    isaac_word tmp___10;
 3515|      0|    isaac_word tmp___11;
 3516|      0|    isaac_word tmp___12;
 3517|      0|    isaac_word x___2;
 3518|      0|    isaac_word y___2;
 3519|      0|    isaac_word tmp___13;
 3520|      0|    isaac_word tmp___14;
 3521|      0|    isaac_word tmp___15;
 3522|      0|    isaac_word tmp___16;
 3523|      0|    isaac_word tmp___17;
 3524|      0|    isaac_word tmp___18;
 3525|      0|    isaac_word x___3;
 3526|      0|    isaac_word y___3;
 3527|      0|    isaac_word tmp___19;
 3528|      0|    isaac_word tmp___20;
 3529|      0|    isaac_word tmp___21;
 3530|      0|    isaac_word tmp___22;
 3531|      0|    isaac_word x___4;
 3532|      0|    isaac_word y___4;
 3533|      0|    isaac_word tmp___23;
 3534|      0|    isaac_word tmp___24;
 3535|      0|    isaac_word tmp___25;
 3536|      0|    isaac_word tmp___26;
 3537|      0|    isaac_word tmp___27;
 3538|      0|    isaac_word tmp___28;
 3539|      0|    isaac_word x___5;
 3540|      0|    isaac_word y___5;
 3541|      0|    isaac_word tmp___29;
 3542|      0|    isaac_word tmp___30;
 3543|      0|    isaac_word tmp___31;
 3544|      0|    isaac_word tmp___32;
 3545|      0|    isaac_word x___6;
 3546|      0|    isaac_word y___6;
 3547|      0|    isaac_word tmp___33;
 3548|      0|    isaac_word tmp___34;
 3549|      0|    isaac_word tmp___35;
 3550|      0|    isaac_word tmp___36;
 3551|      0|    isaac_word tmp___37;
 3552|      0|    isaac_word tmp___38;
 3553|       |
 3554|      0|    {
 3555|      0|        a = s->a;
 3556|      0|        (s->c)++;
 3557|      0|        b = s->b + s->c;
 3558|      0|        m = s->m;
 3559|      0|        r = result;
 3560|      0|        while (1) {
 3561|       |
 3562|      0|            if (1 << 6 == 32) {
 3563|      0|                tmp = a;
 3564|      0|            }
 3565|      0|            else {
 3566|      0|                tmp = (isaac_word)0;
 3567|      0|            }
 3568|      0|            if (1 << 6 == 32) {
 3569|      0|                tmp___0 = a << 13;
 3570|      0|            }
 3571|      0|            else {
 3572|      0|                tmp___0 = ~(a ^ (a << 21));
 3573|      0|            }
 3574|      0|            a = (tmp ^ tmp___0) + *(m + 128);
 3575|      0|            x = *(m + 0);
 3576|      0|            tmp___1 = ind((isaac_word const *)(s->m), x);
 3577|      0|            y = (tmp___1 + a) + b;
 3578|      0|            *(m + 0) = y;
 3579|      0|            tmp___2 = ind((isaac_word const *)(s->m), y >> 8);
 3580|      0|            b = just(tmp___2 + x);
 3581|      0|            *(r + 0) = b;
 3582|      0|            if (1 << 6 == 32) {
 3583|      0|                tmp___3 = a;
 3584|      0|            }
 3585|      0|            else {
 3586|      0|                tmp___3 = (isaac_word)0;
 3587|      0|            }
 3588|      0|            if (1 << 6 == 32) {
 3589|      0|                tmp___4 = just(a);
 3590|      0|                tmp___6 = tmp___4 >> 6;
 3591|      0|            }
 3592|      0|            else {
 3593|      0|                tmp___5 = just(a);
 3594|      0|                tmp___6 = a ^ (tmp___5 >> 5);
 3595|      0|            }
 3596|      0|            a = (tmp___3 ^ tmp___6) + *(m + 129);
 3597|      0|            x___0 = *(m + 1);
 3598|      0|            tmp___7 = ind((isaac_word const *)(s->m), x___0);
 3599|      0|            y___0 = (tmp___7 + a) + b;
 3600|      0|            *(m + 1) = y___0;
 3601|      0|            tmp___8 = ind((isaac_word const *)(s->m), y___0 >> 8);
 3602|      0|            b = just(tmp___8 + x___0);
 3603|      0|            *(r + 1) = b;
 3604|      0|            if (1 << 6 == 32) {
 3605|      0|                tmp___9 = a;
 3606|      0|            }
 3607|      0|            else {
 3608|      0|                tmp___9 = (isaac_word)0;
 3609|      0|            }
 3610|      0|            if (1 << 6 == 32) {
 3611|      0|                tmp___10 = a << 2;
 3612|      0|            }
 3613|      0|            else {
 3614|      0|                tmp___10 = a ^ (a << 12);
 3615|      0|            }
 3616|      0|            a = (tmp___9 ^ tmp___10) + *(m + 130);
 3617|      0|            x___1 = *(m + 2);
 3618|      0|            tmp___11 = ind((isaac_word const *)(s->m), x___1);
 3619|      0|            y___1 = (tmp___11 + a) + b;
 3620|      0|            *(m + 2) = y___1;
 3621|      0|            tmp___12 = ind((isaac_word const *)(s->m), y___1 >> 8);
 3622|      0|            b = just(tmp___12 + x___1);
 3623|      0|            *(r + 2) = b;
 3624|      0|            if (1 << 6 == 32) {
 3625|      0|                tmp___13 = a;
 3626|      0|            }
 3627|      0|            else {
 3628|      0|                tmp___13 = (isaac_word)0;
 3629|      0|            }
 3630|      0|            if (1 << 6 == 32) {
 3631|      0|                tmp___14 = just(a);
 3632|      0|                tmp___16 = tmp___14 >> 16;
 3633|      0|            }
 3634|      0|            else {
 3635|      0|                tmp___15 = just(a);
 3636|      0|                tmp___16 = a ^ (tmp___15 >> 33);
 3637|      0|            }
 3638|      0|            a = (tmp___13 ^ tmp___16) + *(m + 131);
 3639|      0|            x___2 = *(m + 3);
 3640|      0|            tmp___17 = ind((isaac_word const *)(s->m), x___2);
 3641|      0|            y___2 = (tmp___17 + a) + b;
 3642|      0|            *(m + 3) = y___2;
 3643|      0|            tmp___18 = ind((isaac_word const *)(s->m), y___2 >> 8);
 3644|      0|            b = just(tmp___18 + x___2);
 3645|      0|            *(r + 3) = b;
 3646|      0|            r += 4;
 3647|      0|            m += 4;
 3648|      0|            if (!((unsigned long)m < (unsigned long)(s->m + 128))) {
 3649|      0|                goto while_break;
 3650|      0|            }
 3651|      0|        }
 3652|      0|while_break:
 3653|      0|        ;
 3654|      0|        while (1) {
 3655|       |
 3656|      0|            if (1 << 6 == 32) {
 3657|      0|                tmp___19 = a;
 3658|      0|            }
 3659|      0|            else {
 3660|      0|                tmp___19 = (isaac_word)0;
 3661|      0|            }
 3662|      0|            if (1 << 6 == 32) {
 3663|      0|                tmp___20 = a << 13;
 3664|      0|            }
 3665|      0|            else {
 3666|      0|                tmp___20 = ~(a ^ (a << 21));
 3667|      0|            }
 3668|      0|            a = (tmp___19 ^ tmp___20) + *(m + -128);
 3669|      0|            x___3 = *(m + 0);
 3670|      0|            tmp___21 = ind((isaac_word const *)(s->m), x___3);
 3671|      0|            y___3 = (tmp___21 + a) + b;
 3672|      0|            *(m + 0) = y___3;
 3673|      0|            tmp___22 = ind((isaac_word const *)(s->m), y___3 >> 8);
 3674|      0|            b = just(tmp___22 + x___3);
 3675|      0|            *(r + 0) = b;
 3676|      0|            if (1 << 6 == 32) {
 3677|      0|                tmp___23 = a;
 3678|      0|            }
 3679|      0|            else {
 3680|      0|                tmp___23 = (isaac_word)0;
 3681|      0|            }
 3682|      0|            if (1 << 6 == 32) {
 3683|      0|                tmp___24 = just(a);
 3684|      0|                tmp___26 = tmp___24 >> 6;
 3685|      0|            }
 3686|      0|            else {
 3687|      0|                tmp___25 = just(a);
 3688|      0|                tmp___26 = a ^ (tmp___25 >> 5);
 3689|      0|            }
 3690|      0|            a = (tmp___23 ^ tmp___26) + *(m + -127);
 3691|      0|            x___4 = *(m + 1);
 3692|      0|            tmp___27 = ind((isaac_word const *)(s->m), x___4);
 3693|      0|            y___4 = (tmp___27 + a) + b;
 3694|      0|            *(m + 1) = y___4;
 3695|      0|            tmp___28 = ind((isaac_word const *)(s->m), y___4 >> 8);
 3696|      0|            b = just(tmp___28 + x___4);
 3697|      0|            *(r + 1) = b;
 3698|      0|            if (1 << 6 == 32) {
 3699|      0|                tmp___29 = a;
 3700|      0|            }
 3701|      0|            else {
 3702|      0|                tmp___29 = (isaac_word)0;
 3703|      0|            }
 3704|      0|            if (1 << 6 == 32) {
 3705|      0|                tmp___30 = a << 2;
 3706|      0|            }
 3707|      0|            else {
 3708|      0|                tmp___30 = a ^ (a << 12);
 3709|      0|            }
 3710|      0|            a = (tmp___29 ^ tmp___30) + *(m + -126);
 3711|      0|            x___5 = *(m + 2);
 3712|      0|            tmp___31 = ind((isaac_word const *)(s->m), x___5);
 3713|      0|            y___5 = (tmp___31 + a) + b;
 3714|      0|            *(m + 2) = y___5;
 3715|      0|            tmp___32 = ind((isaac_word const *)(s->m), y___5 >> 8);
 3716|      0|            b = just(tmp___32 + x___5);
 3717|      0|            *(r + 2) = b;
 3718|      0|            if (1 << 6 == 32) {
 3719|      0|                tmp___33 = a;
 3720|      0|            }
 3721|      0|            else {
 3722|      0|                tmp___33 = (isaac_word)0;
 3723|      0|            }
 3724|      0|            if (1 << 6 == 32) {
 3725|      0|                tmp___34 = just(a);
 3726|      0|                tmp___36 = tmp___34 >> 16;
 3727|      0|            }
 3728|      0|            else {
 3729|      0|                tmp___35 = just(a);
 3730|      0|                tmp___36 = a ^ (tmp___35 >> 33);
 3731|      0|            }
 3732|      0|            a = (tmp___33 ^ tmp___36) + *(m + -125);
 3733|      0|            x___6 = *(m + 3);
 3734|      0|            tmp___37 = ind((isaac_word const *)(s->m), x___6);
 3735|      0|            y___6 = (tmp___37 + a) + b;
 3736|      0|            *(m + 3) = y___6;
 3737|      0|            tmp___38 = ind((isaac_word const *)(s->m), y___6 >> 8);
 3738|      0|            b = just(tmp___38 + x___6);
 3739|      0|            *(r + 3) = b;
 3740|      0|            r += 4;
 3741|      0|            m += 4;
 3742|      0|            if (!((unsigned long)m < (unsigned long)(s->m + (1 << 8)))) {
 3743|      0|                goto while_break___0;
 3744|      0|            }
 3745|      0|        }
 3746|      0|while_break___0:
 3747|      0|        s->a = a;
 3748|      0|        s->b = b;
 3749|      0|        return;
 3750|      0|    }
 3751|      0|}
 3752|       |void isaac_seed(struct isaac_state *s)
 3753|      0|{
 3754|      0|    isaac_word a;
 3755|      0|    unsigned long tmp;
 3756|      0|    isaac_word b;
 3757|      0|    unsigned long tmp___0;
 3758|      0|    isaac_word c;
 3759|      0|    unsigned long tmp___1;
 3760|      0|    isaac_word d;
 3761|      0|    unsigned long tmp___2;
 3762|      0|    isaac_word e;
 3763|      0|    unsigned long tmp___3;
 3764|      0|    isaac_word f;
 3765|      0|    unsigned long tmp___4;
 3766|      0|    isaac_word g;
 3767|      0|    unsigned long tmp___5;
 3768|      0|    isaac_word h;
 3769|      0|    unsigned long tmp___6;
 3770|      0|    int i;
 3771|      0|    isaac_word tmp___7;
 3772|      0|    isaac_word tmp___8;
 3773|      0|    isaac_word tmp___9;
 3774|      0|    isaac_word tmp___10;
 3775|      0|    int i___0;
 3776|      0|    isaac_word tmp___11;
 3777|      0|    isaac_word tmp___12;
 3778|      0|    isaac_word tmp___13;
 3779|      0|    isaac_word tmp___14;
 3780|      0|    isaac_word tmp___15;
 3781|      0|    isaac_word tmp___16;
 3782|       |
 3783|      0|    {
 3784|      0|        if (1 << 6 == 32) {
 3785|      0|            tmp = 325574490UL;
 3786|      0|        }
 3787|      0|        else {
 3788|      0|            tmp = 7240739780546808700UL;
 3789|      0|        }
 3790|      0|        a = tmp;
 3791|      0|        if (1 << 6 == 32) {
 3792|      0|            tmp___0 = 2514026585UL;
 3793|      0|        }
 3794|      0|        else {
 3795|      0|            tmp___0 = 0xb9f8b322c73ac862UL;
 3796|      0|        }
 3797|      0|        b = tmp___0;
 3798|      0|        if (1 << 6 == 32) {
 3799|      0|            tmp___1 = 3273014859UL;
 3800|      0|        }
 3801|      0|        else {
 3802|      0|            tmp___1 = 0x8c0ea5053d4712a0UL;
 3803|      0|        }
 3804|      0|        c = tmp___1;
 3805|      0|        if (1 << 6 == 32) {
 3806|      0|            tmp___2 = 255990488UL;
 3807|      0|        }
 3808|      0|        else {
 3809|      0|            tmp___2 = 0xb29b2e824a595524UL;
 3810|      0|        }
 3811|      0|        d = tmp___2;
 3812|      0|        if (1 << 6 == 32) {
 3813|      0|            tmp___3 = 3643427448UL;
 3814|      0|        }
 3815|      0|        else {
 3816|      0|            tmp___3 = 0x82f053db8355e0ceUL;
 3817|      0|        }
 3818|      0|        e = tmp___3;
 3819|      0|        if (1 << 6 == 32) {
 3820|      0|            tmp___4 = 2769960009UL;
 3821|      0|        }
 3822|      0|        else {
 3823|      0|            tmp___4 = 5259722845879046933UL;
 3824|      0|        }
 3825|      0|        f = tmp___4;
 3826|      0|        if (1 << 6 == 32) {
 3827|      0|            tmp___5 = 3304057371UL;
 3828|      0|        }
 3829|      0|        else {
 3830|      0|            tmp___5 = 0xae985bf2cbfc89edUL;
 3831|      0|        }
 3832|      0|        g = tmp___5;
 3833|      0|        if (1 << 6 == 32) {
 3834|      0|            tmp___6 = 811634969UL;
 3835|      0|        }
 3836|      0|        else {
 3837|      0|            tmp___6 = 0x98f5704f6c44c0abUL;
 3838|      0|        }
 3839|      0|        h = tmp___6;
 3840|      0|        i = 0;
 3841|      0|        while (1) {
 3842|       |
 3843|      0|            if (!(i < 1 << 8)) {
 3844|      0|                goto while_break;
 3845|      0|            }
 3846|      0|            a += s->m[i];
 3847|      0|            b += s->m[i + 1];
 3848|      0|            c += s->m[i + 2];
 3849|      0|            d += s->m[i + 3];
 3850|      0|            e += s->m[i + 4];
 3851|      0|            f += s->m[i + 5];
 3852|      0|            g += s->m[i + 6];
 3853|      0|            h += s->m[i + 7];
 3854|      0|            a -= e;
 3855|      0|            tmp___7 = just(h);
 3856|      0|            f ^= tmp___7 >> 9;
 3857|      0|            h += a;
 3858|      0|            b -= f;
 3859|      0|            g ^= a << 9;
 3860|      0|            a += b;
 3861|      0|            c -= g;
 3862|      0|            tmp___8 = just(b);
 3863|      0|            h ^= tmp___8 >> 23;
 3864|      0|            b += c;
 3865|      0|            d -= h;
 3866|      0|            a ^= c << 15;
 3867|      0|            c += d;
 3868|      0|            e -= a;
 3869|      0|            tmp___9 = just(d);
 3870|      0|            b ^= tmp___9 >> 14;
 3871|      0|            d += e;
 3872|      0|            f -= b;
 3873|      0|            c ^= e << 20;
 3874|      0|            e += f;
 3875|      0|            g -= c;
 3876|      0|            tmp___10 = just(f);
 3877|      0|            d ^= tmp___10 >> 17;
 3878|      0|            f += g;
 3879|      0|            h -= d;
 3880|      0|            e ^= g << 14;
 3881|      0|            g += h;
 3882|      0|            s->m[i] = a;
 3883|      0|            s->m[i + 1] = b;
 3884|      0|            s->m[i + 2] = c;
 3885|      0|            s->m[i + 3] = d;
 3886|      0|            s->m[i + 4] = e;
 3887|      0|            s->m[i + 5] = f;
 3888|      0|            s->m[i + 6] = g;
 3889|      0|            s->m[i + 7] = h;
 3890|      0|            i += 8;
 3891|      0|        }
 3892|      0|while_break:
 3893|      0|        i___0 = 0;
 3894|      0|        while (1) {
 3895|       |
 3896|      0|            if (!(i___0 < 1 << 8)) {
 3897|      0|                goto while_break___0;
 3898|      0|            }
 3899|      0|            a += s->m[i___0];
 3900|      0|            b += s->m[i___0 + 1];
 3901|      0|            c += s->m[i___0 + 2];
 3902|      0|            d += s->m[i___0 + 3];
 3903|      0|            e += s->m[i___0 + 4];
 3904|      0|            f += s->m[i___0 + 5];
 3905|      0|            g += s->m[i___0 + 6];
 3906|      0|            h += s->m[i___0 + 7];
 3907|      0|            a -= e;
 3908|      0|            tmp___11 = just(h);
 3909|      0|            f ^= tmp___11 >> 9;
 3910|      0|            h += a;
 3911|      0|            b -= f;
 3912|      0|            g ^= a << 9;
 3913|      0|            a += b;
 3914|      0|            c -= g;
 3915|      0|            tmp___12 = just(b);
 3916|      0|            h ^= tmp___12 >> 23;
 3917|      0|            b += c;
 3918|      0|            d -= h;
 3919|      0|            a ^= c << 15;
 3920|      0|            c += d;
 3921|      0|            e -= a;
 3922|      0|            tmp___13 = just(d);
 3923|      0|            b ^= tmp___13 >> 14;
 3924|      0|            d += e;
 3925|      0|            f -= b;
 3926|      0|            c ^= e << 20;
 3927|      0|            e += f;
 3928|      0|            g -= c;
 3929|      0|            tmp___14 = just(f);
 3930|      0|            d ^= tmp___14 >> 17;
 3931|      0|            f += g;
 3932|      0|            h -= d;
 3933|      0|            e ^= g << 14;
 3934|      0|            g += h;
 3935|      0|            s->m[i___0] = a;
 3936|      0|            s->m[i___0 + 1] = b;
 3937|      0|            s->m[i___0 + 2] = c;
 3938|      0|            s->m[i___0 + 3] = d;
 3939|      0|            s->m[i___0 + 4] = e;
 3940|      0|            s->m[i___0 + 5] = f;
 3941|      0|            s->m[i___0 + 6] = g;
 3942|      0|            s->m[i___0 + 7] = h;
 3943|      0|            i___0 += 8;
 3944|      0|        }
 3945|      0|while_break___0:
 3946|      0|        tmp___16 = (isaac_word)0;
 3947|      0|        s->c = tmp___16;
 3948|      0|        tmp___15 = tmp___16;
 3949|      0|        s->b = tmp___15;
 3950|      0|        s->a = tmp___15;
 3951|      0|        return;
 3952|      0|    }
 3953|      0|}
 3954|       |#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
 3955|       |char const *const quoting_style_args[9];
 3956|       |enum quoting_style const quoting_style_vals[8];
 3957|       |int set_char_quoting(struct quoting_options *o, char c, int i);
 3958|       |char *quotearg_char(char const *arg, char ch);
 3959|       |char *quotearg_char_mem(char const *arg, size_t argsize, char ch);
 3960|       |struct quoting_options quote_quoting_options;
 3961|       |__inline static char *xcharalloc(size_t n)
 3962|       |__attribute__((__malloc__, __alloc_size__(1)));
 3963|       |__inline static char *xcharalloc(size_t n)
 3964|       |__attribute__((__malloc__, __alloc_size__(1)));
 3965|       |__inline static char *xcharalloc(size_t n)
 3966|      0|{
 3967|      0|    void *tmp;
 3968|      0|    void *tmp___0;
 3969|      0|    void *tmp___1;
 3970|       |
 3971|      0|    {
 3972|      0|        if (sizeof(char) == 1UL) {
 3973|      0|            tmp = xmalloc(n);
 3974|      0|            tmp___1 = tmp;
 3975|      0|        }
 3976|      0|        else {
 3977|      0|            tmp___0 = xnmalloc(n, sizeof(char));
 3978|      0|            tmp___1 = tmp___0;
 3979|      0|        }
 3980|      0|        return ((char *)tmp___1);
 3981|      0|    }
 3982|      0|}
 3983|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) iswprint)(
 3984|       |    wint_t __wc);
 3985|       |char const *const quoting_style_args[9] = {
 3986|       |    "literal", "shell",   "shell-always", "c", "c-maybe", "escape",
 3987|       |    "locale",  "clocale", (char const *)0
 3988|       |};
 3989|       |enum quoting_style const quoting_style_vals[8] = {
 3990|       |    (enum quoting_style const)0, (enum quoting_style const)1,
 3991|       |    (enum quoting_style const)2, (enum quoting_style const)3,
 3992|       |    (enum quoting_style const)4, (enum quoting_style const)5,
 3993|       |    (enum quoting_style const)6, (enum quoting_style const)7
 3994|       |};
 3995|       |static struct quoting_options default_quoting_options;
 3996|       |int set_char_quoting(struct quoting_options *o, char c, int i)
 3997|      0|{
 3998|      0|    unsigned char uc;
 3999|      0|    unsigned int *p;
 4000|      0|    struct quoting_options *tmp;
 4001|      0|    int shift;
 4002|      0|    int r;
 4003|       |
 4004|      0|    {
 4005|      0|        uc = (unsigned char)c;
 4006|      0|        if (o) {
 4007|      0|            tmp = o;
 4008|      0|        }
 4009|      0|        else {
 4010|      0|            tmp = &default_quoting_options;
 4011|      0|        }
 4012|      0|        p = tmp->quote_these_too + (unsigned long)uc / (sizeof(int) * 8UL);
 4013|      0|        shift = (int)((unsigned long)uc % (sizeof(int) * 8UL));
 4014|      0|        r = (int)((*p >> shift) & 1U);
 4015|      0|        *p ^= (unsigned int)(((i & 1) ^ r) << shift);
 4016|      0|        return (r);
 4017|      0|    }
 4018|      0|}
 4019|       |static struct quoting_options
 4020|       |quoting_options_from_style(enum quoting_style style)
 4021|      0|{
 4022|      0|    struct quoting_options o;
 4023|      0|    unsigned int tmp;
 4024|       |
 4025|      0|    {
 4026|      0|        o.style = (enum quoting_style)0;
 4027|      0|        o.flags = 0;
 4028|      0|        o.quote_these_too[0] = 0U;
 4029|      0|        tmp = 1U;
 4030|      0|        while (1) {
 4031|       |
 4032|      0|            if (!(!(tmp >= 8U))) {
 4033|      0|                goto while_break;
 4034|      0|            }
 4035|      0|            o.quote_these_too[tmp] = 0U;
 4036|      0|            tmp++;
 4037|      0|        }
 4038|      0|while_break:
 4039|      0|        o.left_quote = (char const *)((void *)0);
 4040|      0|        o.right_quote = (char const *)((void *)0);
 4041|      0|        if ((unsigned int)style == 8U) {
 4042|      0|            abort();
 4043|      0|        }
 4044|      0|        o.style = style;
 4045|      0|        return (o);
 4046|      0|    }
 4047|      0|}
 4048|       |static char const *gettext_quote(char const *msgid, enum quoting_style s)
 4049|      0|{
 4050|      0|    char const *translation;
 4051|      0|    char const *tmp;
 4052|      0|    char const *locale_code;
 4053|      0|    char const *tmp___0;
 4054|      0|    int tmp___1;
 4055|      0|    char const *tmp___2;
 4056|      0|    int tmp___3;
 4057|      0|    char const *tmp___4;
 4058|       |
 4059|      0|    {
 4060|      0|        tmp = (char const *)gettext(msgid);
 4061|      0|        translation = tmp;
 4062|      0|        if ((unsigned long)translation != (unsigned long)msgid) {
 4063|      0|            return (translation);
 4064|      0|        }
 4065|      0|        locale_code = locale_charset();
 4066|      0|        tmp___1 = c_strcasecmp(locale_code, "UTF-8");
 4067|      0|        if (tmp___1 == 0) {
 4068|      0|            if ((int const) * (msgid + 0) == 96) {
 4069|      0|                tmp___0 = "\342\200\230";
 4070|      0|            }
 4071|      0|            else {
 4072|      0|                tmp___0 = "\342\200\231";
 4073|      0|            }
 4074|      0|            return (tmp___0);
 4075|      0|        }
 4076|      0|        tmp___3 = c_strcasecmp(locale_code, "GB18030");
 4077|      0|        if (tmp___3 == 0) {
 4078|      0|            if ((int const) * (msgid + 0) == 96) {
 4079|      0|                tmp___2 = "\241\ae";
 4080|      0|            }
 4081|      0|            else {
 4082|      0|                tmp___2 = "\241\257";
 4083|      0|            }
 4084|      0|            return (tmp___2);
 4085|      0|        }
 4086|      0|        if ((unsigned int)s == 7U) {
 4087|      0|            tmp___4 = "\"";
 4088|      0|        }
 4089|      0|        else {
 4090|      0|            tmp___4 = "\'";
 4091|      0|        }
 4092|      0|        return (tmp___4);
 4093|      0|    }
 4094|      0|}
 4095|       |static size_t
 4096|       |quotearg_buffer_restyled(char *buffer, size_t buffersize, char const *arg,
 4097|       |                         size_t argsize, enum quoting_style quoting_style,
 4098|       |                         int flags, unsigned int const *quote_these_too,
 4099|       |                         char const *left_quote, char const *right_quote)
 4100|      0|{
 4101|      0|    size_t i;
 4102|      0|    size_t len;
 4103|      0|    char const *quote_string;
 4104|      0|    size_t quote_string_len;
 4105|      0|    _Bool backslash_escapes;
 4106|      0|    _Bool unibyte_locale;
 4107|      0|    size_t tmp;
 4108|      0|    _Bool elide_outer_quotes;
 4109|      0|    unsigned char c;
 4110|      0|    unsigned char esc;
 4111|      0|    _Bool is_right_quote;
 4112|      0|    int tmp___0;
 4113|      0|    int tmp___1;
 4114|      0|    size_t m;
 4115|      0|    _Bool printable;
 4116|      0|    unsigned short const **tmp___2;
 4117|      0|    mbstate_t mbstate;
 4118|      0|    wchar_t w;
 4119|      0|    size_t bytes;
 4120|      0|    size_t tmp___3;
 4121|      0|    size_t j;
 4122|      0|    int tmp___4;
 4123|      0|    int tmp___5;
 4124|      0|    size_t ilim;
 4125|      0|    int tmp___6;
 4126|      0|    size_t tmp___7;
 4127|       |
 4128|      0|    {
 4129|      0|        len = (size_t)0;
 4130|      0|        quote_string = (char const *)0;
 4131|      0|        quote_string_len = (size_t)0;
 4132|      0|        backslash_escapes = (_Bool)0;
 4133|      0|        tmp = __ctype_get_mb_cur_max();
 4134|      0|        unibyte_locale = (_Bool)(tmp == 1UL);
 4135|      0|        elide_outer_quotes = (_Bool)((flags & 2) != 0);
 4136|      0|        if ((unsigned int)quoting_style == 4U) {
 4137|      0|            goto case_4;
 4138|      0|        }
 4139|      0|        if ((unsigned int)quoting_style == 3U) {
 4140|      0|            goto case_3;
 4141|      0|        }
 4142|      0|        if ((unsigned int)quoting_style == 5U) {
 4143|      0|            goto case_5;
 4144|      0|        }
 4145|      0|        if ((unsigned int)quoting_style == 6U) {
 4146|      0|            goto case_6;
 4147|      0|        }
 4148|      0|        if ((unsigned int)quoting_style == 7U) {
 4149|      0|            goto case_6;
 4150|      0|        }
 4151|      0|        if ((unsigned int)quoting_style == 8U) {
 4152|      0|            goto case_6;
 4153|      0|        }
 4154|      0|        if ((unsigned int)quoting_style == 1U) {
 4155|      0|            goto case_1;
 4156|      0|        }
 4157|      0|        if ((unsigned int)quoting_style == 2U) {
 4158|      0|            goto case_2;
 4159|      0|        }
 4160|      0|        if ((unsigned int)quoting_style == 0U) {
 4161|      0|            goto case_0;
 4162|      0|        }
 4163|      0|        goto switch_default;
 4164|      0|case_4:
 4165|      0|        quoting_style = (enum quoting_style)3;
 4166|      0|        elide_outer_quotes = (_Bool)1;
 4167|      0|case_3:
 4168|      0|        if (!elide_outer_quotes) {
 4169|      0|            while (1) {
 4170|       |
 4171|      0|                if (len < buffersize) {
 4172|      0|                    *(buffer + len) = (char)'\"';
 4173|      0|                }
 4174|      0|                len++;
 4175|      0|                goto while_break;
 4176|      0|            }
 4177|      0|while_break:
 4178|      0|            ;
 4179|      0|        }
 4180|      0|        backslash_escapes = (_Bool)1;
 4181|      0|        quote_string = "\"";
 4182|      0|        quote_string_len = (size_t)1;
 4183|      0|        goto switch_break;
 4184|      0|case_5:
 4185|      0|        backslash_escapes = (_Bool)1;
 4186|      0|        elide_outer_quotes = (_Bool)0;
 4187|      0|        goto switch_break;
 4188|      0|case_6:
 4189|      0|        if ((unsigned int)quoting_style != 8U) {
 4190|      0|            left_quote = gettext_quote("`", quoting_style);
 4191|      0|            right_quote = gettext_quote("\'", quoting_style);
 4192|      0|        }
 4193|      0|        if (!elide_outer_quotes) {
 4194|      0|            quote_string = left_quote;
 4195|      0|            while (1) {
 4196|       |
 4197|      0|                if (!*quote_string) {
 4198|      0|                    goto while_break___0;
 4199|      0|                }
 4200|      0|                while (1) {
 4201|       |
 4202|      0|                    if (len < buffersize) {
 4203|      0|                        *(buffer + len) = (char)*quote_string;
 4204|      0|                    }
 4205|      0|                    len++;
 4206|      0|                    goto while_break___1;
 4207|      0|                }
 4208|      0|while_break___1:
 4209|      0|                quote_string++;
 4210|      0|            }
 4211|      0|while_break___0:
 4212|      0|            ;
 4213|      0|        }
 4214|      0|        backslash_escapes = (_Bool)1;
 4215|      0|        quote_string = right_quote;
 4216|      0|        quote_string_len = strlen(quote_string);
 4217|      0|        goto switch_break;
 4218|      0|case_1:
 4219|      0|        quoting_style = (enum quoting_style)2;
 4220|      0|        elide_outer_quotes = (_Bool)1;
 4221|      0|case_2:
 4222|      0|        if (!elide_outer_quotes) {
 4223|      0|            while (1) {
 4224|       |
 4225|      0|                if (len < buffersize) {
 4226|      0|                    *(buffer + len) = (char)'\'';
 4227|      0|                }
 4228|      0|                len++;
 4229|      0|                goto while_break___2;
 4230|      0|            }
 4231|      0|while_break___2:
 4232|      0|            ;
 4233|      0|        }
 4234|      0|        quote_string = "\'";
 4235|      0|        quote_string_len = (size_t)1;
 4236|      0|        goto switch_break;
 4237|      0|case_0:
 4238|      0|        elide_outer_quotes = (_Bool)0;
 4239|      0|        goto switch_break;
 4240|      0|switch_default:
 4241|      0|        abort();
 4242|      0|switch_break:
 4243|      0|        i = (size_t)0;
 4244|      0|        while (1) {
 4245|       |
 4246|      0|            if (argsize == 0xffffffffffffffffUL) {
 4247|      0|                tmp___6 = (int const) * (arg + i) == 0;
 4248|      0|            }
 4249|      0|            else {
 4250|      0|                tmp___6 = i == argsize;
 4251|      0|            }
 4252|      0|            if (tmp___6) {
 4253|      0|                goto while_break___3;
 4254|      0|            }
 4255|      0|            is_right_quote = (_Bool)0;
 4256|      0|            if (backslash_escapes) {
 4257|      0|                if (quote_string_len) {
 4258|      0|                    if (i + quote_string_len <= argsize) {
 4259|      0|                        tmp___0 = memcmp((void const *)(arg + i),
 4260|      0|                                         (void const *)quote_string, quote_string_len);
 4261|      0|                        if (tmp___0 == 0) {
 4262|      0|                            if (elide_outer_quotes) {
 4263|      0|                                goto force_outer_quoting_style;
 4264|      0|                            }
 4265|      0|                            is_right_quote = (_Bool)1;
 4266|      0|                        }
 4267|      0|                    }
 4268|      0|                }
 4269|      0|            }
 4270|      0|            c = (unsigned char)*(arg + i);
 4271|      0|            if ((int)c == 0) {
 4272|      0|                goto case_0___0;
 4273|      0|            }
 4274|      0|            if ((int)c == 63) {
 4275|      0|                goto case_63;
 4276|      0|            }
 4277|      0|            if ((int)c == 7) {
 4278|      0|                goto case_7___0;
 4279|      0|            }
 4280|      0|            if ((int)c == 8) {
 4281|      0|                goto case_8___0;
 4282|      0|            }
 4283|      0|            if ((int)c == 12) {
 4284|      0|                goto case_12;
 4285|      0|            }
 4286|      0|            if ((int)c == 10) {
 4287|      0|                goto case_10;
 4288|      0|            }
 4289|      0|            if ((int)c == 13) {
 4290|      0|                goto case_13;
 4291|      0|            }
 4292|      0|            if ((int)c == 9) {
 4293|      0|                goto case_9;
 4294|      0|            }
 4295|      0|            if ((int)c == 11) {
 4296|      0|                goto case_11;
 4297|      0|            }
 4298|      0|            if ((int)c == 92) {
 4299|      0|                goto case_92;
 4300|      0|            }
 4301|      0|            if ((int)c == 123) {
 4302|      0|                goto case_123;
 4303|      0|            }
 4304|      0|            if ((int)c == 125) {
 4305|      0|                goto case_123;
 4306|      0|            }
 4307|      0|            if ((int)c == 35) {
 4308|      0|                goto case_35;
 4309|      0|            }
 4310|      0|            if ((int)c == 126) {
 4311|      0|                goto case_35;
 4312|      0|            }
 4313|      0|            if ((int)c == 32) {
 4314|      0|                goto case_32;
 4315|      0|            }
 4316|      0|            if ((int)c == 33) {
 4317|      0|                goto case_32;
 4318|      0|            }
 4319|      0|            if ((int)c == 34) {
 4320|      0|                goto case_32;
 4321|      0|            }
 4322|      0|            if ((int)c == 36) {
 4323|      0|                goto case_32;
 4324|      0|            }
 4325|      0|            if ((int)c == 38) {
 4326|      0|                goto case_32;
 4327|      0|            }
 4328|      0|            if ((int)c == 40) {
 4329|      0|                goto case_32;
 4330|      0|            }
 4331|      0|            if ((int)c == 41) {
 4332|      0|                goto case_32;
 4333|      0|            }
 4334|      0|            if ((int)c == 42) {
 4335|      0|                goto case_32;
 4336|      0|            }
 4337|      0|            if ((int)c == 59) {
 4338|      0|                goto case_32;
 4339|      0|            }
 4340|      0|            if ((int)c == 60) {
 4341|      0|                goto case_32;
 4342|      0|            }
 4343|      0|            if ((int)c == 61) {
 4344|      0|                goto case_32;
 4345|      0|            }
 4346|      0|            if ((int)c == 62) {
 4347|      0|                goto case_32;
 4348|      0|            }
 4349|      0|            if ((int)c == 91) {
 4350|      0|                goto case_32;
 4351|      0|            }
 4352|      0|            if ((int)c == 94) {
 4353|      0|                goto case_32;
 4354|      0|            }
 4355|      0|            if ((int)c == 96) {
 4356|      0|                goto case_32;
 4357|      0|            }
 4358|      0|            if ((int)c == 124) {
 4359|      0|                goto case_32;
 4360|      0|            }
 4361|      0|            if ((int)c == 39) {
 4362|      0|                goto case_39___0;
 4363|      0|            }
 4364|      0|            if ((int)c == 37) {
 4365|      0|                goto case_37;
 4366|      0|            }
 4367|      0|            if ((int)c == 43) {
 4368|      0|                goto case_37;
 4369|      0|            }
 4370|      0|            if ((int)c == 44) {
 4371|      0|                goto case_37;
 4372|      0|            }
 4373|      0|            if ((int)c == 45) {
 4374|      0|                goto case_37;
 4375|      0|            }
 4376|      0|            if ((int)c == 46) {
 4377|      0|                goto case_37;
 4378|      0|            }
 4379|      0|            if ((int)c == 47) {
 4380|      0|                goto case_37;
 4381|      0|            }
 4382|      0|            if ((int)c == 48) {
 4383|      0|                goto case_37;
 4384|      0|            }
 4385|      0|            if ((int)c == 49) {
 4386|      0|                goto case_37;
 4387|      0|            }
 4388|      0|            if ((int)c == 50) {
 4389|      0|                goto case_37;
 4390|      0|            }
 4391|      0|            if ((int)c == 51) {
 4392|      0|                goto case_37;
 4393|      0|            }
 4394|      0|            if ((int)c == 52) {
 4395|      0|                goto case_37;
 4396|      0|            }
 4397|      0|            if ((int)c == 53) {
 4398|      0|                goto case_37;
 4399|      0|            }
 4400|      0|            if ((int)c == 54) {
 4401|      0|                goto case_37;
 4402|      0|            }
 4403|      0|            if ((int)c == 55) {
 4404|      0|                goto case_37;
 4405|      0|            }
 4406|      0|            if ((int)c == 56) {
 4407|      0|                goto case_37;
 4408|      0|            }
 4409|      0|            if ((int)c == 57) {
 4410|      0|                goto case_37;
 4411|      0|            }
 4412|      0|            if ((int)c == 58) {
 4413|      0|                goto case_37;
 4414|      0|            }
 4415|      0|            if ((int)c == 65) {
 4416|      0|                goto case_37;
 4417|      0|            }
 4418|      0|            if ((int)c == 66) {
 4419|      0|                goto case_37;
 4420|      0|            }
 4421|      0|            if ((int)c == 67) {
 4422|      0|                goto case_37;
 4423|      0|            }
 4424|      0|            if ((int)c == 68) {
 4425|      0|                goto case_37;
 4426|      0|            }
 4427|      0|            if ((int)c == 69) {
 4428|      0|                goto case_37;
 4429|      0|            }
 4430|      0|            if ((int)c == 70) {
 4431|      0|                goto case_37;
 4432|      0|            }
 4433|      0|            if ((int)c == 71) {
 4434|      0|                goto case_37;
 4435|      0|            }
 4436|      0|            if ((int)c == 72) {
 4437|      0|                goto case_37;
 4438|      0|            }
 4439|      0|            if ((int)c == 73) {
 4440|      0|                goto case_37;
 4441|      0|            }
 4442|      0|            if ((int)c == 74) {
 4443|      0|                goto case_37;
 4444|      0|            }
 4445|      0|            if ((int)c == 75) {
 4446|      0|                goto case_37;
 4447|      0|            }
 4448|      0|            if ((int)c == 76) {
 4449|      0|                goto case_37;
 4450|      0|            }
 4451|      0|            if ((int)c == 77) {
 4452|      0|                goto case_37;
 4453|      0|            }
 4454|      0|            if ((int)c == 78) {
 4455|      0|                goto case_37;
 4456|      0|            }
 4457|      0|            if ((int)c == 79) {
 4458|      0|                goto case_37;
 4459|      0|            }
 4460|      0|            if ((int)c == 80) {
 4461|      0|                goto case_37;
 4462|      0|            }
 4463|      0|            if ((int)c == 81) {
 4464|      0|                goto case_37;
 4465|      0|            }
 4466|      0|            if ((int)c == 82) {
 4467|      0|                goto case_37;
 4468|      0|            }
 4469|      0|            if ((int)c == 83) {
 4470|      0|                goto case_37;
 4471|      0|            }
 4472|      0|            if ((int)c == 84) {
 4473|      0|                goto case_37;
 4474|      0|            }
 4475|      0|            if ((int)c == 85) {
 4476|      0|                goto case_37;
 4477|      0|            }
 4478|      0|            if ((int)c == 86) {
 4479|      0|                goto case_37;
 4480|      0|            }
 4481|      0|            if ((int)c == 87) {
 4482|      0|                goto case_37;
 4483|      0|            }
 4484|      0|            if ((int)c == 88) {
 4485|      0|                goto case_37;
 4486|      0|            }
 4487|      0|            if ((int)c == 89) {
 4488|      0|                goto case_37;
 4489|      0|            }
 4490|      0|            if ((int)c == 90) {
 4491|      0|                goto case_37;
 4492|      0|            }
 4493|      0|            if ((int)c == 93) {
 4494|      0|                goto case_37;
 4495|      0|            }
 4496|      0|            if ((int)c == 95) {
 4497|      0|                goto case_37;
 4498|      0|            }
 4499|      0|            if ((int)c == 97) {
 4500|      0|                goto case_37;
 4501|      0|            }
 4502|      0|            if ((int)c == 98) {
 4503|      0|                goto case_37;
 4504|      0|            }
 4505|      0|            if ((int)c == 99) {
 4506|      0|                goto case_37;
 4507|      0|            }
 4508|      0|            if ((int)c == 100) {
 4509|      0|                goto case_37;
 4510|      0|            }
 4511|      0|            if ((int)c == 101) {
 4512|      0|                goto case_37;
 4513|      0|            }
 4514|      0|            if ((int)c == 102) {
 4515|      0|                goto case_37;
 4516|      0|            }
 4517|      0|            if ((int)c == 103) {
 4518|      0|                goto case_37;
 4519|      0|            }
 4520|      0|            if ((int)c == 104) {
 4521|      0|                goto case_37;
 4522|      0|            }
 4523|      0|            if ((int)c == 105) {
 4524|      0|                goto case_37;
 4525|      0|            }
 4526|      0|            if ((int)c == 106) {
 4527|      0|                goto case_37;
 4528|      0|            }
 4529|      0|            if ((int)c == 107) {
 4530|      0|                goto case_37;
 4531|      0|            }
 4532|      0|            if ((int)c == 108) {
 4533|      0|                goto case_37;
 4534|      0|            }
 4535|      0|            if ((int)c == 109) {
 4536|      0|                goto case_37;
 4537|      0|            }
 4538|      0|            if ((int)c == 110) {
 4539|      0|                goto case_37;
 4540|      0|            }
 4541|      0|            if ((int)c == 111) {
 4542|      0|                goto case_37;
 4543|      0|            }
 4544|      0|            if ((int)c == 112) {
 4545|      0|                goto case_37;
 4546|      0|            }
 4547|      0|            if ((int)c == 113) {
 4548|      0|                goto case_37;
 4549|      0|            }
 4550|      0|            if ((int)c == 114) {
 4551|      0|                goto case_37;
 4552|      0|            }
 4553|      0|            if ((int)c == 115) {
 4554|      0|                goto case_37;
 4555|      0|            }
 4556|      0|            if ((int)c == 116) {
 4557|      0|                goto case_37;
 4558|      0|            }
 4559|      0|            if ((int)c == 117) {
 4560|      0|                goto case_37;
 4561|      0|            }
 4562|      0|            if ((int)c == 118) {
 4563|      0|                goto case_37;
 4564|      0|            }
 4565|      0|            if ((int)c == 119) {
 4566|      0|                goto case_37;
 4567|      0|            }
 4568|      0|            if ((int)c == 120) {
 4569|      0|                goto case_37;
 4570|      0|            }
 4571|      0|            if ((int)c == 121) {
 4572|      0|                goto case_37;
 4573|      0|            }
 4574|      0|            if ((int)c == 122) {
 4575|      0|                goto case_37;
 4576|      0|            }
 4577|      0|            goto switch_default___2;
 4578|      0|case_0___0:
 4579|      0|            if (backslash_escapes) {
 4580|      0|                if (elide_outer_quotes) {
 4581|      0|                    goto force_outer_quoting_style;
 4582|      0|                }
 4583|      0|                while (1) {
 4584|       |
 4585|      0|                    if (len < buffersize) {
 4586|      0|                        *(buffer + len) = (char)'\\';
 4587|      0|                    }
 4588|      0|                    len++;
 4589|      0|                    goto while_break___4;
 4590|      0|                }
 4591|      0|while_break___4:
 4592|      0|                ;
 4593|      0|                if (i + 1UL < argsize) {
 4594|      0|                    if (48 <= (int)*(arg + (i + 1UL))) {
 4595|      0|                        if ((int const) * (arg + (i + 1UL)) <= 57) {
 4596|      0|                            while (1) {
 4597|       |
 4598|      0|                                if (len < buffersize) {
 4599|      0|                                    *(buffer + len) = (char)'0';
 4600|      0|                                }
 4601|      0|                                len++;
 4602|      0|                                goto while_break___5;
 4603|      0|                            }
 4604|      0|while_break___5:
 4605|      0|                            ;
 4606|      0|                            while (1) {
 4607|       |
 4608|      0|                                if (len < buffersize) {
 4609|      0|                                    *(buffer + len) = (char)'0';
 4610|      0|                                }
 4611|      0|                                len++;
 4612|      0|                                goto while_break___6;
 4613|      0|                            }
 4614|      0|while_break___6:
 4615|      0|                            ;
 4616|      0|                        }
 4617|      0|                    }
 4618|      0|                }
 4619|      0|                c = (unsigned char)'0';
 4620|      0|            }
 4621|      0|            else {
 4622|      0|                if (flags & 1) {
 4623|      0|                    goto __Cont;
 4624|      0|                }
 4625|      0|            }
 4626|      0|            goto switch_break___0;
 4627|      0|case_63:
 4628|      0|            if ((unsigned int)quoting_style == 2U) {
 4629|      0|                goto case_2___0;
 4630|      0|            }
 4631|      0|            if ((unsigned int)quoting_style == 3U) {
 4632|      0|                goto case_3___0;
 4633|      0|            }
 4634|      0|            goto switch_default___1;
 4635|      0|case_2___0:
 4636|      0|            if (elide_outer_quotes) {
 4637|      0|                goto force_outer_quoting_style;
 4638|      0|            }
 4639|      0|            goto switch_break___1;
 4640|      0|case_3___0:
 4641|      0|            if (flags & 4) {
 4642|      0|                if (i + 2UL < argsize) {
 4643|      0|                    if ((int const) * (arg + (i + 1UL)) == 63) {
 4644|      0|                        if ((int const) * (arg + (i + 2UL)) == 33) {
 4645|      0|                            goto case_33;
 4646|      0|                        }
 4647|      0|                        if ((int const) * (arg + (i + 2UL)) == 39) {
 4648|      0|                            goto case_33;
 4649|      0|                        }
 4650|      0|                        if ((int const) * (arg + (i + 2UL)) == 40) {
 4651|      0|                            goto case_33;
 4652|      0|                        }
 4653|      0|                        if ((int const) * (arg + (i + 2UL)) == 41) {
 4654|      0|                            goto case_33;
 4655|      0|                        }
 4656|      0|                        if ((int const) * (arg + (i + 2UL)) == 45) {
 4657|      0|                            goto case_33;
 4658|      0|                        }
 4659|      0|                        if ((int const) * (arg + (i + 2UL)) == 47) {
 4660|      0|                            goto case_33;
 4661|      0|                        }
 4662|      0|                        if ((int const) * (arg + (i + 2UL)) == 60) {
 4663|      0|                            goto case_33;
 4664|      0|                        }
 4665|      0|                        if ((int const) * (arg + (i + 2UL)) == 61) {
 4666|      0|                            goto case_33;
 4667|      0|                        }
 4668|      0|                        if ((int const) * (arg + (i + 2UL)) == 62) {
 4669|      0|                            goto case_33;
 4670|      0|                        }
 4671|      0|                        goto switch_default___0;
 4672|      0|case_33:
 4673|      0|                        if (elide_outer_quotes) {
 4674|      0|                            goto force_outer_quoting_style;
 4675|      0|                        }
 4676|      0|                        c = (unsigned char)*(arg + (i + 2UL));
 4677|      0|                        i += 2UL;
 4678|      0|                        while (1) {
 4679|       |
 4680|      0|                            if (len < buffersize) {
 4681|      0|                                *(buffer + len) = (char)'?';
 4682|      0|                            }
 4683|      0|                            len++;
 4684|      0|                            goto while_break___7;
 4685|      0|                        }
 4686|      0|while_break___7:
 4687|      0|                        ;
 4688|      0|                        while (1) {
 4689|       |
 4690|      0|                            if (len < buffersize) {
 4691|      0|                                *(buffer + len) = (char)'\"';
 4692|      0|                            }
 4693|      0|                            len++;
 4694|      0|                            goto while_break___8;
 4695|      0|                        }
 4696|      0|while_break___8:
 4697|      0|                        ;
 4698|      0|                        while (1) {
 4699|       |
 4700|      0|                            if (len < buffersize) {
 4701|      0|                                *(buffer + len) = (char)'\"';
 4702|      0|                            }
 4703|      0|                            len++;
 4704|      0|                            goto while_break___9;
 4705|      0|                        }
 4706|      0|while_break___9:
 4707|      0|                        ;
 4708|      0|                        while (1) {
 4709|       |
 4710|      0|                            if (len < buffersize) {
 4711|      0|                                *(buffer + len) = (char)'?';
 4712|      0|                            }
 4713|      0|                            len++;
 4714|      0|                            goto while_break___10;
 4715|      0|                        }
 4716|      0|while_break___10:
 4717|      0|                        ;
 4718|      0|                        goto switch_break___2;
 4719|      0|switch_default___0:
 4720|      0|                        goto switch_break___2;
 4721|      0|switch_break___2:
 4722|      0|                        ;
 4723|      0|                    }
 4724|      0|                }
 4725|      0|            }
 4726|      0|            goto switch_break___1;
 4727|      0|switch_default___1:
 4728|      0|            goto switch_break___1;
 4729|      0|switch_break___1:
 4730|      0|            ;
 4731|      0|            goto switch_break___0;
 4732|      0|case_7___0:
 4733|      0|            esc = (unsigned char)'a';
 4734|      0|            goto c_escape;
 4735|      0|case_8___0:
 4736|      0|            esc = (unsigned char)'b';
 4737|      0|            goto c_escape;
 4738|      0|case_12:
 4739|      0|            esc = (unsigned char)'f';
 4740|      0|            goto c_escape;
 4741|      0|case_10:
 4742|      0|            esc = (unsigned char)'n';
 4743|      0|            goto c_and_shell_escape;
 4744|      0|case_13:
 4745|      0|            esc = (unsigned char)'r';
 4746|      0|            goto c_and_shell_escape;
 4747|      0|case_9:
 4748|      0|            esc = (unsigned char)'t';
 4749|      0|            goto c_and_shell_escape;
 4750|      0|case_11:
 4751|      0|            esc = (unsigned char)'v';
 4752|      0|            goto c_escape;
 4753|      0|case_92:
 4754|      0|            esc = c;
 4755|      0|            if (backslash_escapes) {
 4756|      0|                if (elide_outer_quotes) {
 4757|      0|                    if (quote_string_len) {
 4758|      0|                        goto store_c;
 4759|      0|                    }
 4760|      0|                }
 4761|      0|            }
 4762|      0|c_and_shell_escape:
 4763|      0|            if ((unsigned int)quoting_style == 2U) {
 4764|      0|                if (elide_outer_quotes) {
 4765|      0|                    goto force_outer_quoting_style;
 4766|      0|                }
 4767|      0|            }
 4768|      0|c_escape:
 4769|      0|            if (backslash_escapes) {
 4770|      0|                c = esc;
 4771|      0|                goto store_escape;
 4772|      0|            }
 4773|      0|            goto switch_break___0;
 4774|      0|case_123:
 4775|      0|            if (argsize == 0xffffffffffffffffUL) {
 4776|      0|                tmp___1 = (int const) * (arg + 1) == 0;
 4777|      0|            }
 4778|      0|            else {
 4779|      0|                tmp___1 = argsize == 1UL;
 4780|      0|            }
 4781|      0|            if (!tmp___1) {
 4782|      0|                goto switch_break___0;
 4783|      0|            }
 4784|      0|case_35:
 4785|      0|            if (i != 0UL) {
 4786|      0|                goto switch_break___0;
 4787|      0|            }
 4788|      0|case_32:
 4789|      0|            if ((unsigned int)quoting_style == 2U) {
 4790|      0|                if (elide_outer_quotes) {
 4791|      0|                    goto force_outer_quoting_style;
 4792|      0|                }
 4793|      0|            }
 4794|      0|            goto switch_break___0;
 4795|      0|case_39___0:
 4796|      0|            if ((unsigned int)quoting_style == 2U) {
 4797|      0|                if (elide_outer_quotes) {
 4798|      0|                    goto force_outer_quoting_style;
 4799|      0|                }
 4800|      0|                while (1) {
 4801|       |
 4802|      0|                    if (len < buffersize) {
 4803|      0|                        *(buffer + len) = (char)'\'';
 4804|      0|                    }
 4805|      0|                    len++;
 4806|      0|                    goto while_break___11;
 4807|      0|                }
 4808|      0|while_break___11:
 4809|      0|                ;
 4810|      0|                while (1) {
 4811|       |
 4812|      0|                    if (len < buffersize) {
 4813|      0|                        *(buffer + len) = (char)'\\';
 4814|      0|                    }
 4815|      0|                    len++;
 4816|      0|                    goto while_break___12;
 4817|      0|                }
 4818|      0|while_break___12:
 4819|      0|                ;
 4820|      0|                while (1) {
 4821|       |
 4822|      0|                    if (len < buffersize) {
 4823|      0|                        *(buffer + len) = (char)'\'';
 4824|      0|                    }
 4825|      0|                    len++;
 4826|      0|                    goto while_break___13;
 4827|      0|                }
 4828|      0|while_break___13:
 4829|      0|                ;
 4830|      0|            }
 4831|      0|            goto switch_break___0;
 4832|      0|case_37:
 4833|      0|            goto switch_break___0;
 4834|      0|switch_default___2:
 4835|      0|            if (unibyte_locale) {
 4836|      0|                m = (size_t)1;
 4837|      0|                tmp___2 = __ctype_b_loc();
 4838|      0|                printable = (_Bool)(((int const) * (*tmp___2 + (int)c) & 16384) != 0);
 4839|      0|            }
 4840|      0|            else {
 4841|      0|                memset((void *)(&mbstate), 0, sizeof(mbstate));
 4842|      0|                m = (size_t)0;
 4843|      0|                printable = (_Bool)1;
 4844|      0|                if (argsize == 0xffffffffffffffffUL) {
 4845|      0|                    argsize = strlen(arg);
 4846|      0|                }
 4847|      0|                while (1) {
 4848|      0|                    tmp___3 = mbrtowc(&w, arg + (i + m), argsize - (i + m), &mbstate);
 4849|      0|                    bytes = tmp___3;
 4850|      0|                    if (bytes == 0UL) {
 4851|      0|                        goto while_break___14;
 4852|      0|                    }
 4853|      0|                    else {
 4854|      0|                        if (bytes == 0xffffffffffffffffUL) {
 4855|      0|                            printable = (_Bool)0;
 4856|      0|                            goto while_break___14;
 4857|      0|                        }
 4858|      0|                        else {
 4859|      0|                            if (bytes == 0xfffffffffffffffeUL) {
 4860|      0|                                printable = (_Bool)0;
 4861|      0|                                while (1) {
 4862|       |
 4863|      0|                                    if (i + m < argsize) {
 4864|      0|                                        if (!*(arg + (i + m))) {
 4865|      0|                                            goto while_break___15;
 4866|      0|                                        }
 4867|      0|                                    }
 4868|      0|                                    else {
 4869|      0|                                        goto while_break___15;
 4870|      0|                                    }
 4871|      0|                                    m++;
 4872|      0|                                }
 4873|      0|while_break___15:
 4874|      0|                                ;
 4875|      0|                                goto while_break___14;
 4876|      0|                            }
 4877|      0|                            else {
 4878|      0|                                if (elide_outer_quotes) {
 4879|      0|                                    if ((unsigned int)quoting_style == 2U) {
 4880|      0|                                        j = (size_t)1;
 4881|      0|                                        while (1) {
 4882|       |
 4883|      0|                                            if (!(j < bytes)) {
 4884|      0|                                                goto while_break___16;
 4885|      0|                                            }
 4886|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 91) {
 4887|      0|                                                goto case_91___0;
 4888|      0|                                            }
 4889|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 92) {
 4890|      0|                                                goto case_91___0;
 4891|      0|                                            }
 4892|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 94) {
 4893|      0|                                                goto case_91___0;
 4894|      0|                                            }
 4895|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 96) {
 4896|      0|                                                goto case_91___0;
 4897|      0|                                            }
 4898|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 124) {
 4899|      0|                                                goto case_91___0;
 4900|      0|                                            }
 4901|      0|                                            goto switch_default___3;
 4902|      0|case_91___0:
 4903|      0|                                            goto force_outer_quoting_style;
 4904|      0|switch_default___3:
 4905|      0|                                            goto switch_break___3;
 4906|      0|switch_break___3:
 4907|      0|                                            j++;
 4908|      0|                                        }
 4909|      0|while_break___16:
 4910|      0|                                        ;
 4911|      0|                                    }
 4912|      0|                                }
 4913|      0|                                tmp___4 = iswprint((wint_t)w);
 4914|      0|                                if (!tmp___4) {
 4915|      0|                                    printable = (_Bool)0;
 4916|      0|                                }
 4917|      0|                                m += bytes;
 4918|      0|                            }
 4919|      0|                        }
 4920|      0|                    }
 4921|      0|                    tmp___5 = mbsinit((mbstate_t const *)(&mbstate));
 4922|      0|                    if (tmp___5) {
 4923|      0|                        goto while_break___14;
 4924|      0|                    }
 4925|      0|                }
 4926|      0|while_break___14:
 4927|      0|                ;
 4928|      0|            }
 4929|      0|            if (1UL < m) {
 4930|      0|                goto _L___0;
 4931|      0|            }
 4932|      0|            else {
 4933|      0|                if (backslash_escapes) {
 4934|      0|                    if (!printable) {
 4935|      0|_L___0:
 4936|      0|                        ilim = i + m;
 4937|      0|                        while (1) {
 4938|       |
 4939|      0|                            if (backslash_escapes) {
 4940|      0|                                if (!printable) {
 4941|      0|                                    if (elide_outer_quotes) {
 4942|      0|                                        goto force_outer_quoting_style;
 4943|      0|                                    }
 4944|      0|                                    while (1) {
 4945|       |
 4946|      0|                                        if (len < buffersize) {
 4947|      0|                                            *(buffer + len) = (char)'\\';
 4948|      0|                                        }
 4949|      0|                                        len++;
 4950|      0|                                        goto while_break___18;
 4951|      0|                                    }
 4952|      0|while_break___18:
 4953|      0|                                    ;
 4954|      0|                                    while (1) {
 4955|       |
 4956|      0|                                        if (len < buffersize) {
 4957|      0|                                            *(buffer + len) = (char)(48 + ((int)c >> 6));
 4958|      0|                                        }
 4959|      0|                                        len++;
 4960|      0|                                        goto while_break___19;
 4961|      0|                                    }
 4962|      0|while_break___19:
 4963|      0|                                    ;
 4964|      0|                                    while (1) {
 4965|       |
 4966|      0|                                        if (len < buffersize) {
 4967|      0|                                            *(buffer + len) = (char)(48 + (((int)c >> 3) & 7));
 4968|      0|                                        }
 4969|      0|                                        len++;
 4970|      0|                                        goto while_break___20;
 4971|      0|                                    }
 4972|      0|while_break___20:
 4973|      0|                                    c = (unsigned char)(48 + ((int)c & 7));
 4974|      0|                                }
 4975|      0|                                else {
 4976|      0|                                    goto _L;
 4977|      0|                                }
 4978|      0|                            }
 4979|      0|                            else {
 4980|      0|_L:
 4981|      0|                                if (is_right_quote) {
 4982|      0|                                    while (1) {
 4983|       |
 4984|      0|                                        if (len < buffersize) {
 4985|      0|                                            *(buffer + len) = (char)'\\';
 4986|      0|                                        }
 4987|      0|                                        len++;
 4988|      0|                                        goto while_break___21;
 4989|      0|                                    }
 4990|      0|while_break___21:
 4991|      0|                                    is_right_quote = (_Bool)0;
 4992|      0|                                }
 4993|      0|                            }
 4994|      0|                            if (ilim <= i + 1UL) {
 4995|      0|                                goto while_break___17;
 4996|      0|                            }
 4997|      0|                            while (1) {
 4998|       |
 4999|      0|                                if (len < buffersize) {
 5000|      0|                                    *(buffer + len) = (char)c;
 5001|      0|                                }
 5002|      0|                                len++;
 5003|      0|                                goto while_break___22;
 5004|      0|                            }
 5005|      0|while_break___22:
 5006|      0|                            i++;
 5007|      0|                            c = (unsigned char)*(arg + i);
 5008|      0|                        }
 5009|      0|while_break___17:
 5010|      0|                        ;
 5011|      0|                        goto store_c;
 5012|      0|                    }
 5013|      0|                }
 5014|      0|            }
 5015|      0|switch_break___0:
 5016|      0|            ;
 5017|      0|            if (backslash_escapes) {
 5018|      0|                goto _L___3;
 5019|      0|            }
 5020|      0|            else {
 5021|      0|                if (elide_outer_quotes) {
 5022|      0|_L___3:
 5023|      0|                    if (quote_these_too) {
 5024|      0|                        if (!(*(quote_these_too + (unsigned long)c / (sizeof(int) * 8UL)) &
 5025|      0|                                (unsigned int const)(1 << (unsigned long)c %
 5026|      0|                                                     (sizeof(int) * 8UL)))) {
 5027|      0|                            goto _L___2;
 5028|      0|                        }
 5029|      0|                    }
 5030|      0|                    else {
 5031|      0|                        goto _L___2;
 5032|      0|                    }
 5033|      0|                }
 5034|      0|                else {
 5035|      0|_L___2:
 5036|      0|                    if (!is_right_quote) {
 5037|      0|                        goto store_c;
 5038|      0|                    }
 5039|      0|                }
 5040|      0|            }
 5041|      0|store_escape:
 5042|      0|            if (elide_outer_quotes) {
 5043|      0|                goto force_outer_quoting_style;
 5044|      0|            }
 5045|      0|            while (1) {
 5046|       |
 5047|      0|                if (len < buffersize) {
 5048|      0|                    *(buffer + len) = (char)'\\';
 5049|      0|                }
 5050|      0|                len++;
 5051|      0|                goto while_break___23;
 5052|      0|            }
 5053|      0|while_break___23:
 5054|      0|            ;
 5055|      0|store_c:
 5056|      0|            while (1) {
 5057|       |
 5058|      0|                if (len < buffersize) {
 5059|      0|                    *(buffer + len) = (char)c;
 5060|      0|                }
 5061|      0|                len++;
 5062|      0|                goto while_break___24;
 5063|      0|            }
 5064|      0|while_break___24:
 5065|      0|            ;
 5066|      0|__Cont:
 5067|      0|            i++;
 5068|      0|        }
 5069|      0|while_break___3:
 5070|      0|        ;
 5071|      0|        if (len == 0UL) {
 5072|      0|            if ((unsigned int)quoting_style == 2U) {
 5073|      0|                if (elide_outer_quotes) {
 5074|      0|                    goto force_outer_quoting_style;
 5075|      0|                }
 5076|      0|            }
 5077|      0|        }
 5078|      0|        if (quote_string) {
 5079|      0|            if (!elide_outer_quotes) {
 5080|      0|                while (1) {
 5081|       |
 5082|      0|                    if (!*quote_string) {
 5083|      0|                        goto while_break___25;
 5084|      0|                    }
 5085|      0|                    while (1) {
 5086|       |
 5087|      0|                        if (len < buffersize) {
 5088|      0|                            *(buffer + len) = (char)*quote_string;
 5089|      0|                        }
 5090|      0|                        len++;
 5091|      0|                        goto while_break___26;
 5092|      0|                    }
 5093|      0|while_break___26:
 5094|      0|                    quote_string++;
 5095|      0|                }
 5096|      0|while_break___25:
 5097|      0|                ;
 5098|      0|            }
 5099|      0|        }
 5100|      0|        if (len < buffersize) {
 5101|      0|            *(buffer + len) = (char)'\000';
 5102|      0|        }
 5103|      0|        return (len);
 5104|      0|force_outer_quoting_style:
 5105|      0|        tmp___7 = quotearg_buffer_restyled(
 5106|      0|                      buffer, buffersize, arg, argsize, quoting_style, flags & -3,
 5107|      0|                      (unsigned int const *)((void *)0), left_quote, right_quote);
 5108|      0|        return (tmp___7);
 5109|      0|    }
 5110|      0|}
 5111|       |static char slot0[256];
 5112|       |static unsigned int nslots = 1U;
 5113|       |static struct slotvec slotvec0 = {sizeof(slot0), slot0};
 5114|       |static struct slotvec *slotvec = &slotvec0;
 5115|       |static char *quotearg_n_options(int n, char const *arg, size_t argsize,
 5116|       |                                struct quoting_options const *options)
 5117|      0|{
 5118|      0|    int e;
 5119|      0|    int *tmp;
 5120|      0|    unsigned int n0;
 5121|      0|    struct slotvec *sv;
 5122|      0|    size_t n1;
 5123|      0|    _Bool preallocated;
 5124|      0|    int tmp___0;
 5125|      0|    struct slotvec *tmp___1;
 5126|      0|    size_t size;
 5127|      0|    char *val;
 5128|      0|    int flags;
 5129|      0|    size_t qsize;
 5130|      0|    size_t tmp___2;
 5131|      0|    int *tmp___3;
 5132|       |
 5133|      0|    {
 5134|      0|        tmp = __errno_location();
 5135|      0|        e = *tmp;
 5136|      0|        n0 = (unsigned int)n;
 5137|      0|        sv = slotvec;
 5138|      0|        if (n < 0) {
 5139|      0|            abort();
 5140|      0|        }
 5141|      0|        if (nslots <= n0) {
 5142|      0|            n1 = (size_t)(n0 + 1U);
 5143|      0|            preallocated = (_Bool)((unsigned long)sv == (unsigned long)(&slotvec0));
 5144|      0|            if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 5145|      0|                tmp___0 = -1;
 5146|      0|            }
 5147|      0|            else {
 5148|      0|                tmp___0 = -2;
 5149|      0|            }
 5150|      0|            if ((size_t)tmp___0 / sizeof(*sv) < n1) {
 5151|      0|                xalloc_die();
 5152|      0|            }
 5153|      0|            if (preallocated) {
 5154|      0|                tmp___1 = (struct slotvec *)((void *)0);
 5155|      0|            }
 5156|      0|            else {
 5157|      0|                tmp___1 = sv;
 5158|      0|            }
 5159|      0|            sv = (struct slotvec *)xrealloc((void *)tmp___1, n1 * sizeof(*sv));
 5160|      0|            slotvec = sv;
 5161|      0|            if (preallocated) {
 5162|      0|                *sv = slotvec0;
 5163|      0|            }
 5164|      0|            memset((void *)(sv + nslots), 0, (n1 - (size_t)nslots) * sizeof(*sv));
 5165|      0|            nslots = (unsigned int)n1;
 5166|      0|        }
 5167|      0|        size = (sv + n)->size;
 5168|      0|        val = (sv + n)->val;
 5169|      0|        flags = (int)(options->flags | 1);
 5170|      0|        tmp___2 = quotearg_buffer_restyled(
 5171|      0|                      val, size, arg, argsize, (enum quoting_style)options->style, flags,
 5172|      0|                      (unsigned int const *)(options->quote_these_too),
 5173|      0|                      (char const *)options->left_quote, (char const *)options->right_quote);
 5174|      0|        qsize = tmp___2;
 5175|      0|        if (size <= qsize) {
 5176|      0|            size = qsize + 1UL;
 5177|      0|            (sv + n)->size = size;
 5178|      0|            if ((unsigned long)val != (unsigned long)(slot0)) {
 5179|      0|                free((void *)val);
 5180|      0|            }
 5181|      0|            val = xcharalloc(size);
 5182|      0|            (sv + n)->val = val;
 5183|      0|            quotearg_buffer_restyled(val, size, arg, argsize,
 5184|      0|                                     (enum quoting_style)options->style, flags,
 5185|      0|                                     (unsigned int const *)(options->quote_these_too),
 5186|      0|                                     (char const *)options->left_quote,
 5187|      0|                                     (char const *)options->right_quote);
 5188|      0|        }
 5189|      0|        tmp___3 = __errno_location();
 5190|      0|        *tmp___3 = e;
 5191|      0|        return (val);
 5192|      0|    }
 5193|      0|}
 5194|       |char *quotearg_n_style(int n, enum quoting_style s, char const *arg)
 5195|      0|{
 5196|      0|    struct quoting_options o;
 5197|      0|    struct quoting_options tmp;
 5198|      0|    char *tmp___0;
 5199|       |
 5200|      0|    {
 5201|      0|        tmp = quoting_options_from_style(s);
 5202|      0|        o = tmp;
 5203|      0|        tmp___0 = quotearg_n_options(n, arg, (size_t)-1,
 5204|      0|                                     (struct quoting_options const *)(&o));
 5205|      0|        return (tmp___0);
 5206|      0|    }
 5207|      0|}
 5208|       |char *quotearg_n_style_mem(int n, enum quoting_style s, char const *arg,
 5209|       |                           size_t argsize)
 5210|      0|{
 5211|      0|    struct quoting_options o;
 5212|      0|    struct quoting_options tmp;
 5213|      0|    char *tmp___0;
 5214|       |
 5215|      0|    {
 5216|      0|        tmp = quoting_options_from_style(s);
 5217|      0|        o = tmp;
 5218|      0|        tmp___0 = quotearg_n_options(n, arg, argsize,
 5219|      0|                                     (struct quoting_options const *)(&o));
 5220|      0|        return (tmp___0);
 5221|      0|    }
 5222|      0|}
 5223|       |char *quotearg_char_mem(char const *arg, size_t argsize, char ch)
 5224|      0|{
 5225|      0|    struct quoting_options options;
 5226|      0|    char *tmp;
 5227|       |
 5228|      0|    {
 5229|      0|        options = default_quoting_options;
 5230|      0|        set_char_quoting(&options, ch, 1);
 5231|      0|        tmp = quotearg_n_options(0, arg, argsize,
 5232|      0|                                 (struct quoting_options const *)(&options));
 5233|      0|        return (tmp);
 5234|      0|    }
 5235|      0|}
 5236|       |char *quotearg_char(char const *arg, char ch)
 5237|      0|{
 5238|      0|    char *tmp;
 5239|       |
 5240|      0|    {
 5241|      0|        tmp = quotearg_char_mem(arg, (size_t)-1, ch);
 5242|      0|        return (tmp);
 5243|      0|    }
 5244|      0|}
 5245|       |char *quotearg_colon(char const *arg)
 5246|      0|{
 5247|      0|    char *tmp;
 5248|       |
 5249|      0|    {
 5250|      0|        tmp = quotearg_char(arg, (char)':');
 5251|      0|        return (tmp);
 5252|      0|    }
 5253|      0|}
 5254|       |struct quoting_options quote_quoting_options = {(enum quoting_style)6,
 5255|       |           0,
 5256|       |    {0U},
 5257|       |    (char const *)((void *)0),
 5258|       |    (char const *)((void *)0)
 5259|       |};
 5260|       |char const *quote_n(int n, char const *name)
 5261|      0|{
 5262|      0|    char const *tmp;
 5263|       |
 5264|      0|    {
 5265|      0|        tmp = (char const *)quotearg_n_options(
 5266|      0|                  n, name, (size_t)-1,
 5267|      0|                  (struct quoting_options const *)(&quote_quoting_options));
 5268|      0|        return (tmp);
 5269|      0|    }
 5270|      0|}
 5271|       |char const *quote(char const *name)
 5272|      0|{
 5273|      0|    char const *tmp;
 5274|       |
 5275|      0|    {
 5276|      0|        tmp = quote_n(0, name);
 5277|      0|        return (tmp);
 5278|      0|    }
 5279|      0|}
 5280|       |#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
 5281|       |__inline static void mbuiter_multi_next(struct mbuiter_multi *iter)
 5282|      0|{
 5283|      0|    int tmp;
 5284|      0|    size_t tmp___0;
 5285|      0|    size_t tmp___1;
 5286|      0|    int tmp___2;
 5287|      0|    _Bool tmp___3;
 5288|       |
 5289|      0|    {
 5290|      0|        if (iter->next_done) {
 5291|      0|            return;
 5292|      0|        }
 5293|      0|        if (iter->in_shift) {
 5294|      0|            goto with_shift;
 5295|      0|        }
 5296|      0|        tmp___3 = is_basic((char)*(iter->cur.ptr));
 5297|      0|        if (tmp___3) {
 5298|      0|            iter->cur.bytes = (size_t)1;
 5299|      0|            iter->cur.wc = (wchar_t) * (iter->cur.ptr);
 5300|      0|            iter->cur.wc_valid = (_Bool)1;
 5301|      0|        }
 5302|      0|        else {
 5303|      0|            tmp = mbsinit((mbstate_t const *)(&iter->state));
 5304|      0|            if (!tmp) {
 5305|      0|                __assert_fail("mbsinit (&iter->state)",
 5306|      0|                              "/home/khheo/project/program-reduce/benchmark/"
 5307|      0|                              "coreutils-8.16/lib/mbuiter.h",
 5308|      0|                              142U, "mbuiter_multi_next");
 5309|      0|            }
 5310|      0|            iter->in_shift = (_Bool)1;
 5311|      0|with_shift:
 5312|      0|            tmp___0 = __ctype_get_mb_cur_max();
 5313|      0|            tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
 5314|      0|            iter->cur.bytes =
 5315|      0|                mbrtowc(&iter->cur.wc, iter->cur.ptr, tmp___1, &iter->state);
 5316|      0|            if (iter->cur.bytes == 0xffffffffffffffffUL) {
 5317|      0|                iter->cur.bytes = (size_t)1;
 5318|      0|                iter->cur.wc_valid = (_Bool)0;
 5319|      0|            }
 5320|      0|            else {
 5321|      0|                if (iter->cur.bytes == 0xfffffffffffffffeUL) {
 5322|      0|                    iter->cur.bytes = strlen(iter->cur.ptr);
 5323|      0|                    iter->cur.wc_valid = (_Bool)0;
 5324|      0|                }
 5325|      0|                else {
 5326|      0|                    if (iter->cur.bytes == 0UL) {
 5327|      0|                        iter->cur.bytes = (size_t)1;
 5328|      0|                        if (!((int const) * (iter->cur.ptr) == 0)) {
 5329|      0|                            __assert_fail("*iter->cur.ptr == \'\\0\'",
 5330|      0|                                          "/home/khheo/project/program-reduce/benchmark/"
 5331|      0|                                          "coreutils-8.16/lib/mbuiter.h",
 5332|      0|                                          170U, "mbuiter_multi_next");
 5333|      0|                        }
 5334|      0|                        if (!(iter->cur.wc == 0)) {
 5335|      0|                            __assert_fail("iter->cur.wc == 0",
 5336|      0|                                          "/home/khheo/project/program-reduce/benchmark/"
 5337|      0|                                          "coreutils-8.16/lib/mbuiter.h",
 5338|      0|                                          171U, "mbuiter_multi_next");
 5339|      0|                        }
 5340|      0|                    }
 5341|      0|                    iter->cur.wc_valid = (_Bool)1;
 5342|      0|                    tmp___2 = mbsinit((mbstate_t const *)(&iter->state));
 5343|      0|                    if (tmp___2) {
 5344|      0|                        iter->in_shift = (_Bool)0;
 5345|      0|                    }
 5346|      0|                }
 5347|      0|            }
 5348|      0|        }
 5349|      0|        iter->next_done = (_Bool)1;
 5350|      0|        return;
 5351|      0|    }
 5352|      0|}
 5353|       |char const *program_name;
 5354|       |void set_program_name(char const *argv0);
 5355|       |extern char *program_invocation_name;
 5356|       |extern char *program_invocation_short_name;
 5357|       |extern int fputs(char const *__restrict __s, FILE *__restrict __stream);
 5358|       |extern __attribute__((__nothrow__)) char *(
 5359|       |    __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const *__s, int __c)
 5360|       |__attribute__((__pure__));
 5361|       |char const *program_name = (char const *)((void *)0);
 5362|       |void set_program_name(char const *argv0)
 5363|      2|{
 5364|      2|    char const *slash;
 5365|      2|    char const *base;
 5366|      2|    int tmp;
 5367|      2|    int tmp___0;
 5368|       |
 5369|      2|    {
 5370|      2|        if ((unsigned long)argv0 == (unsigned long)((void *)0)) {
 5371|      0|            fputs("A NULL argv[0] was passed through an exec system call.\n", stderr);
 5372|      0|            abort();
 5373|      0|        }
 5374|      2|        slash = (char const *)strrchr(argv0, '/');
 5375|      2|        if ((unsigned long)slash != (unsigned long)((void *)0)) {
 5376|      2|            base = slash + 1;
 5377|      2|        }
 5378|      0|        else {
 5379|      0|            base = argv0;
 5380|      0|        }
 5381|      2|        if (base - argv0 >= 7L) {
 5382|      0|            tmp___0 = strncmp(base - 7, "/.libs/", (size_t)7);
 5383|      0|            if (tmp___0 == 0) {
 5384|      0|                argv0 = base;
 5385|      0|                tmp = strncmp(base, "lt-", (size_t)3);
 5386|      0|                if (tmp == 0) {
 5387|      0|                    argv0 = base + 3;
 5388|      0|                    program_invocation_short_name = (char *)argv0;
 5389|      0|                }
 5390|      0|            }
 5391|      0|        }
 5392|      2|        program_name = argv0;
 5393|      2|        program_invocation_name = (char *)argv0;
 5394|      2|        return;
 5395|      2|    }
 5396|      2|}
 5397|       |int posix2_version(void);
 5398|       |int posix2_version(void)
 5399|      2|{
 5400|      2|    long v;
 5401|      2|    char const *s;
 5402|      2|    char const *tmp;
 5403|      2|    char *e;
 5404|      2|    long i;
 5405|      2|    long tmp___0;
 5406|      2|    long tmp___1;
 5407|      2|    long tmp___2;
 5408|       |
 5409|      2|    {
 5410|      2|        v = 200809L;
 5411|      2|        tmp = (char const *)getenv("_POSIX2_VERSION");
 5412|      2|        s = tmp;
 5413|      2|        if (s) {
 5414|      0|            if (*s) {
 5415|      0|                tmp___0 = strtol(s, &e, 10);
 5416|      0|                i = tmp___0;
 5417|      0|                if (!*e) {
 5418|      0|                    v = i;
 5419|      0|                }
 5420|      0|            }
 5421|      0|        }
 5422|      2|        if (v < (-0x7FFFFFFF - 1)) {
 5423|      0|            tmp___2 = (-0x7FFFFFFF - 1);
 5424|      0|        }
 5425|      2|        else {
 5426|      2|            if (v < 2147483647L) {
 5427|      2|                tmp___1 = v;
 5428|      2|            }
 5429|      0|            else {
 5430|      0|                tmp___1 = 2147483647L;
 5431|      0|            }
 5432|      2|            tmp___2 = tmp___1;
 5433|      2|        }
 5434|      2|        return ((int)tmp___2);
 5435|      2|    }
 5436|      2|}
 5437|       |extern __attribute__((__nothrow__)) char *(__attribute__((
 5438|       |            __nonnull__(1, 2), __leaf__)) stpcpy)(char *__restrict __dest,
 5439|       |                    char const *__restrict __src);
 5440|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) pipe)(
 5441|       |    int *__pipedes);
 5442|       |double physmem_total(void);
 5443|       |double physmem_available(void);
 5444|       |extern __attribute__((__nothrow__)) long(__attribute__((__leaf__)) sysconf)(
 5445|       |    int __name);
 5446|       |double physmem_total(void)
 5447|      2|{
 5448|      2|    double pages;
 5449|      2|    double tmp;
 5450|      2|    double pagesize;
 5451|      2|    double tmp___0;
 5452|       |
 5453|      2|    {
 5454|      2|        tmp = (double)sysconf(85);
 5455|      2|        pages = tmp;
 5456|      2|        tmp___0 = (double)sysconf(30);
 5457|      2|        pagesize = tmp___0;
 5458|      2|        if ((double)0 <= pages) {
 5459|      2|            if ((double)0 <= pagesize) {
 5460|      2|                return (pages * pagesize);
 5461|      2|            }
 5462|      2|        }
 5463|      0|        return ((double)67108864);
 5464|      2|    }
 5465|      2|}
 5466|       |double physmem_available(void)
 5467|      2|{
 5468|      2|    double pages;
 5469|      2|    double tmp;
 5470|      2|    double pagesize;
 5471|      2|    double tmp___0;
 5472|      2|    double tmp___1;
 5473|       |
 5474|      2|    {
 5475|      2|        tmp = (double)sysconf(86);
 5476|      2|        pages = tmp;
 5477|      2|        tmp___0 = (double)sysconf(30);
 5478|      2|        pagesize = tmp___0;
 5479|      2|        if ((double)0 <= pages) {
 5480|      2|            if ((double)0 <= pagesize) {
 5481|      2|                return (pages * pagesize);
 5482|      2|            }
 5483|      2|        }
 5484|      0|        tmp___1 = physmem_total();
 5485|      0|        return (tmp___1 / (double)4);
 5486|      2|    }
 5487|      2|}
 5488|       |int dup_safer(int fd);
 5489|       |#pragma GCC diagnostic ignored "-Wtype-limits"
 5490|       |unsigned long num_processors(enum nproc_query query);
 5491|       |extern __attribute__((__nothrow__)) int(__attribute__((
 5492|       |        __leaf__)) __sched_cpucount)(size_t __setsize, cpu_set_t const *__setp);
 5493|       |extern __attribute__((__nothrow__)) int(__attribute__((
 5494|       |        __leaf__)) sched_getaffinity)(__pid_t __pid, size_t __cpusetsize,
 5495|       |                                      cpu_set_t *__cpuset);
 5496|       |static unsigned long num_processors_via_affinity_mask(void)
 5497|      2|{
 5498|      2|    cpu_set_t set;
 5499|      2|    unsigned long count;
 5500|      2|    int tmp;
 5501|       |
 5502|      2|    {
 5503|      2|        tmp = sched_getaffinity(0, sizeof(set), &set);
 5504|      2|        if (tmp == 0) {
 5505|      2|            count = (unsigned long)__sched_cpucount(sizeof(cpu_set_t),
 5506|      2|                                                    (cpu_set_t const *)(&set));
 5507|      2|            if (count > 0UL) {
 5508|      2|                return (count);
 5509|      2|            }
 5510|      2|        }
 5511|      0|        return (0UL);
 5512|      2|    }
 5513|      2|}
 5514|       |unsigned long num_processors(enum nproc_query query)
 5515|      2|{
 5516|      2|    char const *envvalue;
 5517|      2|    char const *tmp;
 5518|      2|    _Bool tmp___0;
 5519|      2|    char *endptr;
 5520|      2|    unsigned long value;
 5521|      2|    unsigned long tmp___1;
 5522|      2|    _Bool tmp___2;
 5523|      2|    unsigned long tmp___3;
 5524|      2|    _Bool tmp___4;
 5525|      2|    unsigned long nprocs___0;
 5526|      2|    unsigned long tmp___5;
 5527|      2|    long nprocs___1;
 5528|      2|    long tmp___6;
 5529|      2|    long nprocs___2;
 5530|      2|    long tmp___7;
 5531|      2|    unsigned long nprocs_current;
 5532|      2|    unsigned long tmp___8;
 5533|       |
 5534|      2|    {
 5535|      2|        if ((unsigned int)query == 2U) {
 5536|      2|            tmp = (char const *)getenv("OMP_NUM_THREADS");
 5537|      2|            envvalue = tmp;
 5538|      2|            if ((unsigned long)envvalue != (unsigned long)((void *)0)) {
 5539|      0|                while (1) {
 5540|       |
 5541|      0|                    if ((int const) * envvalue != 0) {
 5542|      0|                        tmp___0 = c_isspace((int)*envvalue);
 5543|      0|                        if (!tmp___0) {
 5544|      0|                            goto while_break;
 5545|      0|                        }
 5546|      0|                    }
 5547|      0|                    else {
 5548|      0|                        goto while_break;
 5549|      0|                    }
 5550|      0|                    envvalue++;
 5551|      0|                }
 5552|      0|while_break:
 5553|      0|                tmp___4 = c_isdigit((int)*envvalue);
 5554|      0|                if (tmp___4) {
 5555|      0|                    endptr = (char *)((void *)0);
 5556|      0|                    tmp___1 = strtoul(envvalue, &endptr, 10);
 5557|      0|                    value = tmp___1;
 5558|      0|                    if ((unsigned long)endptr != (unsigned long)((void *)0)) {
 5559|      0|                        while (1) {
 5560|       |
 5561|      0|                            if ((int)*endptr != 0) {
 5562|      0|                                tmp___2 = c_isspace((int)*endptr);
 5563|      0|                                if (!tmp___2) {
 5564|      0|                                    goto while_break___0;
 5565|      0|                                }
 5566|      0|                            }
 5567|      0|                            else {
 5568|      0|                                goto while_break___0;
 5569|      0|                            }
 5570|      0|                            endptr++;
 5571|      0|                        }
 5572|      0|while_break___0:
 5573|      0|                        ;
 5574|      0|                        if ((int)*endptr == 0) {
 5575|      0|                            if (value > 0UL) {
 5576|      0|                                tmp___3 = value;
 5577|      0|                            }
 5578|      0|                            else {
 5579|      0|                                tmp___3 = 1UL;
 5580|      0|                            }
 5581|      0|                            return (tmp___3);
 5582|      0|                        }
 5583|      0|                    }
 5584|      0|                }
 5585|      0|            }
 5586|      2|            query = (enum nproc_query)1;
 5587|      2|        }
 5588|      2|        if ((unsigned int)query == 1U) {
 5589|      2|            tmp___5 = num_processors_via_affinity_mask();
 5590|      2|            nprocs___0 = tmp___5;
 5591|      2|            if (nprocs___0 > 0UL) {
 5592|      2|                return (nprocs___0);
 5593|      2|            }
 5594|      0|            tmp___6 = sysconf(84);
 5595|      0|            nprocs___1 = tmp___6;
 5596|      0|            if (nprocs___1 > 0L) {
 5597|      0|                return ((unsigned long)nprocs___1);
 5598|      0|            }
 5599|      0|        }
 5600|      0|        else {
 5601|      0|            tmp___7 = sysconf(83);
 5602|      0|            nprocs___2 = tmp___7;
 5603|      0|            if (nprocs___2 == 1L) {
 5604|      0|                tmp___8 = num_processors_via_affinity_mask();
 5605|      0|                nprocs_current = tmp___8;
 5606|      0|                if (nprocs_current > 0UL) {
 5607|      0|                    nprocs___2 = (long)nprocs_current;
 5608|      0|                }
 5609|      0|            }
 5610|      0|            if (nprocs___2 > 0L) {
 5611|      0|                return ((unsigned long)nprocs___2);
 5612|      0|            }
 5613|      0|        }
 5614|      0|        return (1UL);
 5615|      2|    }
 5616|      2|}
 5617|       |extern int nanosleep(struct timespec const *__requested_time,
 5618|       |                     struct timespec *__remaining);
 5619|       |int(__attribute__((__nonnull__(1))) rpl_nanosleep)(
 5620|       |    struct timespec const *requested_delay, struct timespec *remaining_delay)
 5621|      0|{
 5622|      0|    int *tmp;
 5623|      0|    time_t limit;
 5624|      0|    time_t seconds;
 5625|      0|    struct timespec intermediate;
 5626|      0|    int result;
 5627|      0|    int tmp___0;
 5628|       |
 5629|      0|    {
 5630|      0|        if (requested_delay->tv_nsec < 0L) {
 5631|      0|            tmp = __errno_location();
 5632|      0|            *tmp = 22;
 5633|      0|            return (-1);
 5634|      0|        }
 5635|      0|        else {
 5636|      0|            if (1000000000L <= (long)requested_delay->tv_nsec) {
 5637|      0|                tmp = __errno_location();
 5638|      0|                *tmp = 22;
 5639|      0|                return (-1);
 5640|      0|            }
 5641|      0|        }
 5642|      0|        limit = (time_t)2073600;
 5643|      0|        seconds = (time_t)requested_delay->tv_sec;
 5644|      0|        intermediate.tv_nsec = (__syscall_slong_t)requested_delay->tv_nsec;
 5645|      0|        while (1) {
 5646|       |
 5647|      0|            if (!(limit < seconds)) {
 5648|      0|                goto while_break;
 5649|      0|            }
 5650|      0|            intermediate.tv_sec = limit;
 5651|      0|            result =
 5652|      0|                nanosleep((struct timespec const *)(&intermediate), remaining_delay);
 5653|      0|            seconds -= limit;
 5654|      0|            if (result) {
 5655|      0|                if (remaining_delay) {
 5656|      0|                    remaining_delay->tv_sec += seconds;
 5657|      0|                }
 5658|      0|                return (result);
 5659|      0|            }
 5660|      0|            intermediate.tv_nsec = (__syscall_slong_t)0;
 5661|      0|        }
 5662|      0|while_break:
 5663|      0|        intermediate.tv_sec = seconds;
 5664|      0|        tmp___0 =
 5665|      0|            nanosleep((struct timespec const *)(&intermediate), remaining_delay);
 5666|      0|        return (tmp___0);
 5667|      0|    }
 5668|      0|}
 5669|       |int mkstemp_safer(char *templ);
 5670|       |extern int(__attribute__((__nonnull__(1))) mkstemp)(char *__template);
 5671|       |int mkstemp_safer(char *templ)
 5672|      0|{
 5673|      0|    int tmp;
 5674|      0|    int tmp___0;
 5675|       |
 5676|      0|    {
 5677|      0|        tmp = mkstemp(templ);
 5678|      0|        tmp___0 = fd_safer(tmp);
 5679|      0|        return (tmp___0);
 5680|      0|    }
 5681|      0|}
 5682|       |extern __attribute__((__nothrow__)) int(__attribute__((
 5683|       |        __nonnull__(1, 2), __leaf__)) strcoll)(char const *__s1, char const *__s2)
 5684|       |__attribute__((__pure__));
 5685|       |__inline static int strcoll_loop(char const *s1, size_t s1size, char const *s2,
 5686|       |                                 size_t s2size)
 5687|   166k|{
 5688|   166k|    int diff;
 5689|   166k|    size_t size1;
 5690|   166k|    size_t tmp;
 5691|   166k|    size_t size2;
 5692|   166k|    size_t tmp___0;
 5693|   166k|    int *tmp___1;
 5694|   166k|    int *tmp___2;
 5695|   166k|    int tmp___3;
 5696|       |
 5697|   166k|    {
 5698|   166k|        while (1) {
 5699|   166k|            tmp___1 = __errno_location();
 5700|   166k|            *tmp___1 = 0;
 5701|   166k|            diff = strcoll(s1, s2);
 5702|   166k|            if (diff) {
 5703|   166k|                tmp___3 = 1;
 5704|   166k|            }
 5705|      0|            else {
 5706|      0|                tmp___2 = __errno_location();
 5707|      0|                if (*tmp___2) {
 5708|      0|                    tmp___3 = 1;
 5709|      0|                }
 5710|      0|                else {
 5711|      0|                    tmp___3 = 0;
 5712|      0|                }
 5713|      0|            }
 5714|   166k|            if (tmp___3) {
 5715|   166k|                goto while_break;
 5716|   166k|            }
 5717|      0|            tmp = strlen(s1);
 5718|      0|            size1 = tmp + 1UL;
 5719|      0|            tmp___0 = strlen(s2);
 5720|      0|            size2 = tmp___0 + 1UL;
 5721|      0|            s1 += size1;
 5722|      0|            s2 += size2;
 5723|      0|            s1size -= size1;
 5724|      0|            s2size -= size2;
 5725|      0|            if (s1size == 0UL) {
 5726|      0|                return (-(s2size != 0UL));
 5727|      0|            }
 5728|      0|            if (s2size == 0UL) {
 5729|      0|                return (1);
 5730|      0|            }
 5731|      0|        }
 5732|   166k|while_break:
 5733|   166k|        ;
 5734|   166k|        return (diff);
 5735|   166k|    }
 5736|   166k|}
 5737|       |int memcoll0(char const *s1, size_t s1size, char const *s2, size_t s2size)
 5738|   215k|{
 5739|   215k|    int *tmp;
 5740|   215k|    int tmp___0;
 5741|   215k|    int tmp___1;
 5742|       |
 5743|   215k|    {
 5744|   215k|        if (s1size == s2size) {
 5745|  60.9k|            tmp___1 = memcmp((void const *)s1, (void const *)s2, s1size);
 5746|  60.9k|            if (tmp___1 == 0) {
 5747|  48.9k|                tmp = __errno_location();
 5748|  48.9k|                *tmp = 0;
 5749|  48.9k|                return (0);
 5750|  48.9k|            }
 5751|  12.0k|            else {
 5752|  12.0k|                tmp___0 = strcoll_loop(s1, s1size, s2, s2size);
 5753|  12.0k|                return (tmp___0);
 5754|  12.0k|            }
 5755|  60.9k|        }
 5756|   154k|        else {
 5757|   154k|            tmp___0 = strcoll_loop(s1, s1size, s2, s2size);
 5758|   154k|            return (tmp___0);
 5759|   154k|        }
 5760|   215k|    }
 5761|   215k|}
 5762|       |__attribute__((__nothrow__)) void(__attribute__((__leaf__)) md5_init_ctx)(
 5763|       |    struct md5_ctx *ctx);
 5764|       |__attribute__((__nothrow__)) void(__attribute__((__leaf__)) md5_process_block)(
 5765|       |    void const *buffer, size_t len, struct md5_ctx *ctx);
 5766|       |__attribute__((__nothrow__)) void(__attribute__((__leaf__)) md5_process_bytes)(
 5767|       |    void const *buffer, size_t len, struct md5_ctx *ctx);
 5768|       |__attribute__((__nothrow__)) void *(__attribute__((__leaf__)) md5_finish_ctx)(
 5769|       |    struct md5_ctx *ctx, void *resbuf);
 5770|       |__attribute__((__nothrow__)) void *(__attribute__((__leaf__)) md5_read_ctx)(
 5771|       |    struct md5_ctx const *ctx, void *resbuf);
 5772|       |static unsigned char const fillbuf___2[64] = {(unsigned char const)128,
 5773|       |                                              (unsigned char const)0
 5774|       |                                             };
 5775|       |__attribute__((__nothrow__)) void(__attribute__((__leaf__)) md5_init_ctx)(
 5776|       |    struct md5_ctx *ctx);
 5777|       |void(__attribute__((__leaf__)) md5_init_ctx)(struct md5_ctx *ctx)
 5778|      0|{
 5779|      0|    uint32_t tmp;
 5780|       |
 5781|      0|    {
 5782|      0|        ctx->A = (uint32_t)1732584193;
 5783|      0|        ctx->B = 4023233417U;
 5784|      0|        ctx->C = 2562383102U;
 5785|      0|        ctx->D = (uint32_t)271733878;
 5786|      0|        tmp = (uint32_t)0;
 5787|      0|        ctx->total[1] = tmp;
 5788|      0|        ctx->total[0] = tmp;
 5789|      0|        ctx->buflen = (uint32_t)0;
 5790|      0|        return;
 5791|      0|    }
 5792|      0|}
 5793|       |__attribute__((__nothrow__)) void *(__attribute__((__leaf__)) md5_read_ctx)(
 5794|       |    struct md5_ctx const *ctx, void *resbuf);
 5795|       |void *(__attribute__((__leaf__)) md5_read_ctx)(struct md5_ctx const *ctx,
 5796|       |        void *resbuf)
 5797|      0|{
 5798|      0|    char *r;
 5799|       |
 5800|      0|    {
 5801|      0|        r = (char *)resbuf;
 5802|      0|        set_uint32(r + 0UL, (uint32_t)ctx->A);
 5803|      0|        set_uint32(r + sizeof(ctx->B), (uint32_t)ctx->B);
 5804|      0|        set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t)ctx->C);
 5805|      0|        set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t)ctx->D);
 5806|      0|        return (resbuf);
 5807|      0|    }
 5808|      0|}
 5809|       |__attribute__((__nothrow__)) void *(__attribute__((__leaf__)) md5_finish_ctx)(
 5810|       |    struct md5_ctx *ctx, void *resbuf);
 5811|       |void *(__attribute__((__leaf__)) md5_finish_ctx)(struct md5_ctx *ctx,
 5812|       |        void *resbuf)
 5813|      0|{
 5814|      0|    uint32_t bytes;
 5815|      0|    size_t size;
 5816|      0|    int tmp;
 5817|      0|    void *tmp___0;
 5818|       |
 5819|      0|    {
 5820|      0|        bytes = ctx->buflen;
 5821|      0|        if (bytes < 56U) {
 5822|      0|            tmp = 16;
 5823|      0|        }
 5824|      0|        else {
 5825|      0|            tmp = 32;
 5826|      0|        }
 5827|      0|        size = (size_t)tmp;
 5828|      0|        ctx->total[0] += bytes;
 5829|      0|        if (ctx->total[0] < bytes) {
 5830|      0|            (ctx->total[1])++;
 5831|      0|        }
 5832|      0|        ctx->buffer[size - 2UL] = ctx->total[0] << 3;
 5833|      0|        ctx->buffer[size - 1UL] = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
 5834|      0|        memcpy((void *)((char *)(ctx->buffer) + bytes), (void const *)(fillbuf___2),
 5835|      0|               (size - 2UL) * 4UL - (size_t)bytes);
 5836|      0|        md5_process_block((void const *)(ctx->buffer), size * 4UL, ctx);
 5837|      0|        tmp___0 = md5_read_ctx((struct md5_ctx const *)ctx, resbuf);
 5838|      0|        return (tmp___0);
 5839|      0|    }
 5840|      0|}
 5841|       |__attribute__((__nothrow__)) void(__attribute__((__leaf__)) md5_process_bytes)(
 5842|       |    void const *buffer, size_t len, struct md5_ctx *ctx);
 5843|       |void(__attribute__((__leaf__)) md5_process_bytes)(void const *buffer,
 5844|       |        size_t len,
 5845|       |        struct md5_ctx *ctx)
 5846|      0|{
 5847|      0|    size_t left_over;
 5848|      0|    size_t add;
 5849|      0|    size_t tmp;
 5850|      0|    size_t left_over___0;
 5851|       |
 5852|      0|    {
 5853|      0|        if (ctx->buflen != 0U) {
 5854|      0|            left_over = (size_t)ctx->buflen;
 5855|      0|            if (128UL - left_over > len) {
 5856|      0|                tmp = len;
 5857|      0|            }
 5858|      0|            else {
 5859|      0|                tmp = 128UL - left_over;
 5860|      0|            }
 5861|      0|            add = tmp;
 5862|      0|            memcpy((void *)((char *)(ctx->buffer) + left_over), buffer, add);
 5863|      0|            ctx->buflen = (uint32_t)((size_t)ctx->buflen + add);
 5864|      0|            if (ctx->buflen > 64U) {
 5865|      0|                md5_process_block((void const *)(ctx->buffer),
 5866|      0|                                  (size_t)(ctx->buflen & 4294967232U), ctx);
 5867|      0|                ctx->buflen &= 63U;
 5868|      0|                memcpy((void *)(ctx->buffer),
 5869|      0|                       (void const *)((char *)(ctx->buffer) +
 5870|      0|                                      ((left_over + add) & 0xffffffffffffffc0UL)),
 5871|      0|                       (size_t)ctx->buflen);
 5872|      0|            }
 5873|      0|            buffer = (void const *)((char const *)buffer + add);
 5874|      0|            len -= add;
 5875|      0|        }
 5876|      0|        if (len >= 64UL) {
 5877|      0|            md5_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
 5878|      0|            buffer =
 5879|      0|                (void const *)((char const *)buffer + (len & 0xffffffffffffffc0UL));
 5880|      0|            len &= 63UL;
 5881|      0|        }
 5882|      0|        if (len > 0UL) {
 5883|      0|            left_over___0 = (size_t)ctx->buflen;
 5884|      0|            memcpy((void *)((char *)(ctx->buffer) + left_over___0), buffer, len);
 5885|      0|            left_over___0 += len;
 5886|      0|            if (left_over___0 >= 64UL) {
 5887|      0|                md5_process_block((void const *)(ctx->buffer), (size_t)64, ctx);
 5888|      0|                left_over___0 -= 64UL;
 5889|      0|                memcpy((void *)(ctx->buffer), (void const *)(&ctx->buffer[16]),
 5890|      0|                       left_over___0);
 5891|      0|            }
 5892|      0|            ctx->buflen = (uint32_t)left_over___0;
 5893|      0|        }
 5894|      0|        return;
 5895|      0|    }
 5896|      0|}
 5897|       |__attribute__((__nothrow__)) void(__attribute__((__leaf__)) md5_process_block)(
 5898|       |    void const *buffer, size_t len, struct md5_ctx *ctx);
 5899|       |void(__attribute__((__leaf__)) md5_process_block)(void const *buffer,
 5900|       |        size_t len,
 5901|       |        struct md5_ctx *ctx)
 5902|      0|{
 5903|      0|    uint32_t correct_words[16];
 5904|      0|    uint32_t const *words;
 5905|      0|    size_t nwords;
 5906|      0|    uint32_t const *endp;
 5907|      0|    uint32_t A;
 5908|      0|    uint32_t B;
 5909|      0|    uint32_t C;
 5910|      0|    uint32_t D;
 5911|      0|    uint32_t *cwp;
 5912|      0|    uint32_t A_save;
 5913|      0|    uint32_t B_save;
 5914|      0|    uint32_t C_save;
 5915|      0|    uint32_t D_save;
 5916|      0|    uint32_t *tmp;
 5917|      0|    uint32_t tmp___0;
 5918|      0|    uint32_t *tmp___1;
 5919|      0|    uint32_t tmp___2;
 5920|      0|    uint32_t *tmp___3;
 5921|      0|    uint32_t tmp___4;
 5922|      0|    uint32_t *tmp___5;
 5923|      0|    uint32_t tmp___6;
 5924|      0|    uint32_t *tmp___7;
 5925|      0|    uint32_t tmp___8;
 5926|      0|    uint32_t *tmp___9;
 5927|      0|    uint32_t tmp___10;
 5928|      0|    uint32_t *tmp___11;
 5929|      0|    uint32_t tmp___12;
 5930|      0|    uint32_t *tmp___13;
 5931|      0|    uint32_t tmp___14;
 5932|      0|    uint32_t *tmp___15;
 5933|      0|    uint32_t tmp___16;
 5934|      0|    uint32_t *tmp___17;
 5935|      0|    uint32_t tmp___18;
 5936|      0|    uint32_t *tmp___19;
 5937|      0|    uint32_t tmp___20;
 5938|      0|    uint32_t *tmp___21;
 5939|      0|    uint32_t tmp___22;
 5940|      0|    uint32_t *tmp___23;
 5941|      0|    uint32_t tmp___24;
 5942|      0|    uint32_t *tmp___25;
 5943|      0|    uint32_t tmp___26;
 5944|      0|    uint32_t *tmp___27;
 5945|      0|    uint32_t tmp___28;
 5946|      0|    uint32_t *tmp___29;
 5947|      0|    uint32_t tmp___30;
 5948|       |
 5949|      0|    {
 5950|      0|        words = (uint32_t const *)buffer;
 5951|      0|        nwords = len / sizeof(uint32_t);
 5952|      0|        endp = words + nwords;
 5953|      0|        A = ctx->A;
 5954|      0|        B = ctx->B;
 5955|      0|        C = ctx->C;
 5956|      0|        D = ctx->D;
 5957|      0|        ctx->total[0] = (uint32_t)((size_t)ctx->total[0] + len);
 5958|      0|        if ((size_t)ctx->total[0] < len) {
 5959|      0|            (ctx->total[1])++;
 5960|      0|        }
 5961|      0|        while (1) {
 5962|       |
 5963|      0|            if (!((unsigned long)words < (unsigned long)endp)) {
 5964|      0|                goto while_break;
 5965|      0|            }
 5966|      0|            cwp = correct_words;
 5967|      0|            A_save = A;
 5968|      0|            B_save = B;
 5969|      0|            C_save = C;
 5970|      0|            D_save = D;
 5971|      0|            while (1) {
 5972|      0|                tmp = cwp;
 5973|      0|                cwp++;
 5974|      0|                tmp___0 = (uint32_t)*words;
 5975|      0|                *tmp = tmp___0;
 5976|      0|                A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
 5977|      0|                words++;
 5978|      0|                A = (A << 7) | (A >> 25);
 5979|      0|                A += B;
 5980|      0|                goto while_break___0;
 5981|      0|            }
 5982|      0|while_break___0:
 5983|      0|            ;
 5984|      0|            while (1) {
 5985|      0|                tmp___1 = cwp;
 5986|      0|                cwp++;
 5987|      0|                tmp___2 = (uint32_t)*words;
 5988|      0|                *tmp___1 = tmp___2;
 5989|      0|                D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
 5990|      0|                words++;
 5991|      0|                D = (D << 12) | (D >> 20);
 5992|      0|                D += A;
 5993|      0|                goto while_break___1;
 5994|      0|            }
 5995|      0|while_break___1:
 5996|      0|            ;
 5997|      0|            while (1) {
 5998|      0|                tmp___3 = cwp;
 5999|      0|                cwp++;
 6000|      0|                tmp___4 = (uint32_t)*words;
 6001|      0|                *tmp___3 = tmp___4;
 6002|      0|                C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
 6003|      0|                words++;
 6004|      0|                C = (C << 17) | (C >> 15);
 6005|      0|                C += D;
 6006|      0|                goto while_break___2;
 6007|      0|            }
 6008|      0|while_break___2:
 6009|      0|            ;
 6010|      0|            while (1) {
 6011|      0|                tmp___5 = cwp;
 6012|      0|                cwp++;
 6013|      0|                tmp___6 = (uint32_t)*words;
 6014|      0|                *tmp___5 = tmp___6;
 6015|      0|                B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
 6016|      0|                words++;
 6017|      0|                B = (B << 22) | (B >> 10);
 6018|      0|                B += C;
 6019|      0|                goto while_break___3;
 6020|      0|            }
 6021|      0|while_break___3:
 6022|      0|            ;
 6023|      0|            while (1) {
 6024|      0|                tmp___7 = cwp;
 6025|      0|                cwp++;
 6026|      0|                tmp___8 = (uint32_t)*words;
 6027|      0|                *tmp___7 = tmp___8;
 6028|      0|                A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
 6029|      0|                words++;
 6030|      0|                A = (A << 7) | (A >> 25);
 6031|      0|                A += B;
 6032|      0|                goto while_break___4;
 6033|      0|            }
 6034|      0|while_break___4:
 6035|      0|            ;
 6036|      0|            while (1) {
 6037|      0|                tmp___9 = cwp;
 6038|      0|                cwp++;
 6039|      0|                tmp___10 = (uint32_t)*words;
 6040|      0|                *tmp___9 = tmp___10;
 6041|      0|                D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
 6042|      0|                words++;
 6043|      0|                D = (D << 12) | (D >> 20);
 6044|      0|                D += A;
 6045|      0|                goto while_break___5;
 6046|      0|            }
 6047|      0|while_break___5:
 6048|      0|            ;
 6049|      0|            while (1) {
 6050|      0|                tmp___11 = cwp;
 6051|      0|                cwp++;
 6052|      0|                tmp___12 = (uint32_t)*words;
 6053|      0|                *tmp___11 = tmp___12;
 6054|      0|                C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
 6055|      0|                words++;
 6056|      0|                C = (C << 17) | (C >> 15);
 6057|      0|                C += D;
 6058|      0|                goto while_break___6;
 6059|      0|            }
 6060|      0|while_break___6:
 6061|      0|            ;
 6062|      0|            while (1) {
 6063|      0|                tmp___13 = cwp;
 6064|      0|                cwp++;
 6065|      0|                tmp___14 = (uint32_t)*words;
 6066|      0|                *tmp___13 = tmp___14;
 6067|      0|                B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
 6068|      0|                words++;
 6069|      0|                B = (B << 22) | (B >> 10);
 6070|      0|                B += C;
 6071|      0|                goto while_break___7;
 6072|      0|            }
 6073|      0|while_break___7:
 6074|      0|            ;
 6075|      0|            while (1) {
 6076|      0|                tmp___15 = cwp;
 6077|      0|                cwp++;
 6078|      0|                tmp___16 = (uint32_t)*words;
 6079|      0|                *tmp___15 = tmp___16;
 6080|      0|                A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
 6081|      0|                words++;
 6082|      0|                A = (A << 7) | (A >> 25);
 6083|      0|                A += B;
 6084|      0|                goto while_break___8;
 6085|      0|            }
 6086|      0|while_break___8:
 6087|      0|            ;
 6088|      0|            while (1) {
 6089|      0|                tmp___17 = cwp;
 6090|      0|                cwp++;
 6091|      0|                tmp___18 = (uint32_t)*words;
 6092|      0|                *tmp___17 = tmp___18;
 6093|      0|                D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
 6094|      0|                words++;
 6095|      0|                D = (D << 12) | (D >> 20);
 6096|      0|                D += A;
 6097|      0|                goto while_break___9;
 6098|      0|            }
 6099|      0|while_break___9:
 6100|      0|            ;
 6101|      0|            while (1) {
 6102|      0|                tmp___19 = cwp;
 6103|      0|                cwp++;
 6104|      0|                tmp___20 = (uint32_t)*words;
 6105|      0|                *tmp___19 = tmp___20;
 6106|      0|                C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
 6107|      0|                words++;
 6108|      0|                C = (C << 17) | (C >> 15);
 6109|      0|                C += D;
 6110|      0|                goto while_break___10;
 6111|      0|            }
 6112|      0|while_break___10:
 6113|      0|            ;
 6114|      0|            while (1) {
 6115|      0|                tmp___21 = cwp;
 6116|      0|                cwp++;
 6117|      0|                tmp___22 = (uint32_t)*words;
 6118|      0|                *tmp___21 = tmp___22;
 6119|      0|                B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
 6120|      0|                words++;
 6121|      0|                B = (B << 22) | (B >> 10);
 6122|      0|                B += C;
 6123|      0|                goto while_break___11;
 6124|      0|            }
 6125|      0|while_break___11:
 6126|      0|            ;
 6127|      0|            while (1) {
 6128|      0|                tmp___23 = cwp;
 6129|      0|                cwp++;
 6130|      0|                tmp___24 = (uint32_t)*words;
 6131|      0|                *tmp___23 = tmp___24;
 6132|      0|                A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
 6133|      0|                words++;
 6134|      0|                A = (A << 7) | (A >> 25);
 6135|      0|                A += B;
 6136|      0|                goto while_break___12;
 6137|      0|            }
 6138|      0|while_break___12:
 6139|      0|            ;
 6140|      0|            while (1) {
 6141|      0|                tmp___25 = cwp;
 6142|      0|                cwp++;
 6143|      0|                tmp___26 = (uint32_t)*words;
 6144|      0|                *tmp___25 = tmp___26;
 6145|      0|                D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
 6146|      0|                words++;
 6147|      0|                D = (D << 12) | (D >> 20);
 6148|      0|                D += A;
 6149|      0|                goto while_break___13;
 6150|      0|            }
 6151|      0|while_break___13:
 6152|      0|            ;
 6153|      0|            while (1) {
 6154|      0|                tmp___27 = cwp;
 6155|      0|                cwp++;
 6156|      0|                tmp___28 = (uint32_t)*words;
 6157|      0|                *tmp___27 = tmp___28;
 6158|      0|                C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
 6159|      0|                words++;
 6160|      0|                C = (C << 17) | (C >> 15);
 6161|      0|                C += D;
 6162|      0|                goto while_break___14;
 6163|      0|            }
 6164|      0|while_break___14:
 6165|      0|            ;
 6166|      0|            while (1) {
 6167|      0|                tmp___29 = cwp;
 6168|      0|                cwp++;
 6169|      0|                tmp___30 = (uint32_t)*words;
 6170|      0|                *tmp___29 = tmp___30;
 6171|      0|                B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
 6172|      0|                words++;
 6173|      0|                B = (B << 22) | (B >> 10);
 6174|      0|                B += C;
 6175|      0|                goto while_break___15;
 6176|      0|            }
 6177|      0|while_break___15:
 6178|      0|            ;
 6179|      0|            while (1) {
 6180|      0|                A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
 6181|      0|                A = (A << 5) | (A >> 27);
 6182|      0|                A += B;
 6183|      0|                goto while_break___16;
 6184|      0|            }
 6185|      0|while_break___16:
 6186|      0|            ;
 6187|      0|            while (1) {
 6188|      0|                D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
 6189|      0|                D = (D << 9) | (D >> 23);
 6190|      0|                D += A;
 6191|      0|                goto while_break___17;
 6192|      0|            }
 6193|      0|while_break___17:
 6194|      0|            ;
 6195|      0|            while (1) {
 6196|      0|                C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
 6197|      0|                C = (C << 14) | (C >> 18);
 6198|      0|                C += D;
 6199|      0|                goto while_break___18;
 6200|      0|            }
 6201|      0|while_break___18:
 6202|      0|            ;
 6203|      0|            while (1) {
 6204|      0|                B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
 6205|      0|                B = (B << 20) | (B >> 12);
 6206|      0|                B += C;
 6207|      0|                goto while_break___19;
 6208|      0|            }
 6209|      0|while_break___19:
 6210|      0|            ;
 6211|      0|            while (1) {
 6212|      0|                A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
 6213|      0|                A = (A << 5) | (A >> 27);
 6214|      0|                A += B;
 6215|      0|                goto while_break___20;
 6216|      0|            }
 6217|      0|while_break___20:
 6218|      0|            ;
 6219|      0|            while (1) {
 6220|      0|                D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
 6221|      0|                D = (D << 9) | (D >> 23);
 6222|      0|                D += A;
 6223|      0|                goto while_break___21;
 6224|      0|            }
 6225|      0|while_break___21:
 6226|      0|            ;
 6227|      0|            while (1) {
 6228|      0|                C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
 6229|      0|                C = (C << 14) | (C >> 18);
 6230|      0|                C += D;
 6231|      0|                goto while_break___22;
 6232|      0|            }
 6233|      0|while_break___22:
 6234|      0|            ;
 6235|      0|            while (1) {
 6236|      0|                B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
 6237|      0|                B = (B << 20) | (B >> 12);
 6238|      0|                B += C;
 6239|      0|                goto while_break___23;
 6240|      0|            }
 6241|      0|while_break___23:
 6242|      0|            ;
 6243|      0|            while (1) {
 6244|      0|                A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
 6245|      0|                A = (A << 5) | (A >> 27);
 6246|      0|                A += B;
 6247|      0|                goto while_break___24;
 6248|      0|            }
 6249|      0|while_break___24:
 6250|      0|            ;
 6251|      0|            while (1) {
 6252|      0|                D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
 6253|      0|                D = (D << 9) | (D >> 23);
 6254|      0|                D += A;
 6255|      0|                goto while_break___25;
 6256|      0|            }
 6257|      0|while_break___25:
 6258|      0|            ;
 6259|      0|            while (1) {
 6260|      0|                C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
 6261|      0|                C = (C << 14) | (C >> 18);
 6262|      0|                C += D;
 6263|      0|                goto while_break___26;
 6264|      0|            }
 6265|      0|while_break___26:
 6266|      0|            ;
 6267|      0|            while (1) {
 6268|      0|                B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
 6269|      0|                B = (B << 20) | (B >> 12);
 6270|      0|                B += C;
 6271|      0|                goto while_break___27;
 6272|      0|            }
 6273|      0|while_break___27:
 6274|      0|            ;
 6275|      0|            while (1) {
 6276|      0|                A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
 6277|      0|                A = (A << 5) | (A >> 27);
 6278|      0|                A += B;
 6279|      0|                goto while_break___28;
 6280|      0|            }
 6281|      0|while_break___28:
 6282|      0|            ;
 6283|      0|            while (1) {
 6284|      0|                D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
 6285|      0|                D = (D << 9) | (D >> 23);
 6286|      0|                D += A;
 6287|      0|                goto while_break___29;
 6288|      0|            }
 6289|      0|while_break___29:
 6290|      0|            ;
 6291|      0|            while (1) {
 6292|      0|                C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
 6293|      0|                C = (C << 14) | (C >> 18);
 6294|      0|                C += D;
 6295|      0|                goto while_break___30;
 6296|      0|            }
 6297|      0|while_break___30:
 6298|      0|            ;
 6299|      0|            while (1) {
 6300|      0|                B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
 6301|      0|                B = (B << 20) | (B >> 12);
 6302|      0|                B += C;
 6303|      0|                goto while_break___31;
 6304|      0|            }
 6305|      0|while_break___31:
 6306|      0|            ;
 6307|      0|            while (1) {
 6308|      0|                A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
 6309|      0|                A = (A << 4) | (A >> 28);
 6310|      0|                A += B;
 6311|      0|                goto while_break___32;
 6312|      0|            }
 6313|      0|while_break___32:
 6314|      0|            ;
 6315|      0|            while (1) {
 6316|      0|                D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
 6317|      0|                D = (D << 11) | (D >> 21);
 6318|      0|                D += A;
 6319|      0|                goto while_break___33;
 6320|      0|            }
 6321|      0|while_break___33:
 6322|      0|            ;
 6323|      0|            while (1) {
 6324|      0|                C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
 6325|      0|                C = (C << 16) | (C >> 16);
 6326|      0|                C += D;
 6327|      0|                goto while_break___34;
 6328|      0|            }
 6329|      0|while_break___34:
 6330|      0|            ;
 6331|      0|            while (1) {
 6332|      0|                B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
 6333|      0|                B = (B << 23) | (B >> 9);
 6334|      0|                B += C;
 6335|      0|                goto while_break___35;
 6336|      0|            }
 6337|      0|while_break___35:
 6338|      0|            ;
 6339|      0|            while (1) {
 6340|      0|                A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
 6341|      0|                A = (A << 4) | (A >> 28);
 6342|      0|                A += B;
 6343|      0|                goto while_break___36;
 6344|      0|            }
 6345|      0|while_break___36:
 6346|      0|            ;
 6347|      0|            while (1) {
 6348|      0|                D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
 6349|      0|                D = (D << 11) | (D >> 21);
 6350|      0|                D += A;
 6351|      0|                goto while_break___37;
 6352|      0|            }
 6353|      0|while_break___37:
 6354|      0|            ;
 6355|      0|            while (1) {
 6356|      0|                C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
 6357|      0|                C = (C << 16) | (C >> 16);
 6358|      0|                C += D;
 6359|      0|                goto while_break___38;
 6360|      0|            }
 6361|      0|while_break___38:
 6362|      0|            ;
 6363|      0|            while (1) {
 6364|      0|                B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
 6365|      0|                B = (B << 23) | (B >> 9);
 6366|      0|                B += C;
 6367|      0|                goto while_break___39;
 6368|      0|            }
 6369|      0|while_break___39:
 6370|      0|            ;
 6371|      0|            while (1) {
 6372|      0|                A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
 6373|      0|                A = (A << 4) | (A >> 28);
 6374|      0|                A += B;
 6375|      0|                goto while_break___40;
 6376|      0|            }
 6377|      0|while_break___40:
 6378|      0|            ;
 6379|      0|            while (1) {
 6380|      0|                D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
 6381|      0|                D = (D << 11) | (D >> 21);
 6382|      0|                D += A;
 6383|      0|                goto while_break___41;
 6384|      0|            }
 6385|      0|while_break___41:
 6386|      0|            ;
 6387|      0|            while (1) {
 6388|      0|                C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
 6389|      0|                C = (C << 16) | (C >> 16);
 6390|      0|                C += D;
 6391|      0|                goto while_break___42;
 6392|      0|            }
 6393|      0|while_break___42:
 6394|      0|            ;
 6395|      0|            while (1) {
 6396|      0|                B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
 6397|      0|                B = (B << 23) | (B >> 9);
 6398|      0|                B += C;
 6399|      0|                goto while_break___43;
 6400|      0|            }
 6401|      0|while_break___43:
 6402|      0|            ;
 6403|      0|            while (1) {
 6404|      0|                A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
 6405|      0|                A = (A << 4) | (A >> 28);
 6406|      0|                A += B;
 6407|      0|                goto while_break___44;
 6408|      0|            }
 6409|      0|while_break___44:
 6410|      0|            ;
 6411|      0|            while (1) {
 6412|      0|                D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
 6413|      0|                D = (D << 11) | (D >> 21);
 6414|      0|                D += A;
 6415|      0|                goto while_break___45;
 6416|      0|            }
 6417|      0|while_break___45:
 6418|      0|            ;
 6419|      0|            while (1) {
 6420|      0|                C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
 6421|      0|                C = (C << 16) | (C >> 16);
 6422|      0|                C += D;
 6423|      0|                goto while_break___46;
 6424|      0|            }
 6425|      0|while_break___46:
 6426|      0|            ;
 6427|      0|            while (1) {
 6428|      0|                B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
 6429|      0|                B = (B << 23) | (B >> 9);
 6430|      0|                B += C;
 6431|      0|                goto while_break___47;
 6432|      0|            }
 6433|      0|while_break___47:
 6434|      0|            ;
 6435|      0|            while (1) {
 6436|      0|                A += ((C ^ (B | ~D)) + correct_words[0]) + 4096336452U;
 6437|      0|                A = (A << 6) | (A >> 26);
 6438|      0|                A += B;
 6439|      0|                goto while_break___48;
 6440|      0|            }
 6441|      0|while_break___48:
 6442|      0|            ;
 6443|      0|            while (1) {
 6444|      0|                D += ((B ^ (A | ~C)) + correct_words[7]) + 1126891415U;
 6445|      0|                D = (D << 10) | (D >> 22);
 6446|      0|                D += A;
 6447|      0|                goto while_break___49;
 6448|      0|            }
 6449|      0|while_break___49:
 6450|      0|            ;
 6451|      0|            while (1) {
 6452|      0|                C += ((A ^ (D | ~B)) + correct_words[14]) + 2878612391U;
 6453|      0|                C = (C << 15) | (C >> 17);
 6454|      0|                C += D;
 6455|      0|                goto while_break___50;
 6456|      0|            }
 6457|      0|while_break___50:
 6458|      0|            ;
 6459|      0|            while (1) {
 6460|      0|                B += ((D ^ (C | ~A)) + correct_words[5]) + 4237533241U;
 6461|      0|                B = (B << 21) | (B >> 11);
 6462|      0|                B += C;
 6463|      0|                goto while_break___51;
 6464|      0|            }
 6465|      0|while_break___51:
 6466|      0|            ;
 6467|      0|            while (1) {
 6468|      0|                A += ((C ^ (B | ~D)) + correct_words[12]) + 1700485571U;
 6469|      0|                A = (A << 6) | (A >> 26);
 6470|      0|                A += B;
 6471|      0|                goto while_break___52;
 6472|      0|            }
 6473|      0|while_break___52:
 6474|      0|            ;
 6475|      0|            while (1) {
 6476|      0|                D += ((B ^ (A | ~C)) + correct_words[3]) + 2399980690U;
 6477|      0|                D = (D << 10) | (D >> 22);
 6478|      0|                D += A;
 6479|      0|                goto while_break___53;
 6480|      0|            }
 6481|      0|while_break___53:
 6482|      0|            ;
 6483|      0|            while (1) {
 6484|      0|                C += ((A ^ (D | ~B)) + correct_words[10]) + 4293915773U;
 6485|      0|                C = (C << 15) | (C >> 17);
 6486|      0|                C += D;
 6487|      0|                goto while_break___54;
 6488|      0|            }
 6489|      0|while_break___54:
 6490|      0|            ;
 6491|      0|            while (1) {
 6492|      0|                B += ((D ^ (C | ~A)) + correct_words[1]) + 2240044497U;
 6493|      0|                B = (B << 21) | (B >> 11);
 6494|      0|                B += C;
 6495|      0|                goto while_break___55;
 6496|      0|            }
 6497|      0|while_break___55:
 6498|      0|            ;
 6499|      0|            while (1) {
 6500|      0|                A += ((C ^ (B | ~D)) + correct_words[8]) + 1873313359U;
 6501|      0|                A = (A << 6) | (A >> 26);
 6502|      0|                A += B;
 6503|      0|                goto while_break___56;
 6504|      0|            }
 6505|      0|while_break___56:
 6506|      0|            ;
 6507|      0|            while (1) {
 6508|      0|                D += ((B ^ (A | ~C)) + correct_words[15]) + 4264355552U;
 6509|      0|                D = (D << 10) | (D >> 22);
 6510|      0|                D += A;
 6511|      0|                goto while_break___57;
 6512|      0|            }
 6513|      0|while_break___57:
 6514|      0|            ;
 6515|      0|            while (1) {
 6516|      0|                C += ((A ^ (D | ~B)) + correct_words[6]) + 2734768916U;
 6517|      0|                C = (C << 15) | (C >> 17);
 6518|      0|                C += D;
 6519|      0|                goto while_break___58;
 6520|      0|            }
 6521|      0|while_break___58:
 6522|      0|            ;
 6523|      0|            while (1) {
 6524|      0|                B += ((D ^ (C | ~A)) + correct_words[13]) + 1309151649U;
 6525|      0|                B = (B << 21) | (B >> 11);
 6526|      0|                B += C;
 6527|      0|                goto while_break___59;
 6528|      0|            }
 6529|      0|while_break___59:
 6530|      0|            ;
 6531|      0|            while (1) {
 6532|      0|                A += ((C ^ (B | ~D)) + correct_words[4]) + 4149444226U;
 6533|      0|                A = (A << 6) | (A >> 26);
 6534|      0|                A += B;
 6535|      0|                goto while_break___60;
 6536|      0|            }
 6537|      0|while_break___60:
 6538|      0|            ;
 6539|      0|            while (1) {
 6540|      0|                D += ((B ^ (A | ~C)) + correct_words[11]) + 3174756917U;
 6541|      0|                D = (D << 10) | (D >> 22);
 6542|      0|                D += A;
 6543|      0|                goto while_break___61;
 6544|      0|            }
 6545|      0|while_break___61:
 6546|      0|            ;
 6547|      0|            while (1) {
 6548|      0|                C += ((A ^ (D | ~B)) + correct_words[2]) + 718787259U;
 6549|      0|                C = (C << 15) | (C >> 17);
 6550|      0|                C += D;
 6551|      0|                goto while_break___62;
 6552|      0|            }
 6553|      0|while_break___62:
 6554|      0|            ;
 6555|      0|            while (1) {
 6556|      0|                B += ((D ^ (C | ~A)) + correct_words[9]) + 3951481745U;
 6557|      0|                B = (B << 21) | (B >> 11);
 6558|      0|                B += C;
 6559|      0|                goto while_break___63;
 6560|      0|            }
 6561|      0|while_break___63:
 6562|      0|            A += A_save;
 6563|      0|            B += B_save;
 6564|      0|            C += C_save;
 6565|      0|            D += D_save;
 6566|      0|        }
 6567|      0|while_break:
 6568|      0|        ctx->A = A;
 6569|      0|        ctx->B = B;
 6570|      0|        ctx->C = C;
 6571|      0|        ctx->D = D;
 6572|      0|        return;
 6573|      0|    }
 6574|      0|}
 6575|       |int mbsnwidth(char const *string, size_t nbytes, int flags);
 6576|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) wcwidth)(
 6577|       |    wchar_t __c);
 6578|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) iswcntrl)(
 6579|       |    wint_t __wc);
 6580|       |int mbsnwidth(char const *string, size_t nbytes, int flags)
 6581|      0|{
 6582|      0|    char const *p;
 6583|      0|    char const *plimit;
 6584|      0|    int width;
 6585|      0|    mbstate_t mbstate;
 6586|      0|    wchar_t wc;
 6587|      0|    size_t bytes;
 6588|      0|    int w;
 6589|      0|    int tmp;
 6590|      0|    int tmp___0;
 6591|      0|    size_t tmp___1;
 6592|      0|    unsigned char c;
 6593|      0|    char const *tmp___2;
 6594|      0|    unsigned short const **tmp___3;
 6595|      0|    unsigned short const **tmp___4;
 6596|       |
 6597|      0|    {
 6598|      0|        p = string;
 6599|      0|        plimit = p + nbytes;
 6600|      0|        width = 0;
 6601|      0|        tmp___1 = __ctype_get_mb_cur_max();
 6602|      0|        if (tmp___1 > 1UL) {
 6603|      0|            while (1) {
 6604|       |
 6605|      0|                if (!((unsigned long)p < (unsigned long)plimit)) {
 6606|      0|                    goto while_break;
 6607|      0|                }
 6608|      0|                if ((int const) * p == 32) {
 6609|      0|                    goto case_32;
 6610|      0|                }
 6611|      0|                if ((int const) * p == 33) {
 6612|      0|                    goto case_32;
 6613|      0|                }
 6614|      0|                if ((int const) * p == 34) {
 6615|      0|                    goto case_32;
 6616|      0|                }
 6617|      0|                if ((int const) * p == 35) {
 6618|      0|                    goto case_32;
 6619|      0|                }
 6620|      0|                if ((int const) * p == 37) {
 6621|      0|                    goto case_32;
 6622|      0|                }
 6623|      0|                if ((int const) * p == 38) {
 6624|      0|                    goto case_32;
 6625|      0|                }
 6626|      0|                if ((int const) * p == 39) {
 6627|      0|                    goto case_32;
 6628|      0|                }
 6629|      0|                if ((int const) * p == 40) {
 6630|      0|                    goto case_32;
 6631|      0|                }
 6632|      0|                if ((int const) * p == 41) {
 6633|      0|                    goto case_32;
 6634|      0|                }
 6635|      0|                if ((int const) * p == 42) {
 6636|      0|                    goto case_32;
 6637|      0|                }
 6638|      0|                if ((int const) * p == 43) {
 6639|      0|                    goto case_32;
 6640|      0|                }
 6641|      0|                if ((int const) * p == 44) {
 6642|      0|                    goto case_32;
 6643|      0|                }
 6644|      0|                if ((int const) * p == 45) {
 6645|      0|                    goto case_32;
 6646|      0|                }
 6647|      0|                if ((int const) * p == 46) {
 6648|      0|                    goto case_32;
 6649|      0|                }
 6650|      0|                if ((int const) * p == 47) {
 6651|      0|                    goto case_32;
 6652|      0|                }
 6653|      0|                if ((int const) * p == 48) {
 6654|      0|                    goto case_32;
 6655|      0|                }
 6656|      0|                if ((int const) * p == 49) {
 6657|      0|                    goto case_32;
 6658|      0|                }
 6659|      0|                if ((int const) * p == 50) {
 6660|      0|                    goto case_32;
 6661|      0|                }
 6662|      0|                if ((int const) * p == 51) {
 6663|      0|                    goto case_32;
 6664|      0|                }
 6665|      0|                if ((int const) * p == 52) {
 6666|      0|                    goto case_32;
 6667|      0|                }
 6668|      0|                if ((int const) * p == 53) {
 6669|      0|                    goto case_32;
 6670|      0|                }
 6671|      0|                if ((int const) * p == 54) {
 6672|      0|                    goto case_32;
 6673|      0|                }
 6674|      0|                if ((int const) * p == 55) {
 6675|      0|                    goto case_32;
 6676|      0|                }
 6677|      0|                if ((int const) * p == 56) {
 6678|      0|                    goto case_32;
 6679|      0|                }
 6680|      0|                if ((int const) * p == 57) {
 6681|      0|                    goto case_32;
 6682|      0|                }
 6683|      0|                if ((int const) * p == 58) {
 6684|      0|                    goto case_32;
 6685|      0|                }
 6686|      0|                if ((int const) * p == 59) {
 6687|      0|                    goto case_32;
 6688|      0|                }
 6689|      0|                if ((int const) * p == 60) {
 6690|      0|                    goto case_32;
 6691|      0|                }
 6692|      0|                if ((int const) * p == 61) {
 6693|      0|                    goto case_32;
 6694|      0|                }
 6695|      0|                if ((int const) * p == 62) {
 6696|      0|                    goto case_32;
 6697|      0|                }
 6698|      0|                if ((int const) * p == 63) {
 6699|      0|                    goto case_32;
 6700|      0|                }
 6701|      0|                if ((int const) * p == 65) {
 6702|      0|                    goto case_32;
 6703|      0|                }
 6704|      0|                if ((int const) * p == 66) {
 6705|      0|                    goto case_32;
 6706|      0|                }
 6707|      0|                if ((int const) * p == 67) {
 6708|      0|                    goto case_32;
 6709|      0|                }
 6710|      0|                if ((int const) * p == 68) {
 6711|      0|                    goto case_32;
 6712|      0|                }
 6713|      0|                if ((int const) * p == 69) {
 6714|      0|                    goto case_32;
 6715|      0|                }
 6716|      0|                if ((int const) * p == 70) {
 6717|      0|                    goto case_32;
 6718|      0|                }
 6719|      0|                if ((int const) * p == 71) {
 6720|      0|                    goto case_32;
 6721|      0|                }
 6722|      0|                if ((int const) * p == 72) {
 6723|      0|                    goto case_32;
 6724|      0|                }
 6725|      0|                if ((int const) * p == 73) {
 6726|      0|                    goto case_32;
 6727|      0|                }
 6728|      0|                if ((int const) * p == 74) {
 6729|      0|                    goto case_32;
 6730|      0|                }
 6731|      0|                if ((int const) * p == 75) {
 6732|      0|                    goto case_32;
 6733|      0|                }
 6734|      0|                if ((int const) * p == 76) {
 6735|      0|                    goto case_32;
 6736|      0|                }
 6737|      0|                if ((int const) * p == 77) {
 6738|      0|                    goto case_32;
 6739|      0|                }
 6740|      0|                if ((int const) * p == 78) {
 6741|      0|                    goto case_32;
 6742|      0|                }
 6743|      0|                if ((int const) * p == 79) {
 6744|      0|                    goto case_32;
 6745|      0|                }
 6746|      0|                if ((int const) * p == 80) {
 6747|      0|                    goto case_32;
 6748|      0|                }
 6749|      0|                if ((int const) * p == 81) {
 6750|      0|                    goto case_32;
 6751|      0|                }
 6752|      0|                if ((int const) * p == 82) {
 6753|      0|                    goto case_32;
 6754|      0|                }
 6755|      0|                if ((int const) * p == 83) {
 6756|      0|                    goto case_32;
 6757|      0|                }
 6758|      0|                if ((int const) * p == 84) {
 6759|      0|                    goto case_32;
 6760|      0|                }
 6761|      0|                if ((int const) * p == 85) {
 6762|      0|                    goto case_32;
 6763|      0|                }
 6764|      0|                if ((int const) * p == 86) {
 6765|      0|                    goto case_32;
 6766|      0|                }
 6767|      0|                if ((int const) * p == 87) {
 6768|      0|                    goto case_32;
 6769|      0|                }
 6770|      0|                if ((int const) * p == 88) {
 6771|      0|                    goto case_32;
 6772|      0|                }
 6773|      0|                if ((int const) * p == 89) {
 6774|      0|                    goto case_32;
 6775|      0|                }
 6776|      0|                if ((int const) * p == 90) {
 6777|      0|                    goto case_32;
 6778|      0|                }
 6779|      0|                if ((int const) * p == 91) {
 6780|      0|                    goto case_32;
 6781|      0|                }
 6782|      0|                if ((int const) * p == 92) {
 6783|      0|                    goto case_32;
 6784|      0|                }
 6785|      0|                if ((int const) * p == 93) {
 6786|      0|                    goto case_32;
 6787|      0|                }
 6788|      0|                if ((int const) * p == 94) {
 6789|      0|                    goto case_32;
 6790|      0|                }
 6791|      0|                if ((int const) * p == 95) {
 6792|      0|                    goto case_32;
 6793|      0|                }
 6794|      0|                if ((int const) * p == 97) {
 6795|      0|                    goto case_32;
 6796|      0|                }
 6797|      0|                if ((int const) * p == 98) {
 6798|      0|                    goto case_32;
 6799|      0|                }
 6800|      0|                if ((int const) * p == 99) {
 6801|      0|                    goto case_32;
 6802|      0|                }
 6803|      0|                if ((int const) * p == 100) {
 6804|      0|                    goto case_32;
 6805|      0|                }
 6806|      0|                if ((int const) * p == 101) {
 6807|      0|                    goto case_32;
 6808|      0|                }
 6809|      0|                if ((int const) * p == 102) {
 6810|      0|                    goto case_32;
 6811|      0|                }
 6812|      0|                if ((int const) * p == 103) {
 6813|      0|                    goto case_32;
 6814|      0|                }
 6815|      0|                if ((int const) * p == 104) {
 6816|      0|                    goto case_32;
 6817|      0|                }
 6818|      0|                if ((int const) * p == 105) {
 6819|      0|                    goto case_32;
 6820|      0|                }
 6821|      0|                if ((int const) * p == 106) {
 6822|      0|                    goto case_32;
 6823|      0|                }
 6824|      0|                if ((int const) * p == 107) {
 6825|      0|                    goto case_32;
 6826|      0|                }
 6827|      0|                if ((int const) * p == 108) {
 6828|      0|                    goto case_32;
 6829|      0|                }
 6830|      0|                if ((int const) * p == 109) {
 6831|      0|                    goto case_32;
 6832|      0|                }
 6833|      0|                if ((int const) * p == 110) {
 6834|      0|                    goto case_32;
 6835|      0|                }
 6836|      0|                if ((int const) * p == 111) {
 6837|      0|                    goto case_32;
 6838|      0|                }
 6839|      0|                if ((int const) * p == 112) {
 6840|      0|                    goto case_32;
 6841|      0|                }
 6842|      0|                if ((int const) * p == 113) {
 6843|      0|                    goto case_32;
 6844|      0|                }
 6845|      0|                if ((int const) * p == 114) {
 6846|      0|                    goto case_32;
 6847|      0|                }
 6848|      0|                if ((int const) * p == 115) {
 6849|      0|                    goto case_32;
 6850|      0|                }
 6851|      0|                if ((int const) * p == 116) {
 6852|      0|                    goto case_32;
 6853|      0|                }
 6854|      0|                if ((int const) * p == 117) {
 6855|      0|                    goto case_32;
 6856|      0|                }
 6857|      0|                if ((int const) * p == 118) {
 6858|      0|                    goto case_32;
 6859|      0|                }
 6860|      0|                if ((int const) * p == 119) {
 6861|      0|                    goto case_32;
 6862|      0|                }
 6863|      0|                if ((int const) * p == 120) {
 6864|      0|                    goto case_32;
 6865|      0|                }
 6866|      0|                if ((int const) * p == 121) {
 6867|      0|                    goto case_32;
 6868|      0|                }
 6869|      0|                if ((int const) * p == 122) {
 6870|      0|                    goto case_32;
 6871|      0|                }
 6872|      0|                if ((int const) * p == 123) {
 6873|      0|                    goto case_32;
 6874|      0|                }
 6875|      0|                if ((int const) * p == 124) {
 6876|      0|                    goto case_32;
 6877|      0|                }
 6878|      0|                if ((int const) * p == 125) {
 6879|      0|                    goto case_32;
 6880|      0|                }
 6881|      0|                if ((int const) * p == 126) {
 6882|      0|                    goto case_32;
 6883|      0|                }
 6884|      0|                goto switch_default;
 6885|      0|case_32:
 6886|      0|                p++;
 6887|      0|                width++;
 6888|      0|                goto switch_break;
 6889|      0|switch_default:
 6890|      0|                memset((void *)(&mbstate), 0, sizeof(mbstate));
 6891|      0|                while (1) {
 6892|      0|                    bytes = mbrtowc(&wc, p, (size_t)(plimit - p), &mbstate);
 6893|      0|                    if (bytes == 0xffffffffffffffffUL) {
 6894|      0|                        if (!(flags & 1)) {
 6895|      0|                            p++;
 6896|      0|                            width++;
 6897|      0|                            goto while_break___0;
 6898|      0|                        }
 6899|      0|                        else {
 6900|      0|                            return (-1);
 6901|      0|                        }
 6902|      0|                    }
 6903|      0|                    if (bytes == 0xfffffffffffffffeUL) {
 6904|      0|                        if (!(flags & 1)) {
 6905|      0|                            p = plimit;
 6906|      0|                            width++;
 6907|      0|                            goto while_break___0;
 6908|      0|                        }
 6909|      0|                        else {
 6910|      0|                            return (-1);
 6911|      0|                        }
 6912|      0|                    }
 6913|      0|                    if (bytes == 0UL) {
 6914|      0|                        bytes = (size_t)1;
 6915|      0|                    }
 6916|      0|                    w = wcwidth(wc);
 6917|      0|                    if (w >= 0) {
 6918|      0|                        if (w > 2147483647 - width) {
 6919|      0|                            goto overflow;
 6920|      0|                        }
 6921|      0|                        width += w;
 6922|      0|                    }
 6923|      0|                    else {
 6924|      0|                        if (!(flags & 2)) {
 6925|      0|                            tmp = iswcntrl((wint_t)wc);
 6926|      0|                            if (!tmp) {
 6927|      0|                                if (width == 2147483647) {
 6928|      0|                                    goto overflow;
 6929|      0|                                }
 6930|      0|                                width++;
 6931|      0|                            }
 6932|      0|                        }
 6933|      0|                        else {
 6934|      0|                            return (-1);
 6935|      0|                        }
 6936|      0|                    }
 6937|      0|                    p += bytes;
 6938|      0|                    tmp___0 = mbsinit((mbstate_t const *)(&mbstate));
 6939|      0|                    if (tmp___0) {
 6940|      0|                        goto while_break___0;
 6941|      0|                    }
 6942|      0|                }
 6943|      0|while_break___0:
 6944|      0|                ;
 6945|      0|                goto switch_break;
 6946|      0|switch_break:
 6947|      0|                ;
 6948|      0|            }
 6949|      0|while_break:
 6950|      0|            ;
 6951|      0|            return (width);
 6952|      0|        }
 6953|      0|        while (1) {
 6954|       |
 6955|      0|            if (!((unsigned long)p < (unsigned long)plimit)) {
 6956|      0|                goto while_break___1;
 6957|      0|            }
 6958|      0|            tmp___2 = p;
 6959|      0|            p++;
 6960|      0|            c = (unsigned char)*tmp___2;
 6961|      0|            tmp___4 = __ctype_b_loc();
 6962|      0|            if ((int const) * (*tmp___4 + (int)c) & 16384) {
 6963|      0|                if (width == 2147483647) {
 6964|      0|                    goto overflow;
 6965|      0|                }
 6966|      0|                width++;
 6967|      0|            }
 6968|      0|            else {
 6969|      0|                if (!(flags & 2)) {
 6970|      0|                    tmp___3 = __ctype_b_loc();
 6971|      0|                    if (!((int const) * (*tmp___3 + (int)c) & 2)) {
 6972|      0|                        if (width == 2147483647) {
 6973|      0|                            goto overflow;
 6974|      0|                        }
 6975|      0|                        width++;
 6976|      0|                    }
 6977|      0|                }
 6978|      0|                else {
 6979|      0|                    return (-1);
 6980|      0|                }
 6981|      0|            }
 6982|      0|        }
 6983|      0|while_break___1:
 6984|      0|        ;
 6985|      0|        return (width);
 6986|      0|overflow:
 6987|      0|        return (2147483647);
 6988|      0|    }
 6989|      0|}
 6990|       |int(__attribute__((__nonnull__(1, 2))) mbscasecmp)(char const *s1,
 6991|       |        char const *s2);
 6992|       |extern __attribute__((__nothrow__))
 6993|       |wint_t(__attribute__((__leaf__)) towlower)(wint_t __wc);
 6994|       |int(__attribute__((__nonnull__(1, 2))) mbscasecmp)(char const *s1,
 6995|       |        char const *s2)
 6996|      0|{
 6997|      0|    mbui_iterator_t iter1;
 6998|      0|    mbui_iterator_t iter2;
 6999|      0|    int cmp;
 7000|      0|    wint_t tmp;
 7001|      0|    wint_t tmp___0;
 7002|      0|    int tmp___1;
 7003|      0|    int tmp___2;
 7004|      0|    int tmp___4;
 7005|      0|    int tmp___5;
 7006|      0|    int tmp___7;
 7007|      0|    int tmp___8;
 7008|      0|    int tmp___9;
 7009|      0|    int tmp___10;
 7010|      0|    int tmp___11;
 7011|      0|    int tmp___12;
 7012|      0|    int tmp___13;
 7013|      0|    int tmp___14;
 7014|      0|    int tmp___15;
 7015|      0|    int tmp___16;
 7016|      0|    unsigned char const *p1;
 7017|      0|    unsigned char const *p2;
 7018|      0|    unsigned char c1;
 7019|      0|    unsigned char c2;
 7020|      0|    int tmp___18;
 7021|      0|    unsigned short const **tmp___19;
 7022|      0|    int tmp___21;
 7023|      0|    unsigned short const **tmp___22;
 7024|      0|    size_t tmp___25;
 7025|       |
 7026|      0|    {
 7027|      0|        if ((unsigned long)s1 == (unsigned long)s2) {
 7028|      0|            return (0);
 7029|      0|        }
 7030|      0|        tmp___25 = __ctype_get_mb_cur_max();
 7031|      0|        if (tmp___25 > 1UL) {
 7032|      0|            iter1.cur.ptr = s1;
 7033|      0|            iter1.in_shift = (_Bool)0;
 7034|      0|            memset((void *)(&iter1.state), '\000', sizeof(mbstate_t));
 7035|      0|            iter1.next_done = (_Bool)0;
 7036|      0|            iter2.cur.ptr = s2;
 7037|      0|            iter2.in_shift = (_Bool)0;
 7038|      0|            memset((void *)(&iter2.state), '\000', sizeof(mbstate_t));
 7039|      0|            iter2.next_done = (_Bool)0;
 7040|      0|            while (1) {
 7041|      0|                mbuiter_multi_next(&iter1);
 7042|      0|                if (iter1.cur.wc_valid) {
 7043|      0|                    if (iter1.cur.wc == 0) {
 7044|      0|                        tmp___13 = 0;
 7045|      0|                    }
 7046|      0|                    else {
 7047|      0|                        tmp___13 = 1;
 7048|      0|                    }
 7049|      0|                }
 7050|      0|                else {
 7051|      0|                    tmp___13 = 1;
 7052|      0|                }
 7053|      0|                if (tmp___13) {
 7054|      0|                    mbuiter_multi_next(&iter2);
 7055|      0|                    if (iter2.cur.wc_valid) {
 7056|      0|                        if (iter2.cur.wc == 0) {
 7057|      0|                            tmp___14 = 0;
 7058|      0|                        }
 7059|      0|                        else {
 7060|      0|                            tmp___14 = 1;
 7061|      0|                        }
 7062|      0|                    }
 7063|      0|                    else {
 7064|      0|                        tmp___14 = 1;
 7065|      0|                    }
 7066|      0|                    if (!tmp___14) {
 7067|      0|                        goto while_break;
 7068|      0|                    }
 7069|      0|                }
 7070|      0|                else {
 7071|      0|                    goto while_break;
 7072|      0|                }
 7073|      0|                if (iter1.cur.wc_valid) {
 7074|      0|                    if (iter2.cur.wc_valid) {
 7075|      0|                        tmp = towlower((wint_t)iter1.cur.wc);
 7076|      0|                        tmp___0 = towlower((wint_t)iter2.cur.wc);
 7077|      0|                        tmp___1 = (int)tmp - (int)tmp___0;
 7078|      0|                    }
 7079|      0|                    else {
 7080|      0|                        tmp___1 = -1;
 7081|      0|                    }
 7082|      0|                    tmp___12 = tmp___1;
 7083|      0|                }
 7084|      0|                else {
 7085|      0|                    if (iter2.cur.wc_valid) {
 7086|      0|                        tmp___11 = 1;
 7087|      0|                    }
 7088|      0|                    else {
 7089|      0|                        if (iter1.cur.bytes == iter2.cur.bytes) {
 7090|      0|                            tmp___2 = memcmp((void const *)iter1.cur.ptr,
 7091|      0|                                             (void const *)iter2.cur.ptr, iter1.cur.bytes);
 7092|      0|                            tmp___10 = tmp___2;
 7093|      0|                        }
 7094|      0|                        else {
 7095|      0|                            if (iter1.cur.bytes < iter2.cur.bytes) {
 7096|      0|                                tmp___5 = memcmp((void const *)iter1.cur.ptr,
 7097|      0|                                                 (void const *)iter2.cur.ptr, iter1.cur.bytes);
 7098|      0|                                if (tmp___5 > 0) {
 7099|      0|                                    tmp___4 = 1;
 7100|      0|                                }
 7101|      0|                                else {
 7102|      0|                                    tmp___4 = -1;
 7103|      0|                                }
 7104|      0|                                tmp___9 = tmp___4;
 7105|      0|                            }
 7106|      0|                            else {
 7107|      0|                                tmp___8 = memcmp((void const *)iter1.cur.ptr,
 7108|      0|                                                 (void const *)iter2.cur.ptr, iter2.cur.bytes);
 7109|      0|                                if (tmp___8 >= 0) {
 7110|      0|                                    tmp___7 = 1;
 7111|      0|                                }
 7112|      0|                                else {
 7113|      0|                                    tmp___7 = -1;
 7114|      0|                                }
 7115|      0|                                tmp___9 = tmp___7;
 7116|      0|                            }
 7117|      0|                            tmp___10 = tmp___9;
 7118|      0|                        }
 7119|      0|                        tmp___11 = tmp___10;
 7120|      0|                    }
 7121|      0|                    tmp___12 = tmp___11;
 7122|      0|                }
 7123|      0|                cmp = tmp___12;
 7124|      0|                if (cmp != 0) {
 7125|      0|                    return (cmp);
 7126|      0|                }
 7127|      0|                iter1.cur.ptr += iter1.cur.bytes;
 7128|      0|                iter1.next_done = (_Bool)0;
 7129|      0|                iter2.cur.ptr += iter2.cur.bytes;
 7130|      0|                iter2.next_done = (_Bool)0;
 7131|      0|            }
 7132|      0|while_break:
 7133|      0|            mbuiter_multi_next(&iter1);
 7134|      0|            if (iter1.cur.wc_valid) {
 7135|      0|                if (iter1.cur.wc == 0) {
 7136|      0|                    tmp___15 = 0;
 7137|      0|                }
 7138|      0|                else {
 7139|      0|                    tmp___15 = 1;
 7140|      0|                }
 7141|      0|            }
 7142|      0|            else {
 7143|      0|                tmp___15 = 1;
 7144|      0|            }
 7145|      0|            if (tmp___15) {
 7146|      0|                return (1);
 7147|      0|            }
 7148|      0|            mbuiter_multi_next(&iter2);
 7149|      0|            if (iter2.cur.wc_valid) {
 7150|      0|                if (iter2.cur.wc == 0) {
 7151|      0|                    tmp___16 = 0;
 7152|      0|                }
 7153|      0|                else {
 7154|      0|                    tmp___16 = 1;
 7155|      0|                }
 7156|      0|            }
 7157|      0|            else {
 7158|      0|                tmp___16 = 1;
 7159|      0|            }
 7160|      0|            if (tmp___16) {
 7161|      0|                return (-1);
 7162|      0|            }
 7163|      0|            return (0);
 7164|      0|        }
 7165|      0|        else {
 7166|      0|            p1 = (unsigned char const *)s1;
 7167|      0|            p2 = (unsigned char const *)s2;
 7168|      0|            while (1) {
 7169|      0|                tmp___19 = __ctype_b_loc();
 7170|      0|                if ((int const) * (*tmp___19 + (int)*p1) & 256) {
 7171|      0|                    tmp___18 = tolower((int)*p1);
 7172|      0|                    c1 = (unsigned char)tmp___18;
 7173|      0|                }
 7174|      0|                else {
 7175|      0|                    c1 = (unsigned char)*p1;
 7176|      0|                }
 7177|      0|                tmp___22 = __ctype_b_loc();
 7178|      0|                if ((int const) * (*tmp___22 + (int)*p2) & 256) {
 7179|      0|                    tmp___21 = tolower((int)*p2);
 7180|      0|                    c2 = (unsigned char)tmp___21;
 7181|      0|                }
 7182|      0|                else {
 7183|      0|                    c2 = (unsigned char)*p2;
 7184|      0|                }
 7185|      0|                if ((int)c1 == 0) {
 7186|      0|                    goto while_break___0;
 7187|      0|                }
 7188|      0|                p1++;
 7189|      0|                p2++;
 7190|      0|                if (!((int)c1 == (int)c2)) {
 7191|      0|                    goto while_break___0;
 7192|      0|                }
 7193|      0|            }
 7194|      0|while_break___0:
 7195|      0|            ;
 7196|      0|            return ((int)c1 - (int)c2);
 7197|      0|        }
 7198|      0|    }
 7199|      0|}
 7200|       |unsigned int const is_basic_table[8] = {
 7201|       |    (unsigned int const)6656, (unsigned int const)4294967279U,
 7202|       |    (unsigned int const)4294967294U, (unsigned int const)2147483646
 7203|       |};
 7204|       |extern __attribute__((__nothrow__, __noreturn__)) void(
 7205|       |    __attribute__((__leaf__)) exit)(int __status);
 7206|       |extern int optind;
 7207|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) getopt_long)(
 7208|       |    int ___argc, char *const *___argv, char const *__shortopts,
 7209|       |    struct option const *__longopts, int *__longind);
 7210|       |extern __attribute__((__nothrow__)) int(
 7211|       |    __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(
 7212|       |        pthread_mutex_t *__mutex, pthread_mutexattr_t const *__mutexattr);
 7213|       |#pragma weak pthread_mutex_init
 7214|       |#pragma weak pthread_mutex_lock
 7215|       |#pragma weak pthread_mutex_unlock
 7216|       |#pragma weak pthread_mutex_destroy
 7217|       |#pragma weak pthread_rwlock_init
 7218|       |#pragma weak pthread_rwlock_rdlock
 7219|       |#pragma weak pthread_rwlock_wrlock
 7220|       |#pragma weak pthread_rwlock_unlock
 7221|       |#pragma weak pthread_rwlock_destroy
 7222|       |#pragma weak pthread_once
 7223|       |#pragma weak pthread_cond_init
 7224|       |#pragma weak pthread_cond_wait
 7225|       |#pragma weak pthread_cond_signal
 7226|       |#pragma weak pthread_cond_broadcast
 7227|       |#pragma weak pthread_cond_destroy
 7228|       |#pragma weak pthread_mutexattr_init
 7229|       |#pragma weak pthread_mutexattr_settype
 7230|       |#pragma weak pthread_mutexattr_destroy
 7231|       |#pragma weak pthread_self
 7232|       |#pragma weak pthread_cancel
 7233|       |extern __attribute__((__nothrow__))
 7234|       |FILE *(__attribute__((__leaf__)) fdopen)(int __fd, char const *__modes);
 7235|       |extern int fscanf(FILE *__restrict __stream, char const *__restrict __format,
 7236|       |                  ...);
 7237|       |extern int ungetc(int __c, FILE *__stream);
 7238|       |static char const *volatile charset_aliases;
 7239|       |static char const *get_charset_aliases(void)
 7240|      0|{
 7241|      0|    char const *cp;
 7242|      0|    char const *dir;
 7243|      0|    char const *base;
 7244|      0|    char *file_name___3;
 7245|      0|    size_t dir_len___0;
 7246|      0|    size_t tmp;
 7247|      0|    size_t base_len___0;
 7248|      0|    size_t tmp___0;
 7249|      0|    int add_slash;
 7250|      0|    int tmp___1;
 7251|      0|    int fd;
 7252|      0|    FILE *fp;
 7253|      0|    char *res_ptr;
 7254|      0|    size_t res_size;
 7255|      0|    int c;
 7256|      0|    char buf1[51];
 7257|      0|    char buf2[51];
 7258|      0|    size_t l1;
 7259|      0|    size_t l2;
 7260|      0|    char *old_res_ptr;
 7261|      0|    int tmp___3;
 7262|       |
 7263|      0|    {
 7264|      0|        cp = (char const *)charset_aliases;
 7265|      0|        if ((unsigned long)cp == (unsigned long)((void *)0)) {
 7266|      0|            base = "charset.alias";
 7267|      0|            dir = (char const *)getenv("CHARSETALIASDIR");
 7268|      0|            if ((unsigned long)dir == (unsigned long)((void *)0)) {
 7269|      0|                dir = "/usr/local/lib";
 7270|      0|            }
 7271|      0|            else {
 7272|      0|                if ((int const) * (dir + 0) == 0) {
 7273|      0|                    dir = "/usr/local/lib";
 7274|      0|                }
 7275|      0|            }
 7276|      0|            tmp = strlen(dir);
 7277|      0|            dir_len___0 = tmp;
 7278|      0|            tmp___0 = strlen(base);
 7279|      0|            base_len___0 = tmp___0;
 7280|      0|            if (dir_len___0 > 0UL) {
 7281|      0|                if (!((int const) * (dir + (dir_len___0 - 1UL)) == 47)) {
 7282|      0|                    tmp___1 = 1;
 7283|      0|                }
 7284|      0|                else {
 7285|      0|                    tmp___1 = 0;
 7286|      0|                }
 7287|      0|            }
 7288|      0|            else {
 7289|      0|                tmp___1 = 0;
 7290|      0|            }
 7291|      0|            add_slash = tmp___1;
 7292|      0|            file_name___3 = (char *)malloc(
 7293|      0|                                ((dir_len___0 + (size_t)add_slash) + base_len___0) + 1UL);
 7294|      0|            if ((unsigned long)file_name___3 != (unsigned long)((void *)0)) {
 7295|      0|                memcpy((void *)file_name___3, (void const *)dir, dir_len___0);
 7296|      0|                if (add_slash) {
 7297|      0|                    *(file_name___3 + dir_len___0) = (char)'/';
 7298|      0|                }
 7299|      0|                memcpy((void *)((file_name___3 + dir_len___0) + add_slash),
 7300|      0|                       (void const *)base, base_len___0 + 1UL);
 7301|      0|            }
 7302|      0|            if ((unsigned long)file_name___3 == (unsigned long)((void *)0)) {
 7303|      0|                cp = "";
 7304|      0|            }
 7305|      0|            else {
 7306|      0|                fd = open((char const *)file_name___3, 131072);
 7307|      0|                if (fd < 0) {
 7308|      0|                    cp = "";
 7309|      0|                }
 7310|      0|                else {
 7311|      0|                    fp = fdopen(fd, "r");
 7312|      0|                    if ((unsigned long)fp == (unsigned long)((void *)0)) {
 7313|      0|                        close(fd);
 7314|      0|                        cp = "";
 7315|      0|                    }
 7316|      0|                    else {
 7317|      0|                        res_ptr = (char *)((void *)0);
 7318|      0|                        res_size = (size_t)0;
 7319|      0|                        while (1) {
 7320|      0|                            c = getc_unlocked(fp);
 7321|      0|                            if (c == -1) {
 7322|      0|                                goto while_break;
 7323|      0|                            }
 7324|      0|                            if (c == 10) {
 7325|      0|                                goto __Cont;
 7326|      0|                            }
 7327|      0|                            else {
 7328|      0|                                if (c == 32) {
 7329|      0|                                    goto __Cont;
 7330|      0|                                }
 7331|      0|                                else {
 7332|      0|                                    if (c == 9) {
 7333|      0|                                        goto __Cont;
 7334|      0|                                    }
 7335|      0|                                }
 7336|      0|                            }
 7337|      0|                            if (c == 35) {
 7338|      0|                                while (1) {
 7339|      0|                                    c = getc_unlocked(fp);
 7340|      0|                                    if (c == -1) {
 7341|      0|                                        goto while_break___0;
 7342|      0|                                    }
 7343|      0|                                    else {
 7344|      0|                                        if (c == 10) {
 7345|      0|                                            goto while_break___0;
 7346|      0|                                        }
 7347|      0|                                    }
 7348|      0|                                }
 7349|      0|while_break___0:
 7350|      0|                                ;
 7351|      0|                                if (c == -1) {
 7352|      0|                                    goto while_break;
 7353|      0|                                }
 7354|      0|                                goto __Cont;
 7355|      0|                            }
 7356|      0|                            ungetc(c, fp);
 7357|      0|                            tmp___3 = fscanf(fp, "%50s %50s", buf1, buf2);
 7358|      0|                            if (tmp___3 < 2) {
 7359|      0|                                goto while_break;
 7360|      0|                            }
 7361|      0|                            l1 = strlen((char const *)(buf1));
 7362|      0|                            l2 = strlen((char const *)(buf2));
 7363|      0|                            old_res_ptr = res_ptr;
 7364|      0|                            if (res_size == 0UL) {
 7365|      0|                                res_size = ((l1 + 1UL) + l2) + 1UL;
 7366|      0|                                res_ptr = (char *)malloc(res_size + 1UL);
 7367|      0|                            }
 7368|      0|                            else {
 7369|      0|                                res_size += ((l1 + 1UL) + l2) + 1UL;
 7370|      0|                                res_ptr = (char *)realloc((void *)res_ptr, res_size + 1UL);
 7371|      0|                            }
 7372|      0|                            if ((unsigned long)res_ptr == (unsigned long)((void *)0)) {
 7373|      0|                                res_size = (size_t)0;
 7374|      0|                                free((void *)old_res_ptr);
 7375|      0|                                goto while_break;
 7376|      0|                            }
 7377|      0|                            strcpy(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL),
 7378|      0|                                   (char const *)(buf1));
 7379|      0|                            strcpy((res_ptr + res_size) - (l2 + 1UL), (char const *)(buf2));
 7380|      0|__Cont:
 7381|      0|                            ;
 7382|      0|                        }
 7383|      0|while_break:
 7384|      0|                        rpl_fclose(fp);
 7385|      0|                        if (res_size == 0UL) {
 7386|      0|                            cp = "";
 7387|      0|                        }
 7388|      0|                        else {
 7389|      0|                            *(res_ptr + res_size) = (char)'\000';
 7390|      0|                            cp = (char const *)res_ptr;
 7391|      0|                        }
 7392|      0|                    }
 7393|      0|                }
 7394|      0|                free((void *)file_name___3);
 7395|      0|            }
 7396|      0|            charset_aliases = cp;
 7397|      0|        }
 7398|      0|        return (cp);
 7399|      0|    }
 7400|      0|}
 7401|       |char const *locale_charset(void)
 7402|      0|{
 7403|      0|    char const *codeset;
 7404|      0|    char const *aliases;
 7405|      0|    size_t tmp;
 7406|      0|    size_t tmp___0;
 7407|      0|    size_t tmp___1;
 7408|      0|    int tmp___2;
 7409|       |
 7410|      0|    {
 7411|      0|        codeset = (char const *)nl_langinfo(14);
 7412|      0|        if ((unsigned long)codeset == (unsigned long)((void *)0)) {
 7413|      0|            codeset = "";
 7414|      0|        }
 7415|      0|        aliases = get_charset_aliases();
 7416|      0|        while (1) {
 7417|       |
 7418|      0|            if (!((int const) * aliases != 0)) {
 7419|      0|                goto while_break;
 7420|      0|            }
 7421|      0|            tmp___2 = strcmp(codeset, aliases);
 7422|      0|            if (tmp___2 == 0) {
 7423|      0|                tmp___1 = strlen(aliases);
 7424|      0|                codeset = (aliases + tmp___1) + 1;
 7425|      0|                goto while_break;
 7426|      0|            }
 7427|      0|            else {
 7428|      0|                if ((int const) * (aliases + 0) == 42) {
 7429|      0|                    if ((int const) * (aliases + 1) == 0) {
 7430|      0|                        tmp___1 = strlen(aliases);
 7431|      0|                        codeset = (aliases + tmp___1) + 1;
 7432|      0|                        goto while_break;
 7433|      0|                    }
 7434|      0|                }
 7435|      0|            }
 7436|      0|            tmp = strlen(aliases);
 7437|      0|            aliases += tmp + 1UL;
 7438|      0|            tmp___0 = strlen(aliases);
 7439|      0|            aliases += tmp___0 + 1UL;
 7440|      0|        }
 7441|      0|while_break:
 7442|      0|        ;
 7443|      0|        if ((int const) * (codeset + 0) == 0) {
 7444|      0|            codeset = "ASCII";
 7445|      0|        }
 7446|      0|        return (codeset);
 7447|      0|    }
 7448|      0|}
 7449|       |extern __attribute__((__nothrow__)) long double(__attribute__((
 7450|       |            __nonnull__(1), __leaf__)) strtold)(char const *__restrict __nptr,
 7451|       |                    char **__restrict __endptr);
 7452|       |#pragma GCC diagnostic ignored "-Wtype-limits"
 7453|       |#pragma GCC diagnostic ignored "-Wtype-limits"
 7454|       |extern __attribute__((__nothrow__)) struct lconv *(
 7455|       |    __attribute__((__leaf__)) localeconv)(void);
 7456|       |struct heap *heap_alloc(int (*compare___0)(void const *, void const *),
 7457|       |                        size_t n_reserve);
 7458|       |void heap_free(struct heap *heap);
 7459|       |int heap_insert(struct heap *heap, void *item);
 7460|       |void *heap_remove_top(struct heap *heap);
 7461|       |static size_t heapify_down(void **array, size_t count, size_t initial,
 7462|       |                           int (*compare___0)(void const *, void const *));
 7463|       |static void heapify_up(void **array, size_t count,
 7464|       |                       int (*compare___0)(void const *, void const *));
 7465|       |static int heap_default_compare(void const *a, void const *b)
 7466|      0|{
 7467|       |
 7468|      0|    {
 7469|      0|        return (0);
 7470|      0|    }
 7471|      0|}
 7472|       |struct heap *heap_alloc(int (*compare___0)(void const *, void const *),
 7473|       |                        size_t n_reserve)
 7474|      2|{
 7475|      2|    struct heap *heap;
 7476|      2|    struct heap *tmp;
 7477|       |
 7478|      2|    {
 7479|      2|        tmp = (struct heap *)xmalloc(sizeof(*heap));
 7480|      2|        heap = tmp;
 7481|      2|        if (n_reserve == 0UL) {
 7482|      0|            n_reserve = (size_t)1;
 7483|      0|        }
 7484|      2|        heap->array = (void **)xnmalloc(n_reserve, sizeof(*(heap->array)));
 7485|      2|        *(heap->array + 0) = (void *)0;
 7486|      2|        heap->capacity = n_reserve;
 7487|      2|        heap->count = (size_t)0;
 7488|      2|        if (compare___0) {
 7489|      2|            heap->compare = compare___0;
 7490|      2|        }
 7491|      0|        else {
 7492|      0|            heap->compare = &heap_default_compare;
 7493|      0|        }
 7494|      2|        return (heap);
 7495|      2|    }
 7496|      2|}
 7497|       |void heap_free(struct heap *heap)
 7498|      2|{
 7499|       |
 7500|      2|    {
 7501|      2|        free((void *)heap->array);
 7502|      2|        free((void *)heap);
 7503|      2|        return;
 7504|      2|    }
 7505|      2|}
 7506|       |int heap_insert(struct heap *heap, void *item)
 7507|     35|{
 7508|       |
 7509|     35|    {
 7510|     35|        if (heap->capacity - 1UL <= heap->count) {
 7511|      0|            heap->array = (void **)x2nrealloc((void *)heap->array, &heap->capacity,
 7512|      0|                                              sizeof(*(heap->array)));
 7513|      0|        }
 7514|     35|        (heap->count)++;
 7515|     35|        *(heap->array + heap->count) = item;
 7516|     35|        heapify_up(heap->array, heap->count, heap->compare);
 7517|     35|        return (0);
 7518|     35|    }
 7519|     35|}
 7520|       |void *heap_remove_top(struct heap *heap)
 7521|     33|{
 7522|     33|    void *top;
 7523|     33|    size_t tmp;
 7524|       |
 7525|     33|    {
 7526|     33|        if (heap->count == 0UL) {
 7527|      0|            return ((void *)0);
 7528|      0|        }
 7529|     33|        top = *(heap->array + 1);
 7530|     33|        tmp = heap->count;
 7531|     33|        (heap->count)--;
 7532|     33|        *(heap->array + 1) = *(heap->array + tmp);
 7533|     33|        heapify_down(heap->array, heap->count, (size_t)1, heap->compare);
 7534|     33|        return (top);
 7535|     33|    }
 7536|     33|}
 7537|       |static size_t heapify_down(void **array, size_t count, size_t initial,
 7538|       |                           int (*compare___0)(void const *, void const *))
 7539|     33|{
 7540|     33|    void *element;
 7541|     33|    size_t parent;
 7542|     33|    size_t child;
 7543|     33|    int tmp;
 7544|     33|    int tmp___0;
 7545|       |
 7546|     33|    {
 7547|     33|        element = *(array + initial);
 7548|     33|        parent = initial;
 7549|     33|        while (1) {
 7550|       |
 7551|     33|            if (!(parent <= count / 2UL)) {
 7552|     33|                goto while_break;
 7553|     33|            }
 7554|      0|            child = 2UL * parent;
 7555|      0|            if (child < count) {
 7556|      0|                tmp = (*compare___0)((void const *)*(array + child),
 7557|      0|                                     (void const *)*(array + (child + 1UL)));
 7558|      0|                if (tmp < 0) {
 7559|      0|                    child++;
 7560|      0|                }
 7561|      0|            }
 7562|      0|            tmp___0 =
 7563|      0|                (*compare___0)((void const *)*(array + child), (void const *)element);
 7564|      0|            if (tmp___0 <= 0) {
 7565|      0|                goto while_break;
 7566|      0|            }
 7567|      0|            *(array + parent) = *(array + child);
 7568|      0|            parent = child;
 7569|      0|        }
 7570|     33|while_break:
 7571|     33|        *(array + parent) = element;
 7572|     33|        return (parent);
 7573|     33|    }
 7574|     33|}
 7575|       |static void heapify_up(void **array, size_t count,
 7576|       |                       int (*compare___0)(void const *, void const *))
 7577|     35|{
 7578|     35|    size_t k;
 7579|     35|    void *new_element;
 7580|     35|    int tmp;
 7581|       |
 7582|     35|    {
 7583|     35|        k = count;
 7584|     35|        new_element = *(array + k);
 7585|     35|        while (1) {
 7586|       |
 7587|     35|            if (k != 1UL) {
 7588|      0|                tmp = (*compare___0)((void const *)*(array + k / 2UL),
 7589|      0|                                     (void const *)new_element);
 7590|      0|                if (!(tmp <= 0)) {
 7591|      0|                    goto while_break;
 7592|      0|                }
 7593|      0|            }
 7594|     35|            else {
 7595|     35|                goto while_break;
 7596|     35|            }
 7597|      0|            *(array + k) = *(array + k / 2UL);
 7598|      0|            k /= 2UL;
 7599|      0|        }
 7600|     35|while_break:
 7601|     35|        *(array + k) = new_element;
 7602|     35|        return;
 7603|     35|    }
 7604|     35|}
 7605|       |size_t hash_string(char const *string, size_t n_buckets)
 7606|       |__attribute__((__pure__));
 7607|       |_Bool(__attribute__((__warn_unused_result__)) hash_rehash)(
 7608|       |    Hash_table *table___0, size_t candidate);
 7609|       |__inline static size_t rotr_sz(size_t x, int n)
 7610|      0|{
 7611|       |
 7612|      0|    {
 7613|      0|        return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long)n))) &
 7614|      0|                0xffffffffffffffffUL);
 7615|      0|    }
 7616|      0|}
 7617|       |static struct hash_tuning const default_tuning = {0.0f, 1.0f, 0.8f, 1.414f,
 7618|       |           (_Bool)0
 7619|       |};
 7620|       |static struct hash_entry *safe_hasher(Hash_table const *table___0,
 7621|       |                                      void const *key)
 7622|      0|{
 7623|      0|    size_t n;
 7624|      0|    size_t tmp;
 7625|       |
 7626|      0|    {
 7627|      0|        tmp = (*(table___0->hasher))(key, (size_t)table___0->n_buckets);
 7628|      0|        n = tmp;
 7629|      0|        if (!(n < (size_t)table___0->n_buckets)) {
 7630|      0|            abort();
 7631|      0|        }
 7632|      0|        return ((struct hash_entry *)(table___0->bucket + n));
 7633|      0|    }
 7634|      0|}
 7635|       |size_t hash_string(char const *string, size_t n_buckets)
 7636|       |__attribute__((__pure__));
 7637|       |size_t hash_string(char const *string, size_t n_buckets)
 7638|      0|{
 7639|      0|    size_t value;
 7640|      0|    unsigned char ch;
 7641|       |
 7642|      0|    {
 7643|      0|        value = (size_t)0;
 7644|      0|        while (1) {
 7645|      0|            ch = (unsigned char)*string;
 7646|      0|            if (!ch) {
 7647|      0|                goto while_break;
 7648|      0|            }
 7649|      0|            value = (value * 31UL + (size_t)ch) % n_buckets;
 7650|      0|            string++;
 7651|      0|        }
 7652|      0|while_break:
 7653|      0|        ;
 7654|      0|        return (value);
 7655|      0|    }
 7656|      0|}
 7657|       |static _Bool is_prime(size_t candidate) __attribute__((__const__));
 7658|       |static _Bool is_prime(size_t candidate) __attribute__((__const__));
 7659|       |static _Bool is_prime(size_t candidate)
 7660|      0|{
 7661|      0|    size_t divisor;
 7662|      0|    size_t square;
 7663|      0|    int tmp;
 7664|       |
 7665|      0|    {
 7666|      0|        divisor = (size_t)3;
 7667|      0|        square = divisor * divisor;
 7668|      0|        while (1) {
 7669|       |
 7670|      0|            if (square < candidate) {
 7671|      0|                if (!(candidate % divisor)) {
 7672|      0|                    goto while_break;
 7673|      0|                }
 7674|      0|            }
 7675|      0|            else {
 7676|      0|                goto while_break;
 7677|      0|            }
 7678|      0|            divisor++;
 7679|      0|            square += 4UL * divisor;
 7680|      0|            divisor++;
 7681|      0|        }
 7682|      0|while_break:
 7683|      0|        ;
 7684|      0|        if (candidate % divisor) {
 7685|      0|            tmp = 1;
 7686|      0|        }
 7687|      0|        else {
 7688|      0|            tmp = 0;
 7689|      0|        }
 7690|      0|        return ((_Bool)tmp);
 7691|      0|    }
 7692|      0|}
 7693|       |static size_t next_prime(size_t candidate) __attribute__((__const__));
 7694|       |static size_t next_prime(size_t candidate) __attribute__((__const__));
 7695|       |static size_t next_prime(size_t candidate)
 7696|      0|{
 7697|      0|    _Bool tmp;
 7698|       |
 7699|      0|    {
 7700|      0|        if (candidate < 10UL) {
 7701|      0|            candidate = (size_t)10;
 7702|      0|        }
 7703|      0|        candidate |= 1UL;
 7704|      0|        while (1) {
 7705|       |
 7706|      0|            if (0xffffffffffffffffUL != candidate) {
 7707|      0|                tmp = is_prime(candidate);
 7708|      0|                if (tmp) {
 7709|      0|                    goto while_break;
 7710|      0|                }
 7711|      0|            }
 7712|      0|            else {
 7713|      0|                goto while_break;
 7714|      0|            }
 7715|      0|            candidate += 2UL;
 7716|      0|        }
 7717|      0|while_break:
 7718|      0|        ;
 7719|      0|        return (candidate);
 7720|      0|    }
 7721|      0|}
 7722|       |static size_t raw_hasher(void const *data, size_t n)
 7723|      0|{
 7724|      0|    size_t val;
 7725|      0|    size_t tmp;
 7726|       |
 7727|      0|    {
 7728|      0|        tmp = rotr_sz((size_t)data, 3);
 7729|      0|        val = tmp;
 7730|      0|        return (val % n);
 7731|      0|    }
 7732|      0|}
 7733|       |static _Bool raw_comparator(void const *a, void const *b)
 7734|      0|{
 7735|       |
 7736|      0|    {
 7737|      0|        return ((_Bool)((unsigned long)a == (unsigned long)b));
 7738|      0|    }
 7739|      0|}
 7740|       |static _Bool check_tuning(Hash_table *table___0)
 7741|      0|{
 7742|      0|    Hash_tuning const *tuning;
 7743|      0|    float epsilon;
 7744|       |
 7745|      0|    {
 7746|      0|        tuning = table___0->tuning;
 7747|      0|        if ((unsigned long)tuning == (unsigned long)(&default_tuning)) {
 7748|      0|            return ((_Bool)1);
 7749|      0|        }
 7750|      0|        epsilon = 0.1f;
 7751|      0|        if (epsilon < (float)tuning->growth_threshold) {
 7752|      0|            if (tuning->growth_threshold < (float const)((float)1 - epsilon)) {
 7753|      0|                if ((float)1 + epsilon < (float)tuning->growth_factor) {
 7754|      0|                    if ((float const)0 <= tuning->shrink_threshold) {
 7755|      0|                        if (tuning->shrink_threshold + (float const)epsilon <
 7756|      0|                                tuning->shrink_factor) {
 7757|      0|                            if (tuning->shrink_factor <= (float const)1) {
 7758|      0|                                if (tuning->shrink_threshold + (float const)epsilon <
 7759|      0|                                        tuning->growth_threshold) {
 7760|      0|                                    return ((_Bool)1);
 7761|      0|                                }
 7762|      0|                            }
 7763|      0|                        }
 7764|      0|                    }
 7765|      0|                }
 7766|      0|            }
 7767|      0|        }
 7768|      0|        table___0->tuning = &default_tuning;
 7769|      0|        return ((_Bool)0);
 7770|      0|    }
 7771|      0|}
 7772|       |static size_t __attribute__((__pure__))
 7773|       |compute_bucket_size(size_t candidate, Hash_tuning const *tuning)
 7774|      0|{
 7775|      0|    float new_candidate;
 7776|      0|    int tmp;
 7777|       |
 7778|      0|    {
 7779|      0|        if (!tuning->is_n_buckets) {
 7780|      0|            new_candidate =
 7781|      0|                (float)((float const)candidate / tuning->growth_threshold);
 7782|      0|            if ((float)0xffffffffffffffffUL <= new_candidate) {
 7783|      0|                return ((size_t __attribute__((__pure__)))0);
 7784|      0|            }
 7785|      0|            candidate = (size_t)new_candidate;
 7786|      0|        }
 7787|      0|        candidate = next_prime(candidate);
 7788|      0|        if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 7789|      0|            tmp = -1;
 7790|      0|        }
 7791|      0|        else {
 7792|      0|            tmp = -2;
 7793|      0|        }
 7794|      0|        if ((size_t)tmp / sizeof(struct hash_entry *) < candidate) {
 7795|      0|            return ((size_t __attribute__((__pure__)))0);
 7796|      0|        }
 7797|      0|        return ((size_t __attribute__((__pure__)))candidate);
 7798|      0|    }
 7799|      0|}
 7800|       |Hash_table *(__attribute__((__warn_unused_result__)) hash_initialize)(
 7801|       |    size_t candidate, Hash_tuning const *tuning,
 7802|       |    size_t (*hasher)(void const *, size_t),
 7803|       |    _Bool (*comparator)(void const *, void const *),
 7804|       |    void (*data_freer)(void *))
 7805|      0|{
 7806|      0|    Hash_table *table___0;
 7807|      0|    _Bool tmp;
 7808|       |
 7809|      0|    {
 7810|      0|        if ((unsigned long)hasher == (unsigned long)((void *)0)) {
 7811|      0|            hasher = &raw_hasher;
 7812|      0|        }
 7813|      0|        if ((unsigned long)comparator == (unsigned long)((void *)0)) {
 7814|      0|            comparator = &raw_comparator;
 7815|      0|        }
 7816|      0|        table___0 = (Hash_table *)malloc(sizeof(*table___0));
 7817|      0|        if ((unsigned long)table___0 == (unsigned long)((void *)0)) {
 7818|      0|            return ((Hash_table *)((void *)0));
 7819|      0|        }
 7820|      0|        if (!tuning) {
 7821|      0|            tuning = &default_tuning;
 7822|      0|        }
 7823|      0|        table___0->tuning = tuning;
 7824|      0|        tmp = check_tuning(table___0);
 7825|      0|        if (!tmp) {
 7826|      0|            goto fail;
 7827|      0|        }
 7828|      0|        table___0->n_buckets = (size_t)compute_bucket_size(candidate, tuning);
 7829|      0|        if (!table___0->n_buckets) {
 7830|      0|            goto fail;
 7831|      0|        }
 7832|      0|        table___0->bucket = (struct hash_entry *)calloc(
 7833|      0|                                table___0->n_buckets, sizeof(*(table___0->bucket)));
 7834|      0|        if ((unsigned long)table___0->bucket == (unsigned long)((void *)0)) {
 7835|      0|            goto fail;
 7836|      0|        }
 7837|      0|        table___0->bucket_limit =
 7838|      0|            (struct hash_entry const *)(table___0->bucket + table___0->n_buckets);
 7839|      0|        table___0->n_buckets_used = (size_t)0;
 7840|      0|        table___0->n_entries = (size_t)0;
 7841|      0|        table___0->hasher = hasher;
 7842|      0|        table___0->comparator = comparator;
 7843|      0|        table___0->data_freer = data_freer;
 7844|      0|        table___0->free_entry_list = (struct hash_entry *)((void *)0);
 7845|      0|        return (table___0);
 7846|      0|fail:
 7847|      0|        free((void *)table___0);
 7848|      0|        return ((Hash_table *)((void *)0));
 7849|      0|    }
 7850|      0|}
 7851|       |static struct hash_entry *allocate_entry(Hash_table *table___0)
 7852|      0|{
 7853|      0|    struct hash_entry *new;
 7854|       |
 7855|      0|    {
 7856|      0|        if (table___0->free_entry_list) {
 7857|      0|            new = table___0->free_entry_list;
 7858|      0|            table___0->free_entry_list = new->next;
 7859|      0|        }
 7860|      0|        else {
 7861|      0|            new = (struct hash_entry *)malloc(sizeof(*new));
 7862|      0|        }
 7863|      0|        return (new);
 7864|      0|    }
 7865|      0|}
 7866|       |static void free_entry(Hash_table *table___0, struct hash_entry *entry)
 7867|      0|{
 7868|       |
 7869|      0|    {
 7870|      0|        entry->data = (void *)0;
 7871|      0|        entry->next = table___0->free_entry_list;
 7872|      0|        table___0->free_entry_list = entry;
 7873|      0|        return;
 7874|      0|    }
 7875|      0|}
 7876|       |static void *hash_find_entry(Hash_table *table___0, void const *entry,
 7877|       |                             struct hash_entry **bucket_head, _Bool delete)
 7878|      0|{
 7879|      0|    struct hash_entry *bucket;
 7880|      0|    struct hash_entry *tmp;
 7881|      0|    struct hash_entry *cursor;
 7882|      0|    void *data;
 7883|      0|    struct hash_entry *next;
 7884|      0|    _Bool tmp___0;
 7885|      0|    void *data___0;
 7886|      0|    struct hash_entry *next___0;
 7887|      0|    _Bool tmp___1;
 7888|       |
 7889|      0|    {
 7890|      0|        tmp = safe_hasher((Hash_table const *)table___0, entry);
 7891|      0|        bucket = tmp;
 7892|      0|        *bucket_head = bucket;
 7893|      0|        if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
 7894|      0|            return ((void *)0);
 7895|      0|        }
 7896|      0|        if ((unsigned long)entry == (unsigned long)bucket->data) {
 7897|      0|            goto _L;
 7898|      0|        }
 7899|      0|        else {
 7900|      0|            tmp___0 = (*(table___0->comparator))(entry, (void const *)bucket->data);
 7901|      0|            if (tmp___0) {
 7902|      0|_L:
 7903|      0|                data = bucket->data;
 7904|      0|                if (delete) {
 7905|      0|                    if (bucket->next) {
 7906|      0|                        next = bucket->next;
 7907|      0|                        *bucket = *next;
 7908|      0|                        free_entry(table___0, next);
 7909|      0|                    }
 7910|      0|                    else {
 7911|      0|                        bucket->data = (void *)0;
 7912|      0|                    }
 7913|      0|                }
 7914|      0|                return (data);
 7915|      0|            }
 7916|      0|        }
 7917|      0|        cursor = bucket;
 7918|      0|        while (1) {
 7919|       |
 7920|      0|            if (!cursor->next) {
 7921|      0|                goto while_break;
 7922|      0|            }
 7923|      0|            if ((unsigned long)entry == (unsigned long)(cursor->next)->data) {
 7924|      0|                goto _L___0;
 7925|      0|            }
 7926|      0|            else {
 7927|      0|                tmp___1 = (*(table___0->comparator))(
 7928|      0|                              entry, (void const *)(cursor->next)->data);
 7929|      0|                if (tmp___1) {
 7930|      0|_L___0:
 7931|      0|                    data___0 = (cursor->next)->data;
 7932|      0|                    if (delete) {
 7933|      0|                        next___0 = cursor->next;
 7934|      0|                        cursor->next = next___0->next;
 7935|      0|                        free_entry(table___0, next___0);
 7936|      0|                    }
 7937|      0|                    return (data___0);
 7938|      0|                }
 7939|      0|            }
 7940|      0|            cursor = cursor->next;
 7941|      0|        }
 7942|      0|while_break:
 7943|      0|        ;
 7944|      0|        return ((void *)0);
 7945|      0|    }
 7946|      0|}
 7947|       |static _Bool transfer_entries(Hash_table *dst, Hash_table *src, _Bool safe)
 7948|      0|{
 7949|      0|    struct hash_entry *bucket;
 7950|      0|    struct hash_entry *cursor;
 7951|      0|    struct hash_entry *next;
 7952|      0|    void *data;
 7953|      0|    struct hash_entry *new_bucket;
 7954|      0|    struct hash_entry *new_entry;
 7955|      0|    struct hash_entry *tmp;
 7956|       |
 7957|      0|    {
 7958|      0|        bucket = src->bucket;
 7959|      0|        while (1) {
 7960|       |
 7961|      0|            if (!((unsigned long)bucket < (unsigned long)src->bucket_limit)) {
 7962|      0|                goto while_break;
 7963|      0|            }
 7964|      0|            if (bucket->data) {
 7965|      0|                cursor = bucket->next;
 7966|      0|                while (1) {
 7967|       |
 7968|      0|                    if (!cursor) {
 7969|      0|                        goto while_break___0;
 7970|      0|                    }
 7971|      0|                    data = cursor->data;
 7972|      0|                    new_bucket = safe_hasher((Hash_table const *)dst, (void const *)data);
 7973|      0|                    next = cursor->next;
 7974|      0|                    if (new_bucket->data) {
 7975|      0|                        cursor->next = new_bucket->next;
 7976|      0|                        new_bucket->next = cursor;
 7977|      0|                    }
 7978|      0|                    else {
 7979|      0|                        new_bucket->data = data;
 7980|      0|                        (dst->n_buckets_used)++;
 7981|      0|                        free_entry(dst, cursor);
 7982|      0|                    }
 7983|      0|                    cursor = next;
 7984|      0|                }
 7985|      0|while_break___0:
 7986|      0|                data = bucket->data;
 7987|      0|                bucket->next = (struct hash_entry *)((void *)0);
 7988|      0|                if (safe) {
 7989|      0|                    goto __Cont;
 7990|      0|                }
 7991|      0|                new_bucket = safe_hasher((Hash_table const *)dst, (void const *)data);
 7992|      0|                if (new_bucket->data) {
 7993|      0|                    tmp = allocate_entry(dst);
 7994|      0|                    new_entry = tmp;
 7995|      0|                    if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 7996|      0|                        return ((_Bool)0);
 7997|      0|                    }
 7998|      0|                    new_entry->data = data;
 7999|      0|                    new_entry->next = new_bucket->next;
 8000|      0|                    new_bucket->next = new_entry;
 8001|      0|                }
 8002|      0|                else {
 8003|      0|                    new_bucket->data = data;
 8004|      0|                    (dst->n_buckets_used)++;
 8005|      0|                }
 8006|      0|                bucket->data = (void *)0;
 8007|      0|                (src->n_buckets_used)--;
 8008|      0|            }
 8009|      0|__Cont:
 8010|      0|            bucket++;
 8011|      0|        }
 8012|      0|while_break:
 8013|      0|        ;
 8014|      0|        return ((_Bool)1);
 8015|      0|    }
 8016|      0|}
 8017|       |_Bool(__attribute__((__warn_unused_result__)) hash_rehash)(
 8018|       |    Hash_table *table___0, size_t candidate)
 8019|      0|{
 8020|      0|    Hash_table storage;
 8021|      0|    Hash_table *new_table;
 8022|      0|    size_t new_size;
 8023|      0|    size_t tmp;
 8024|      0|    _Bool tmp___0;
 8025|      0|    _Bool tmp___1;
 8026|      0|    _Bool tmp___2;
 8027|       |
 8028|      0|    {
 8029|      0|        tmp = (size_t)compute_bucket_size(candidate, table___0->tuning);
 8030|      0|        new_size = tmp;
 8031|      0|        if (!new_size) {
 8032|      0|            return ((_Bool)0);
 8033|      0|        }
 8034|      0|        if (new_size == table___0->n_buckets) {
 8035|      0|            return ((_Bool)1);
 8036|      0|        }
 8037|      0|        new_table = &storage;
 8038|      0|        new_table->bucket =
 8039|      0|            (struct hash_entry *)calloc(new_size, sizeof(*(new_table->bucket)));
 8040|      0|        if ((unsigned long)new_table->bucket == (unsigned long)((void *)0)) {
 8041|      0|            return ((_Bool)0);
 8042|      0|        }
 8043|      0|        new_table->n_buckets = new_size;
 8044|      0|        new_table->bucket_limit =
 8045|      0|            (struct hash_entry const *)(new_table->bucket + new_size);
 8046|      0|        new_table->n_buckets_used = (size_t)0;
 8047|      0|        new_table->n_entries = (size_t)0;
 8048|      0|        new_table->tuning = table___0->tuning;
 8049|      0|        new_table->hasher = table___0->hasher;
 8050|      0|        new_table->comparator = table___0->comparator;
 8051|      0|        new_table->data_freer = table___0->data_freer;
 8052|      0|        new_table->free_entry_list = table___0->free_entry_list;
 8053|      0|        tmp___0 = transfer_entries(new_table, table___0, (_Bool)0);
 8054|      0|        if (tmp___0) {
 8055|      0|            free((void *)table___0->bucket);
 8056|      0|            table___0->bucket = new_table->bucket;
 8057|      0|            table___0->bucket_limit = new_table->bucket_limit;
 8058|      0|            table___0->n_buckets = new_table->n_buckets;
 8059|      0|            table___0->n_buckets_used = new_table->n_buckets_used;
 8060|      0|            table___0->free_entry_list = new_table->free_entry_list;
 8061|      0|            return ((_Bool)1);
 8062|      0|        }
 8063|      0|        table___0->free_entry_list = new_table->free_entry_list;
 8064|      0|        tmp___1 = transfer_entries(table___0, new_table, (_Bool)1);
 8065|      0|        if (tmp___1) {
 8066|      0|            tmp___2 = transfer_entries(table___0, new_table, (_Bool)0);
 8067|      0|            if (!tmp___2) {
 8068|      0|                abort();
 8069|      0|            }
 8070|      0|        }
 8071|      0|        else {
 8072|      0|            abort();
 8073|      0|        }
 8074|      0|        free((void *)new_table->bucket);
 8075|      0|        return ((_Bool)0);
 8076|      0|    }
 8077|      0|}
 8078|       |int hash_insert_if_absent(Hash_table *table___0, void const *entry,
 8079|       |                          void const **matched_ent)
 8080|      0|{
 8081|      0|    void *data;
 8082|      0|    struct hash_entry *bucket;
 8083|      0|    Hash_tuning const *tuning;
 8084|      0|    float candidate;
 8085|      0|    float tmp;
 8086|      0|    _Bool tmp___0;
 8087|      0|    void *tmp___1;
 8088|      0|    struct hash_entry *new_entry;
 8089|      0|    struct hash_entry *tmp___2;
 8090|       |
 8091|      0|    {
 8092|      0|        if (!entry) {
 8093|      0|            abort();
 8094|      0|        }
 8095|      0|        data = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 8096|      0|        if ((unsigned long)data != (unsigned long)((void *)0)) {
 8097|      0|            if (matched_ent) {
 8098|      0|                *matched_ent = (void const *)data;
 8099|      0|            }
 8100|      0|            return (0);
 8101|      0|        }
 8102|      0|        if ((float const)table___0->n_buckets_used >
 8103|      0|                (table___0->tuning)->growth_threshold *
 8104|      0|                (float const)table___0->n_buckets) {
 8105|      0|            check_tuning(table___0);
 8106|      0|            if ((float const)table___0->n_buckets_used >
 8107|      0|                    (table___0->tuning)->growth_threshold *
 8108|      0|                    (float const)table___0->n_buckets) {
 8109|      0|                tuning = table___0->tuning;
 8110|      0|                if (tuning->is_n_buckets) {
 8111|      0|                    tmp = (float)((float const)table___0->n_buckets *
 8112|      0|                                  tuning->growth_factor);
 8113|      0|                }
 8114|      0|                else {
 8115|      0|                    tmp = (float)(((float const)table___0->n_buckets *
 8116|      0|                                   tuning->growth_factor) *
 8117|      0|                                  tuning->growth_threshold);
 8118|      0|                }
 8119|      0|                candidate = tmp;
 8120|      0|                if ((float)0xffffffffffffffffUL <= candidate) {
 8121|      0|                    return (-1);
 8122|      0|                }
 8123|      0|                tmp___0 = hash_rehash(table___0, (size_t)candidate);
 8124|      0|                if (!tmp___0) {
 8125|      0|                    return (-1);
 8126|      0|                }
 8127|      0|                tmp___1 = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 8128|      0|                if ((unsigned long)tmp___1 != (unsigned long)((void *)0)) {
 8129|      0|                    abort();
 8130|      0|                }
 8131|      0|            }
 8132|      0|        }
 8133|      0|        if (bucket->data) {
 8134|      0|            tmp___2 = allocate_entry(table___0);
 8135|      0|            new_entry = tmp___2;
 8136|      0|            if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 8137|      0|                return (-1);
 8138|      0|            }
 8139|      0|            new_entry->data = (void *)entry;
 8140|      0|            new_entry->next = bucket->next;
 8141|      0|            bucket->next = new_entry;
 8142|      0|            (table___0->n_entries)++;
 8143|      0|            return (1);
 8144|      0|        }
 8145|      0|        bucket->data = (void *)entry;
 8146|      0|        (table___0->n_entries)++;
 8147|      0|        (table___0->n_buckets_used)++;
 8148|      0|        return (1);
 8149|      0|    }
 8150|      0|}
 8151|       |void *(__attribute__((__warn_unused_result__)) hash_insert)(
 8152|       |    Hash_table *table___0, void const *entry)
 8153|      0|{
 8154|      0|    void const *matched_ent;
 8155|      0|    int err;
 8156|      0|    int tmp;
 8157|      0|    void const *tmp___0;
 8158|      0|    void *tmp___1;
 8159|       |
 8160|      0|    {
 8161|      0|        tmp = hash_insert_if_absent(table___0, entry, &matched_ent);
 8162|      0|        err = tmp;
 8163|      0|        if (err == -1) {
 8164|      0|            tmp___1 = (void *)0;
 8165|      0|        }
 8166|      0|        else {
 8167|      0|            if (err == 0) {
 8168|      0|                tmp___0 = matched_ent;
 8169|      0|            }
 8170|      0|            else {
 8171|      0|                tmp___0 = entry;
 8172|      0|            }
 8173|      0|            tmp___1 = (void *)tmp___0;
 8174|      0|        }
 8175|      0|        return (tmp___1);
 8176|      0|    }
 8177|      0|}
 8178|       |void *hash_delete(Hash_table *table___0, void const *entry)
 8179|      0|{
 8180|      0|    void *data;
 8181|      0|    struct hash_entry *bucket;
 8182|      0|    Hash_tuning const *tuning;
 8183|      0|    size_t candidate;
 8184|      0|    float tmp;
 8185|      0|    struct hash_entry *cursor;
 8186|      0|    struct hash_entry *next;
 8187|      0|    _Bool tmp___0;
 8188|       |
 8189|      0|    {
 8190|      0|        data = hash_find_entry(table___0, entry, &bucket, (_Bool)1);
 8191|      0|        if (!data) {
 8192|      0|            return ((void *)0);
 8193|      0|        }
 8194|      0|        (table___0->n_entries)--;
 8195|      0|        if (!bucket->data) {
 8196|      0|            (table___0->n_buckets_used)--;
 8197|      0|            if ((float const)table___0->n_buckets_used <
 8198|      0|                    (table___0->tuning)->shrink_threshold *
 8199|      0|                    (float const)table___0->n_buckets) {
 8200|      0|                check_tuning(table___0);
 8201|      0|                if ((float const)table___0->n_buckets_used <
 8202|      0|                        (table___0->tuning)->shrink_threshold *
 8203|      0|                        (float const)table___0->n_buckets) {
 8204|      0|                    tuning = table___0->tuning;
 8205|      0|                    if (tuning->is_n_buckets) {
 8206|      0|                        tmp = (float)((float const)table___0->n_buckets *
 8207|      0|                                      tuning->shrink_factor);
 8208|      0|                    }
 8209|      0|                    else {
 8210|      0|                        tmp = (float)(((float const)table___0->n_buckets *
 8211|      0|                                       tuning->shrink_factor) *
 8212|      0|                                      tuning->growth_threshold);
 8213|      0|                    }
 8214|      0|                    candidate = (size_t)tmp;
 8215|      0|                    tmp___0 = hash_rehash(table___0, candidate);
 8216|      0|                    if (!tmp___0) {
 8217|      0|                        cursor = table___0->free_entry_list;
 8218|      0|                        while (1) {
 8219|       |
 8220|      0|                            if (!cursor) {
 8221|      0|                                goto while_break;
 8222|      0|                            }
 8223|      0|                            next = cursor->next;
 8224|      0|                            free((void *)cursor);
 8225|      0|                            cursor = next;
 8226|      0|                        }
 8227|      0|while_break:
 8228|      0|                        table___0->free_entry_list = (struct hash_entry *)((void *)0);
 8229|      0|                    }
 8230|      0|                }
 8231|      0|            }
 8232|      0|        }
 8233|      0|        return (data);
 8234|      0|    }
 8235|      0|}
 8236|       |size_t hash_pjw(void const *x, size_t tablesize) __attribute__((__pure__));
 8237|       |size_t triple_hash(void const *x, size_t table_size) __attribute__((__pure__));
 8238|       |size_t triple_hash(void const *x, size_t table_size)
 8239|      0|{
 8240|      0|    struct F_triple const *p;
 8241|      0|    size_t tmp;
 8242|      0|    size_t tmp___0;
 8243|       |
 8244|      0|    {
 8245|      0|        p = (struct F_triple const *)x;
 8246|      0|        tmp___0 = hash_pjw((void const *)p->name, table_size);
 8247|      0|        tmp = tmp___0;
 8248|      0|        return ((tmp ^ (unsigned long)p->st_ino) % table_size);
 8249|      0|    }
 8250|      0|}
 8251|       |_Bool triple_compare_ino_str(void const *x, void const *y)
 8252|       |__attribute__((__pure__));
 8253|       |_Bool triple_compare_ino_str(void const *x, void const *y)
 8254|      0|{
 8255|      0|    struct F_triple const *a;
 8256|      0|    struct F_triple const *b;
 8257|      0|    int tmp___0;
 8258|      0|    int tmp___1;
 8259|       |
 8260|      0|    {
 8261|      0|        a = (struct F_triple const *)x;
 8262|      0|        b = (struct F_triple const *)y;
 8263|      0|        if (a->st_ino == b->st_ino) {
 8264|      0|            if (a->st_dev == b->st_dev) {
 8265|      0|                tmp___1 = strcmp((char const *)a->name, (char const *)b->name);
 8266|      0|                if (tmp___1 == 0) {
 8267|      0|                    tmp___0 = 1;
 8268|      0|                }
 8269|      0|                else {
 8270|      0|                    tmp___0 = 0;
 8271|      0|                }
 8272|      0|            }
 8273|      0|            else {
 8274|      0|                tmp___0 = 0;
 8275|      0|            }
 8276|      0|        }
 8277|      0|        else {
 8278|      0|            tmp___0 = 0;
 8279|      0|        }
 8280|      0|        return ((_Bool)tmp___0);
 8281|      0|    }
 8282|      0|}
 8283|       |size_t hash_pjw(void const *x, size_t tablesize) __attribute__((__pure__));
 8284|       |size_t hash_pjw(void const *x, size_t tablesize)
 8285|      0|{
 8286|      0|    char const *s;
 8287|      0|    size_t h;
 8288|       |
 8289|      0|    {
 8290|      0|        h = (size_t)0;
 8291|      0|        s = (char const *)x;
 8292|      0|        while (1) {
 8293|       |
 8294|      0|            if (!*s) {
 8295|      0|                goto while_break;
 8296|      0|            }
 8297|      0|            h = (unsigned long)*s + ((h << 9) | (h >> (sizeof(size_t) * 8UL - 9UL)));
 8298|      0|            s++;
 8299|      0|        }
 8300|      0|while_break:
 8301|      0|        ;
 8302|      0|        return (h % tablesize);
 8303|      0|    }
 8304|      0|}
 8305|       |_Bool hard_locale(int category);
 8306|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) setlocale)(
 8307|       |    int __category, char const *__locale);
 8308|       |_Bool hard_locale(int category)
 8309|      4|{
 8310|      4|    _Bool hard;
 8311|      4|    char const *p;
 8312|      4|    char const *tmp;
 8313|      4|    int tmp___0;
 8314|      4|    int tmp___1;
 8315|      4|    char *locale;
 8316|      4|    char *tmp___2;
 8317|      4|    int tmp___3;
 8318|      4|    int tmp___4;
 8319|       |
 8320|      4|    {
 8321|      4|        hard = (_Bool)1;
 8322|      4|        tmp = (char const *)setlocale(category, (char const *)((void *)0));
 8323|      4|        p = tmp;
 8324|      4|        if (p) {
 8325|      4|            if (1) {
 8326|      4|                tmp___0 = strcmp(p, "C");
 8327|      4|                if (tmp___0 == 0) {
 8328|      0|                    hard = (_Bool)0;
 8329|      0|                }
 8330|      4|                else {
 8331|      4|                    tmp___1 = strcmp(p, "POSIX");
 8332|      4|                    if (tmp___1 == 0) {
 8333|      0|                        hard = (_Bool)0;
 8334|      0|                    }
 8335|      4|                }
 8336|      4|            }
 8337|      0|            else {
 8338|      0|                tmp___2 = strdup(p);
 8339|      0|                locale = tmp___2;
 8340|      0|                if (locale) {
 8341|      0|                    p = (char const *)setlocale(category, "C");
 8342|      0|                    if (p) {
 8343|      0|                        tmp___3 = strcmp(p, (char const *)locale);
 8344|      0|                        if (tmp___3 == 0) {
 8345|      0|                            hard = (_Bool)0;
 8346|      0|                        }
 8347|      0|                        else {
 8348|      0|                            goto _L;
 8349|      0|                        }
 8350|      0|                    }
 8351|      0|                    else {
 8352|      0|_L:
 8353|      0|                        p = (char const *)setlocale(category, "POSIX");
 8354|      0|                        if (p) {
 8355|      0|                            tmp___4 = strcmp(p, (char const *)locale);
 8356|      0|                            if (tmp___4 == 0) {
 8357|      0|                                hard = (_Bool)0;
 8358|      0|                            }
 8359|      0|                        }
 8360|      0|                    }
 8361|      0|                    setlocale(category, (char const *)locale);
 8362|      0|                    free((void *)locale);
 8363|      0|                }
 8364|      0|            }
 8365|      4|        }
 8366|      4|        return (hard);
 8367|      4|    }
 8368|      4|}
 8369|       |extern int fflush_unlocked(FILE *__stream);
 8370|       |extern void(__attribute__((__nonnull__(1, 4))) qsort)(
 8371|       |    void *__base, size_t __nmemb, size_t __size,
 8372|       |    int (*__compar)(void const *, void const *));
 8373|       |extern int fseeko(FILE *__stream, __off_t __off, int __whence);
 8374|       |extern __attribute__((__nothrow__))
 8375|       |__off_t(__attribute__((__leaf__)) lseek)(int __fd, __off_t __offset,
 8376|       |        int __whence);
 8377|       |int(__attribute__((__nonnull__(1))) rpl_fseeko)(FILE *fp, off_t offset,
 8378|       |        int whence)
 8379|      0|{
 8380|      0|    off_t pos;
 8381|      0|    int tmp;
 8382|      0|    off_t tmp___0;
 8383|      0|    int tmp___1;
 8384|       |
 8385|      0|    {
 8386|      0|        if ((unsigned long)fp->_IO_read_end == (unsigned long)fp->_IO_read_ptr) {
 8387|      0|            if ((unsigned long)fp->_IO_write_ptr ==
 8388|      0|                    (unsigned long)fp->_IO_write_base) {
 8389|      0|                if ((unsigned long)fp->_IO_save_base == (unsigned long)((void *)0)) {
 8390|      0|                    tmp = fileno(fp);
 8391|      0|                    tmp___0 = lseek(tmp, offset, whence);
 8392|      0|                    pos = tmp___0;
 8393|      0|                    if (pos == -1L) {
 8394|      0|                        return (-1);
 8395|      0|                    }
 8396|      0|                    fp->_flags &= -17;
 8397|      0|                    fp->_offset = pos;
 8398|      0|                    return (0);
 8399|      0|                }
 8400|      0|            }
 8401|      0|        }
 8402|      0|        tmp___1 = fseeko(fp, offset, whence);
 8403|      0|        return (tmp___1);
 8404|      0|    }
 8405|      0|}
 8406|       |extern
 8407|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__)) dup2)(int __fd,
 8408|       |        int __fd2);
 8409|       |FILE *fopen_safer(char const *file, char const *mode)
 8410|      4|{
 8411|      4|    FILE *fp;
 8412|      4|    FILE *tmp;
 8413|      4|    int fd;
 8414|      4|    int tmp___0;
 8415|      4|    int f;
 8416|      4|    int tmp___1;
 8417|      4|    int e;
 8418|      4|    int *tmp___2;
 8419|      4|    int *tmp___3;
 8420|      4|    int e___0;
 8421|      4|    int *tmp___4;
 8422|      4|    int *tmp___5;
 8423|      4|    int tmp___6;
 8424|       |
 8425|      4|    {
 8426|      4|        tmp = fopen(file, mode);
 8427|      4|        fp = tmp;
 8428|      4|        if (fp) {
 8429|      4|            tmp___0 = fileno(fp);
 8430|      4|            fd = tmp___0;
 8431|      4|            if (0 <= fd) {
 8432|      4|                if (fd <= 2) {
 8433|      0|                    tmp___1 = dup_safer(fd);
 8434|      0|                    f = tmp___1;
 8435|      0|                    if (f < 0) {
 8436|      0|                        tmp___2 = __errno_location();
 8437|      0|                        e = *tmp___2;
 8438|      0|                        rpl_fclose(fp);
 8439|      0|                        tmp___3 = __errno_location();
 8440|      0|                        *tmp___3 = e;
 8441|      0|                        return ((FILE *)((void *)0));
 8442|      0|                    }
 8443|      0|                    tmp___6 = rpl_fclose(fp);
 8444|      0|                    if (tmp___6 != 0) {
 8445|      0|                        goto _L;
 8446|      0|                    }
 8447|      0|                    else {
 8448|      0|                        fp = fdopen(f, mode);
 8449|      0|                        if (!fp) {
 8450|      0|_L:
 8451|      0|                            tmp___4 = __errno_location();
 8452|      0|                            e___0 = *tmp___4;
 8453|      0|                            close(f);
 8454|      0|                            tmp___5 = __errno_location();
 8455|      0|                            *tmp___5 = e___0;
 8456|      0|                            return ((FILE *)((void *)0));
 8457|      0|                        }
 8458|      0|                    }
 8459|      0|                }
 8460|      4|            }
 8461|      4|        }
 8462|      4|        return (fp);
 8463|      4|    }
 8464|      4|}
 8465|       |int filevercmp(char const *s1, char const *s2);
 8466|       |static char const *match_suffix(char const **str)
 8467|      0|{
 8468|      0|    char const *match;
 8469|      0|    _Bool read_alpha;
 8470|      0|    _Bool tmp;
 8471|      0|    _Bool tmp___0;
 8472|       |
 8473|      0|    {
 8474|      0|        match = (char const *)((void *)0);
 8475|      0|        read_alpha = (_Bool)0;
 8476|      0|        while (1) {
 8477|       |
 8478|      0|            if (!*(*str)) {
 8479|      0|                goto while_break;
 8480|      0|            }
 8481|      0|            if (read_alpha) {
 8482|      0|                read_alpha = (_Bool)0;
 8483|      0|                tmp = c_isalpha((int)*(*str));
 8484|      0|                if (!tmp) {
 8485|      0|                    if (126 != (int)*(*str)) {
 8486|      0|                        match = (char const *)((void *)0);
 8487|      0|                    }
 8488|      0|                }
 8489|      0|            }
 8490|      0|            else {
 8491|      0|                if (46 == (int)*(*str)) {
 8492|      0|                    read_alpha = (_Bool)1;
 8493|      0|                    if (!match) {
 8494|      0|                        match = *str;
 8495|      0|                    }
 8496|      0|                }
 8497|      0|                else {
 8498|      0|                    tmp___0 = c_isalnum((int)*(*str));
 8499|      0|                    if (!tmp___0) {
 8500|      0|                        if (126 != (int)*(*str)) {
 8501|      0|                            match = (char const *)((void *)0);
 8502|      0|                        }
 8503|      0|                    }
 8504|      0|                }
 8505|      0|            }
 8506|      0|            (*str)++;
 8507|      0|        }
 8508|      0|while_break:
 8509|      0|        ;
 8510|      0|        return (match);
 8511|      0|    }
 8512|      0|}
 8513|       |__inline static int order(unsigned char c)
 8514|      0|{
 8515|      0|    _Bool tmp;
 8516|      0|    _Bool tmp___0;
 8517|       |
 8518|      0|    {
 8519|      0|        tmp___0 = c_isdigit((int)c);
 8520|      0|        if (tmp___0) {
 8521|      0|            return (0);
 8522|      0|        }
 8523|      0|        else {
 8524|      0|            tmp = c_isalpha((int)c);
 8525|      0|            if (tmp) {
 8526|      0|                return ((int)c);
 8527|      0|            }
 8528|      0|            else {
 8529|      0|                if ((int)c == 126) {
 8530|      0|                    return (-1);
 8531|      0|                }
 8532|      0|                else {
 8533|      0|                    return (((int)c + 255) + 1);
 8534|      0|                }
 8535|      0|            }
 8536|      0|        }
 8537|      0|    }
 8538|      0|}
 8539|       |static int __attribute__((__pure__)) verrevcmp(char const *s1, size_t s1_len,
 8540|       |        char const *s2, size_t s2_len)
 8541|      0|{
 8542|      0|    size_t s1_pos;
 8543|      0|    size_t s2_pos;
 8544|      0|    int first_diff;
 8545|      0|    int s1_c;
 8546|      0|    int tmp;
 8547|      0|    int tmp___0;
 8548|      0|    int s2_c;
 8549|      0|    int tmp___1;
 8550|      0|    int tmp___2;
 8551|      0|    _Bool tmp___3;
 8552|      0|    _Bool tmp___4;
 8553|      0|    _Bool tmp___5;
 8554|      0|    _Bool tmp___6;
 8555|      0|    _Bool tmp___7;
 8556|      0|    _Bool tmp___8;
 8557|       |
 8558|      0|    {
 8559|      0|        s1_pos = (size_t)0;
 8560|      0|        s2_pos = (size_t)0;
 8561|      0|        while (1) {
 8562|       |
 8563|      0|            if (!(s1_pos < s1_len)) {
 8564|      0|                if (!(s2_pos < s2_len)) {
 8565|      0|                    goto while_break;
 8566|      0|                }
 8567|      0|            }
 8568|      0|            first_diff = 0;
 8569|      0|            while (1) {
 8570|       |
 8571|      0|                if (s1_pos < s1_len) {
 8572|      0|                    tmp___3 = c_isdigit((int)*(s1 + s1_pos));
 8573|      0|                    if (tmp___3) {
 8574|      0|                        goto _L;
 8575|      0|                    }
 8576|      0|                }
 8577|      0|                else {
 8578|      0|_L:
 8579|      0|                    if (s2_pos < s2_len) {
 8580|      0|                        tmp___4 = c_isdigit((int)*(s2 + s2_pos));
 8581|      0|                        if (tmp___4) {
 8582|      0|                            goto while_break___0;
 8583|      0|                        }
 8584|      0|                    }
 8585|      0|                    else {
 8586|      0|                        goto while_break___0;
 8587|      0|                    }
 8588|      0|                }
 8589|      0|                if (s1_pos == s1_len) {
 8590|      0|                    tmp___0 = 0;
 8591|      0|                }
 8592|      0|                else {
 8593|      0|                    tmp = order((unsigned char)*(s1 + s1_pos));
 8594|      0|                    tmp___0 = tmp;
 8595|      0|                }
 8596|      0|                s1_c = tmp___0;
 8597|      0|                if (s2_pos == s2_len) {
 8598|      0|                    tmp___2 = 0;
 8599|      0|                }
 8600|      0|                else {
 8601|      0|                    tmp___1 = order((unsigned char)*(s2 + s2_pos));
 8602|      0|                    tmp___2 = tmp___1;
 8603|      0|                }
 8604|      0|                s2_c = tmp___2;
 8605|      0|                if (s1_c != s2_c) {
 8606|      0|                    return ((int __attribute__((__pure__)))(s1_c - s2_c));
 8607|      0|                }
 8608|      0|                s1_pos++;
 8609|      0|                s2_pos++;
 8610|      0|            }
 8611|      0|while_break___0:
 8612|      0|            ;
 8613|      0|            while (1) {
 8614|       |
 8615|      0|                if (!((int const) * (s1 + s1_pos) == 48)) {
 8616|      0|                    goto while_break___1;
 8617|      0|                }
 8618|      0|                s1_pos++;
 8619|      0|            }
 8620|      0|while_break___1:
 8621|      0|            ;
 8622|      0|            while (1) {
 8623|       |
 8624|      0|                if (!((int const) * (s2 + s2_pos) == 48)) {
 8625|      0|                    goto while_break___2;
 8626|      0|                }
 8627|      0|                s2_pos++;
 8628|      0|            }
 8629|      0|while_break___2:
 8630|      0|            ;
 8631|      0|            while (1) {
 8632|      0|                tmp___5 = c_isdigit((int)*(s1 + s1_pos));
 8633|      0|                if (tmp___5) {
 8634|      0|                    tmp___6 = c_isdigit((int)*(s2 + s2_pos));
 8635|      0|                    if (!tmp___6) {
 8636|      0|                        goto while_break___3;
 8637|      0|                    }
 8638|      0|                }
 8639|      0|                else {
 8640|      0|                    goto while_break___3;
 8641|      0|                }
 8642|      0|                if (!first_diff) {
 8643|      0|                    first_diff =
 8644|      0|                        (int)((int const) * (s1 + s1_pos) - (int const) * (s2 + s2_pos));
 8645|      0|                }
 8646|      0|                s1_pos++;
 8647|      0|                s2_pos++;
 8648|      0|            }
 8649|      0|while_break___3:
 8650|      0|            tmp___7 = c_isdigit((int)*(s1 + s1_pos));
 8651|      0|            if (tmp___7) {
 8652|      0|                return ((int __attribute__((__pure__)))1);
 8653|      0|            }
 8654|      0|            tmp___8 = c_isdigit((int)*(s2 + s2_pos));
 8655|      0|            if (tmp___8) {
 8656|      0|                return ((int __attribute__((__pure__))) - 1);
 8657|      0|            }
 8658|      0|            if (first_diff) {
 8659|      0|                return ((int __attribute__((__pure__)))first_diff);
 8660|      0|            }
 8661|      0|        }
 8662|      0|while_break:
 8663|      0|        ;
 8664|      0|        return ((int __attribute__((__pure__)))0);
 8665|      0|    }
 8666|      0|}
 8667|       |int filevercmp(char const *s1, char const *s2)
 8668|      0|{
 8669|      0|    char const *s1_pos;
 8670|      0|    char const *s2_pos;
 8671|      0|    char const *s1_suffix;
 8672|      0|    char const *s2_suffix;
 8673|      0|    size_t s1_len;
 8674|      0|    size_t s2_len;
 8675|      0|    int result;
 8676|      0|    int simple_cmp;
 8677|      0|    int tmp;
 8678|      0|    int tmp___0;
 8679|      0|    int tmp___1;
 8680|      0|    int tmp___2;
 8681|      0|    int tmp___3;
 8682|      0|    char const *tmp___4;
 8683|      0|    char const *tmp___5;
 8684|      0|    int tmp___6;
 8685|      0|    int tmp___7;
 8686|       |
 8687|      0|    {
 8688|      0|        tmp = strcmp(s1, s2);
 8689|      0|        simple_cmp = tmp;
 8690|      0|        if (simple_cmp == 0) {
 8691|      0|            return (0);
 8692|      0|        }
 8693|      0|        if (!*s1) {
 8694|      0|            return (-1);
 8695|      0|        }
 8696|      0|        if (!*s2) {
 8697|      0|            return (1);
 8698|      0|        }
 8699|      0|        tmp___0 = strcmp(".", s1);
 8700|      0|        if (0 == tmp___0) {
 8701|      0|            return (-1);
 8702|      0|        }
 8703|      0|        tmp___1 = strcmp(".", s2);
 8704|      0|        if (0 == tmp___1) {
 8705|      0|            return (1);
 8706|      0|        }
 8707|      0|        tmp___2 = strcmp("..", s1);
 8708|      0|        if (0 == tmp___2) {
 8709|      0|            return (-1);
 8710|      0|        }
 8711|      0|        tmp___3 = strcmp("..", s2);
 8712|      0|        if (0 == tmp___3) {
 8713|      0|            return (1);
 8714|      0|        }
 8715|      0|        if ((int const) * s1 == 46) {
 8716|      0|            if ((int const) * s2 != 46) {
 8717|      0|                return (-1);
 8718|      0|            }
 8719|      0|        }
 8720|      0|        if ((int const) * s1 != 46) {
 8721|      0|            if ((int const) * s2 == 46) {
 8722|      0|                return (1);
 8723|      0|            }
 8724|      0|        }
 8725|      0|        if ((int const) * s1 == 46) {
 8726|      0|            if ((int const) * s2 == 46) {
 8727|      0|                s1++;
 8728|      0|                s2++;
 8729|      0|            }
 8730|      0|        }
 8731|      0|        s1_pos = s1;
 8732|      0|        s2_pos = s2;
 8733|      0|        s1_suffix = match_suffix(&s1_pos);
 8734|      0|        s2_suffix = match_suffix(&s2_pos);
 8735|      0|        if (s1_suffix) {
 8736|      0|            tmp___4 = s1_suffix;
 8737|      0|        }
 8738|      0|        else {
 8739|      0|            tmp___4 = s1_pos;
 8740|      0|        }
 8741|      0|        s1_len = (size_t)(tmp___4 - s1);
 8742|      0|        if (s2_suffix) {
 8743|      0|            tmp___5 = s2_suffix;
 8744|      0|        }
 8745|      0|        else {
 8746|      0|            tmp___5 = s2_pos;
 8747|      0|        }
 8748|      0|        s2_len = (size_t)(tmp___5 - s2);
 8749|      0|        if (s1_suffix) {
 8750|      0|            goto _L;
 8751|      0|        }
 8752|      0|        else {
 8753|      0|            if (s2_suffix) {
 8754|      0|_L:
 8755|      0|                if (s1_len == s2_len) {
 8756|      0|                    tmp___6 = strncmp(s1, s2, s1_len);
 8757|      0|                    if (0 == tmp___6) {
 8758|      0|                        s1_len = (size_t)(s1_pos - s1);
 8759|      0|                        s2_len = (size_t)(s2_pos - s2);
 8760|      0|                    }
 8761|      0|                }
 8762|      0|            }
 8763|      0|        }
 8764|      0|        result = (int)verrevcmp(s1, s1_len, s2, s2_len);
 8765|      0|        if (result == 0) {
 8766|      0|            tmp___7 = simple_cmp;
 8767|      0|        }
 8768|      0|        else {
 8769|      0|            tmp___7 = result;
 8770|      0|        }
 8771|      0|        return (tmp___7);
 8772|      0|    }
 8773|      0|}
 8774|       |#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
 8775|       |extern int fflush(FILE *__stream);
 8776|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) __freading)(
 8777|       |    FILE *__fp);
 8778|       |__inline static void clear_ungetc_buffer_preserving_position(FILE *fp)
 8779|      4|{
 8780|       |
 8781|      4|    {
 8782|      4|        if (fp->_flags & 256) {
 8783|      0|            rpl_fseeko(fp, (off_t)0, 1);
 8784|      0|        }
 8785|      4|        return;
 8786|      4|    }
 8787|      4|}
 8788|       |int rpl_fflush(FILE *stream)
 8789|      8|{
 8790|      8|    int tmp;
 8791|      8|    int tmp___0;
 8792|      8|    int tmp___1;
 8793|       |
 8794|      8|    {
 8795|      8|        if ((unsigned long)stream == (unsigned long)((void *)0)) {
 8796|      0|            tmp = fflush(stream);
 8797|      0|            return (tmp);
 8798|      0|        }
 8799|      8|        else {
 8800|      8|            tmp___0 = __freading(stream);
 8801|      8|            if (!(tmp___0 != 0)) {
 8802|      4|                tmp = fflush(stream);
 8803|      4|                return (tmp);
 8804|      4|            }
 8805|      8|        }
 8806|      4|        clear_ungetc_buffer_preserving_position(stream);
 8807|      4|        tmp___1 = fflush(stream);
 8808|      4|        return (tmp___1);
 8809|      8|    }
 8810|      8|}
 8811|       |int fd_safer(int fd)
 8812|      0|{
 8813|      0|    int f;
 8814|      0|    int tmp;
 8815|      0|    int e;
 8816|      0|    int *tmp___0;
 8817|      0|    int *tmp___1;
 8818|       |
 8819|      0|    {
 8820|      0|        if (0 <= fd) {
 8821|      0|            if (fd <= 2) {
 8822|      0|                tmp = dup_safer(fd);
 8823|      0|                f = tmp;
 8824|      0|                tmp___0 = __errno_location();
 8825|      0|                e = *tmp___0;
 8826|      0|                close(fd);
 8827|      0|                tmp___1 = __errno_location();
 8828|      0|                *tmp___1 = e;
 8829|      0|                fd = f;
 8830|      0|            }
 8831|      0|        }
 8832|      0|        return (fd);
 8833|      0|    }
 8834|      0|}
 8835|       |extern int fcntl(int __fd, int __cmd, ...);
 8836|       |static int have_dupfd_cloexec = 0;
 8837|       |int rpl_fcntl(int fd, int action, ...)
 8838|      0|{
 8839|      0|    va_list arg;
 8840|      0|    int result;
 8841|      0|    int target;
 8842|      0|    int tmp;
 8843|      0|    int *tmp___0;
 8844|      0|    int flags;
 8845|      0|    int tmp___1;
 8846|      0|    int saved_errno;
 8847|      0|    int *tmp___2;
 8848|      0|    int *tmp___3;
 8849|      0|    int tmp___4;
 8850|      0|    void *p;
 8851|      0|    void *tmp___5;
 8852|       |
 8853|      0|    {
 8854|      0|        result = -1;
 8855|      0|        __builtin_va_start(arg, action);
 8856|      0|        if (action == 1030) {
 8857|      0|            goto case_1030;
 8858|      0|        }
 8859|      0|        goto switch_default;
 8860|      0|case_1030:
 8861|      0|        tmp = __builtin_va_arg(arg, int);
 8862|      0|        target = tmp;
 8863|      0|        if (0 <= have_dupfd_cloexec) {
 8864|      0|            result = fcntl(fd, action, target);
 8865|      0|            if (0 <= result) {
 8866|      0|                have_dupfd_cloexec = 1;
 8867|      0|            }
 8868|      0|            else {
 8869|      0|                tmp___0 = __errno_location();
 8870|      0|                if (*tmp___0 != 22) {
 8871|      0|                    have_dupfd_cloexec = 1;
 8872|      0|                }
 8873|      0|                else {
 8874|      0|                    result = rpl_fcntl(fd, 0, target);
 8875|      0|                    if (result < 0) {
 8876|      0|                        goto switch_break;
 8877|      0|                    }
 8878|      0|                    have_dupfd_cloexec = -1;
 8879|      0|                }
 8880|      0|            }
 8881|      0|        }
 8882|      0|        else {
 8883|      0|            result = rpl_fcntl(fd, 0, target);
 8884|      0|        }
 8885|      0|        if (0 <= result) {
 8886|      0|            if (have_dupfd_cloexec == -1) {
 8887|      0|                tmp___1 = fcntl(result, 1);
 8888|      0|                flags = tmp___1;
 8889|      0|                if (flags < 0) {
 8890|      0|                    goto _L;
 8891|      0|                }
 8892|      0|                else {
 8893|      0|                    tmp___4 = fcntl(result, 2, flags | 1);
 8894|      0|                    if (tmp___4 == -1) {
 8895|      0|_L:
 8896|      0|                        tmp___2 = __errno_location();
 8897|      0|                        saved_errno = *tmp___2;
 8898|      0|                        close(result);
 8899|      0|                        tmp___3 = __errno_location();
 8900|      0|                        *tmp___3 = saved_errno;
 8901|      0|                        result = -1;
 8902|      0|                    }
 8903|      0|                }
 8904|      0|            }
 8905|      0|        }
 8906|      0|        goto switch_break;
 8907|      0|switch_default:
 8908|      0|        tmp___5 = __builtin_va_arg(arg, void *);
 8909|      0|        p = tmp___5;
 8910|      0|        result = fcntl(fd, action, p);
 8911|      0|        goto switch_break;
 8912|      0|switch_break:
 8913|      0|        __builtin_va_end(arg);
 8914|      0|        return (result);
 8915|      0|    }
 8916|      0|}
 8917|       |extern int fclose(FILE *__stream);
 8918|       |int(__attribute__((__nonnull__(1))) rpl_fclose)(FILE *fp)
 8919|      8|{
 8920|      8|    int saved_errno;
 8921|      8|    int fd;
 8922|      8|    int result;
 8923|      8|    int tmp;
 8924|      8|    int *tmp___0;
 8925|      8|    int tmp___1;
 8926|      8|    int tmp___2;
 8927|      8|    __off_t tmp___3;
 8928|      8|    int tmp___4;
 8929|      8|    int *tmp___5;
 8930|       |
 8931|      8|    {
 8932|      8|        saved_errno = 0;
 8933|      8|        result = 0;
 8934|      8|        fd = fileno(fp);
 8935|      8|        if (fd < 0) {
 8936|      0|            tmp = fclose(fp);
 8937|      0|            return (tmp);
 8938|      0|        }
 8939|      8|        tmp___1 = __freading(fp);
 8940|      8|        if (tmp___1 != 0) {
 8941|      4|            tmp___2 = fileno(fp);
 8942|      4|            tmp___3 = lseek(tmp___2, (__off_t)0, 1);
 8943|      4|            if (tmp___3 != -1L) {
 8944|      8|_L:
 8945|      8|                tmp___4 = rpl_fflush(fp);
 8946|      8|                if (tmp___4) {
 8947|      0|                    tmp___0 = __errno_location();
 8948|      0|                    saved_errno = *tmp___0;
 8949|      0|                }
 8950|      8|            }
 8951|      4|        }
 8952|      4|        else {
 8953|      4|            goto _L;
 8954|      4|        }
 8955|      8|        result = fclose(fp);
 8956|      8|        if (saved_errno != 0) {
 8957|      0|            tmp___5 = __errno_location();
 8958|      0|            *tmp___5 = saved_errno;
 8959|      0|            result = -1;
 8960|      0|        }
 8961|      8|        return (result);
 8962|      8|    }
 8963|      8|}
 8964|       |extern __attribute__((__nothrow__)) int(
 8965|       |    __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set);
 8966|       |extern __attribute__((__nothrow__)) int(__attribute__((
 8967|       |        __nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set, int __signo);
 8968|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) sigaction)(
 8969|       |    int __sig, struct sigaction const *__restrict __act,
 8970|       |    struct sigaction *__restrict __oact);
 8971|       |extern
 8972|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__)) posix_fadvise)(
 8973|       |    int __fd, off_t __offset, off_t __len, int __advise);
 8974|       |void fdadvise(int fd, off_t offset, off_t len, fadvice_t advice);
 8975|       |void fadvise(FILE *fp, fadvice_t advice);
 8976|       |void fdadvise(int fd, off_t offset, off_t len, fadvice_t advice)
 8977|      4|{
 8978|      4|    int __x;
 8979|      4|    int tmp;
 8980|       |
 8981|      4|    {
 8982|      4|        tmp = posix_fadvise(fd, offset, len, (int)advice);
 8983|      4|        __x = tmp;
 8984|      4|        return;
 8985|      4|    }
 8986|      4|}
 8987|       |void fadvise(FILE *fp, fadvice_t advice)
 8988|      4|{
 8989|      4|    int tmp;
 8990|       |
 8991|      4|    {
 8992|      4|        if (fp) {
 8993|      4|            tmp = fileno(fp);
 8994|      4|            fdadvise(tmp, (off_t)0, (off_t)0, advice);
 8995|      4|        }
 8996|      4|        return;
 8997|      4|    }
 8998|      4|}
 8999|       |int volatile exit_failure = (int volatile)1;
 9000|       |int dup_safer(int fd)
 9001|      0|{
 9002|      0|    int tmp;
 9003|       |
 9004|      0|    {
 9005|      0|        tmp = rpl_fcntl(fd, 0, 3);
 9006|      0|        return (tmp);
 9007|      0|    }
 9008|      0|}
 9009|       |#pragma GCC diagnostic ignored "-Wtype-limits"
 9010|       |#pragma GCC diagnostic ignored "-Wtype-limits"
 9011|       |#pragma weak pthread_key_create
 9012|       |#pragma weak pthread_getspecific
 9013|       |#pragma weak pthread_setspecific
 9014|       |#pragma weak pthread_key_delete
 9015|       |#pragma weak pthread_self
 9016|       |#pragma weak pthread_cancel
 9017|       |#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
 9018|       |#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
 9019|       |#pragma GCC diagnostic ignored "-Wtype-limits"
 9020|       |#pragma weak pthread_mutex_init
 9021|       |#pragma weak pthread_mutex_lock
 9022|       |#pragma weak pthread_mutex_unlock
 9023|       |#pragma weak pthread_mutex_destroy
 9024|       |#pragma weak pthread_rwlock_init
 9025|       |#pragma weak pthread_rwlock_rdlock
 9026|       |#pragma weak pthread_rwlock_wrlock
 9027|       |#pragma weak pthread_rwlock_unlock
 9028|       |#pragma weak pthread_rwlock_destroy
 9029|       |#pragma weak pthread_once
 9030|       |#pragma weak pthread_cond_init
 9031|       |#pragma weak pthread_cond_wait
 9032|       |#pragma weak pthread_cond_signal
 9033|       |#pragma weak pthread_cond_broadcast
 9034|       |#pragma weak pthread_cond_destroy
 9035|       |#pragma weak pthread_mutexattr_init
 9036|       |#pragma weak pthread_mutexattr_settype
 9037|       |#pragma weak pthread_mutexattr_destroy
 9038|       |#pragma weak pthread_self
 9039|       |#pragma weak pthread_cancel
 9040|       |#pragma GCC diagnostic ignored "-Wtype-limits"
 9041|       |#pragma GCC diagnostic ignored "-Wtype-limits"
 9042|       |#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
 9043|       |char const *Version = "8.16";
 9044|       |extern char *optarg;
 9045|       |extern __attribute__((__nothrow__)) int(__attribute__((
 9046|       |        __nonnull__(1, 3))) pthread_create)(pthread_t *__restrict __newthread,
 9047|       |                pthread_attr_t const *__restrict __attr,
 9048|       |                void *(*__start_routine)(void *),
 9049|       |                void *__restrict __arg);
 9050|       |extern int pthread_join(pthread_t __th, void **__thread_return);
 9051|       |extern __attribute__((__nothrow__)) int(__attribute__((
 9052|       |        __nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex);
 9053|       |extern __attribute__((__nothrow__)) int(__attribute__((
 9054|       |        __nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex);
 9055|       |extern __attribute__((__nothrow__)) int(__attribute__((
 9056|       |        __nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex);
 9057|       |extern __attribute__((__nothrow__)) int(
 9058|       |    __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(
 9059|       |        pthread_cond_t *__restrict __cond,
 9060|       |        pthread_condattr_t const *__restrict __cond_attr);
 9061|       |extern __attribute__((__nothrow__)) int(__attribute__((
 9062|       |        __nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond);
 9063|       |extern __attribute__((__nothrow__)) int(__attribute__((
 9064|       |        __nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond);
 9065|       |extern int(__attribute__((__nonnull__(1, 2))) pthread_cond_wait)(
 9066|       |    pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex);
 9067|       |extern __attribute__((__nothrow__))
 9068|       |__sighandler_t(__attribute__((__leaf__)) signal)(int __sig,
 9069|       |        void (*__handler)(int));
 9070|       |extern __attribute__((__nothrow__)) int(__attribute__((
 9071|       |        __nonnull__(1), __leaf__)) sigismember)(sigset_t const *__set, int __signo);
 9072|       |extern __attribute__((__nothrow__)) int(__attribute__((
 9073|       |        __nonnull__(1, 2), __leaf__)) execlp)(char const *__file, char const *__arg,
 9074|       |                ...);
 9075|       |extern __attribute__((__nothrow__))
 9076|       |size_t(__attribute__((__nonnull__(2), __leaf__)) strxfrm)(
 9077|       |    char *__restrict __dest, char const *__restrict __src, size_t __n);
 9078|       |__inline static void initialize_exit_failure(int status)
 9079|      2|{
 9080|       |
 9081|      2|    {
 9082|      2|        if (status != 1) {
 9083|      2|            exit_failure = (int volatile)status;
 9084|      2|        }
 9085|      2|        return;
 9086|      2|    }
 9087|      2|}
 9088|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__)) ngettext)(
 9089|       |    char const *__msgid1, char const *__msgid2, unsigned long __n)
 9090|       |__attribute__((__format_arg__(2), __format_arg__(1)));
 9091|       |extern __attribute__((__nothrow__)) char *(
 9092|       |    __attribute__((__leaf__)) textdomain)(char const *__domainname);
 9093|       |extern __attribute__((__nothrow__)) char *(__attribute__((
 9094|       |            __leaf__)) bindtextdomain)(char const *__domainname, char const *__dirname);
 9095|       |__inline static unsigned long select_plural(uintmax_t n)
 9096|      0|{
 9097|      0|    uintmax_t tmp;
 9098|       |
 9099|      0|    {
 9100|      0|        if (n <= 0xffffffffffffffffUL) {
 9101|      0|            tmp = n;
 9102|      0|        }
 9103|      0|        else {
 9104|      0|            tmp = n % 1000000UL + 1000000UL;
 9105|      0|        }
 9106|      0|        return (tmp);
 9107|      0|    }
 9108|      0|}
 9109|       |extern int fputc_unlocked(int __c, FILE *__stream);
 9110|       |extern int putchar_unlocked(int __c);
 9111|       |extern size_t fwrite_unlocked(void const *__restrict __ptr, size_t __size,
 9112|       |                              size_t __n, FILE *__restrict __stream);
 9113|       |extern __attribute__((__nothrow__)) void(
 9114|       |    __attribute__((__leaf__)) clearerr_unlocked)(FILE *__stream);
 9115|       |__inline static void emit_ancillary_info(void)
 9116|      0|{
 9117|      0|    char *tmp;
 9118|      0|    char *tmp___0;
 9119|      0|    char *tmp___1;
 9120|      0|    char *tmp___2;
 9121|      0|    char const *lc_messages;
 9122|      0|    char const *tmp___3;
 9123|      0|    char *tmp___4;
 9124|      0|    char *tmp___5;
 9125|      0|    int tmp___6;
 9126|      0|    char *tmp___7;
 9127|      0|    char *tmp___8;
 9128|       |
 9129|      0|    {
 9130|      0|        tmp = last_component(program_name);
 9131|      0|        tmp___0 = gettext("\nReport %s bugs to %s\n");
 9132|      0|        printf((char const *)tmp___0, tmp, "bug-coreutils@gnu.org");
 9133|      0|        tmp___1 = gettext("%s home page: <%s>\n");
 9134|      0|        printf((char const *)tmp___1, "GNU coreutils",
 9135|      0|               "http://www.gnu.org/software/coreutils/");
 9136|      0|        tmp___2 = gettext(
 9137|      0|                      "General help using GNU software: <http://www.gnu.org/gethelp/>\n");
 9138|      0|        fputs_unlocked((char const *)tmp___2, stdout);
 9139|      0|        tmp___3 = (char const *)setlocale(5, (char const *)((void *)0));
 9140|      0|        lc_messages = tmp___3;
 9141|      0|        if (lc_messages) {
 9142|      0|            tmp___6 = strncmp(lc_messages, "en_", sizeof("en_") - 1UL);
 9143|      0|            if (tmp___6) {
 9144|      0|                tmp___4 = last_component(program_name);
 9145|      0|                tmp___5 = gettext("Report %s translation bugs to "
 9146|      0|                                  "<http://translationproject.org/team/>\n");
 9147|      0|                printf((char const *)tmp___5, tmp___4);
 9148|      0|            }
 9149|      0|        }
 9150|      0|        tmp___7 = last_component(program_name);
 9151|      0|        tmp___8 = gettext(
 9152|      0|                      "For complete documentation, run: info coreutils \'%s invocation\'\n");
 9153|      0|        printf((char const *)tmp___8, tmp___7);
 9154|      0|        return;
 9155|      0|    }
 9156|      0|}
 9157|       |__inline static void emit_try_help(void)
 9158|      0|{
 9159|      0|    char *tmp;
 9160|       |
 9161|      0|    {
 9162|      0|        tmp = gettext("Try \'%s --help\' for more information.\n");
 9163|      0|        fprintf(stderr, (char const *)tmp, program_name);
 9164|      0|        return;
 9165|      0|    }
 9166|      0|}
 9167|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) getrlimit)(
 9168|       |    __rlimit_resource_t __resource, struct rlimit *__rlimits);
 9169|       |static int decimal_point;
 9170|       |static int thousands_sep;
 9171|       |static _Bool hard_LC_COLLATE;
 9172|       |static _Bool hard_LC_TIME;
 9173|       |static char eolchar = (char)'\n';
 9174|       |static _Bool blanks[256];
 9175|       |static _Bool nonprinting[256];
 9176|       |static _Bool nondictionary[256];
 9177|       |static char fold_toupper[256];
 9178|       |static struct month monthtab[12] = {
 9179|       |    {"APR", 4}, {"AUG", 8}, {"DEC", 12}, {"FEB", 2},  {"JAN", 1},  {"JUL", 7},
 9180|       |    {"JUN", 6}, {"MAR", 3}, {"MAY", 5},  {"NOV", 11}, {"OCT", 10}, {"SEP", 9}
 9181|       |};
 9182|       |static size_t merge_buffer_size = (size_t)262144;
 9183|       |static size_t sort_size;
 9184|       |static char const **temp_dirs;
 9185|       |static size_t temp_dir_count;
 9186|       |static size_t temp_dir_alloc;
 9187|       |static _Bool reverse;
 9188|       |static _Bool stable;
 9189|       |static int tab = 128;
 9190|       |static _Bool unique;
 9191|       |static _Bool have_read_stdin;
 9192|       |static struct keyfield *keylist;
 9193|       |static char const *compress_program;
 9194|       |static _Bool debug;
 9195|       |static unsigned int nmerge = 16U;
 9196|       |static __attribute__((__noreturn__)) void die(char const *message,
 9197|       |        char const *file);
 9198|       |static __attribute__((__noreturn__)) void die(char const *message,
 9199|       |        char const *file);
 9200|       |static void die(char const *message, char const *file)
 9201|      0|{
 9202|      0|    char *tmp;
 9203|      0|    char const *tmp___0;
 9204|      0|    int *tmp___1;
 9205|       |
 9206|      0|    {
 9207|      0|        if (file) {
 9208|      0|            tmp___0 = file;
 9209|      0|        }
 9210|      0|        else {
 9211|      0|            tmp = gettext("standard output");
 9212|      0|            tmp___0 = (char const *)tmp;
 9213|      0|        }
 9214|      0|        tmp___1 = __errno_location();
 9215|      0|        error(0, *tmp___1, "%s: %s", message, tmp___0);
 9216|      0|        exit(2);
 9217|      0|    }
 9218|      0|}
 9219|       |__attribute__((__noreturn__)) void usage(int status);
 9220|       |void usage(int status)
 9221|      0|{
 9222|      0|    char *tmp;
 9223|      0|    char *tmp___0;
 9224|      0|    char *tmp___1;
 9225|      0|    char *tmp___2;
 9226|      0|    char *tmp___3;
 9227|      0|    char *tmp___4;
 9228|      0|    char *tmp___5;
 9229|      0|    char *tmp___6;
 9230|      0|    char *tmp___7;
 9231|      0|    char *tmp___8;
 9232|      0|    char *tmp___9;
 9233|      0|    char *tmp___10;
 9234|      0|    char *tmp___11;
 9235|      0|    char *tmp___12;
 9236|      0|    char *tmp___13;
 9237|      0|    char *tmp___14;
 9238|      0|    char *tmp___15;
 9239|      0|    char *tmp___16;
 9240|      0|    char *tmp___17;
 9241|      0|    char *tmp___18;
 9242|      0|    char *tmp___19;
 9243|       |
 9244|      0|    {
 9245|      0|        if (status != 0) {
 9246|      0|            emit_try_help();
 9247|      0|        }
 9248|      0|        else {
 9249|      0|            tmp = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... "
 9250|      0|                          "--files0-from=F\n");
 9251|      0|            printf((char const *)tmp, program_name, program_name);
 9252|      0|            tmp___0 = gettext(
 9253|      0|                          "Write sorted concatenation of all FILE(s) to standard output.\n\n");
 9254|      0|            fputs_unlocked((char const *)tmp___0, stdout);
 9255|      0|            tmp___1 = gettext("Mandatory arguments to long options are mandatory for "
 9256|      0|                              "short options too.\n");
 9257|      0|            fputs_unlocked((char const *)tmp___1, stdout);
 9258|      0|            tmp___2 = gettext("Ordering options:\n\n");
 9259|      0|            fputs_unlocked((char const *)tmp___2, stdout);
 9260|      0|            tmp___3 =
 9261|      0|                gettext("  -b, --ignore-leading-blanks  ignore leading blanks\n  -d, "
 9262|      0|                        "--dictionary-order      consider only blanks and "
 9263|      0|                        "alphanumeric characters\n  -f, --ignore-case           fold "
 9264|      0|                        "lower case to upper case characters\n");
 9265|      0|            fputs_unlocked((char const *)tmp___3, stdout);
 9266|      0|            tmp___4 =
 9267|      0|                gettext("  -g, --general-numeric-sort  compare according to general "
 9268|      0|                        "numerical value\n  -i, --ignore-nonprinting    consider "
 9269|      0|                        "only printable characters\n  -M, --month-sort            "
 9270|      0|                        "compare (unknown) < \'JAN\' < ... < \'DEC\'\n");
 9271|      0|            fputs_unlocked((char const *)tmp___4, stdout);
 9272|      0|            tmp___5 = gettext("  -h, --human-numeric-sort    compare human readable "
 9273|      0|                              "numbers (e.g., 2K 1G)\n");
 9274|      0|            fputs_unlocked((char const *)tmp___5, stdout);
 9275|      0|            tmp___6 = gettext(
 9276|      0|                          "  -n, --numeric-sort          compare according to string numerical "
 9277|      0|                          "value\n  -R, --random-sort           sort by random hash of keys\n  "
 9278|      0|                          "    --random-source=FILE    get random bytes from FILE\n  -r, "
 9279|      0|                          "--reverse               reverse the result of comparisons\n");
 9280|      0|            fputs_unlocked((char const *)tmp___6, stdout);
 9281|      0|            tmp___7 =
 9282|      0|                gettext("      --sort=WORD             sort according to WORD:\n     "
 9283|      0|                        "                           general-numeric -g, "
 9284|      0|                        "human-numeric -h, month -M,\n                               "
 9285|      0|                        " numeric -n, random -R, version -V\n  -V, --version-sort    "
 9286|      0|                        "      natural sort of (version) numbers within text\n\n");
 9287|      0|            fputs_unlocked((char const *)tmp___7, stdout);
 9288|      0|            tmp___8 = gettext("Other options:\n\n");
 9289|      0|            fputs_unlocked((char const *)tmp___8, stdout);
 9290|      0|            tmp___9 = gettext(
 9291|      0|                          "      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n  "
 9292|      0|                          "                          for more use temp files\n");
 9293|      0|            fputs_unlocked((char const *)tmp___9, stdout);
 9294|      0|            tmp___10 =
 9295|      0|                gettext("  -c, --check, --check=diagnose-first  check for sorted "
 9296|      0|                        "input; do not sort\n  -C, --check=quiet, --check=silent  "
 9297|      0|                        "like -c, but do not report first bad line\n      "
 9298|      0|                        "--compress-program=PROG  compress temporaries with PROG;\n  "
 9299|      0|                        "                            decompress them with PROG -d\n");
 9300|      0|            fputs_unlocked((char const *)tmp___10, stdout);
 9301|      0|            tmp___11 =
 9302|      0|                gettext("      --debug               annotate the part of the line "
 9303|      0|                        "used to sort,\n                              and warn about "
 9304|      0|                        "questionable usage to stderr\n      --files0-from=F       "
 9305|      0|                        "read input from the files specified by\n                    "
 9306|      0|                        "        NUL-terminated names in file F;\n                   "
 9307|      0|                        "         If F is - then read names from standard input\n");
 9308|      0|            fputs_unlocked((char const *)tmp___11, stdout);
 9309|      0|            tmp___12 = gettext("  -k, --key=KEYDEF          sort via a key; KEYDEF "
 9310|      0|                               "gives location and type\n  -m, --merge               "
 9311|      0|                               "merge already sorted files; do not sort\n");
 9312|      0|            fputs_unlocked((char const *)tmp___12, stdout);
 9313|      0|            tmp___13 =
 9314|      0|                gettext("  -o, --output=FILE         write result to FILE instead of "
 9315|      0|                        "standard output\n  -s, --stable              stabilize sort "
 9316|      0|                        "by disabling last-resort comparison\n  -S, "
 9317|      0|                        "--buffer-size=SIZE    use SIZE for main memory buffer\n");
 9318|      0|            fputs_unlocked((char const *)tmp___13, stdout);
 9319|      0|            tmp___14 =
 9320|      0|                gettext("  -t, --field-separator=SEP  use SEP instead of non-blank "
 9321|      0|                        "to blank transition\n  -T, --temporary-directory=DIR  use "
 9322|      0|                        "DIR for temporaries, not $TMPDIR or %s;\n                   "
 9323|      0|                        "           multiple options specify multiple directories\n  "
 9324|      0|                        "    --parallel=N          change the number of sorts run "
 9325|      0|                        "concurrently to N\n  -u, --unique              with -c, "
 9326|      0|                        "check for strict ordering;\n                              "
 9327|      0|                        "without -c, output only the first of an equal run\n");
 9328|      0|            printf((char const *)tmp___14, "/tmp");
 9329|      0|            tmp___15 = gettext(
 9330|      0|                           "  -z, --zero-terminated     end lines with 0 byte, not newline\n");
 9331|      0|            fputs_unlocked((char const *)tmp___15, stdout);
 9332|      0|            tmp___16 = gettext("      --help     display this help and exit\n");
 9333|      0|            fputs_unlocked((char const *)tmp___16, stdout);
 9334|      0|            tmp___17 =
 9335|      0|                gettext("      --version  output version information and exit\n");
 9336|      0|            fputs_unlocked((char const *)tmp___17, stdout);
 9337|      0|            tmp___18 = gettext(
 9338|      0|                           "\nKEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, "
 9339|      0|                           "where F is a\nfield number and C a character position in the field; "
 9340|      0|                           "both are origin 1, and\nthe stop position defaults to the line\'s "
 9341|      0|                           "end.  If neither -t nor -b is in\neffect, characters in a field are "
 9342|      0|                           "counted from the beginning of the preceding\nwhitespace.  OPTS is "
 9343|      0|                           "one or more single-letter ordering options [bdfgiMhnRrV],\nwhich "
 9344|      0|                           "override global ordering options for that key.  If no key is given, "
 9345|      0|                           "use\nthe entire line as the key.\n\nSIZE may be followed by the "
 9346|      0|                           "following multiplicative suffixes:\n");
 9347|      0|            fputs_unlocked((char const *)tmp___18, stdout);
 9348|      0|            tmp___19 = gettext(
 9349|      0|                           "% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, "
 9350|      0|                           "Z, Y.\n\nWith no FILE, or when FILE is -, read standard "
 9351|      0|                           "input.\n\n*** WARNING ***\nThe locale specified by the environment "
 9352|      0|                           "affects sort order.\nSet LC_ALL=C to get the traditional sort order "
 9353|      0|                           "that uses\nnative byte values.\n");
 9354|      0|            fputs_unlocked((char const *)tmp___19, stdout);
 9355|      0|            emit_ancillary_info();
 9356|      0|        }
 9357|      0|        exit(status);
 9358|      0|    }
 9359|      0|}
 9360|       |static char const short_options[31] = {
 9361|       |    (char const)'-', (char const)'b', (char const)'c',   (char const)'C',
 9362|       |    (char const)'d', (char const)'f', (char const)'g',   (char const)'h',
 9363|       |    (char const)'i', (char const)'k', (char const)':',   (char const)'m',
 9364|       |    (char const)'M', (char const)'n', (char const)'o',   (char const)':',
 9365|       |    (char const)'r', (char const)'R', (char const)'s',   (char const)'S',
 9366|       |    (char const)':', (char const)'t', (char const)':',   (char const)'T',
 9367|       |    (char const)':', (char const)'u', (char const)'V',   (char const)'y',
 9368|       |    (char const)':', (char const)'z', (char const)'\000'
 9369|       |};
 9370|       |static struct option const long_options___1[31] = {
 9371|       |    {"ignore-leading-blanks", 0, (int *)((void *)0), 'b'},
 9372|       |    {"check", 2, (int *)((void *)0), 128},
 9373|       |    {"compress-program", 1, (int *)((void *)0), 129},
 9374|       |    {"debug", 0, (int *)((void *)0), 130},
 9375|       |    {"dictionary-order", 0, (int *)((void *)0), 'd'},
 9376|       |    {"ignore-case", 0, (int *)((void *)0), 'f'},
 9377|       |    {"files0-from", 1, (int *)((void *)0), 131},
 9378|       |    {"general-numeric-sort", 0, (int *)((void *)0), 'g'},
 9379|       |    {"ignore-nonprinting", 0, (int *)((void *)0), 'i'},
 9380|       |    {"key", 1, (int *)((void *)0), 'k'},
 9381|       |    {"merge", 0, (int *)((void *)0), 'm'},
 9382|       |    {"month-sort", 0, (int *)((void *)0), 'M'},
 9383|       |    {"numeric-sort", 0, (int *)((void *)0), 'n'},
 9384|       |    {"human-numeric-sort", 0, (int *)((void *)0), 'h'},
 9385|       |    {"version-sort", 0, (int *)((void *)0), 'V'},
 9386|       |    {"random-sort", 0, (int *)((void *)0), 'R'},
 9387|       |    {"random-source", 1, (int *)((void *)0), 133},
 9388|       |    {"sort", 1, (int *)((void *)0), 134},
 9389|       |    {"output", 1, (int *)((void *)0), 'o'},
 9390|       |    {"reverse", 0, (int *)((void *)0), 'r'},
 9391|       |    {"stable", 0, (int *)((void *)0), 's'},
 9392|       |    {"batch-size", 1, (int *)((void *)0), 132},
 9393|       |    {"buffer-size", 1, (int *)((void *)0), 'S'},
 9394|       |    {"field-separator", 1, (int *)((void *)0), 't'},
 9395|       |    {"temporary-directory", 1, (int *)((void *)0), 'T'},
 9396|       |    {"unique", 0, (int *)((void *)0), 'u'},
 9397|       |    {"zero-terminated", 0, (int *)((void *)0), 'z'},
 9398|       |    {"parallel", 1, (int *)((void *)0), 135},
 9399|       |    {"help", 0, (int *)((void *)0), -130},
 9400|       |    {"version", 0, (int *)((void *)0), -131},
 9401|       |    {(char const *)((void *)0), 0, (int *)((void *)0), 0}
 9402|       |};
 9403|       |static char const *const check_args[4] = {"quiet", "silent", "diagnose-first",
 9404|       |                                          (char const *)((void *)0)
 9405|       |                                         };
 9406|       |static char const check_types[3] = {(char const)'C', (char const)'C',
 9407|       |                                    (char const)'c'
 9408|       |                                   };
 9409|       |static char const *const sort_args[7] = {
 9410|       |    "general-numeric", "human-numeric",          "month", "numeric", "random",
 9411|       |    "version",         (char const *)((void *)0)
 9412|       |};
 9413|       |static char const sort_types[6] = {(char const)'g', (char const)'h',
 9414|       |                                   (char const)'M', (char const)'n',
 9415|       |                                   (char const)'R', (char const)'V'
 9416|       |                                  };
 9417|       |static sigset_t caught_signals;
 9418|       |static struct cs_status cs_enter(void)
 9419|      0|{
 9420|      0|    struct cs_status status;
 9421|      0|    int tmp;
 9422|       |
 9423|      0|    {
 9424|      0|        tmp = sigprocmask(0, (sigset_t const *)(&caught_signals), &status.sigs);
 9425|      0|        status.valid = (_Bool)(tmp == 0);
 9426|      0|        return (status);
 9427|      0|    }
 9428|      0|}
 9429|       |static void cs_leave(struct cs_status status)
 9430|      0|{
 9431|       |
 9432|      0|    {
 9433|      0|        if (status.valid) {
 9434|      0|            sigprocmask(2, (sigset_t const *)(&status.sigs), (sigset_t *)((void *)0));
 9435|      0|        }
 9436|      0|        return;
 9437|      0|    }
 9438|      0|}
 9439|       |static struct tempnode *volatile temphead;
 9440|       |static struct tempnode *volatile *temptail = &temphead;
 9441|       |static Hash_table *proctab;
 9442|       |static size_t proctab_hasher(void const *entry, size_t tabsize)
 9443|      0|{
 9444|      0|    struct tempnode const *node;
 9445|       |
 9446|      0|    {
 9447|      0|        node = (struct tempnode const *)entry;
 9448|      0|        return ((unsigned long)node->pid % tabsize);
 9449|      0|    }
 9450|      0|}
 9451|       |static _Bool proctab_comparator(void const *e1, void const *e2)
 9452|      0|{
 9453|      0|    struct tempnode const *n1;
 9454|      0|    struct tempnode const *n2;
 9455|       |
 9456|      0|    {
 9457|      0|        n1 = (struct tempnode const *)e1;
 9458|      0|        n2 = (struct tempnode const *)e2;
 9459|      0|        return ((_Bool)(n1->pid == n2->pid));
 9460|      0|    }
 9461|      0|}
 9462|       |static pid_t nprocs;
 9463|       |static _Bool delete_proc(pid_t pid);
 9464|       |static pid_t reap(pid_t pid)
 9465|      0|{
 9466|      0|    int status;
 9467|      0|    pid_t cpid;
 9468|      0|    int tmp;
 9469|      0|    pid_t tmp___0;
 9470|      0|    pid_t tmp___1;
 9471|      0|    char *tmp___2;
 9472|      0|    int *tmp___3;
 9473|      0|    char *tmp___4;
 9474|      0|    union __anonunion_101 __constr_expr_82;
 9475|      0|    union __anonunion_102 __constr_expr_83;
 9476|      0|    _Bool tmp___5;
 9477|       |
 9478|      0|    {
 9479|      0|        if (pid) {
 9480|      0|            tmp = 0;
 9481|      0|        }
 9482|      0|        else {
 9483|      0|            tmp = 1;
 9484|      0|        }
 9485|      0|        if (pid) {
 9486|      0|            tmp___0 = pid;
 9487|      0|        }
 9488|      0|        else {
 9489|      0|            tmp___0 = -1;
 9490|      0|        }
 9491|      0|        tmp___1 = waitpid(tmp___0, &status, tmp);
 9492|      0|        cpid = tmp___1;
 9493|      0|        if (cpid < 0) {
 9494|      0|            tmp___2 = gettext("waiting for %s [-d]");
 9495|      0|            tmp___3 = __errno_location();
 9496|      0|            error(2, *tmp___3, (char const *)tmp___2, compress_program);
 9497|      0|        }
 9498|      0|        else {
 9499|      0|            if (0 < cpid) {
 9500|      0|                if (0 < pid) {
 9501|      0|                    goto _L;
 9502|      0|                }
 9503|      0|                else {
 9504|      0|                    tmp___5 = delete_proc(cpid);
 9505|      0|                    if (tmp___5) {
 9506|      0|_L:
 9507|      0|                        __constr_expr_82.__in = status;
 9508|      0|                        if ((__constr_expr_82.__i & 127) == 0) {
 9509|      0|                            __constr_expr_83.__in = status;
 9510|      0|                            if ((__constr_expr_83.__i & 65280) >> 8) {
 9511|      0|                                tmp___4 = gettext("%s [-d] terminated abnormally");
 9512|      0|                                error(2, 0, (char const *)tmp___4, compress_program);
 9513|      0|                            }
 9514|      0|                        }
 9515|      0|                        else {
 9516|      0|                            tmp___4 = gettext("%s [-d] terminated abnormally");
 9517|      0|                            error(2, 0, (char const *)tmp___4, compress_program);
 9518|      0|                        }
 9519|      0|                        nprocs--;
 9520|      0|                    }
 9521|      0|                }
 9522|      0|            }
 9523|      0|        }
 9524|      0|        return (cpid);
 9525|      0|    }
 9526|      0|}
 9527|       |static void register_proc(struct tempnode *temp)
 9528|      0|{
 9529|      0|    void *tmp;
 9530|       |
 9531|      0|    {
 9532|      0|        if (!proctab) {
 9533|      0|            proctab = hash_initialize((size_t)47, (Hash_tuning const *)((void *)0),
 9534|      0|                                      &proctab_hasher, &proctab_comparator,
 9535|      0|                                      (void (*)(void *))((void *)0));
 9536|      0|            if (!proctab) {
 9537|      0|                xalloc_die();
 9538|      0|            }
 9539|      0|        }
 9540|      0|        temp->state = (char)1;
 9541|      0|        tmp = hash_insert(proctab, (void const *)temp);
 9542|      0|        if (!tmp) {
 9543|      0|            xalloc_die();
 9544|      0|        }
 9545|      0|        return;
 9546|      0|    }
 9547|      0|}
 9548|       |static _Bool delete_proc(pid_t pid)
 9549|      0|{
 9550|      0|    struct tempnode test;
 9551|      0|    struct tempnode *node;
 9552|      0|    struct tempnode *tmp;
 9553|       |
 9554|      0|    {
 9555|      0|        test.pid = pid;
 9556|      0|        tmp = (struct tempnode *)hash_delete(proctab, (void const *)(&test));
 9557|      0|        node = tmp;
 9558|      0|        if (!node) {
 9559|      0|            return ((_Bool)0);
 9560|      0|        }
 9561|      0|        node->state = (char)2;
 9562|      0|        return ((_Bool)1);
 9563|      0|    }
 9564|      0|}
 9565|       |static void wait_proc(pid_t pid)
 9566|      0|{
 9567|      0|    _Bool tmp;
 9568|       |
 9569|      0|    {
 9570|      0|        tmp = delete_proc(pid);
 9571|      0|        if (tmp) {
 9572|      0|            reap(pid);
 9573|      0|        }
 9574|      0|        return;
 9575|      0|    }
 9576|      0|}
 9577|       |static void reap_exited(void)
 9578|      0|{
 9579|      0|    pid_t tmp;
 9580|       |
 9581|      0|    {
 9582|      0|        while (1) {
 9583|      0|while_continue:
 9584|      0|            ;
 9585|      0|            if (0 < nprocs) {
 9586|      0|                tmp = reap(0);
 9587|      0|                if (!tmp) {
 9588|      0|                    goto while_break;
 9589|      0|                }
 9590|      0|            }
 9591|      0|            else {
 9592|      0|                goto while_break;
 9593|      0|            }
 9594|      0|            goto while_continue;
 9595|      0|        }
 9596|      0|while_break:
 9597|      0|        ;
 9598|      0|        return;
 9599|      0|    }
 9600|      0|}
 9601|       |static void reap_some(void)
 9602|      0|{
 9603|       |
 9604|      0|    {
 9605|      0|        reap(-1);
 9606|      0|        reap_exited();
 9607|      0|        return;
 9608|      0|    }
 9609|      0|}
 9610|       |static void reap_all(void)
 9611|      2|{
 9612|       |
 9613|      2|    {
 9614|      2|        while (1) {
 9615|       |
 9616|      2|            if (!(0 < nprocs)) {
 9617|      2|                goto while_break;
 9618|      2|            }
 9619|      0|            reap(-1);
 9620|      0|        }
 9621|      2|while_break:
 9622|      2|        ;
 9623|      2|        return;
 9624|      2|    }
 9625|      2|}
 9626|       |static void cleanup(void)
 9627|      0|{
 9628|      0|    struct tempnode const *node;
 9629|       |
 9630|      0|    {
 9631|      0|        node = (struct tempnode const *)temphead;
 9632|      0|        while (1) {
 9633|       |
 9634|      0|            if (!node) {
 9635|      0|                goto while_break;
 9636|      0|            }
 9637|      0|            unlink((char const *)(node->name));
 9638|      0|            node = (struct tempnode const *)node->next;
 9639|      0|        }
 9640|      0|while_break:
 9641|      0|        temphead = (struct tempnode *)((void *)0);
 9642|      0|        return;
 9643|      0|    }
 9644|      0|}
 9645|       |static void exit_cleanup(void)
 9646|      2|{
 9647|      2|    struct cs_status cs;
 9648|      2|    struct cs_status tmp;
 9649|       |
 9650|      2|    {
 9651|      2|        if (temphead) {
 9652|      0|            tmp = cs_enter();
 9653|      0|            cs = tmp;
 9654|      0|            cleanup();
 9655|      0|            cs_leave(cs);
 9656|      0|        }
 9657|      2|        close_stdout();
 9658|      2|        return;
 9659|      2|    }
 9660|      2|}
 9661|       |static struct tempnode *create_temp_file(int *pfd, _Bool survive_fd_exhaustion);
 9662|       |static char const slashbase[12] = {
 9663|       |    (char const)'/', (char const)'s', (char const)'o', (char const)'r',
 9664|       |    (char const)'t', (char const)'X', (char const)'X', (char const)'X',
 9665|       |    (char const)'X', (char const)'X', (char const)'X', (char const)'\000'
 9666|       |};
 9667|       |static size_t temp_dir_index;
 9668|       |static struct tempnode *create_temp_file(int *pfd,
 9669|       |        _Bool survive_fd_exhaustion)
 9670|      0|{
 9671|      0|    int fd;
 9672|      0|    int saved_errno;
 9673|      0|    char const *temp_dir;
 9674|      0|    size_t len;
 9675|      0|    size_t tmp;
 9676|      0|    struct tempnode *node;
 9677|      0|    struct tempnode *tmp___0;
 9678|      0|    char *file;
 9679|      0|    struct cs_status cs;
 9680|      0|    int *tmp___1;
 9681|      0|    int *tmp___2;
 9682|      0|    char const *tmp___3;
 9683|      0|    char *tmp___4;
 9684|      0|    int *tmp___5;
 9685|      0|    int *tmp___6;
 9686|       |
 9687|      0|    {
 9688|      0|        temp_dir = *(temp_dirs + temp_dir_index);
 9689|      0|        tmp = strlen(temp_dir);
 9690|      0|        len = tmp;
 9691|      0|        tmp___0 = (struct tempnode *)xmalloc(
 9692|      0|                      ((unsigned long)(&((struct tempnode *)0)->name) + len) +
 9693|      0|                      sizeof(slashbase));
 9694|      0|        node = tmp___0;
 9695|      0|        file = node->name;
 9696|      0|        memcpy((void *)file, (void const *)temp_dir, len);
 9697|      0|        memcpy((void *)(file + len), (void const *)(slashbase), sizeof(slashbase));
 9698|      0|        node->next = (struct tempnode *)((void *)0);
 9699|      0|        temp_dir_index++;
 9700|      0|        if (temp_dir_index == temp_dir_count) {
 9701|      0|            temp_dir_index = (size_t)0;
 9702|      0|        }
 9703|      0|        cs = cs_enter();
 9704|      0|        fd = mkstemp_safer(file);
 9705|      0|        if (0 <= fd) {
 9706|      0|            *temptail = node;
 9707|      0|            temptail = &node->next;
 9708|      0|        }
 9709|      0|        tmp___1 = __errno_location();
 9710|      0|        saved_errno = *tmp___1;
 9711|      0|        cs_leave(cs);
 9712|      0|        tmp___2 = __errno_location();
 9713|      0|        *tmp___2 = saved_errno;
 9714|      0|        if (fd < 0) {
 9715|      0|            if (survive_fd_exhaustion) {
 9716|      0|                tmp___6 = __errno_location();
 9717|      0|                if (!(*tmp___6 == 24)) {
 9718|      0|                    tmp___3 = quote(temp_dir);
 9719|      0|                    tmp___4 = gettext("cannot create temporary file in %s");
 9720|      0|                    tmp___5 = __errno_location();
 9721|      0|                    error(2, *tmp___5, (char const *)tmp___4, tmp___3);
 9722|      0|                }
 9723|      0|            }
 9724|      0|            else {
 9725|      0|                tmp___3 = quote(temp_dir);
 9726|      0|                tmp___4 = gettext("cannot create temporary file in %s");
 9727|      0|                tmp___5 = __errno_location();
 9728|      0|                error(2, *tmp___5, (char const *)tmp___4, tmp___3);
 9729|      0|            }
 9730|      0|            free((void *)node);
 9731|      0|            node = (struct tempnode *)((void *)0);
 9732|      0|        }
 9733|      0|        *pfd = fd;
 9734|      0|        return (node);
 9735|      0|    }
 9736|      0|}
 9737|       |static FILE *stream_open(char const *file, char const *how)
 9738|      6|{
 9739|      6|    FILE *fp;
 9740|      6|    int tmp;
 9741|      6|    FILE *tmp___0;
 9742|       |
 9743|      6|    {
 9744|      6|        if (!file) {
 9745|      2|            return (stdout);
 9746|      2|        }
 9747|      4|        if ((int const) * how == 114) {
 9748|      4|            tmp = strcmp(file, "-");
 9749|      4|            if (tmp == 0) {
 9750|      0|                have_read_stdin = (_Bool)1;
 9751|      0|                fp = stdin;
 9752|      0|            }
 9753|      4|            else {
 9754|      4|                fp = fopen_safer(file, how);
 9755|      4|            }
 9756|      4|            fadvise(fp, (fadvice_t)2);
 9757|      4|            return (fp);
 9758|      4|        }
 9759|      0|        tmp___0 = fopen_safer(file, how);
 9760|      0|        return (tmp___0);
 9761|      4|    }
 9762|      4|}
 9763|       |static FILE *xfopen(char const *file, char const *how)
 9764|      6|{
 9765|      6|    FILE *fp;
 9766|      6|    FILE *tmp;
 9767|      6|    char *tmp___0;
 9768|       |
 9769|      6|    {
 9770|      6|        tmp = stream_open(file, how);
 9771|      6|        fp = tmp;
 9772|      6|        if (!fp) {
 9773|      0|            tmp___0 = gettext("open failed");
 9774|      0|            die((char const *)tmp___0, file);
 9775|      0|        }
 9776|      6|        return (fp);
 9777|      6|    }
 9778|      6|}
 9779|       |static void xfclose(FILE *fp, char const *file)
 9780|      6|{
 9781|      6|    int tmp;
 9782|      6|    int tmp___0;
 9783|      6|    char *tmp___1;
 9784|      6|    int tmp___2;
 9785|      6|    char *tmp___3;
 9786|      6|    int tmp___4;
 9787|       |
 9788|      6|    {
 9789|      6|        tmp = fileno(fp);
 9790|      6|        if (tmp == 0) {
 9791|      0|            goto case_0;
 9792|      0|        }
 9793|      6|        if (tmp == 1) {
 9794|      2|            goto case_1;
 9795|      2|        }
 9796|      4|        goto switch_default;
 9797|      4|case_0:
 9798|      0|        tmp___0 = feof_unlocked(fp);
 9799|      0|        if (tmp___0) {
 9800|      0|            clearerr_unlocked(fp);
 9801|      0|        }
 9802|      0|        goto switch_break;
 9803|      2|case_1:
 9804|      2|        tmp___2 = fflush_unlocked(fp);
 9805|      2|        if (tmp___2 != 0) {
 9806|      0|            tmp___1 = gettext("fflush failed");
 9807|      0|            die((char const *)tmp___1, file);
 9808|      0|        }
 9809|      2|        goto switch_break;
 9810|      4|switch_default:
 9811|      4|        tmp___4 = rpl_fclose(fp);
 9812|      4|        if (tmp___4 != 0) {
 9813|      0|            tmp___3 = gettext("close failed");
 9814|      0|            die((char const *)tmp___3, file);
 9815|      0|        }
 9816|      4|        goto switch_break;
 9817|      6|switch_break:
 9818|      6|        ;
 9819|      6|        return;
 9820|      4|    }
 9821|      4|}
 9822|       |static void dup2_or_die(int oldfd, int newfd)
 9823|      0|{
 9824|      0|    char *tmp;
 9825|      0|    int *tmp___0;
 9826|      0|    int tmp___1;
 9827|       |
 9828|      0|    {
 9829|      0|        tmp___1 = dup2(oldfd, newfd);
 9830|      0|        if (tmp___1 < 0) {
 9831|      0|            tmp = gettext("dup2 failed");
 9832|      0|            tmp___0 = __errno_location();
 9833|      0|            error(2, *tmp___0, (char const *)tmp);
 9834|      0|        }
 9835|      0|        return;
 9836|      0|    }
 9837|      0|}
 9838|       |static pid_t pipe_fork(int *pipefds, size_t tries)
 9839|      0|{
 9840|      0|    struct tempnode *saved_temphead;
 9841|      0|    int saved_errno;
 9842|      0|    double wait_retry;
 9843|      0|    pid_t pid;
 9844|      0|    struct cs_status cs;
 9845|      0|    int tmp;
 9846|      0|    int *tmp___0;
 9847|      0|    int *tmp___1;
 9848|      0|    int *tmp___2;
 9849|      0|    size_t tmp___3;
 9850|      0|    int *tmp___4;
 9851|      0|    int *tmp___5;
 9852|       |
 9853|      0|    {
 9854|      0|        wait_retry = 0.25;
 9855|      0|        tmp = pipe(pipefds);
 9856|      0|        if (tmp < 0) {
 9857|      0|            return (-1);
 9858|      0|        }
 9859|      0|        if (nmerge + 1U < (unsigned int)nprocs) {
 9860|      0|            reap_some();
 9861|      0|        }
 9862|      0|        while (1) {
 9863|      0|            tmp___3 = tries;
 9864|      0|            tries--;
 9865|      0|            if (!tmp___3) {
 9866|      0|                goto while_break;
 9867|      0|            }
 9868|      0|            cs = cs_enter();
 9869|      0|            saved_temphead = (struct tempnode *)temphead;
 9870|      0|            temphead = (struct tempnode *)((void *)0);
 9871|      0|            pid = fork();
 9872|      0|            tmp___0 = __errno_location();
 9873|      0|            saved_errno = *tmp___0;
 9874|      0|            if (pid) {
 9875|      0|                temphead = saved_temphead;
 9876|      0|            }
 9877|      0|            cs_leave(cs);
 9878|      0|            tmp___1 = __errno_location();
 9879|      0|            *tmp___1 = saved_errno;
 9880|      0|            if (0 <= pid) {
 9881|      0|                goto while_break;
 9882|      0|            }
 9883|      0|            else {
 9884|      0|                tmp___2 = __errno_location();
 9885|      0|                if (*tmp___2 != 11) {
 9886|      0|                    goto while_break;
 9887|      0|                }
 9888|      0|                else {
 9889|      0|                    xnanosleep(wait_retry);
 9890|      0|                    wait_retry *= (double)2;
 9891|      0|                    reap_exited();
 9892|      0|                }
 9893|      0|            }
 9894|      0|        }
 9895|      0|while_break:
 9896|      0|        ;
 9897|      0|        if (pid < 0) {
 9898|      0|            tmp___4 = __errno_location();
 9899|      0|            saved_errno = *tmp___4;
 9900|      0|            close(*(pipefds + 0));
 9901|      0|            close(*(pipefds + 1));
 9902|      0|            tmp___5 = __errno_location();
 9903|      0|            *tmp___5 = saved_errno;
 9904|      0|        }
 9905|      0|        else {
 9906|      0|            if (pid == 0) {
 9907|      0|                close(0);
 9908|      0|                close(1);
 9909|      0|            }
 9910|      0|            else {
 9911|      0|                nprocs++;
 9912|      0|            }
 9913|      0|        }
 9914|      0|        return (pid);
 9915|      0|    }
 9916|      0|}
 9917|       |static struct tempnode *maybe_create_temp(FILE **pfp,
 9918|       |        _Bool survive_fd_exhaustion)
 9919|      0|{
 9920|      0|    int tempfd;
 9921|      0|    struct tempnode *node;
 9922|      0|    struct tempnode *tmp;
 9923|      0|    int pipefds[2];
 9924|      0|    char *tmp___0;
 9925|      0|    int *tmp___1;
 9926|      0|    int tmp___2;
 9927|      0|    char *tmp___3;
 9928|       |
 9929|      0|    {
 9930|      0|        tmp = create_temp_file(&tempfd, survive_fd_exhaustion);
 9931|      0|        node = tmp;
 9932|      0|        if (!node) {
 9933|      0|            return ((struct tempnode *)((void *)0));
 9934|      0|        }
 9935|      0|        node->state = (char)0;
 9936|      0|        if (compress_program) {
 9937|      0|            node->pid = pipe_fork(pipefds, (size_t)4);
 9938|      0|            if (0 < node->pid) {
 9939|      0|                close(tempfd);
 9940|      0|                close(pipefds[0]);
 9941|      0|                tempfd = pipefds[1];
 9942|      0|                register_proc(node);
 9943|      0|            }
 9944|      0|            else {
 9945|      0|                if (node->pid == 0) {
 9946|      0|                    close(pipefds[1]);
 9947|      0|                    dup2_or_die(tempfd, 1);
 9948|      0|                    close(tempfd);
 9949|      0|                    dup2_or_die(pipefds[0], 0);
 9950|      0|                    close(pipefds[0]);
 9951|      0|                    tmp___2 =
 9952|      0|                        execlp(compress_program, compress_program, (char *)((void *)0));
 9953|      0|                    if (tmp___2 < 0) {
 9954|      0|                        tmp___0 = gettext("couldn\'t execute %s");
 9955|      0|                        tmp___1 = __errno_location();
 9956|      0|                        error(2, *tmp___1, (char const *)tmp___0, compress_program);
 9957|      0|                    }
 9958|      0|                }
 9959|      0|            }
 9960|      0|        }
 9961|      0|        *pfp = fdopen(tempfd, "w");
 9962|      0|        if (!*pfp) {
 9963|      0|            tmp___3 = gettext("couldn\'t create temporary file");
 9964|      0|            die((char const *)tmp___3, (char const *)(node->name));
 9965|      0|        }
 9966|      0|        return (node);
 9967|      0|    }
 9968|      0|}
 9969|       |static struct tempnode *create_temp(FILE **pfp)
 9970|      0|{
 9971|      0|    struct tempnode *tmp;
 9972|       |
 9973|      0|    {
 9974|      0|        tmp = maybe_create_temp(pfp, (_Bool)0);
 9975|      0|        return (tmp);
 9976|      0|    }
 9977|      0|}
 9978|       |static FILE *open_temp(struct tempnode *temp)
 9979|      0|{
 9980|      0|    int tempfd;
 9981|      0|    int pipefds[2];
 9982|      0|    FILE *fp;
 9983|      0|    pid_t child;
 9984|      0|    pid_t tmp;
 9985|      0|    char *tmp___0;
 9986|      0|    int *tmp___1;
 9987|      0|    int *tmp___2;
 9988|      0|    int *tmp___3;
 9989|      0|    char *tmp___4;
 9990|      0|    int *tmp___5;
 9991|      0|    int saved_errno;
 9992|      0|    int *tmp___6;
 9993|      0|    int *tmp___7;
 9994|       |
 9995|      0|    {
 9996|      0|        fp = (FILE *)((void *)0);
 9997|      0|        if ((int)temp->state == 1) {
 9998|      0|            wait_proc(temp->pid);
 9999|      0|        }
10000|      0|        tempfd = open((char const *)(temp->name), 0);
10001|      0|        if (tempfd < 0) {
10002|      0|            return ((FILE *)((void *)0));
10003|      0|        }
10004|      0|        tmp = pipe_fork(pipefds, (size_t)9);
10005|      0|        child = tmp;
10006|      0|        if (child == -1) {
10007|      0|            goto case_neg_1;
10008|      0|        }
10009|      0|        if (child == 0) {
10010|      0|            goto case_0;
10011|      0|        }
10012|      0|        goto switch_default;
10013|      0|case_neg_1:
10014|      0|        tmp___2 = __errno_location();
10015|      0|        if (*tmp___2 != 24) {
10016|      0|            tmp___0 = gettext("couldn\'t create process for %s -d");
10017|      0|            tmp___1 = __errno_location();
10018|      0|            error(2, *tmp___1, (char const *)tmp___0, compress_program);
10019|      0|        }
10020|      0|        close(tempfd);
10021|      0|        tmp___3 = __errno_location();
10022|      0|        *tmp___3 = 24;
10023|      0|        goto switch_break;
10024|      0|case_0:
10025|      0|        close(pipefds[0]);
10026|      0|        dup2_or_die(tempfd, 0);
10027|      0|        close(tempfd);
10028|      0|        dup2_or_die(pipefds[1], 1);
10029|      0|        close(pipefds[1]);
10030|      0|        execlp(compress_program, compress_program, "-d", (char *)((void *)0));
10031|      0|        tmp___4 = gettext("couldn\'t execute %s -d");
10032|      0|        tmp___5 = __errno_location();
10033|      0|        error(2, *tmp___5, (char const *)tmp___4, compress_program);
10034|      0|switch_default:
10035|      0|        temp->pid = child;
10036|      0|        register_proc(temp);
10037|      0|        close(tempfd);
10038|      0|        close(pipefds[1]);
10039|      0|        fp = fdopen(pipefds[0], "r");
10040|      0|        if (!fp) {
10041|      0|            tmp___6 = __errno_location();
10042|      0|            saved_errno = *tmp___6;
10043|      0|            close(pipefds[0]);
10044|      0|            tmp___7 = __errno_location();
10045|      0|            *tmp___7 = saved_errno;
10046|      0|        }
10047|      0|        goto switch_break;
10048|      0|switch_break:
10049|      0|        ;
10050|      0|        return (fp);
10051|      0|    }
10052|      0|}
10053|       |static void add_temp_dir(char const *dir)
10054|      2|{
10055|      2|    size_t tmp;
10056|       |
10057|      2|    {
10058|      2|        if (temp_dir_count == temp_dir_alloc) {
10059|      2|            temp_dirs = (char const **)x2nrealloc((void *)temp_dirs, &temp_dir_alloc,
10060|      2|                                                  sizeof(*temp_dirs));
10061|      2|        }
10062|      2|        tmp = temp_dir_count;
10063|      2|        temp_dir_count++;
10064|      2|        *(temp_dirs + tmp) = dir;
10065|      2|        return;
10066|      2|    }
10067|      2|}
10068|       |static void zaptemp(char const *name)
10069|      0|{
10070|      0|    struct tempnode *volatile *pnode;
10071|      0|    struct tempnode *node;
10072|      0|    struct tempnode *next;
10073|      0|    int unlink_status;
10074|      0|    int unlink_errno;
10075|      0|    struct cs_status cs;
10076|      0|    int *tmp;
10077|      0|    char *tmp___0;
10078|       |
10079|      0|    {
10080|      0|        unlink_errno = 0;
10081|      0|        pnode = &temphead;
10082|      0|        while (1) {
10083|      0|            node = (struct tempnode *)*pnode;
10084|      0|            if (!((unsigned long)(node->name) != (unsigned long)name)) {
10085|      0|                goto while_break;
10086|      0|            }
10087|      0|            goto __Cont;
10088|      0|__Cont:
10089|      0|            pnode = &node->next;
10090|      0|        }
10091|      0|while_break:
10092|      0|        ;
10093|      0|        if ((int)node->state == 1) {
10094|      0|            wait_proc(node->pid);
10095|      0|        }
10096|      0|        next = (struct tempnode *)node->next;
10097|      0|        cs = cs_enter();
10098|      0|        unlink_status = unlink(name);
10099|      0|        tmp = __errno_location();
10100|      0|        unlink_errno = *tmp;
10101|      0|        *pnode = next;
10102|      0|        cs_leave(cs);
10103|      0|        if (unlink_status != 0) {
10104|      0|            tmp___0 = gettext("warning: cannot remove: %s");
10105|      0|            error(0, unlink_errno, (char const *)tmp___0, name);
10106|      0|        }
10107|      0|        if (!next) {
10108|      0|            temptail = pnode;
10109|      0|        }
10110|      0|        free((void *)node);
10111|      0|        return;
10112|      0|    }
10113|      0|}
10114|       |static int struct_month_cmp(void const *m1, void const *m2)
10115|     60|{
10116|     60|    struct month const *month1;
10117|     60|    struct month const *month2;
10118|     60|    int tmp;
10119|       |
10120|     60|    {
10121|     60|        month1 = (struct month const *)m1;
10122|     60|        month2 = (struct month const *)m2;
10123|     60|        tmp = strcmp((char const *)month1->name, (char const *)month2->name);
10124|     60|        return (tmp);
10125|     60|    }
10126|     60|}
10127|       |static void inittables(void)
10128|      2|{
10129|      2|    size_t i;
10130|      2|    unsigned short const **tmp;
10131|      2|    int tmp___0;
10132|      2|    unsigned short const **tmp___1;
10133|      2|    int tmp___2;
10134|      2|    unsigned short const **tmp___3;
10135|      2|    unsigned short const **tmp___4;
10136|      2|    int tmp___5;
10137|      2|    char const *s;
10138|      2|    size_t s_len;
10139|      2|    size_t j;
10140|      2|    size_t k;
10141|      2|    char *name;
10142|      2|    size_t tmp___6;
10143|      2|    unsigned char tmp___7;
10144|      2|    unsigned short const **tmp___8;
10145|      2|    unsigned char tmp___9;
10146|       |
10147|      2|    {
10148|      2|        i = (size_t)0;
10149|    514|        while (1) {
10150|       |
10151|    514|            if (!(i < 256UL)) {
10152|      2|                goto while_break;
10153|      2|            }
10154|    512|            tmp = __ctype_b_loc();
10155|    512|            if ((int const) * (*tmp + (int)i) & 1) {
10156|      4|                tmp___0 = 1;
10157|      4|            }
10158|    508|            else {
10159|    508|                tmp___0 = 0;
10160|    508|            }
10161|    512|            blanks[i] = (_Bool)tmp___0;
10162|    512|            tmp___1 = __ctype_b_loc();
10163|    512|            if ((int const) * (*tmp___1 + (int)i) & 16384) {
10164|    190|                tmp___2 = 0;
10165|    190|            }
10166|    322|            else {
10167|    322|                tmp___2 = 1;
10168|    322|            }
10169|    512|            nonprinting[i] = (_Bool)tmp___2;
10170|    512|            tmp___3 = __ctype_b_loc();
10171|    512|            if ((int const) * (*tmp___3 + (int)i) & 8) {
10172|    124|                tmp___5 = 0;
10173|    124|            }
10174|    388|            else {
10175|    388|                tmp___4 = __ctype_b_loc();
10176|    388|                if ((int const) * (*tmp___4 + (int)i) & 1) {
10177|      4|                    tmp___5 = 0;
10178|      4|                }
10179|    384|                else {
10180|    384|                    tmp___5 = 1;
10181|    384|                }
10182|    388|            }
10183|    512|            nondictionary[i] = (_Bool)tmp___5;
10184|    512|            fold_toupper[i] = (char)toupper((int)i);
10185|    512|            i++;
10186|    512|        }
10187|      2|while_break:
10188|      2|        ;
10189|      2|        if (hard_LC_TIME) {
10190|      2|            i = (size_t)0;
10191|     26|            while (1) {
10192|       |
10193|     26|                if (!(i < 12UL)) {
10194|      2|                    goto while_break___0;
10195|      2|                }
10196|     24|                s = (char const *)nl_langinfo((nl_item)(131086UL + i));
10197|     24|                s_len = strlen(s);
10198|     24|                name = (char *)xmalloc(s_len + 1UL);
10199|     24|                monthtab[i].name = (char const *)name;
10200|     24|                monthtab[i].val = (int)(i + 1UL);
10201|     24|                k = (size_t)0;
10202|     24|                j = k;
10203|     96|                while (1) {
10204|       |
10205|     96|                    if (!(j < s_len)) {
10206|     24|                        goto while_break___1;
10207|     24|                    }
10208|     72|                    tmp___8 = __ctype_b_loc();
10209|     72|                    tmp___9 = to_uchar((char)*(s + j));
10210|     72|                    if (!((int const) * (*tmp___8 + (int)tmp___9) & 1)) {
10211|     72|                        tmp___6 = k;
10212|     72|                        k++;
10213|     72|                        tmp___7 = to_uchar((char)*(s + j));
10214|     72|                        *(name + tmp___6) = fold_toupper[tmp___7];
10215|     72|                    }
10216|     72|                    j++;
10217|     72|                }
10218|     24|while_break___1:
10219|     24|                *(name + k) = (char)'\000';
10220|     24|                i++;
10221|     24|            }
10222|      2|while_break___0:
10223|      2|            qsort((void *)(monthtab), (size_t)12, sizeof(monthtab[0]),
10224|      2|                  &struct_month_cmp);
10225|      2|        }
10226|      2|        return;
10227|      2|    }
10228|      2|}
10229|       |static void specify_nmerge(int oi, char c, char const *s)
10230|      0|{
10231|      0|    uintmax_t n;
10232|      0|    struct rlimit rlimit;
10233|      0|    enum strtol_error e;
10234|      0|    enum strtol_error tmp;
10235|      0|    unsigned int max_nmerge;
10236|      0|    rlim_t tmp___1;
10237|      0|    int tmp___2;
10238|      0|    char const *tmp___3;
10239|      0|    char *tmp___4;
10240|      0|    char const *tmp___5;
10241|      0|    char *tmp___6;
10242|      0|    char max_nmerge_buf[((sizeof(max_nmerge) * 8UL) * 146UL + 484UL) / 485UL +
10243|      0|                                             1UL];
10244|      0|    char const *tmp___7;
10245|      0|    char *tmp___8;
10246|      0|    char *tmp___9;
10247|      0|    char *tmp___10;
10248|       |
10249|      0|    {
10250|      0|        tmp =
10251|      0|            xstrtoumax(s, (char **)((void *)0), 10, &n, (char const *)((void *)0));
10252|      0|        e = tmp;
10253|      0|        tmp___2 = getrlimit((__rlimit_resource_t)7, &rlimit);
10254|      0|        if (tmp___2 == 0) {
10255|      0|            tmp___1 = rlimit.rlim_cur;
10256|      0|        }
10257|      0|        else {
10258|      0|            tmp___1 = (rlim_t)20;
10259|      0|        }
10260|      0|        max_nmerge = (unsigned int)(tmp___1 - 3UL);
10261|      0|        if ((unsigned int)e == 0U) {
10262|      0|            nmerge = (unsigned int)n;
10263|      0|            if ((uintmax_t)nmerge != n) {
10264|      0|                e = (enum strtol_error)1;
10265|      0|            }
10266|      0|            else {
10267|      0|                if (nmerge < 2U) {
10268|      0|                    tmp___3 = quote(s);
10269|      0|                    tmp___4 = gettext("invalid --%s argument %s");
10270|      0|                    error(0, 0, (char const *)tmp___4, long_options___1[oi].name,
10271|      0|                          tmp___3);
10272|      0|                    tmp___5 = quote("2");
10273|      0|                    tmp___6 = gettext("minimum --%s argument is %s");
10274|      0|                    error(2, 0, (char const *)tmp___6, long_options___1[oi].name,
10275|      0|                          tmp___5);
10276|      0|                }
10277|      0|                else {
10278|      0|                    if (max_nmerge < nmerge) {
10279|      0|                        e = (enum strtol_error)1;
10280|      0|                    }
10281|      0|                    else {
10282|      0|                        return;
10283|      0|                    }
10284|      0|                }
10285|      0|            }
10286|      0|        }
10287|      0|        if ((unsigned int)e == 1U) {
10288|      0|            tmp___7 = quote(s);
10289|      0|            tmp___8 = gettext("--%s argument %s too large");
10290|      0|            error(0, 0, (char const *)tmp___8, long_options___1[oi].name, tmp___7);
10291|      0|            tmp___9 = uinttostr(max_nmerge, max_nmerge_buf);
10292|      0|            tmp___10 = gettext("maximum --%s argument with current rlimit is %s");
10293|      0|            error(2, 0, (char const *)tmp___10, long_options___1[oi].name, tmp___9);
10294|      0|        }
10295|      0|        else {
10296|      0|            xstrtol_fatal(e, oi, c, long_options___1, s);
10297|      0|        }
10298|      0|        return;
10299|      0|    }
10300|      0|}
10301|       |static void specify_sort_size(int oi, char c, char const *s)
10302|      0|{
10303|      0|    uintmax_t n;
10304|      0|    char *suffix;
10305|      0|    enum strtol_error e;
10306|      0|    enum strtol_error tmp;
10307|      0|    double mem;
10308|      0|    double tmp___0;
10309|       |
10310|      0|    {
10311|      0|        tmp = xstrtoumax(s, &suffix, 10, &n, "EgGkKmMPtTYZ");
10312|      0|        e = tmp;
10313|      0|        if ((unsigned int)e == 0U) {
10314|      0|            if ((unsigned int)*(suffix + -1) - 48U <= 9U) {
10315|      0|                if (n <= 18014398509481983UL) {
10316|      0|                    n *= 1024UL;
10317|      0|                }
10318|      0|                else {
10319|      0|                    e = (enum strtol_error)1;
10320|      0|                }
10321|      0|            }
10322|      0|        }
10323|      0|        if ((unsigned int)e == 2U) {
10324|      0|            if ((unsigned int)*(suffix + -1) - 48U <= 9U) {
10325|      0|                if (!*(suffix + 1)) {
10326|      0|                    if ((int)*(suffix + 0) == 98) {
10327|      0|                        goto case_98;
10328|      0|                    }
10329|      0|                    if ((int)*(suffix + 0) == 37) {
10330|      0|                        goto case_37;
10331|      0|                    }
10332|      0|                    goto switch_break;
10333|      0|case_98:
10334|      0|                    e = (enum strtol_error)0;
10335|      0|                    goto switch_break;
10336|      0|case_37:
10337|      0|                    tmp___0 = physmem_total();
10338|      0|                    mem = (tmp___0 * (double)n) / (double)100;
10339|      0|                    if (mem < (double)0xffffffffffffffffUL) {
10340|      0|                        n = (uintmax_t)mem;
10341|      0|                        e = (enum strtol_error)0;
10342|      0|                    }
10343|      0|                    else {
10344|      0|                        e = (enum strtol_error)1;
10345|      0|                    }
10346|      0|                    goto switch_break;
10347|      0|switch_break:
10348|      0|                    ;
10349|      0|                }
10350|      0|            }
10351|      0|        }
10352|      0|        if ((unsigned int)e == 0U) {
10353|      0|            if (n < sort_size) {
10354|      0|                return;
10355|      0|            }
10356|      0|            sort_size = n;
10357|      0|            if (sort_size == n) {
10358|      0|                if (sort_size > (unsigned long)nmerge * (2UL + sizeof(struct line))) {
10359|      0|                    sort_size = sort_size;
10360|      0|                }
10361|      0|                else {
10362|      0|                    sort_size = (unsigned long)nmerge * (2UL + sizeof(struct line));
10363|      0|                }
10364|      0|                return;
10365|      0|            }
10366|      0|            e = (enum strtol_error)1;
10367|      0|        }
10368|      0|        xstrtol_fatal(e, oi, c, long_options___1, s);
10369|      0|    }
10370|      0|}
10371|       |static size_t specify_nthreads(int oi, char c, char const *s)
10372|      0|{
10373|      0|    unsigned long nthreads;
10374|      0|    enum strtol_error e;
10375|      0|    enum strtol_error tmp;
10376|      0|    char *tmp___0;
10377|       |
10378|      0|    {
10379|      0|        tmp = xstrtoul(s, (char **)((void *)0), 10, &nthreads, "");
10380|      0|        e = tmp;
10381|      0|        if ((unsigned int)e == 1U) {
10382|      0|            return (0xffffffffffffffffUL);
10383|      0|        }
10384|      0|        if ((unsigned int)e != 0U) {
10385|      0|            xstrtol_fatal(e, oi, c, long_options___1, s);
10386|      0|        }
10387|      0|        if (0xffffffffffffffffUL < nthreads) {
10388|      0|            nthreads = 0xffffffffffffffffUL;
10389|      0|        }
10390|      0|        if (nthreads == 0UL) {
10391|      0|            tmp___0 = gettext("number in parallel must be nonzero");
10392|      0|            error(2, 0, (char const *)tmp___0);
10393|      0|        }
10394|      0|        return (nthreads);
10395|      0|    }
10396|      0|}
10397|       |static size_t default_sort_size(void)
10398|      2|{
10399|      2|    double avail;
10400|      2|    double tmp;
10401|      2|    double total;
10402|      2|    double tmp___0;
10403|      2|    double mem;
10404|      2|    double tmp___1;
10405|      2|    struct rlimit rlimit;
10406|      2|    size_t size;
10407|      2|    int tmp___2;
10408|      2|    int tmp___3;
10409|      2|    int tmp___4;
10410|      2|    size_t tmp___5;
10411|       |
10412|      2|    {
10413|      2|        tmp = physmem_available();
10414|      2|        avail = tmp;
10415|      2|        tmp___0 = physmem_total();
10416|      2|        total = tmp___0;
10417|      2|        if (avail > total / (double)8) {
10418|      2|            tmp___1 = avail;
10419|      2|        }
10420|      0|        else {
10421|      0|            tmp___1 = total / (double)8;
10422|      0|        }
10423|      2|        mem = tmp___1;
10424|      2|        size = 0xffffffffffffffffUL;
10425|      2|        tmp___2 = getrlimit((__rlimit_resource_t)2, &rlimit);
10426|      2|        if (tmp___2 == 0) {
10427|      2|            if (rlimit.rlim_cur < size) {
10428|      0|                size = rlimit.rlim_cur;
10429|      0|            }
10430|      2|        }
10431|      2|        tmp___3 = getrlimit((__rlimit_resource_t)9, &rlimit);
10432|      2|        if (tmp___3 == 0) {
10433|      2|            if (rlimit.rlim_cur < size) {
10434|      0|                size = rlimit.rlim_cur;
10435|      0|            }
10436|      2|        }
10437|      2|        size /= 2UL;
10438|      2|        tmp___4 = getrlimit((__rlimit_resource_t)5, &rlimit);
10439|      2|        if (tmp___4 == 0) {
10440|      2|            if ((rlimit.rlim_cur / 16UL) * 15UL < size) {
10441|      0|                size = (rlimit.rlim_cur / 16UL) * 15UL;
10442|      0|            }
10443|      2|        }
10444|      2|        if (mem < (double)size) {
10445|      2|            size = (size_t)mem;
10446|      2|        }
10447|      2|        if (size > (unsigned long)nmerge * (2UL + sizeof(struct line))) {
10448|      2|            tmp___5 = size;
10449|      2|        }
10450|      0|        else {
10451|      0|            tmp___5 = (unsigned long)nmerge * (2UL + sizeof(struct line));
10452|      0|        }
10453|      2|        return (tmp___5);
10454|      2|    }
10455|      2|}
10456|       |static size_t size_bound;
10457|       |static size_t sort_buffer_size(FILE *const *fps, size_t nfps,
10458|       |                               char *const *files, size_t nfiles,
10459|       |                               size_t line_bytes)
10460|      2|{
10461|      2|    size_t worst_case_per_input_byte;
10462|      2|    size_t size;
10463|      2|    size_t i;
10464|      2|    struct stat st;
10465|      2|    off_t file_size;
10466|      2|    size_t worst_case;
10467|      2|    char *tmp;
10468|      2|    int tmp___0;
10469|      2|    int tmp___1;
10470|      2|    int tmp___3;
10471|      2|    int tmp___4;
10472|      2|    int tmp___5;
10473|      2|    int tmp___6;
10474|      2|    int tmp___7;
10475|       |
10476|      2|    {
10477|      2|        worst_case_per_input_byte = line_bytes + 1UL;
10478|      2|        size = worst_case_per_input_byte + 1UL;
10479|      2|        i = (size_t)0;
10480|      6|        while (1) {
10481|       |
10482|      6|            if (!(i < nfiles)) {
10483|      2|                goto while_break;
10484|      2|            }
10485|      4|            if (i < nfps) {
10486|      2|                tmp___0 = fileno((FILE *)*(fps + i));
10487|      2|                tmp___1 = fstat(tmp___0, &st);
10488|      2|                tmp___7 = tmp___1;
10489|      2|            }
10490|      2|            else {
10491|      2|                tmp___6 = strcmp((char const *)*(files + i), "-");
10492|      2|                if (tmp___6 == 0) {
10493|      0|                    tmp___3 = fstat(0, &st);
10494|      0|                    tmp___5 = tmp___3;
10495|      0|                }
10496|      2|                else {
10497|      2|                    tmp___4 = stat((char const *)*(files + i), &st);
10498|      2|                    tmp___5 = tmp___4;
10499|      2|                }
10500|      2|                tmp___7 = tmp___5;
10501|      2|            }
10502|      4|            if (tmp___7 != 0) {
10503|      0|                tmp = gettext("stat failed");
10504|      0|                die((char const *)tmp, (char const *)*(files + i));
10505|      0|            }
10506|      4|            if ((st.st_mode & 61440U) == 32768U) {
10507|      4|                file_size = st.st_size;
10508|      4|            }
10509|      0|            else {
10510|      0|                if (sort_size) {
10511|      0|                    return (sort_size);
10512|      0|                }
10513|      0|                file_size = (off_t)131072;
10514|      0|            }
10515|      4|            if (!size_bound) {
10516|      2|                size_bound = sort_size;
10517|      2|                if (!size_bound) {
10518|      2|                    size_bound = default_sort_size();
10519|      2|                }
10520|      2|            }
10521|      4|            worst_case = (size_t)file_size * worst_case_per_input_byte + 1UL;
10522|      4|            if ((size_t)file_size != worst_case / worst_case_per_input_byte) {
10523|      0|                return (size_bound);
10524|      0|            }
10525|      4|            else {
10526|      4|                if (size_bound - size <= worst_case) {
10527|      0|                    return (size_bound);
10528|      0|                }
10529|      4|            }
10530|      4|            size += worst_case;
10531|      4|            i++;
10532|      4|        }
10533|      2|while_break:
10534|      2|        ;
10535|      2|        return (size);
10536|      2|    }
10537|      2|}
10538|       |static void initbuf(struct buffer *buf___1, size_t line_bytes, size_t alloc)
10539|      2|{
10540|      2|    size_t tmp;
10541|      2|    size_t tmp___0;
10542|       |
10543|      2|    {
10544|      2|        while (1) {
10545|      2|            alloc += sizeof(struct line) - alloc % sizeof(struct line);
10546|      2|            buf___1->buf = (char *)malloc(alloc);
10547|      2|            if (buf___1->buf) {
10548|      2|                goto while_break;
10549|      2|            }
10550|      0|            alloc /= 2UL;
10551|      0|            if (alloc <= line_bytes + 1UL) {
10552|      0|                xalloc_die();
10553|      0|            }
10554|      0|        }
10555|      2|while_break:
10556|      2|        buf___1->line_bytes = line_bytes;
10557|      2|        buf___1->alloc = alloc;
10558|      2|        tmp___0 = (size_t)0;
10559|      2|        buf___1->nlines = tmp___0;
10560|      2|        tmp = tmp___0;
10561|      2|        buf___1->left = tmp;
10562|      2|        buf___1->used = tmp;
10563|      2|        buf___1->eof = (_Bool)0;
10564|      2|        return;
10565|      2|    }
10566|      2|}
10567|       |__inline static struct line *buffer_linelim(struct buffer const *buf___1)
10568|     10|{
10569|       |
10570|     10|    {
10571|     10|        return ((struct line *)(buf___1->buf + buf___1->alloc));
10572|     10|    }
10573|     10|}
10574|       |static char *begfield(struct line const *line, struct keyfield const *key)
10575|      0|{
10576|      0|    char *ptr;
10577|      0|    char *lim;
10578|      0|    size_t sword;
10579|      0|    size_t schar;
10580|      0|    size_t tmp;
10581|      0|    unsigned char tmp___0;
10582|      0|    unsigned char tmp___1;
10583|      0|    size_t tmp___2;
10584|      0|    unsigned char tmp___3;
10585|       |
10586|      0|    {
10587|      0|        ptr = (char *)line->text;
10588|      0|        lim = (ptr + line->length) - 1;
10589|      0|        sword = (size_t)key->sword;
10590|      0|        schar = (size_t)key->schar;
10591|      0|        if (tab != 128) {
10592|      0|            while (1) {
10593|       |
10594|      0|                if ((unsigned long)ptr < (unsigned long)lim) {
10595|      0|                    tmp = sword;
10596|      0|                    sword--;
10597|      0|                    if (!tmp) {
10598|      0|                        goto while_break;
10599|      0|                    }
10600|      0|                }
10601|      0|                else {
10602|      0|                    goto while_break;
10603|      0|                }
10604|      0|                while (1) {
10605|       |
10606|      0|                    if ((unsigned long)ptr < (unsigned long)lim) {
10607|      0|                        if (!((int)*ptr != tab)) {
10608|      0|                            goto while_break___0;
10609|      0|                        }
10610|      0|                    }
10611|      0|                    else {
10612|      0|                        goto while_break___0;
10613|      0|                    }
10614|      0|                    ptr++;
10615|      0|                }
10616|      0|while_break___0:
10617|      0|                ;
10618|      0|                if ((unsigned long)ptr < (unsigned long)lim) {
10619|      0|                    ptr++;
10620|      0|                }
10621|      0|            }
10622|      0|while_break:
10623|      0|            ;
10624|      0|        }
10625|      0|        else {
10626|      0|            while (1) {
10627|       |
10628|      0|                if ((unsigned long)ptr < (unsigned long)lim) {
10629|      0|                    tmp___2 = sword;
10630|      0|                    sword--;
10631|      0|                    if (!tmp___2) {
10632|      0|                        goto while_break___1;
10633|      0|                    }
10634|      0|                }
10635|      0|                else {
10636|      0|                    goto while_break___1;
10637|      0|                }
10638|      0|                while (1) {
10639|       |
10640|      0|                    if ((unsigned long)ptr < (unsigned long)lim) {
10641|      0|                        tmp___0 = to_uchar(*ptr);
10642|      0|                        if (!blanks[tmp___0]) {
10643|      0|                            goto while_break___2;
10644|      0|                        }
10645|      0|                    }
10646|      0|                    else {
10647|      0|                        goto while_break___2;
10648|      0|                    }
10649|      0|                    ptr++;
10650|      0|                }
10651|      0|while_break___2:
10652|      0|                ;
10653|      0|                while (1) {
10654|       |
10655|      0|                    if ((unsigned long)ptr < (unsigned long)lim) {
10656|      0|                        tmp___1 = to_uchar(*ptr);
10657|      0|                        if (blanks[tmp___1]) {
10658|      0|                            goto while_break___3;
10659|      0|                        }
10660|      0|                    }
10661|      0|                    else {
10662|      0|                        goto while_break___3;
10663|      0|                    }
10664|      0|                    ptr++;
10665|      0|                }
10666|      0|while_break___3:
10667|      0|                ;
10668|      0|            }
10669|      0|while_break___1:
10670|      0|            ;
10671|      0|        }
10672|      0|        if (key->skipsblanks) {
10673|      0|            while (1) {
10674|       |
10675|      0|                if ((unsigned long)ptr < (unsigned long)lim) {
10676|      0|                    tmp___3 = to_uchar(*ptr);
10677|      0|                    if (!blanks[tmp___3]) {
10678|      0|                        goto while_break___4;
10679|      0|                    }
10680|      0|                }
10681|      0|                else {
10682|      0|                    goto while_break___4;
10683|      0|                }
10684|      0|                ptr++;
10685|      0|            }
10686|      0|while_break___4:
10687|      0|            ;
10688|      0|        }
10689|      0|        if ((unsigned long)lim < (unsigned long)(ptr + schar)) {
10690|      0|            ptr = lim;
10691|      0|        }
10692|      0|        else {
10693|      0|            ptr += schar;
10694|      0|        }
10695|      0|        return (ptr);
10696|      0|    }
10697|      0|}
10698|       |static char *limfield(struct line const *line, struct keyfield const *key)
10699|      0|{
10700|      0|    char *ptr;
10701|      0|    char *lim;
10702|      0|    size_t eword;
10703|      0|    size_t echar;
10704|      0|    size_t tmp;
10705|      0|    unsigned char tmp___0;
10706|      0|    unsigned char tmp___1;
10707|      0|    size_t tmp___2;
10708|      0|    unsigned char tmp___3;
10709|       |
10710|      0|    {
10711|      0|        ptr = (char *)line->text;
10712|      0|        lim = (ptr + line->length) - 1;
10713|      0|        eword = (size_t)key->eword;
10714|      0|        echar = (size_t)key->echar;
10715|      0|        if (echar == 0UL) {
10716|      0|            eword++;
10717|      0|        }
10718|      0|        if (tab != 128) {
10719|      0|            while (1) {
10720|       |
10721|      0|                if ((unsigned long)ptr < (unsigned long)lim) {
10722|      0|                    tmp = eword;
10723|      0|                    eword--;
10724|      0|                    if (!tmp) {
10725|      0|                        goto while_break;
10726|      0|                    }
10727|      0|                }
10728|      0|                else {
10729|      0|                    goto while_break;
10730|      0|                }
10731|      0|                while (1) {
10732|       |
10733|      0|                    if ((unsigned long)ptr < (unsigned long)lim) {
10734|      0|                        if (!((int)*ptr != tab)) {
10735|      0|                            goto while_break___0;
10736|      0|                        }
10737|      0|                    }
10738|      0|                    else {
10739|      0|                        goto while_break___0;
10740|      0|                    }
10741|      0|                    ptr++;
10742|      0|                }
10743|      0|while_break___0:
10744|      0|                ;
10745|      0|                if ((unsigned long)ptr < (unsigned long)lim) {
10746|      0|                    if (eword) {
10747|      0|                        ptr++;
10748|      0|                    }
10749|      0|                    else {
10750|      0|                        if (echar) {
10751|      0|                            ptr++;
10752|      0|                        }
10753|      0|                    }
10754|      0|                }
10755|      0|            }
10756|      0|while_break:
10757|      0|            ;
10758|      0|        }
10759|      0|        else {
10760|      0|            while (1) {
10761|       |
10762|      0|                if ((unsigned long)ptr < (unsigned long)lim) {
10763|      0|                    tmp___2 = eword;
10764|      0|                    eword--;
10765|      0|                    if (!tmp___2) {
10766|      0|                        goto while_break___1;
10767|      0|                    }
10768|      0|                }
10769|      0|                else {
10770|      0|                    goto while_break___1;
10771|      0|                }
10772|      0|                while (1) {
10773|       |
10774|      0|                    if ((unsigned long)ptr < (unsigned long)lim) {
10775|      0|                        tmp___0 = to_uchar(*ptr);
10776|      0|                        if (!blanks[tmp___0]) {
10777|      0|                            goto while_break___2;
10778|      0|                        }
10779|      0|                    }
10780|      0|                    else {
10781|      0|                        goto while_break___2;
10782|      0|                    }
10783|      0|                    ptr++;
10784|      0|                }
10785|      0|while_break___2:
10786|      0|                ;
10787|      0|                while (1) {
10788|       |
10789|      0|                    if ((unsigned long)ptr < (unsigned long)lim) {
10790|      0|                        tmp___1 = to_uchar(*ptr);
10791|      0|                        if (blanks[tmp___1]) {
10792|      0|                            goto while_break___3;
10793|      0|                        }
10794|      0|                    }
10795|      0|                    else {
10796|      0|                        goto while_break___3;
10797|      0|                    }
10798|      0|                    ptr++;
10799|      0|                }
10800|      0|while_break___3:
10801|      0|                ;
10802|      0|            }
10803|      0|while_break___1:
10804|      0|            ;
10805|      0|        }
10806|      0|        if (echar != 0UL) {
10807|      0|            if (key->skipeblanks) {
10808|      0|                while (1) {
10809|       |
10810|      0|                    if ((unsigned long)ptr < (unsigned long)lim) {
10811|      0|                        tmp___3 = to_uchar(*ptr);
10812|      0|                        if (!blanks[tmp___3]) {
10813|      0|                            goto while_break___4;
10814|      0|                        }
10815|      0|                    }
10816|      0|                    else {
10817|      0|                        goto while_break___4;
10818|      0|                    }
10819|      0|                    ptr++;
10820|      0|                }
10821|      0|while_break___4:
10822|      0|                ;
10823|      0|            }
10824|      0|            if ((unsigned long)lim < (unsigned long)(ptr + echar)) {
10825|      0|                ptr = lim;
10826|      0|            }
10827|      0|            else {
10828|      0|                ptr += echar;
10829|      0|            }
10830|      0|        }
10831|      0|        return (ptr);
10832|      0|    }
10833|      0|}
10834|       |static _Bool fillbuf___7(struct buffer *buf___1, FILE *fp, char const *file)
10835|      4|{
10836|      4|    struct keyfield const *key;
10837|      4|    char eol;
10838|      4|    size_t line_bytes;
10839|      4|    size_t mergesize;
10840|      4|    char *ptr;
10841|      4|    struct line *linelim;
10842|      4|    struct line *tmp;
10843|      4|    struct line *line;
10844|      4|    size_t avail;
10845|      4|    char *line_start;
10846|      4|    char *tmp___0;
10847|      4|    size_t readsize;
10848|      4|    size_t bytes_read;
10849|      4|    size_t tmp___1;
10850|      4|    char *ptrlim;
10851|      4|    char *p;
10852|      4|    char *tmp___2;
10853|      4|    int tmp___3;
10854|      4|    char *tmp___4;
10855|      4|    int tmp___5;
10856|      4|    char *tmp___6;
10857|      4|    unsigned char tmp___7;
10858|      4|    struct line *tmp___8;
10859|      4|    size_t line_alloc;
10860|       |
10861|      4|    {
10862|      4|        key = (struct keyfield const *)keylist;
10863|      4|        eol = eolchar;
10864|      4|        line_bytes = buf___1->line_bytes;
10865|      4|        mergesize = merge_buffer_size - (2UL + sizeof(struct line));
10866|      4|        if (buf___1->eof) {
10867|      0|            return ((_Bool)0);
10868|      0|        }
10869|      4|        if (buf___1->used != buf___1->left) {
10870|      0|            memmove((void *)buf___1->buf,
10871|      0|                    (void const *)((buf___1->buf + buf___1->used) - buf___1->left),
10872|      0|                    buf___1->left);
10873|      0|            buf___1->used = buf___1->left;
10874|      0|            buf___1->nlines = (size_t)0;
10875|      0|        }
10876|      4|        while (1) {
10877|      4|            ptr = buf___1->buf + buf___1->used;
10878|      4|            tmp = buffer_linelim((struct buffer const *)buf___1);
10879|      4|            linelim = tmp;
10880|      4|            line = linelim - buf___1->nlines;
10881|      4|            avail = (size_t)(((char *)linelim - buf___1->nlines * line_bytes) - ptr);
10882|      4|            if (buf___1->nlines) {
10883|      2|                tmp___0 = line->text + line->length;
10884|      2|            }
10885|      2|            else {
10886|      2|                tmp___0 = buf___1->buf;
10887|      2|            }
10888|      4|            line_start = tmp___0;
10889|      4|            while (1) {
10890|       |
10891|      4|                if (!(line_bytes + 1UL < avail)) {
10892|      0|                    goto while_break___0;
10893|      0|                }
10894|      4|                readsize = (avail - 1UL) / (line_bytes + 1UL);
10895|      4|                tmp___1 = fread_unlocked((void *)ptr, (size_t)1, readsize, fp);
10896|      4|                bytes_read = tmp___1;
10897|      4|                ptrlim = ptr + bytes_read;
10898|      4|                avail -= bytes_read;
10899|      4|                if (bytes_read != readsize) {
10900|      4|                    tmp___3 = ferror_unlocked(fp);
10901|      4|                    if (tmp___3) {
10902|      0|                        tmp___2 = gettext("read failed");
10903|      0|                        die((char const *)tmp___2, file);
10904|      0|                    }
10905|      4|                    tmp___5 = feof_unlocked(fp);
10906|      4|                    if (tmp___5) {
10907|      4|                        buf___1->eof = (_Bool)1;
10908|      4|                        if ((unsigned long)buf___1->buf == (unsigned long)ptrlim) {
10909|      0|                            return ((_Bool)0);
10910|      0|                        }
10911|      4|                        if ((unsigned long)line_start != (unsigned long)ptrlim) {
10912|      4|                            if ((int)*(ptrlim + -1) != (int)eol) {
10913|      0|                                tmp___4 = ptrlim;
10914|      0|                                ptrlim++;
10915|      0|                                *tmp___4 = eol;
10916|      0|                            }
10917|      4|                        }
10918|      4|                    }
10919|      4|                }
10920|  15.6k|                while (1) {
10921|  15.6k|                    p = (char *)memchr((void const *)ptr, (int)eol,
10922|  15.6k|                                       (size_t)(ptrlim - ptr));
10923|  15.6k|                    if (!p) {
10924|      4|                        goto while_break___1;
10925|      4|                    }
10926|  15.6k|                    *p = (char)'\000';
10927|  15.6k|                    ptr = p + 1;
10928|  15.6k|                    line--;
10929|  15.6k|                    line->text = line_start;
10930|  15.6k|                    line->length = (size_t)(ptr - line_start);
10931|  15.6k|                    if (mergesize > line->length) {
10932|  15.6k|                        mergesize = mergesize;
10933|  15.6k|                    }
10934|      0|                    else {
10935|      0|                        mergesize = line->length;
10936|      0|                    }
10937|  15.6k|                    avail -= line_bytes;
10938|  15.6k|                    if (key) {
10939|  15.6k|                        if (key->eword == 0xffffffffffffffffUL) {
10940|  15.6k|                            line->keylim = p;
10941|  15.6k|                        }
10942|      0|                        else {
10943|      0|                            tmp___6 = limfield((struct line const *)line, key);
10944|      0|                            line->keylim = tmp___6;
10945|      0|                        }
10946|  15.6k|                        if (key->sword != 0xffffffffffffffffUL) {
10947|      0|                            line->keybeg = begfield((struct line const *)line, key);
10948|      0|                        }
10949|  15.6k|                        else {
10950|  15.6k|                            if (key->skipsblanks) {
10951|      0|                                while (1) {
10952|      0|                                    tmp___7 = to_uchar(*line_start);
10953|      0|                                    if (!blanks[tmp___7]) {
10954|      0|                                        goto while_break___2;
10955|      0|                                    }
10956|      0|                                    line_start++;
10957|      0|                                }
10958|      0|while_break___2:
10959|      0|                                ;
10960|      0|                            }
10961|  15.6k|                            line->keybeg = line_start;
10962|  15.6k|                        }
10963|  15.6k|                    }
10964|  15.6k|                    line_start = ptr;
10965|  15.6k|                }
10966|      4|while_break___1:
10967|      4|                ptr = ptrlim;
10968|      4|                if (buf___1->eof) {
10969|      4|                    goto while_break___0;
10970|      4|                }
10971|      4|            }
10972|      4|while_break___0:
10973|      4|            buf___1->used = (size_t)(ptr - buf___1->buf);
10974|      4|            tmp___8 = buffer_linelim((struct buffer const *)buf___1);
10975|      4|            buf___1->nlines = (size_t)(tmp___8 - line);
10976|      4|            if (buf___1->nlines != 0UL) {
10977|      4|                buf___1->left = (size_t)(ptr - line_start);
10978|      4|                merge_buffer_size = mergesize + (2UL + sizeof(struct line));
10979|      4|                return ((_Bool)1);
10980|      4|            }
10981|      0|            line_alloc = buf___1->alloc / sizeof(struct line);
10982|      0|            buf___1->buf = (char *)x2nrealloc((void *)buf___1->buf, &line_alloc,
10983|      0|                                              sizeof(struct line));
10984|      0|            buf___1->alloc = line_alloc * sizeof(struct line);
10985|      0|        }
10986|       |
10987|      0|        return ((_Bool)0);
10988|      4|    }
10989|      4|}
10990|       |static char const unit_order[256] = {
10991|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
10992|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
10993|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
10994|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
10995|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
10996|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
10997|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
10998|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
10999|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11000|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11001|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11002|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11003|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11004|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)6,
11005|       |    (char const)0, (char const)3, (char const)0, (char const)0, (char const)0,
11006|       |    (char const)1, (char const)0, (char const)2, (char const)0, (char const)0,
11007|       |    (char const)5, (char const)0, (char const)0, (char const)0, (char const)4,
11008|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)8,
11009|       |    (char const)7, (char const)0, (char const)0, (char const)0, (char const)0,
11010|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11011|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11012|       |    (char const)0, (char const)0, (char const)1, (char const)0, (char const)0,
11013|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11014|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11015|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11016|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11017|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11018|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11019|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11020|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11021|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11022|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11023|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11024|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11025|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11026|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11027|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11028|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11029|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11030|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11031|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11032|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11033|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11034|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11035|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11036|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11037|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11038|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11039|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11040|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11041|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
11042|       |    (char const)0
11043|       |};
11044|       |static int __attribute__((__pure__)) find_unit_order(char const *number)
11045|      0|{
11046|      0|    _Bool minus_sign;
11047|      0|    char const *p;
11048|      0|    int nonzero;
11049|      0|    unsigned char ch;
11050|      0|    char const *tmp;
11051|      0|    char const *tmp___0;
11052|      0|    int order___0;
11053|      0|    int tmp___1;
11054|       |
11055|      0|    {
11056|      0|        minus_sign = (_Bool)((int const) * number == 45);
11057|      0|        p = number + (int)minus_sign;
11058|      0|        nonzero = 0;
11059|      0|        while (1) {
11060|       |
11061|      0|            while (1) {
11062|      0|                tmp = p;
11063|      0|                p++;
11064|      0|                ch = (unsigned char)*tmp;
11065|      0|                if (!((unsigned int)ch - 48U <= 9U)) {
11066|      0|                    goto while_break___0;
11067|      0|                }
11068|      0|                nonzero |= (int)ch - 48;
11069|      0|            }
11070|      0|while_break___0:
11071|      0|            ;
11072|      0|            if (!((int)ch == thousands_sep)) {
11073|      0|                goto while_break;
11074|      0|            }
11075|      0|        }
11076|      0|while_break:
11077|      0|        ;
11078|      0|        if ((int)ch == decimal_point) {
11079|      0|            while (1) {
11080|      0|                tmp___0 = p;
11081|      0|                p++;
11082|      0|                ch = (unsigned char)*tmp___0;
11083|      0|                if (!((unsigned int)ch - 48U <= 9U)) {
11084|      0|                    goto while_break___1;
11085|      0|                }
11086|      0|                nonzero |= (int)ch - 48;
11087|      0|            }
11088|      0|while_break___1:
11089|      0|            ;
11090|      0|        }
11091|      0|        if (nonzero) {
11092|      0|            order___0 = (int)unit_order[ch];
11093|      0|            if (minus_sign) {
11094|      0|                tmp___1 = -order___0;
11095|      0|            }
11096|      0|            else {
11097|      0|                tmp___1 = order___0;
11098|      0|            }
11099|      0|            return ((int __attribute__((__pure__)))tmp___1);
11100|      0|        }
11101|      0|        else {
11102|      0|            return ((int __attribute__((__pure__)))0);
11103|      0|        }
11104|      0|    }
11105|      0|}
11106|       |static int human_numcompare(char const *a, char const *b)
11107|      0|{
11108|      0|    unsigned char tmp;
11109|      0|    unsigned char tmp___0;
11110|      0|    int diff;
11111|      0|    int __attribute__((__pure__)) tmp___1;
11112|      0|    int __attribute__((__pure__)) tmp___2;
11113|      0|    int tmp___3;
11114|      0|    int tmp___4;
11115|       |
11116|      0|    {
11117|      0|        while (1) {
11118|      0|            tmp = to_uchar((char)*a);
11119|      0|            if (!blanks[tmp]) {
11120|      0|                goto while_break;
11121|      0|            }
11122|      0|            a++;
11123|      0|        }
11124|      0|while_break:
11125|      0|        ;
11126|      0|        while (1) {
11127|      0|            tmp___0 = to_uchar((char)*b);
11128|      0|            if (!blanks[tmp___0]) {
11129|      0|                goto while_break___0;
11130|      0|            }
11131|      0|            b++;
11132|      0|        }
11133|      0|while_break___0:
11134|      0|        tmp___1 = find_unit_order(a);
11135|      0|        tmp___2 = find_unit_order(b);
11136|      0|        diff = (int)(tmp___1 - tmp___2);
11137|      0|        if (diff) {
11138|      0|            tmp___4 = diff;
11139|      0|        }
11140|      0|        else {
11141|      0|            tmp___3 = (int)strnumcmp(a, b, decimal_point, thousands_sep);
11142|      0|            tmp___4 = tmp___3;
11143|      0|        }
11144|      0|        return (tmp___4);
11145|      0|    }
11146|      0|}
11147|       |static int numcompare___3(char const *a, char const *b)
11148|    231|{
11149|    231|    unsigned char tmp;
11150|    231|    unsigned char tmp___0;
11151|    231|    int tmp___1;
11152|       |
11153|    231|    {
11154|    231|        while (1) {
11155|    231|            tmp = to_uchar((char)*a);
11156|    231|            if (!blanks[tmp]) {
11157|    231|                goto while_break;
11158|    231|            }
11159|      0|            a++;
11160|      0|        }
11161|    231|while_break:
11162|    231|        ;
11163|    231|        while (1) {
11164|    231|            tmp___0 = to_uchar((char)*b);
11165|    231|            if (!blanks[tmp___0]) {
11166|    231|                goto while_break___0;
11167|    231|            }
11168|      0|            b++;
11169|      0|        }
11170|    231|while_break___0:
11171|    231|        tmp___1 = (int)strnumcmp(a, b, decimal_point, thousands_sep);
11172|    231|        return (tmp___1);
11173|    231|    }
11174|    231|}
11175|       |static int nan_compare(char const *sa, char const *sb)
11176|      0|{
11177|      0|    long double a;
11178|      0|    long double b;
11179|      0|    int tmp;
11180|       |
11181|      0|    {
11182|      0|        memset((void *)(&a), 0, sizeof(a));
11183|      0|        a = strtold(sa, (char **)((void *)0));
11184|      0|        memset((void *)(&b), 0, sizeof(b));
11185|      0|        b = strtold(sb, (char **)((void *)0));
11186|      0|        tmp = memcmp((void const *)(&a), (void const *)(&b), sizeof(a));
11187|      0|        return (tmp);
11188|      0|    }
11189|      0|}
11190|       |static int general_numcompare(char const *sa, char const *sb)
11191|      0|{
11192|      0|    char *ea;
11193|      0|    char *eb;
11194|      0|    long double a;
11195|      0|    long double tmp;
11196|      0|    long double b;
11197|      0|    long double tmp___0;
11198|      0|    int tmp___1;
11199|      0|    int tmp___2;
11200|      0|    int tmp___3;
11201|      0|    int tmp___4;
11202|      0|    int tmp___5;
11203|      0|    int tmp___6;
11204|      0|    int tmp___7;
11205|       |
11206|      0|    {
11207|      0|        tmp = strtold(sa, &ea);
11208|      0|        a = tmp;
11209|      0|        tmp___0 = strtold(sb, &eb);
11210|      0|        b = tmp___0;
11211|      0|        if ((unsigned long)sa == (unsigned long)ea) {
11212|      0|            if ((unsigned long)sb == (unsigned long)eb) {
11213|      0|                tmp___1 = 0;
11214|      0|            }
11215|      0|            else {
11216|      0|                tmp___1 = -1;
11217|      0|            }
11218|      0|            return (tmp___1);
11219|      0|        }
11220|      0|        if ((unsigned long)sb == (unsigned long)eb) {
11221|      0|            return (1);
11222|      0|        }
11223|      0|        if (a < b) {
11224|      0|            tmp___7 = -1;
11225|      0|        }
11226|      0|        else {
11227|      0|            if (a > b) {
11228|      0|                tmp___6 = 1;
11229|      0|            }
11230|      0|            else {
11231|      0|                if (a == b) {
11232|      0|                    tmp___5 = 0;
11233|      0|                }
11234|      0|                else {
11235|      0|                    if (b == b) {
11236|      0|                        tmp___4 = -1;
11237|      0|                    }
11238|      0|                    else {
11239|      0|                        if (a == a) {
11240|      0|                            tmp___3 = 1;
11241|      0|                        }
11242|      0|                        else {
11243|      0|                            tmp___2 = nan_compare(sa, sb);
11244|      0|                            tmp___3 = tmp___2;
11245|      0|                        }
11246|      0|                        tmp___4 = tmp___3;
11247|      0|                    }
11248|      0|                    tmp___5 = tmp___4;
11249|      0|                }
11250|      0|                tmp___6 = tmp___5;
11251|      0|            }
11252|      0|            tmp___7 = tmp___6;
11253|      0|        }
11254|      0|        return (tmp___7);
11255|      0|    }
11256|      0|}
11257|       |static int getmonth(char const *month, char **ea)
11258|      0|{
11259|      0|    size_t lo;
11260|      0|    size_t hi;
11261|      0|    unsigned char tmp;
11262|      0|    size_t ix;
11263|      0|    char const *m;
11264|      0|    char const *n;
11265|      0|    unsigned char tmp___0;
11266|      0|    unsigned char tmp___1;
11267|      0|    unsigned char tmp___2;
11268|      0|    unsigned char tmp___3;
11269|      0|    unsigned char tmp___4;
11270|      0|    unsigned char tmp___5;
11271|       |
11272|      0|    {
11273|      0|        lo = (size_t)0;
11274|      0|        hi = (size_t)12;
11275|      0|        while (1) {
11276|      0|            tmp = to_uchar((char)*month);
11277|      0|            if (!blanks[tmp]) {
11278|      0|                goto while_break;
11279|      0|            }
11280|      0|            month++;
11281|      0|        }
11282|      0|while_break:
11283|      0|        ;
11284|      0|        while (1) {
11285|      0|            ix = (lo + hi) / 2UL;
11286|      0|            m = month;
11287|      0|            n = monthtab[ix].name;
11288|      0|            while (1) {
11289|       |
11290|      0|                if (!*n) {
11291|      0|                    if (ea) {
11292|      0|                        *ea = (char *)m;
11293|      0|                    }
11294|      0|                    return (monthtab[ix].val);
11295|      0|                }
11296|      0|                tmp___3 = to_uchar((char)*m);
11297|      0|                tmp___4 = to_uchar(fold_toupper[tmp___3]);
11298|      0|                tmp___5 = to_uchar((char)*n);
11299|      0|                if ((int)tmp___4 < (int)tmp___5) {
11300|      0|                    hi = ix;
11301|      0|                    goto while_break___1;
11302|      0|                }
11303|      0|                else {
11304|      0|                    tmp___0 = to_uchar((char)*m);
11305|      0|                    tmp___1 = to_uchar(fold_toupper[tmp___0]);
11306|      0|                    tmp___2 = to_uchar((char)*n);
11307|      0|                    if ((int)tmp___1 > (int)tmp___2) {
11308|      0|                        lo = ix + 1UL;
11309|      0|                        goto while_break___1;
11310|      0|                    }
11311|      0|                }
11312|      0|                m++;
11313|      0|                n++;
11314|      0|            }
11315|      0|while_break___1:
11316|      0|            ;
11317|      0|            if (!(lo < hi)) {
11318|      0|                goto while_break___0;
11319|      0|            }
11320|      0|        }
11321|      0|while_break___0:
11322|      0|        ;
11323|      0|        return (0);
11324|      0|    }
11325|      0|}
11326|       |static struct md5_ctx random_md5_state;
11327|       |static void random_md5_state_init(char const *random_source)
11328|      0|{
11329|      0|    unsigned char buf___1[16];
11330|      0|    struct randread_source *r;
11331|      0|    struct randread_source *tmp;
11332|      0|    char *tmp___0;
11333|      0|    char *tmp___1;
11334|      0|    int tmp___2;
11335|       |
11336|      0|    {
11337|      0|        tmp = randread_new(random_source, sizeof(buf___1));
11338|      0|        r = tmp;
11339|      0|        if (!r) {
11340|      0|            tmp___0 = gettext("open failed");
11341|      0|            die((char const *)tmp___0, random_source);
11342|      0|        }
11343|      0|        randread(r, (void *)(buf___1), sizeof(buf___1));
11344|      0|        tmp___2 = randread_free(r);
11345|      0|        if (tmp___2 != 0) {
11346|      0|            tmp___1 = gettext("close failed");
11347|      0|            die((char const *)tmp___1, random_source);
11348|      0|        }
11349|      0|        md5_init_ctx(&random_md5_state);
11350|      0|        md5_process_bytes((void const *)(buf___1), sizeof(buf___1),
11351|      0|                          &random_md5_state);
11352|      0|        return;
11353|      0|    }
11354|      0|}
11355|       |static size_t xstrxfrm(char *__restrict dest, char const *__restrict src,
11356|       |                       size_t destsize)
11357|      0|{
11358|      0|    int *tmp;
11359|      0|    size_t translated_size;
11360|      0|    size_t tmp___0;
11361|      0|    char *tmp___1;
11362|      0|    int *tmp___2;
11363|      0|    char *tmp___3;
11364|      0|    char *tmp___4;
11365|      0|    char *tmp___5;
11366|      0|    int *tmp___6;
11367|       |
11368|      0|    {
11369|      0|        tmp = __errno_location();
11370|      0|        *tmp = 0;
11371|      0|        tmp___0 = strxfrm(dest, src, destsize);
11372|      0|        translated_size = tmp___0;
11373|      0|        tmp___6 = __errno_location();
11374|      0|        if (*tmp___6) {
11375|      0|            tmp___1 = gettext("string transformation failed");
11376|      0|            tmp___2 = __errno_location();
11377|      0|            error(0, *tmp___2, (char const *)tmp___1);
11378|      0|            tmp___3 = gettext("set LC_ALL=\'C\' to work around the problem");
11379|      0|            error(0, 0, (char const *)tmp___3);
11380|      0|            tmp___4 = quotearg_n_style(0, (enum quoting_style)6, (char const *)src);
11381|      0|            tmp___5 = gettext("the untransformed string was %s");
11382|      0|            error(2, 0, (char const *)tmp___5, tmp___4);
11383|      0|        }
11384|      0|        return (translated_size);
11385|      0|    }
11386|      0|}
11387|       |static int compare_random(char *__restrict texta, size_t lena,
11388|       |                          char *__restrict textb, size_t lenb)
11389|      0|{
11390|      0|    int xfrm_diff;
11391|      0|    char stackbuf[4000];
11392|      0|    char *buf___1;
11393|      0|    size_t bufsize___1;
11394|      0|    void *allocated;
11395|      0|    uint32_t dig[2][16UL / sizeof(uint32_t)];
11396|      0|    struct md5_ctx s[2];
11397|      0|    char const *lima;
11398|      0|    char const *limb;
11399|      0|    size_t guess_bufsize;
11400|      0|    size_t sizea;
11401|      0|    size_t tmp;
11402|      0|    size_t tmp___0;
11403|      0|    _Bool a_fits;
11404|      0|    size_t sizeb;
11405|      0|    size_t tmp___1;
11406|      0|    char *tmp___2;
11407|      0|    size_t tmp___3;
11408|      0|    size_t tmp___4;
11409|      0|    size_t tmp___5;
11410|      0|    size_t tmp___6;
11411|      0|    size_t tmp___7;
11412|      0|    int diff;
11413|      0|    int tmp___8;
11414|      0|    size_t tmp___9;
11415|       |
11416|      0|    {
11417|      0|        xfrm_diff = 0;
11418|      0|        buf___1 = stackbuf;
11419|      0|        bufsize___1 = sizeof(stackbuf);
11420|      0|        allocated = (void *)0;
11421|      0|        s[1] = random_md5_state;
11422|      0|        s[0] = s[1];
11423|      0|        if (hard_LC_COLLATE) {
11424|      0|            lima = (char const *)(texta + lena);
11425|      0|            limb = (char const *)(textb + lenb);
11426|      0|            while (1) {
11427|      0|                guess_bufsize = 3UL * (lena + lenb) + 2UL;
11428|      0|                if (bufsize___1 < guess_bufsize) {
11429|      0|                    if (guess_bufsize > (bufsize___1 * 3UL) / 2UL) {
11430|      0|                        bufsize___1 = guess_bufsize;
11431|      0|                    }
11432|      0|                    else {
11433|      0|                        bufsize___1 = (bufsize___1 * 3UL) / 2UL;
11434|      0|                    }
11435|      0|                    free(allocated);
11436|      0|                    allocated = malloc(bufsize___1);
11437|      0|                    buf___1 = (char *)allocated;
11438|      0|                    if (!buf___1) {
11439|      0|                        buf___1 = stackbuf;
11440|      0|                        bufsize___1 = sizeof(stackbuf);
11441|      0|                    }
11442|      0|                }
11443|      0|                if ((unsigned long)texta < (unsigned long)lima) {
11444|      0|                    tmp = xstrxfrm(buf___1, (char const *)texta, bufsize___1);
11445|      0|                    tmp___0 = tmp + 1UL;
11446|      0|                }
11447|      0|                else {
11448|      0|                    tmp___0 = (size_t)0;
11449|      0|                }
11450|      0|                sizea = tmp___0;
11451|      0|                a_fits = (_Bool)(sizea <= bufsize___1);
11452|      0|                if ((unsigned long)textb < (unsigned long)limb) {
11453|      0|                    if (a_fits) {
11454|      0|                        tmp___1 = bufsize___1 - sizea;
11455|      0|                    }
11456|      0|                    else {
11457|      0|                        tmp___1 = (size_t)0;
11458|      0|                    }
11459|      0|                    if (a_fits) {
11460|      0|                        tmp___2 = buf___1 + sizea;
11461|      0|                    }
11462|      0|                    else {
11463|      0|                        tmp___2 = (char *)((void *)0);
11464|      0|                    }
11465|      0|                    tmp___3 = xstrxfrm(tmp___2, (char const *)textb, tmp___1);
11466|      0|                    tmp___4 = tmp___3 + 1UL;
11467|      0|                }
11468|      0|                else {
11469|      0|                    tmp___4 = (size_t)0;
11470|      0|                }
11471|      0|                sizeb = tmp___4;
11472|      0|                if (a_fits) {
11473|      0|                    if (!(sizea + sizeb <= bufsize___1)) {
11474|      0|                        goto _L;
11475|      0|                    }
11476|      0|                }
11477|      0|                else {
11478|      0|_L:
11479|      0|                    bufsize___1 = sizea + sizeb;
11480|      0|                    if (bufsize___1 < 6148914691236517205UL) {
11481|      0|                        bufsize___1 = (bufsize___1 * 3UL) / 2UL;
11482|      0|                    }
11483|      0|                    free(allocated);
11484|      0|                    allocated = xmalloc(bufsize___1);
11485|      0|                    buf___1 = (char *)allocated;
11486|      0|                    if ((unsigned long)texta < (unsigned long)lima) {
11487|      0|                        strxfrm(buf___1, (char const *)texta, sizea);
11488|      0|                    }
11489|      0|                    if ((unsigned long)textb < (unsigned long)limb) {
11490|      0|                        strxfrm(buf___1 + sizea, (char const *)textb, sizeb);
11491|      0|                    }
11492|      0|                }
11493|      0|                if ((unsigned long)texta < (unsigned long)lima) {
11494|      0|                    tmp___5 = strlen((char const *)texta);
11495|      0|                    texta += tmp___5 + 1UL;
11496|      0|                }
11497|      0|                if ((unsigned long)textb < (unsigned long)limb) {
11498|      0|                    tmp___6 = strlen((char const *)textb);
11499|      0|                    textb += tmp___6 + 1UL;
11500|      0|                }
11501|      0|                if (!((unsigned long)texta < (unsigned long)lima)) {
11502|      0|                    if (!((unsigned long)textb < (unsigned long)limb)) {
11503|      0|                        lena = sizea;
11504|      0|                        texta = buf___1;
11505|      0|                        lenb = sizeb;
11506|      0|                        textb = buf___1 + sizea;
11507|      0|                        goto while_break;
11508|      0|                    }
11509|      0|                }
11510|      0|                md5_process_bytes((void const *)buf___1, sizea, &s[0]);
11511|      0|                md5_process_bytes((void const *)(buf___1 + sizea), sizeb, &s[1]);
11512|      0|                if (!xfrm_diff) {
11513|      0|                    if (sizea < sizeb) {
11514|      0|                        tmp___7 = sizea;
11515|      0|                    }
11516|      0|                    else {
11517|      0|                        tmp___7 = sizeb;
11518|      0|                    }
11519|      0|                    xfrm_diff = memcmp((void const *)buf___1,
11520|      0|                                       (void const *)(buf___1 + sizea), tmp___7);
11521|      0|                    if (!xfrm_diff) {
11522|      0|                        xfrm_diff = (sizea > sizeb) - (sizea < sizeb);
11523|      0|                    }
11524|      0|                }
11525|      0|            }
11526|      0|while_break:
11527|      0|            ;
11528|      0|        }
11529|      0|        md5_process_bytes((void const *)texta, lena, &s[0]);
11530|      0|        md5_finish_ctx(&s[0], (void *)(dig[0]));
11531|      0|        md5_process_bytes((void const *)textb, lenb, &s[1]);
11532|      0|        md5_finish_ctx(&s[1], (void *)(dig[1]));
11533|      0|        tmp___8 =
11534|      0|            memcmp((void const *)(dig[0]), (void const *)(dig[1]), sizeof(dig[0]));
11535|      0|        diff = tmp___8;
11536|      0|        if (!diff) {
11537|      0|            if (!xfrm_diff) {
11538|      0|                if (lena < lenb) {
11539|      0|                    tmp___9 = lena;
11540|      0|                }
11541|      0|                else {
11542|      0|                    tmp___9 = lenb;
11543|      0|                }
11544|      0|                xfrm_diff = memcmp((void const *)texta, (void const *)textb, tmp___9);
11545|      0|                if (!xfrm_diff) {
11546|      0|                    xfrm_diff = (lena > lenb) - (lena < lenb);
11547|      0|                }
11548|      0|            }
11549|      0|            diff = xfrm_diff;
11550|      0|        }
11551|      0|        free(allocated);
11552|      0|        return (diff);
11553|      0|    }
11554|      0|}
11555|       |static size_t debug_width(char const *text, char const *lim)
11556|      0|{
11557|      0|    size_t width;
11558|      0|    size_t tmp;
11559|      0|    char const *tmp___0;
11560|       |
11561|      0|    {
11562|      0|        tmp = (size_t)mbsnwidth(text, (size_t)(lim - text), 0);
11563|      0|        width = tmp;
11564|      0|        while (1) {
11565|       |
11566|      0|            if (!((unsigned long)text < (unsigned long)lim)) {
11567|      0|                goto while_break;
11568|      0|            }
11569|      0|            tmp___0 = text;
11570|      0|            text++;
11571|      0|            width += (size_t)((int const) * tmp___0 == 9);
11572|      0|        }
11573|      0|while_break:
11574|      0|        ;
11575|      0|        return (width);
11576|      0|    }
11577|      0|}
11578|       |static void mark_key(size_t offset, size_t width)
11579|      0|{
11580|      0|    size_t tmp;
11581|      0|    char *tmp___0;
11582|       |
11583|      0|    {
11584|      0|        while (1) {
11585|      0|            tmp = offset;
11586|      0|            offset--;
11587|      0|            if (!tmp) {
11588|      0|                goto while_break;
11589|      0|            }
11590|      0|            putchar_unlocked(' ');
11591|      0|        }
11592|      0|while_break:
11593|      0|        ;
11594|      0|        if (!width) {
11595|      0|            tmp___0 = gettext("^ no match for key\n");
11596|      0|            printf((char const *)tmp___0);
11597|      0|        }
11598|      0|        else {
11599|      0|            while (1) {
11600|      0|                putchar_unlocked('_');
11601|      0|                width--;
11602|      0|                if (!width) {
11603|      0|                    goto while_break___0;
11604|      0|                }
11605|      0|            }
11606|      0|while_break___0:
11607|      0|            putchar_unlocked('\n');
11608|      0|        }
11609|      0|        return;
11610|      0|    }
11611|      0|}
11612|       |__inline static _Bool key_numeric(struct keyfield const *key)
11613|      0|{
11614|      0|    int tmp;
11615|       |
11616|      0|    {
11617|      0|        if (key->numeric) {
11618|      0|            tmp = 1;
11619|      0|        }
11620|      0|        else {
11621|      0|            if (key->general_numeric) {
11622|      0|                tmp = 1;
11623|      0|            }
11624|      0|            else {
11625|      0|                if (key->human_numeric) {
11626|      0|                    tmp = 1;
11627|      0|                }
11628|      0|                else {
11629|      0|                    tmp = 0;
11630|      0|                }
11631|      0|            }
11632|      0|        }
11633|      0|        return ((_Bool)tmp);
11634|      0|    }
11635|      0|}
11636|       |static void debug_key(struct line const *line, struct keyfield const *key)
11637|      0|{
11638|      0|    char *text;
11639|      0|    char *beg;
11640|      0|    char *lim;
11641|      0|    char saved___0;
11642|      0|    unsigned char tmp;
11643|      0|    char *tighter_lim;
11644|      0|    long double __x;
11645|      0|    long double tmp___0;
11646|      0|    char *p;
11647|      0|    int tmp___1;
11648|      0|    _Bool found_digit;
11649|      0|    unsigned char ch;
11650|      0|    char *tmp___2;
11651|      0|    char *tmp___3;
11652|      0|    int tmp___4;
11653|      0|    _Bool tmp___5;
11654|      0|    size_t offset;
11655|      0|    size_t tmp___6;
11656|      0|    size_t width;
11657|      0|    size_t tmp___7;
11658|       |
11659|      0|    {
11660|      0|        text = (char *)line->text;
11661|      0|        beg = text;
11662|      0|        lim = (text + line->length) - 1;
11663|      0|        if (key) {
11664|      0|            if (key->sword != 0xffffffffffffffffUL) {
11665|      0|                beg = begfield(line, key);
11666|      0|            }
11667|      0|            if (key->eword != 0xffffffffffffffffUL) {
11668|      0|                lim = limfield(line, key);
11669|      0|            }
11670|      0|            if (key->skipsblanks) {
11671|      0|                goto _L___0;
11672|      0|            }
11673|      0|            else {
11674|      0|                if (key->month) {
11675|      0|                    goto _L___0;
11676|      0|                }
11677|      0|                else {
11678|      0|                    tmp___5 = key_numeric(key);
11679|      0|                    if (tmp___5) {
11680|      0|_L___0:
11681|      0|                        saved___0 = *lim;
11682|      0|                        *lim = (char)'\000';
11683|      0|                        while (1) {
11684|      0|                            tmp = to_uchar(*beg);
11685|      0|                            if (!blanks[tmp]) {
11686|      0|                                goto while_break;
11687|      0|                            }
11688|      0|                            beg++;
11689|      0|                        }
11690|      0|while_break:
11691|      0|                        tighter_lim = beg;
11692|      0|                        if ((unsigned long)lim < (unsigned long)beg) {
11693|      0|                            tighter_lim = lim;
11694|      0|                        }
11695|      0|                        else {
11696|      0|                            if (key->month) {
11697|      0|                                getmonth((char const *)beg, &tighter_lim);
11698|      0|                            }
11699|      0|                            else {
11700|      0|                                if (key->general_numeric) {
11701|      0|                                    tmp___0 = strtold((char const *)beg, &tighter_lim);
11702|      0|                                    __x = tmp___0;
11703|      0|                                }
11704|      0|                                else {
11705|      0|                                    if (key->numeric) {
11706|      0|                                        goto _L;
11707|      0|                                    }
11708|      0|                                    else {
11709|      0|                                        if (key->human_numeric) {
11710|      0|_L:
11711|      0|                                            if ((unsigned long)beg < (unsigned long)lim) {
11712|      0|                                                if ((int)*beg == 45) {
11713|      0|                                                    tmp___1 = 1;
11714|      0|                                                }
11715|      0|                                                else {
11716|      0|                                                    tmp___1 = 0;
11717|      0|                                                }
11718|      0|                                            }
11719|      0|                                            else {
11720|      0|                                                tmp___1 = 0;
11721|      0|                                            }
11722|      0|                                            p = beg + tmp___1;
11723|      0|                                            found_digit = (_Bool)0;
11724|      0|                                            while (1) {
11725|       |
11726|      0|                                                while (1) {
11727|      0|                                                    tmp___2 = p;
11728|      0|                                                    p++;
11729|      0|                                                    ch = (unsigned char)*tmp___2;
11730|      0|                                                    if (!((unsigned int)ch - 48U <= 9U)) {
11731|      0|                                                        goto while_break___1;
11732|      0|                                                    }
11733|      0|                                                    found_digit = (_Bool)1;
11734|      0|                                                }
11735|      0|while_break___1:
11736|      0|                                                ;
11737|      0|                                                if (!((int)ch == thousands_sep)) {
11738|      0|                                                    goto while_break___0;
11739|      0|                                                }
11740|      0|                                            }
11741|      0|while_break___0:
11742|      0|                                            ;
11743|      0|                                            if ((int)ch == decimal_point) {
11744|      0|                                                while (1) {
11745|      0|                                                    tmp___3 = p;
11746|      0|                                                    p++;
11747|      0|                                                    ch = (unsigned char)*tmp___3;
11748|      0|                                                    if (!((unsigned int)ch - 48U <= 9U)) {
11749|      0|                                                        goto while_break___2;
11750|      0|                                                    }
11751|      0|                                                    found_digit = (_Bool)1;
11752|      0|                                                }
11753|      0|while_break___2:
11754|      0|                                                ;
11755|      0|                                            }
11756|      0|                                            if (found_digit) {
11757|      0|                                                if (key->human_numeric) {
11758|      0|                                                    if (unit_order[ch]) {
11759|      0|                                                        tmp___4 = 0;
11760|      0|                                                    }
11761|      0|                                                    else {
11762|      0|                                                        tmp___4 = 1;
11763|      0|                                                    }
11764|      0|                                                }
11765|      0|                                                else {
11766|      0|                                                    tmp___4 = 1;
11767|      0|                                                }
11768|      0|                                                tighter_lim = p - tmp___4;
11769|      0|                                            }
11770|      0|                                        }
11771|      0|                                        else {
11772|      0|                                            tighter_lim = lim;
11773|      0|                                        }
11774|      0|                                    }
11775|      0|                                }
11776|      0|                            }
11777|      0|                        }
11778|      0|                        *lim = saved___0;
11779|      0|                        lim = tighter_lim;
11780|      0|                    }
11781|      0|                }
11782|      0|            }
11783|      0|        }
11784|      0|        tmp___6 = debug_width((char const *)text, (char const *)beg);
11785|      0|        offset = tmp___6;
11786|      0|        tmp___7 = debug_width((char const *)beg, (char const *)lim);
11787|      0|        width = tmp___7;
11788|      0|        mark_key(offset, width);
11789|      0|        return;
11790|      0|    }
11791|      0|}
11792|       |static void debug_line(struct line const *line)
11793|      0|{
11794|      0|    struct keyfield const *key;
11795|       |
11796|      0|    {
11797|      0|        key = (struct keyfield const *)keylist;
11798|      0|        while (1) {
11799|      0|            debug_key(line, key);
11800|      0|            if (key) {
11801|      0|                key = (struct keyfield const *)key->next;
11802|      0|                if (!key) {
11803|      0|                    if (unique) {
11804|      0|                        goto while_break;
11805|      0|                    }
11806|      0|                    else {
11807|      0|                        if (stable) {
11808|      0|                            goto while_break;
11809|      0|                        }
11810|      0|                    }
11811|      0|                }
11812|      0|            }
11813|      0|            else {
11814|      0|                goto while_break;
11815|      0|            }
11816|      0|        }
11817|      0|while_break:
11818|      0|        ;
11819|      0|        return;
11820|      0|    }
11821|      0|}
11822|       |static _Bool default_key_compare(struct keyfield const *key)
11823|      2|{
11824|      2|    _Bool tmp;
11825|      2|    int tmp___0;
11826|       |
11827|      2|    {
11828|      2|        if (key->ignore) {
11829|      0|            tmp___0 = 0;
11830|      0|        }
11831|      2|        else {
11832|      2|            if (key->translate) {
11833|      2|                tmp___0 = 0;
11834|      2|            }
11835|      0|            else {
11836|      0|                if (key->skipsblanks) {
11837|      0|                    tmp___0 = 0;
11838|      0|                }
11839|      0|                else {
11840|      0|                    if (key->skipeblanks) {
11841|      0|                        tmp___0 = 0;
11842|      0|                    }
11843|      0|                    else {
11844|      0|                        tmp = key_numeric(key);
11845|      0|                        if (tmp) {
11846|      0|                            tmp___0 = 0;
11847|      0|                        }
11848|      0|                        else {
11849|      0|                            if (key->month) {
11850|      0|                                tmp___0 = 0;
11851|      0|                            }
11852|      0|                            else {
11853|      0|                                if (key->version) {
11854|      0|                                    tmp___0 = 0;
11855|      0|                                }
11856|      0|                                else {
11857|      0|                                    if (key->random) {
11858|      0|                                        tmp___0 = 0;
11859|      0|                                    }
11860|      0|                                    else {
11861|      0|                                        tmp___0 = 1;
11862|      0|                                    }
11863|      0|                                }
11864|      0|                            }
11865|      0|                        }
11866|      0|                    }
11867|      0|                }
11868|      0|            }
11869|      2|        }
11870|      2|        return ((_Bool)tmp___0);
11871|      2|    }
11872|      2|}
11873|       |static void key_to_opts(struct keyfield const *key, char *opts___1)
11874|      0|{
11875|      0|    char *tmp;
11876|      0|    char *tmp___0;
11877|      0|    char *tmp___1;
11878|      0|    char *tmp___2;
11879|      0|    char *tmp___3;
11880|      0|    char *tmp___4;
11881|      0|    char *tmp___5;
11882|      0|    char *tmp___6;
11883|      0|    char *tmp___7;
11884|      0|    char *tmp___8;
11885|      0|    char *tmp___9;
11886|       |
11887|      0|    {
11888|      0|        if (key->skipsblanks) {
11889|      0|            tmp = opts___1;
11890|      0|            opts___1++;
11891|      0|            *tmp = (char)'b';
11892|      0|        }
11893|      0|        else {
11894|      0|            if (key->skipeblanks) {
11895|      0|                tmp = opts___1;
11896|      0|                opts___1++;
11897|      0|                *tmp = (char)'b';
11898|      0|            }
11899|      0|        }
11900|      0|        if ((unsigned long)key->ignore == (unsigned long)(nondictionary)) {
11901|      0|            tmp___0 = opts___1;
11902|      0|            opts___1++;
11903|      0|            *tmp___0 = (char)'d';
11904|      0|        }
11905|      0|        if (key->translate) {
11906|      0|            tmp___1 = opts___1;
11907|      0|            opts___1++;
11908|      0|            *tmp___1 = (char)'f';
11909|      0|        }
11910|      0|        if (key->general_numeric) {
11911|      0|            tmp___2 = opts___1;
11912|      0|            opts___1++;
11913|      0|            *tmp___2 = (char)'g';
11914|      0|        }
11915|      0|        if (key->human_numeric) {
11916|      0|            tmp___3 = opts___1;
11917|      0|            opts___1++;
11918|      0|            *tmp___3 = (char)'h';
11919|      0|        }
11920|      0|        if ((unsigned long)key->ignore == (unsigned long)(nonprinting)) {
11921|      0|            tmp___4 = opts___1;
11922|      0|            opts___1++;
11923|      0|            *tmp___4 = (char)'i';
11924|      0|        }
11925|      0|        if (key->month) {
11926|      0|            tmp___5 = opts___1;
11927|      0|            opts___1++;
11928|      0|            *tmp___5 = (char)'M';
11929|      0|        }
11930|      0|        if (key->numeric) {
11931|      0|            tmp___6 = opts___1;
11932|      0|            opts___1++;
11933|      0|            *tmp___6 = (char)'n';
11934|      0|        }
11935|      0|        if (key->random) {
11936|      0|            tmp___7 = opts___1;
11937|      0|            opts___1++;
11938|      0|            *tmp___7 = (char)'R';
11939|      0|        }
11940|      0|        if (key->reverse) {
11941|      0|            tmp___8 = opts___1;
11942|      0|            opts___1++;
11943|      0|            *tmp___8 = (char)'r';
11944|      0|        }
11945|      0|        if (key->version) {
11946|      0|            tmp___9 = opts___1;
11947|      0|            opts___1++;
11948|      0|            *tmp___9 = (char)'V';
11949|      0|        }
11950|      0|        *opts___1 = (char)'\000';
11951|      0|        return;
11952|      0|    }
11953|      0|}
11954|       |static void key_warnings(struct keyfield const *gkey, _Bool gkey_only)
11955|      0|{
11956|      0|    struct keyfield const *key;
11957|      0|    struct keyfield ugkey;
11958|      0|    unsigned long keynum;
11959|      0|    size_t sword;
11960|      0|    size_t eword;
11961|      0|    char tmp[((sizeof(uintmax_t) * 8UL) * 146UL + 484UL) / 485UL + 1UL];
11962|      0|    char
11963|      0|    obuf[(((sizeof(sword) * 8UL) * 146UL + 484UL) / 485UL + 1UL) * 2UL + 4UL];
11964|      0|    char
11965|      0|    nbuf[(((sizeof(sword) * 8UL) * 146UL + 484UL) / 485UL + 1UL) * 2UL + 5UL];
11966|      0|    char *po;
11967|      0|    char *pn;
11968|      0|    char *tmp___0;
11969|      0|    char *tmp___1;
11970|      0|    char *tmp___2;
11971|      0|    char *tmp___3;
11972|      0|    char *tmp___4;
11973|      0|    char *tmp___5;
11974|      0|    char *tmp___6;
11975|      0|    char *tmp___7;
11976|      0|    char const *tmp___8;
11977|      0|    char const *tmp___9;
11978|      0|    char *tmp___10;
11979|      0|    char *tmp___11;
11980|      0|    _Bool implicit_skip;
11981|      0|    _Bool tmp___12;
11982|      0|    int tmp___13;
11983|      0|    _Bool maybe_space_aligned;
11984|      0|    _Bool tmp___14;
11985|      0|    int tmp___15;
11986|      0|    _Bool line_offset;
11987|      0|    int tmp___16;
11988|      0|    char *tmp___17;
11989|      0|    size_t sword___0;
11990|      0|    size_t eword___0;
11991|      0|    char *tmp___18;
11992|      0|    _Bool tmp___19;
11993|      0|    _Bool ugkey_reverse;
11994|      0|    char opts___1[sizeof(short_options)];
11995|      0|    size_t tmp___20;
11996|      0|    unsigned long tmp___21;
11997|      0|    char *tmp___22;
11998|      0|    _Bool tmp___23;
11999|      0|    char *tmp___24;
12000|       |
12001|      0|    {
12002|      0|        ugkey = (struct keyfield) * gkey;
12003|      0|        keynum = 1UL;
12004|      0|        key = (struct keyfield const *)keylist;
12005|      0|        while (1) {
12006|       |
12007|      0|            if (!key) {
12008|      0|                goto while_break;
12009|      0|            }
12010|      0|            if (key->obsolete_used) {
12011|      0|                sword = (size_t)key->sword;
12012|      0|                eword = (size_t)key->eword;
12013|      0|                po = obuf;
12014|      0|                pn = nbuf;
12015|      0|                if (sword == 0xffffffffffffffffUL) {
12016|      0|                    sword++;
12017|      0|                }
12018|      0|                tmp___0 = umaxtostr(sword, tmp);
12019|      0|                tmp___1 = stpcpy(po, "+");
12020|      0|                po = stpcpy(tmp___1, (char const *)tmp___0);
12021|      0|                tmp___2 = umaxtostr(sword + 1UL, tmp);
12022|      0|                tmp___3 = stpcpy(pn, "-k ");
12023|      0|                pn = stpcpy(tmp___3, (char const *)tmp___2);
12024|      0|                if (key->eword != 0xffffffffffffffffUL) {
12025|      0|                    tmp___4 = umaxtostr(eword + 1UL, tmp);
12026|      0|                    tmp___5 = stpcpy(po, " -");
12027|      0|                    stpcpy(tmp___5, (char const *)tmp___4);
12028|      0|                    tmp___6 = umaxtostr((eword + 1UL) +
12029|      0|                                        (size_t)(key->echar == 0xffffffffffffffffUL),
12030|      0|                                        tmp);
12031|      0|                    tmp___7 = stpcpy(pn, ",");
12032|      0|                    stpcpy(tmp___7, (char const *)tmp___6);
12033|      0|                }
12034|      0|                tmp___8 = quote_n(1, (char const *)(nbuf));
12035|      0|                tmp___9 = quote_n(0, (char const *)(obuf));
12036|      0|                tmp___10 = gettext("obsolescent key %s used; consider %s instead");
12037|      0|                error(0, 0, (char const *)tmp___10, tmp___9, tmp___8);
12038|      0|            }
12039|      0|            if (key->sword != 0xffffffffffffffffUL) {
12040|      0|                if (key->eword < key->sword) {
12041|      0|                    tmp___11 = gettext("key %lu has zero width and will be ignored");
12042|      0|                    error(0, 0, (char const *)tmp___11, keynum);
12043|      0|                }
12044|      0|            }
12045|      0|            tmp___12 = key_numeric(key);
12046|      0|            if (tmp___12) {
12047|      0|                tmp___13 = 1;
12048|      0|            }
12049|      0|            else {
12050|      0|                if (key->month) {
12051|      0|                    tmp___13 = 1;
12052|      0|                }
12053|      0|                else {
12054|      0|                    tmp___13 = 0;
12055|      0|                }
12056|      0|            }
12057|      0|            implicit_skip = (_Bool)tmp___13;
12058|      0|            if (!hard_LC_COLLATE) {
12059|      0|                tmp___14 = default_key_compare(key);
12060|      0|                if (tmp___14) {
12061|      0|                    if (key->schar) {
12062|      0|                        tmp___15 = 0;
12063|      0|                    }
12064|      0|                    else {
12065|      0|                        if (key->echar) {
12066|      0|                            tmp___15 = 0;
12067|      0|                        }
12068|      0|                        else {
12069|      0|                            tmp___15 = 1;
12070|      0|                        }
12071|      0|                    }
12072|      0|                }
12073|      0|                else {
12074|      0|                    tmp___15 = 0;
12075|      0|                }
12076|      0|            }
12077|      0|            else {
12078|      0|                tmp___15 = 0;
12079|      0|            }
12080|      0|            maybe_space_aligned = (_Bool)tmp___15;
12081|      0|            if (key->eword == 0UL) {
12082|      0|                if (key->echar != 0UL) {
12083|      0|                    tmp___16 = 1;
12084|      0|                }
12085|      0|                else {
12086|      0|                    tmp___16 = 0;
12087|      0|                }
12088|      0|            }
12089|      0|            else {
12090|      0|                tmp___16 = 0;
12091|      0|            }
12092|      0|            line_offset = (_Bool)tmp___16;
12093|      0|            if (!gkey_only) {
12094|      0|                if (tab == 128) {
12095|      0|                    if (!line_offset) {
12096|      0|                        if (!key->skipsblanks) {
12097|      0|                            if (implicit_skip) {
12098|      0|                                goto _L___0;
12099|      0|                            }
12100|      0|                            else {
12101|      0|                                if (maybe_space_aligned) {
12102|      0|                                    goto _L___0;
12103|      0|                                }
12104|      0|                                else {
12105|      0|                                    tmp___17 = gettext("leading blanks are significant in key "
12106|      0|                                                       "%lu; consider also specifying \'b\'");
12107|      0|                                    error(0, 0, (char const *)tmp___17, keynum);
12108|      0|                                }
12109|      0|                            }
12110|      0|                        }
12111|      0|                        else {
12112|      0|_L___0:
12113|      0|                            if (!key->skipsblanks) {
12114|      0|                                if (key->schar) {
12115|      0|                                    tmp___17 = gettext("leading blanks are significant in key "
12116|      0|                                                       "%lu; consider also specifying \'b\'");
12117|      0|                                    error(0, 0, (char const *)tmp___17, keynum);
12118|      0|                                }
12119|      0|                                else {
12120|      0|                                    goto _L;
12121|      0|                                }
12122|      0|                            }
12123|      0|                            else {
12124|      0|_L:
12125|      0|                                if (!key->skipeblanks) {
12126|      0|                                    if (key->echar) {
12127|      0|                                        tmp___17 = gettext("leading blanks are significant in key "
12128|      0|                                                           "%lu; consider also specifying \'b\'");
12129|      0|                                        error(0, 0, (char const *)tmp___17, keynum);
12130|      0|                                    }
12131|      0|                                }
12132|      0|                            }
12133|      0|                        }
12134|      0|                    }
12135|      0|                }
12136|      0|            }
12137|      0|            if (!gkey_only) {
12138|      0|                tmp___19 = key_numeric(key);
12139|      0|                if (tmp___19) {
12140|      0|                    sword___0 = (size_t)(key->sword + 1UL);
12141|      0|                    eword___0 = (size_t)(key->eword + 1UL);
12142|      0|                    if (!sword___0) {
12143|      0|                        sword___0++;
12144|      0|                    }
12145|      0|                    if (!eword___0) {
12146|      0|                        tmp___18 = gettext("key %lu is numeric and spans multiple fields");
12147|      0|                        error(0, 0, (char const *)tmp___18, keynum);
12148|      0|                    }
12149|      0|                    else {
12150|      0|                        if (sword___0 < eword___0) {
12151|      0|                            tmp___18 =
12152|      0|                                gettext("key %lu is numeric and spans multiple fields");
12153|      0|                            error(0, 0, (char const *)tmp___18, keynum);
12154|      0|                        }
12155|      0|                    }
12156|      0|                }
12157|      0|            }
12158|      0|            if (ugkey.ignore) {
12159|      0|                if ((unsigned long)ugkey.ignore == (unsigned long)key->ignore) {
12160|      0|                    ugkey.ignore = (_Bool const *)((void *)0);
12161|      0|                }
12162|      0|            }
12163|      0|            if (ugkey.translate) {
12164|      0|                if ((unsigned long)ugkey.translate == (unsigned long)key->translate) {
12165|      0|                    ugkey.translate = (char const *)((void *)0);
12166|      0|                }
12167|      0|            }
12168|      0|            ugkey.skipsblanks = (_Bool)((int)ugkey.skipsblanks & !key->skipsblanks);
12169|      0|            ugkey.skipeblanks = (_Bool)((int)ugkey.skipeblanks & !key->skipeblanks);
12170|      0|            ugkey.month = (_Bool)((int)ugkey.month & !key->month);
12171|      0|            ugkey.numeric = (_Bool)((int)ugkey.numeric & !key->numeric);
12172|      0|            ugkey.general_numeric =
12173|      0|                (_Bool)((int)ugkey.general_numeric & !key->general_numeric);
12174|      0|            ugkey.human_numeric =
12175|      0|                (_Bool)((int)ugkey.human_numeric & !key->human_numeric);
12176|      0|            ugkey.random = (_Bool)((int)ugkey.random & !key->random);
12177|      0|            ugkey.version = (_Bool)((int)ugkey.version & !key->version);
12178|      0|            ugkey.reverse = (_Bool)((int)ugkey.reverse & !key->reverse);
12179|      0|            key = (struct keyfield const *)key->next;
12180|      0|            keynum++;
12181|      0|        }
12182|      0|while_break:
12183|      0|        tmp___23 = default_key_compare((struct keyfield const *)(&ugkey));
12184|      0|        if (tmp___23) {
12185|      0|            if (ugkey.reverse) {
12186|      0|                if (stable) {
12187|      0|                    goto _L___2;
12188|      0|                }
12189|      0|                else {
12190|      0|                    if (unique) {
12191|      0|_L___2:
12192|      0|                        if (keylist) {
12193|      0|_L___1:
12194|      0|                            ugkey_reverse = ugkey.reverse;
12195|      0|                            if (!stable) {
12196|      0|                                if (!unique) {
12197|      0|                                    ugkey.reverse = (_Bool)0;
12198|      0|                                }
12199|      0|                            }
12200|      0|                            key_to_opts((struct keyfield const *)(&ugkey), opts___1);
12201|      0|                            tmp___20 = strlen((char const *)(opts___1));
12202|      0|                            tmp___21 = select_plural(tmp___20);
12203|      0|                            tmp___22 = ngettext("option \'-%s\' is ignored",
12204|      0|                                                "options \'-%s\' are ignored", tmp___21);
12205|      0|                            error(0, 0, (char const *)tmp___22, opts___1);
12206|      0|                            ugkey.reverse = ugkey_reverse;
12207|      0|                        }
12208|      0|                    }
12209|      0|                }
12210|      0|            }
12211|      0|        }
12212|      0|        else {
12213|      0|            goto _L___1;
12214|      0|        }
12215|      0|        if (ugkey.reverse) {
12216|      0|            if (!stable) {
12217|      0|                if (!unique) {
12218|      0|                    if (keylist) {
12219|      0|                        tmp___24 =
12220|      0|                            gettext("option \'-r\' only applies to last-resort comparison");
12221|      0|                        error(0, 0, (char const *)tmp___24);
12222|      0|                    }
12223|      0|                }
12224|      0|            }
12225|      0|        }
12226|      0|        return;
12227|      0|    }
12228|      0|}
12229|       |static int keycompare(struct line const *a, struct line const *b)
12230|   196k|{
12231|   196k|    struct keyfield *key;
12232|   196k|    char *texta;
12233|   196k|    char *textb;
12234|   196k|    char *lima;
12235|   196k|    char *limb;
12236|   196k|    int diff;
12237|   196k|    char const *translate;
12238|   196k|    _Bool const *ignore;
12239|   196k|    size_t lena;
12240|   196k|    size_t lenb;
12241|   196k|    char *ta;
12242|   196k|    char *tb;
12243|   196k|    size_t tlena;
12244|   196k|    size_t tlenb;
12245|   196k|    char enda;
12246|   196k|    char endb;
12247|   196k|    void *allocated;
12248|   196k|    char stackbuf[4000];
12249|   196k|    size_t i;
12250|   196k|    size_t size;
12251|   196k|    size_t tmp;
12252|   196k|    unsigned char tmp___0;
12253|   196k|    unsigned char tmp___1;
12254|   196k|    size_t tmp___2;
12255|   196k|    unsigned char tmp___3;
12256|   196k|    unsigned char tmp___4;
12257|   196k|    int tmp___5;
12258|   196k|    int tmp___6;
12259|   196k|    unsigned char tmp___7;
12260|   196k|    unsigned char tmp___8;
12261|   196k|    unsigned char tmp___9;
12262|   196k|    unsigned char tmp___10;
12263|   196k|    unsigned char tmp___11;
12264|   196k|    unsigned char tmp___12;
12265|   196k|    unsigned char tmp___13;
12266|   196k|    unsigned char tmp___14;
12267|   196k|    unsigned char tmp___15;
12268|   196k|    unsigned char tmp___16;
12269|   196k|    char *tmp___17;
12270|   196k|    unsigned char tmp___18;
12271|   196k|    unsigned char tmp___19;
12272|   196k|    char *tmp___20;
12273|   196k|    unsigned char tmp___21;
12274|   196k|    unsigned char tmp___22;
12275|   196k|    size_t tmp___23;
12276|   196k|    _Bool tmp___24;
12277|   196k|    unsigned char tmp___25;
12278|   196k|    unsigned char tmp___26;
12279|   196k|    int tmp___27;
12280|       |
12281|   196k|    {
12282|   196k|        key = keylist;
12283|   196k|        texta = (char *)a->keybeg;
12284|   196k|        textb = (char *)b->keybeg;
12285|   196k|        lima = (char *)a->keylim;
12286|   196k|        limb = (char *)b->keylim;
12287|   196k|        while (1) {
12288|   196k|            translate = key->translate;
12289|   196k|            ignore = key->ignore;
12290|   196k|            if ((unsigned long)texta > (unsigned long)lima) {
12291|      0|                lima = texta;
12292|      0|            }
12293|   196k|            else {
12294|   196k|                lima = lima;
12295|   196k|            }
12296|   196k|            if ((unsigned long)textb > (unsigned long)limb) {
12297|      0|                limb = textb;
12298|      0|            }
12299|   196k|            else {
12300|   196k|                limb = limb;
12301|   196k|            }
12302|   196k|            lena = (size_t)(lima - texta);
12303|   196k|            lenb = (size_t)(limb - textb);
12304|   196k|            if (hard_LC_COLLATE) {
12305|   196k|                goto _L___2;
12306|   196k|            }
12307|      0|            else {
12308|      0|                tmp___24 = key_numeric((struct keyfield const *)key);
12309|      0|                if (tmp___24) {
12310|      0|                    goto _L___2;
12311|      0|                }
12312|      0|                else {
12313|      0|                    if (key->month) {
12314|      0|                        goto _L___2;
12315|      0|                    }
12316|      0|                    else {
12317|      0|                        if (key->random) {
12318|      0|                            goto _L___2;
12319|      0|                        }
12320|      0|                        else {
12321|      0|                            if (key->version) {
12322|   196k|_L___2:
12323|   196k|                                if (ignore) {
12324|      0|                                    goto _L___1;
12325|      0|                                }
12326|   196k|                                else {
12327|   196k|                                    if (translate) {
12328|   196k|_L___1:
12329|   196k|                                        size = ((lena + 1UL) + lenb) + 1UL;
12330|   196k|                                        if (size <= sizeof(stackbuf)) {
12331|   196k|                                            ta = stackbuf;
12332|   196k|                                            allocated = (void *)0;
12333|   196k|                                        }
12334|      0|                                        else {
12335|      0|                                            allocated = xmalloc(size);
12336|      0|                                            ta = (char *)allocated;
12337|      0|                                        }
12338|   196k|                                        tb = (ta + lena) + 1;
12339|   196k|                                        i = (size_t)0;
12340|   196k|                                        tlena = i;
12341|  6.36M|                                        while (1) {
12342|       |
12343|  6.36M|                                            if (!(i < lena)) {
12344|   196k|                                                goto while_break___0;
12345|   196k|                                            }
12346|  6.16M|                                            if (ignore) {
12347|      0|                                                tmp___1 = to_uchar(*(texta + i));
12348|      0|                                                if (!*(ignore + (int)tmp___1)) {
12349|      0|                                                    goto _L;
12350|      0|                                                }
12351|      0|                                            }
12352|  6.16M|                                            else {
12353|  6.16M|_L:
12354|  6.16M|                                                tmp = tlena;
12355|  6.16M|                                                tlena++;
12356|  6.16M|                                                if (translate) {
12357|  6.16M|                                                    tmp___0 = to_uchar(*(texta + i));
12358|  6.16M|                                                    *(ta + tmp) = (char)*(translate + (int)tmp___0);
12359|  6.16M|                                                }
12360|      0|                                                else {
12361|      0|                                                    *(ta + tmp) = *(texta + i);
12362|      0|                                                }
12363|  6.16M|                                            }
12364|  6.16M|                                            i++;
12365|  6.16M|                                        }
12366|   196k|while_break___0:
12367|   196k|                                        *(ta + tlena) = (char)'\000';
12368|   196k|                                        i = (size_t)0;
12369|   196k|                                        tlenb = i;
12370|  6.30M|                                        while (1) {
12371|       |
12372|  6.30M|                                            if (!(i < lenb)) {
12373|   196k|                                                goto while_break___1;
12374|   196k|                                            }
12375|  6.11M|                                            if (ignore) {
12376|      0|                                                tmp___4 = to_uchar(*(textb + i));
12377|      0|                                                if (!*(ignore + (int)tmp___4)) {
12378|      0|                                                    goto _L___0;
12379|      0|                                                }
12380|      0|                                            }
12381|  6.11M|                                            else {
12382|  6.11M|_L___0:
12383|  6.11M|                                                tmp___2 = tlenb;
12384|  6.11M|                                                tlenb++;
12385|  6.11M|                                                if (translate) {
12386|  6.11M|                                                    tmp___3 = to_uchar(*(textb + i));
12387|  6.11M|                                                    *(tb + tmp___2) = (char)*(translate + (int)tmp___3);
12388|  6.11M|                                                }
12389|      0|                                                else {
12390|      0|                                                    *(tb + tmp___2) = *(textb + i);
12391|      0|                                                }
12392|  6.11M|                                            }
12393|  6.11M|                                            i++;
12394|  6.11M|                                        }
12395|   196k|while_break___1:
12396|   196k|                                        *(tb + tlenb) = (char)'\000';
12397|   196k|                                    }
12398|      0|                                    else {
12399|      0|                                        ta = texta;
12400|      0|                                        tlena = lena;
12401|      0|                                        enda = *(ta + tlena);
12402|      0|                                        *(ta + tlena) = (char)'\000';
12403|      0|                                        tb = textb;
12404|      0|                                        tlenb = lenb;
12405|      0|                                        endb = *(tb + tlenb);
12406|      0|                                        *(tb + tlenb) = (char)'\000';
12407|      0|                                    }
12408|   196k|                                }
12409|   196k|                                if (key->numeric) {
12410|    231|                                    diff = numcompare___3((char const *)ta, (char const *)tb);
12411|    231|                                }
12412|   196k|                                else {
12413|   196k|                                    if (key->general_numeric) {
12414|      0|                                        diff =
12415|      0|                                            general_numcompare((char const *)ta, (char const *)tb);
12416|      0|                                    }
12417|   196k|                                    else {
12418|   196k|                                        if (key->human_numeric) {
12419|      0|                                            diff =
12420|      0|                                                human_numcompare((char const *)ta, (char const *)tb);
12421|      0|                                        }
12422|   196k|                                        else {
12423|   196k|                                            if (key->month) {
12424|      0|                                                tmp___5 =
12425|      0|                                                    getmonth((char const *)ta, (char **)((void *)0));
12426|      0|                                                tmp___6 =
12427|      0|                                                    getmonth((char const *)tb, (char **)((void *)0));
12428|      0|                                                diff = tmp___5 - tmp___6;
12429|      0|                                            }
12430|   196k|                                            else {
12431|   196k|                                                if (key->random) {
12432|      0|                                                    diff = compare_random(ta, tlena, tb, tlenb);
12433|      0|                                                }
12434|   196k|                                                else {
12435|   196k|                                                    if (key->version) {
12436|      0|                                                        diff =
12437|      0|                                                            filevercmp((char const *)ta, (char const *)tb);
12438|      0|                                                    }
12439|   196k|                                                    else {
12440|   196k|                                                        if (tlena == 0UL) {
12441|  2.57k|                                                            diff = -(tlenb != 0UL);
12442|  2.57k|                                                        }
12443|   193k|                                                        else {
12444|   193k|                                                            if (tlenb == 0UL) {
12445|  2.71k|                                                                diff = 1;
12446|  2.71k|                                                            }
12447|   190k|                                                            else {
12448|   190k|                                                                diff = xmemcoll0((char const *)ta, tlena + 1UL,
12449|   190k|                                                                                 (char const *)tb, tlenb + 1UL);
12450|   190k|                                                            }
12451|   193k|                                                        }
12452|   196k|                                                    }
12453|   196k|                                                }
12454|   196k|                                            }
12455|   196k|                                        }
12456|   196k|                                    }
12457|   196k|                                }
12458|   196k|                                if (ignore) {
12459|      0|                                    free(allocated);
12460|      0|                                }
12461|   196k|                                else {
12462|   196k|                                    if (translate) {
12463|   196k|                                        free(allocated);
12464|   196k|                                    }
12465|      0|                                    else {
12466|      0|                                        *(ta + tlena) = enda;
12467|      0|                                        *(tb + tlenb) = endb;
12468|      0|                                    }
12469|   196k|                                }
12470|   196k|                            }
12471|      0|                            else {
12472|      0|                                if (ignore) {
12473|      0|                                    if (translate) {
12474|      0|                                        while (1) {
12475|       |
12476|      0|                                            while (1) {
12477|       |
12478|      0|                                                while (1) {
12479|       |
12480|      0|                                                    if ((unsigned long)texta < (unsigned long)lima) {
12481|      0|                                                        tmp___7 = to_uchar(*texta);
12482|      0|                                                        if (!*(ignore + (int)tmp___7)) {
12483|      0|                                                            goto while_break___4;
12484|      0|                                                        }
12485|      0|                                                    }
12486|      0|                                                    else {
12487|      0|                                                        goto while_break___4;
12488|      0|                                                    }
12489|      0|                                                    texta++;
12490|      0|                                                }
12491|      0|while_break___4:
12492|      0|                                                ;
12493|      0|                                                while (1) {
12494|       |
12495|      0|                                                    if ((unsigned long)textb < (unsigned long)limb) {
12496|      0|                                                        tmp___8 = to_uchar(*textb);
12497|      0|                                                        if (!*(ignore + (int)tmp___8)) {
12498|      0|                                                            goto while_break___5;
12499|      0|                                                        }
12500|      0|                                                    }
12501|      0|                                                    else {
12502|      0|                                                        goto while_break___5;
12503|      0|                                                    }
12504|      0|                                                    textb++;
12505|      0|                                                }
12506|      0|while_break___5:
12507|      0|                                                ;
12508|      0|                                                if ((unsigned long)texta < (unsigned long)lima) {
12509|      0|                                                    if (!((unsigned long)textb < (unsigned long)limb)) {
12510|      0|                                                        goto while_break___3;
12511|      0|                                                    }
12512|      0|                                                }
12513|      0|                                                else {
12514|      0|                                                    goto while_break___3;
12515|      0|                                                }
12516|      0|                                                tmp___9 = to_uchar(*texta);
12517|      0|                                                tmp___10 = to_uchar((char)*(translate + (int)tmp___9));
12518|      0|                                                tmp___11 = to_uchar(*textb);
12519|      0|                                                tmp___12 = to_uchar((char)*(translate + (int)tmp___11));
12520|      0|                                                diff = (int)tmp___10 - (int)tmp___12;
12521|      0|                                                if (diff) {
12522|      0|                                                    goto not_equal;
12523|      0|                                                }
12524|      0|                                                texta++;
12525|      0|                                                textb++;
12526|      0|                                            }
12527|      0|while_break___3:
12528|      0|                                            diff = ((unsigned long)texta < (unsigned long)lima) -
12529|      0|                                                   ((unsigned long)textb < (unsigned long)limb);
12530|      0|                                            goto while_break___2;
12531|      0|                                        }
12532|      0|while_break___2:
12533|      0|                                        ;
12534|      0|                                    }
12535|      0|                                    else {
12536|      0|                                        while (1) {
12537|       |
12538|      0|                                            while (1) {
12539|       |
12540|      0|                                                while (1) {
12541|       |
12542|      0|                                                    if ((unsigned long)texta < (unsigned long)lima) {
12543|      0|                                                        tmp___13 = to_uchar(*texta);
12544|      0|                                                        if (!*(ignore + (int)tmp___13)) {
12545|      0|                                                            goto while_break___8;
12546|      0|                                                        }
12547|      0|                                                    }
12548|      0|                                                    else {
12549|      0|                                                        goto while_break___8;
12550|      0|                                                    }
12551|      0|                                                    texta++;
12552|      0|                                                }
12553|      0|while_break___8:
12554|      0|                                                ;
12555|      0|                                                while (1) {
12556|       |
12557|      0|                                                    if ((unsigned long)textb < (unsigned long)limb) {
12558|      0|                                                        tmp___14 = to_uchar(*textb);
12559|      0|                                                        if (!*(ignore + (int)tmp___14)) {
12560|      0|                                                            goto while_break___9;
12561|      0|                                                        }
12562|      0|                                                    }
12563|      0|                                                    else {
12564|      0|                                                        goto while_break___9;
12565|      0|                                                    }
12566|      0|                                                    textb++;
12567|      0|                                                }
12568|      0|while_break___9:
12569|      0|                                                ;
12570|      0|                                                if ((unsigned long)texta < (unsigned long)lima) {
12571|      0|                                                    if (!((unsigned long)textb < (unsigned long)limb)) {
12572|      0|                                                        goto while_break___7;
12573|      0|                                                    }
12574|      0|                                                }
12575|      0|                                                else {
12576|      0|                                                    goto while_break___7;
12577|      0|                                                }
12578|      0|                                                tmp___15 = to_uchar(*texta);
12579|      0|                                                tmp___16 = to_uchar(*textb);
12580|      0|                                                diff = (int)tmp___15 - (int)tmp___16;
12581|      0|                                                if (diff) {
12582|      0|                                                    goto not_equal;
12583|      0|                                                }
12584|      0|                                                texta++;
12585|      0|                                                textb++;
12586|      0|                                            }
12587|      0|while_break___7:
12588|      0|                                            diff = ((unsigned long)texta < (unsigned long)lima) -
12589|      0|                                                   ((unsigned long)textb < (unsigned long)limb);
12590|      0|                                            goto while_break___6;
12591|      0|                                        }
12592|      0|while_break___6:
12593|      0|                                        ;
12594|      0|                                    }
12595|      0|                                }
12596|      0|                                else {
12597|      0|                                    if (lena == 0UL) {
12598|      0|                                        diff = -(lenb != 0UL);
12599|      0|                                    }
12600|      0|                                    else {
12601|      0|                                        if (lenb == 0UL) {
12602|      0|                                            goto greater;
12603|      0|                                        }
12604|      0|                                        else {
12605|      0|                                            if (translate) {
12606|      0|                                                while (1) {
12607|       |
12608|      0|                                                    if ((unsigned long)texta < (unsigned long)lima) {
12609|      0|                                                        if (!((unsigned long)textb < (unsigned long)limb)) {
12610|      0|                                                            goto while_break___10;
12611|      0|                                                        }
12612|      0|                                                    }
12613|      0|                                                    else {
12614|      0|                                                        goto while_break___10;
12615|      0|                                                    }
12616|      0|                                                    tmp___17 = texta;
12617|      0|                                                    texta++;
12618|      0|                                                    tmp___18 = to_uchar(*tmp___17);
12619|      0|                                                    tmp___19 =
12620|      0|                                                        to_uchar((char)*(translate + (int)tmp___18));
12621|      0|                                                    tmp___20 = textb;
12622|      0|                                                    textb++;
12623|      0|                                                    tmp___21 = to_uchar(*tmp___20);
12624|      0|                                                    tmp___22 =
12625|      0|                                                        to_uchar((char)*(translate + (int)tmp___21));
12626|      0|                                                    diff = (int)tmp___19 - (int)tmp___22;
12627|      0|                                                    if (diff) {
12628|      0|                                                        goto not_equal;
12629|      0|                                                    }
12630|      0|                                                }
12631|      0|while_break___10:
12632|      0|                                                ;
12633|      0|                                            }
12634|      0|                                            else {
12635|      0|                                                if (lena < lenb) {
12636|      0|                                                    tmp___23 = lena;
12637|      0|                                                }
12638|      0|                                                else {
12639|      0|                                                    tmp___23 = lenb;
12640|      0|                                                }
12641|      0|                                                diff = memcmp((void const *)texta, (void const *)textb,
12642|      0|                                                              tmp___23);
12643|      0|                                                if (diff) {
12644|      0|                                                    goto not_equal;
12645|      0|                                                }
12646|      0|                                            }
12647|      0|                                            if (lena < lenb) {
12648|      0|                                                diff = -1;
12649|      0|                                            }
12650|      0|                                            else {
12651|      0|                                                diff = lena != lenb;
12652|      0|                                            }
12653|      0|                                        }
12654|      0|                                    }
12655|      0|                                }
12656|      0|                            }
12657|      0|                        }
12658|      0|                    }
12659|      0|                }
12660|      0|            }
12661|   196k|            if (diff) {
12662|   170k|                goto not_equal;
12663|   170k|            }
12664|  26.2k|            key = key->next;
12665|  26.2k|            if (!key) {
12666|  26.2k|                goto while_break;
12667|  26.2k|            }
12668|      0|            if (key->eword != 0xffffffffffffffffUL) {
12669|      0|                lima = limfield(a, (struct keyfield const *)key);
12670|      0|                limb = limfield(b, (struct keyfield const *)key);
12671|      0|            }
12672|      0|            else {
12673|      0|                lima = (char *)((a->text + a->length) - 1);
12674|      0|                limb = (char *)((b->text + b->length) - 1);
12675|      0|            }
12676|      0|            if (key->sword != 0xffffffffffffffffUL) {
12677|      0|                texta = begfield(a, (struct keyfield const *)key);
12678|      0|                textb = begfield(b, (struct keyfield const *)key);
12679|      0|            }
12680|      0|            else {
12681|      0|                texta = (char *)a->text;
12682|      0|                textb = (char *)b->text;
12683|      0|                if (key->skipsblanks) {
12684|      0|                    while (1) {
12685|       |
12686|      0|                        if ((unsigned long)texta < (unsigned long)lima) {
12687|      0|                            tmp___25 = to_uchar(*texta);
12688|      0|                            if (!blanks[tmp___25]) {
12689|      0|                                goto while_break___11;
12690|      0|                            }
12691|      0|                        }
12692|      0|                        else {
12693|      0|                            goto while_break___11;
12694|      0|                        }
12695|      0|                        texta++;
12696|      0|                    }
12697|      0|while_break___11:
12698|      0|                    ;
12699|      0|                    while (1) {
12700|       |
12701|      0|                        if ((unsigned long)textb < (unsigned long)limb) {
12702|      0|                            tmp___26 = to_uchar(*textb);
12703|      0|                            if (!blanks[tmp___26]) {
12704|      0|                                goto while_break___12;
12705|      0|                            }
12706|      0|                        }
12707|      0|                        else {
12708|      0|                            goto while_break___12;
12709|      0|                        }
12710|      0|                        textb++;
12711|      0|                    }
12712|      0|while_break___12:
12713|      0|                    ;
12714|      0|                }
12715|      0|            }
12716|      0|        }
12717|  26.2k|while_break:
12718|  26.2k|        ;
12719|  26.2k|        return (0);
12720|      0|greater:
12721|      0|        diff = 1;
12722|   170k|not_equal:
12723|   170k|        if (key->reverse) {
12724|      0|            tmp___27 = -diff;
12725|      0|        }
12726|   170k|        else {
12727|   170k|            tmp___27 = diff;
12728|   170k|        }
12729|   170k|        return (tmp___27);
12730|      0|    }
12731|      0|}
12732|       |static int compare(struct line const *a, struct line const *b)
12733|   196k|{
12734|   196k|    int diff;
12735|   196k|    size_t alen;
12736|   196k|    size_t blen;
12737|   196k|    size_t tmp;
12738|   196k|    int tmp___0;
12739|       |
12740|   196k|    {
12741|   196k|        if (keylist) {
12742|   196k|            diff = keycompare(a, b);
12743|   196k|            if (diff) {
12744|   170k|                return (diff);
12745|   170k|            }
12746|  26.2k|            else {
12747|  26.2k|                if (unique) {
12748|      0|                    return (diff);
12749|      0|                }
12750|  26.2k|                else {
12751|  26.2k|                    if (stable) {
12752|      0|                        return (diff);
12753|      0|                    }
12754|  26.2k|                }
12755|  26.2k|            }
12756|   196k|        }
12757|  26.2k|        alen = (size_t)(a->length - 1UL);
12758|  26.2k|        blen = (size_t)(b->length - 1UL);
12759|  26.2k|        if (alen == 0UL) {
12760|  1.66k|            diff = -(blen != 0UL);
12761|  1.66k|        }
12762|  24.5k|        else {
12763|  24.5k|            if (blen == 0UL) {
12764|      0|                diff = 1;
12765|      0|            }
12766|  24.5k|            else {
12767|  24.5k|                if (hard_LC_COLLATE) {
12768|  24.5k|                    diff = xmemcoll0((char const *)a->text, alen + 1UL,
12769|  24.5k|                                     (char const *)b->text, blen + 1UL);
12770|  24.5k|                }
12771|      0|                else {
12772|      0|                    if (alen < blen) {
12773|      0|                        tmp = alen;
12774|      0|                    }
12775|      0|                    else {
12776|      0|                        tmp = blen;
12777|      0|                    }
12778|      0|                    diff = memcmp((void const *)a->text, (void const *)b->text, tmp);
12779|      0|                    if (!diff) {
12780|      0|                        if (alen < blen) {
12781|      0|                            diff = -1;
12782|      0|                        }
12783|      0|                        else {
12784|      0|                            diff = alen != blen;
12785|      0|                        }
12786|      0|                    }
12787|      0|                }
12788|  24.5k|            }
12789|  24.5k|        }
12790|  26.2k|        if (reverse) {
12791|      0|            tmp___0 = -diff;
12792|      0|        }
12793|  26.2k|        else {
12794|  26.2k|            tmp___0 = diff;
12795|  26.2k|        }
12796|  26.2k|        return (tmp___0);
12797|   196k|    }
12798|   196k|}
12799|       |static void write_line(struct line const *line, FILE *fp,
12800|       |                       char const *output_file)
12801|  15.6k|{
12802|  15.6k|    char *buf___1;
12803|  15.6k|    size_t n_bytes;
12804|  15.6k|    char *ebuf;
12805|  15.6k|    char const *c;
12806|  15.6k|    char wc;
12807|  15.6k|    char const *tmp;
12808|  15.6k|    char *tmp___0;
12809|  15.6k|    int tmp___1;
12810|  15.6k|    char *tmp___2;
12811|  15.6k|    size_t tmp___3;
12812|       |
12813|  15.6k|    {
12814|  15.6k|        buf___1 = (char *)line->text;
12815|  15.6k|        n_bytes = (size_t)line->length;
12816|  15.6k|        ebuf = buf___1 + n_bytes;
12817|  15.6k|        if (!output_file) {
12818|  15.6k|            if (debug) {
12819|      0|                c = (char const *)buf___1;
12820|      0|                while (1) {
12821|       |
12822|      0|                    if (!((unsigned long)c < (unsigned long)ebuf)) {
12823|      0|                        goto while_break;
12824|      0|                    }
12825|      0|                    tmp = c;
12826|      0|                    c++;
12827|      0|                    wc = (char)*tmp;
12828|      0|                    if ((int)wc == 9) {
12829|      0|                        wc = (char)'>';
12830|      0|                    }
12831|      0|                    else {
12832|      0|                        if ((unsigned long)c == (unsigned long)ebuf) {
12833|      0|                            wc = (char)'\n';
12834|      0|                        }
12835|      0|                    }
12836|      0|                    tmp___1 = fputc_unlocked((int)wc, fp);
12837|      0|                    if (tmp___1 == -1) {
12838|      0|                        tmp___0 = gettext("write failed");
12839|      0|                        die((char const *)tmp___0, output_file);
12840|      0|                    }
12841|      0|                }
12842|      0|while_break:
12843|      0|                debug_line(line);
12844|      0|            }
12845|  15.6k|            else {
12846|  15.6k|                goto _L;
12847|  15.6k|            }
12848|  15.6k|        }
12849|      0|        else {
12850|  15.6k|_L:
12851|  15.6k|            *(ebuf + -1) = eolchar;
12852|  15.6k|            tmp___3 = fwrite_unlocked((void const *)buf___1, (size_t)1, n_bytes, fp);
12853|  15.6k|            if (tmp___3 != n_bytes) {
12854|      0|                tmp___2 = gettext("write failed");
12855|      0|                die((char const *)tmp___2, output_file);
12856|      0|            }
12857|  15.6k|            *(ebuf + -1) = (char)'\000';
12858|  15.6k|        }
12859|  15.6k|        return;
12860|  15.6k|    }
12861|  15.6k|}
12862|       |static _Bool check(char const *file_name___3, char checkonly)
12863|      0|{
12864|      0|    FILE *fp;
12865|      0|    FILE *tmp;
12866|      0|    struct buffer buf___1;
12867|      0|    struct line temp;
12868|      0|    size_t alloc;
12869|      0|    uintmax_t line_number;
12870|      0|    struct keyfield const *key;
12871|      0|    _Bool nonunique;
12872|      0|    _Bool ordered;
12873|      0|    size_t tmp___0;
12874|      0|    struct line const *line;
12875|      0|    struct line const *tmp___1;
12876|      0|    struct line const *linebase;
12877|      0|    struct line const *disorder_line;
12878|      0|    uintmax_t disorder_line_number;
12879|      0|    struct line *tmp___2;
12880|      0|    char hr_buf[((sizeof(disorder_line_number) * 8UL) * 146UL + 484UL) / 485UL +
12881|      0|                                               1UL];
12882|      0|    char *tmp___3;
12883|      0|    char *tmp___4;
12884|      0|    char *tmp___5;
12885|      0|    int tmp___6;
12886|      0|    int tmp___7;
12887|      0|    _Bool tmp___8;
12888|       |
12889|      0|    {
12890|      0|        tmp = xfopen(file_name___3, "r");
12891|      0|        fp = tmp;
12892|      0|        alloc = (size_t)0;
12893|      0|        line_number = (uintmax_t)0;
12894|      0|        key = (struct keyfield const *)keylist;
12895|      0|        nonunique = (_Bool)(!unique);
12896|      0|        ordered = (_Bool)1;
12897|      0|        if (merge_buffer_size > sort_size) {
12898|      0|            tmp___0 = merge_buffer_size;
12899|      0|        }
12900|      0|        else {
12901|      0|            tmp___0 = sort_size;
12902|      0|        }
12903|      0|        initbuf(&buf___1, sizeof(struct line), tmp___0);
12904|      0|        temp.text = (char *)((void *)0);
12905|      0|        while (1) {
12906|      0|            tmp___8 = fillbuf___7(&buf___1, fp, file_name___3);
12907|      0|            if (!tmp___8) {
12908|      0|                goto while_break;
12909|      0|            }
12910|      0|            tmp___1 = (struct line const *)buffer_linelim(
12911|      0|                          (struct buffer const *)(&buf___1));
12912|      0|            line = tmp___1;
12913|      0|            linebase = line - buf___1.nlines;
12914|      0|            if (alloc) {
12915|      0|                tmp___6 = compare((struct line const *)(&temp), line - 1);
12916|      0|                if ((int)nonunique <= tmp___6) {
12917|      0|found_disorder:
12918|      0|                    if ((int)checkonly == 99) {
12919|      0|                        disorder_line = line - 1;
12920|      0|                        tmp___2 = buffer_linelim((struct buffer const *)(&buf___1));
12921|      0|                        disorder_line_number =
12922|      0|                            (uintmax_t)(tmp___2 - (struct line *)disorder_line) +
12923|      0|                            line_number;
12924|      0|                        tmp___3 = umaxtostr(disorder_line_number, hr_buf);
12925|      0|                        tmp___4 = gettext("%s: %s:%s: disorder: ");
12926|      0|                        fprintf(stderr, (char const *)tmp___4, program_name, file_name___3,
12927|      0|                                tmp___3);
12928|      0|                        tmp___5 = gettext("standard error");
12929|      0|                        write_line(disorder_line, stderr, (char const *)tmp___5);
12930|      0|                    }
12931|      0|                    ordered = (_Bool)0;
12932|      0|                    goto while_break;
12933|      0|                }
12934|      0|            }
12935|      0|            while (1) {
12936|      0|                line--;
12937|      0|                if (!((unsigned long)linebase < (unsigned long)line)) {
12938|      0|                    goto while_break___0;
12939|      0|                }
12940|      0|                tmp___7 = compare(line, line - 1);
12941|      0|                if ((int)nonunique <= tmp___7) {
12942|      0|                    goto found_disorder;
12943|      0|                }
12944|      0|            }
12945|      0|while_break___0:
12946|      0|            line_number += buf___1.nlines;
12947|      0|            if (alloc < (size_t)line->length) {
12948|      0|                while (1) {
12949|      0|                    alloc *= 2UL;
12950|      0|                    if (!alloc) {
12951|      0|                        alloc = (size_t)line->length;
12952|      0|                        goto while_break___1;
12953|      0|                    }
12954|      0|                    if (!(alloc < (size_t)line->length)) {
12955|      0|                        goto while_break___1;
12956|      0|                    }
12957|      0|                }
12958|      0|while_break___1:
12959|      0|                free((void *)temp.text);
12960|      0|                temp.text = (char *)xmalloc(alloc);
12961|      0|            }
12962|      0|            memcpy((void *)temp.text, (void const *)line->text, (size_t)line->length);
12963|      0|            temp.length = (size_t)line->length;
12964|      0|            if (key) {
12965|      0|                temp.keybeg = temp.text + (line->keybeg - line->text);
12966|      0|                temp.keylim = temp.text + (line->keylim - line->text);
12967|      0|            }
12968|      0|        }
12969|      0|while_break:
12970|      0|        xfclose(fp, file_name___3);
12971|      0|        free((void *)buf___1.buf);
12972|      0|        free((void *)temp.text);
12973|      0|        return (ordered);
12974|      0|    }
12975|      0|}
12976|       |static size_t open_input_files(struct sortfile *files, size_t nfiles,
12977|       |                               FILE ***pfps)
12978|      0|{
12979|      0|    FILE **fps;
12980|      0|    FILE **tmp;
12981|      0|    int i;
12982|      0|    FILE *tmp___0;
12983|      0|    FILE *tmp___1;
12984|       |
12985|      0|    {
12986|      0|        tmp = (FILE **)xnmalloc(nfiles, sizeof(*fps));
12987|      0|        *pfps = tmp;
12988|      0|        fps = tmp;
12989|      0|        i = 0;
12990|      0|        while (1) {
12991|       |
12992|      0|            if (!((size_t)i < nfiles)) {
12993|      0|                goto while_break;
12994|      0|            }
12995|      0|            if ((files + i)->temp) {
12996|      0|                if ((int)((files + i)->temp)->state != 0) {
12997|      0|                    tmp___0 = open_temp((files + i)->temp);
12998|      0|                    *(fps + i) = tmp___0;
12999|      0|                }
13000|      0|                else {
13001|      0|                    tmp___1 = stream_open((files + i)->name, "r");
13002|      0|                    *(fps + i) = tmp___1;
13003|      0|                }
13004|      0|            }
13005|      0|            else {
13006|      0|                tmp___1 = stream_open((files + i)->name, "r");
13007|      0|                *(fps + i) = tmp___1;
13008|      0|            }
13009|      0|            if (!*(fps + i)) {
13010|      0|                goto while_break;
13011|      0|            }
13012|      0|            i++;
13013|      0|        }
13014|      0|while_break:
13015|      0|        ;
13016|      0|        return ((size_t)i);
13017|      0|    }
13018|      0|}
13019|       |static void mergefps(struct sortfile *files, size_t ntemps, size_t nfiles,
13020|       |                     FILE *ofp, char const *output_file, FILE **fps)
13021|      0|{
13022|      0|    struct buffer *buffer;
13023|      0|    struct buffer *tmp;
13024|      0|    struct line saved___0;
13025|      0|    struct line const *savedline;
13026|      0|    size_t savealloc;
13027|      0|    struct line const **cur;
13028|      0|    struct line const **tmp___0;
13029|      0|    struct line const **base;
13030|      0|    struct line const **tmp___1;
13031|      0|    size_t *ord;
13032|      0|    size_t *tmp___2;
13033|      0|    size_t i;
13034|      0|    size_t j;
13035|      0|    size_t t;
13036|      0|    struct keyfield const *key;
13037|      0|    size_t tmp___3;
13038|      0|    struct line const *linelim;
13039|      0|    struct line const *tmp___4;
13040|      0|    _Bool tmp___5;
13041|      0|    int tmp___6;
13042|      0|    struct line const *smallest;
13043|      0|    int tmp___7;
13044|      0|    struct line const *linelim___0;
13045|      0|    struct line const *tmp___8;
13046|      0|    _Bool tmp___9;
13047|      0|    size_t lo;
13048|      0|    size_t hi;
13049|      0|    size_t probe;
13050|      0|    size_t ord0;
13051|      0|    size_t count_of_smaller_lines;
13052|      0|    int cmp;
13053|      0|    int tmp___10;
13054|       |
13055|      0|    {
13056|      0|        tmp = (struct buffer *)xnmalloc(nfiles, sizeof(*buffer));
13057|      0|        buffer = tmp;
13058|      0|        savedline = (struct line const *)((void *)0);
13059|      0|        savealloc = (size_t)0;
13060|      0|        tmp___0 = (struct line const **)xnmalloc(nfiles, sizeof(*cur));
13061|      0|        cur = tmp___0;
13062|      0|        tmp___1 = (struct line const **)xnmalloc(nfiles, sizeof(*base));
13063|      0|        base = tmp___1;
13064|      0|        tmp___2 = (size_t *)xnmalloc(nfiles, sizeof(*ord));
13065|      0|        ord = tmp___2;
13066|      0|        key = (struct keyfield const *)keylist;
13067|      0|        saved___0.text = (char *)((void *)0);
13068|      0|        i = (size_t)0;
13069|      0|        while (1) {
13070|       |
13071|      0|            if (!(i < nfiles)) {
13072|      0|                goto while_break;
13073|      0|            }
13074|      0|            if (merge_buffer_size > sort_size / nfiles) {
13075|      0|                tmp___3 = merge_buffer_size;
13076|      0|            }
13077|      0|            else {
13078|      0|                tmp___3 = sort_size / nfiles;
13079|      0|            }
13080|      0|            initbuf(buffer + i, sizeof(struct line), tmp___3);
13081|      0|            tmp___5 = fillbuf___7(buffer + i, *(fps + i), (files + i)->name);
13082|      0|            if (tmp___5) {
13083|      0|                tmp___4 = (struct line const *)buffer_linelim(
13084|      0|                              (struct buffer const *)(buffer + i));
13085|      0|                linelim = tmp___4;
13086|      0|                *(cur + i) = linelim - 1;
13087|      0|                *(base + i) = linelim - (buffer + i)->nlines;
13088|      0|                i++;
13089|      0|            }
13090|      0|            else {
13091|      0|                xfclose(*(fps + i), (files + i)->name);
13092|      0|                if (i < ntemps) {
13093|      0|                    ntemps--;
13094|      0|                    zaptemp((files + i)->name);
13095|      0|                }
13096|      0|                free((void *)(buffer + i)->buf);
13097|      0|                nfiles--;
13098|      0|                j = i;
13099|      0|                while (1) {
13100|       |
13101|      0|                    if (!(j < nfiles)) {
13102|      0|                        goto while_break___0;
13103|      0|                    }
13104|      0|                    *(files + j) = *(files + (j + 1UL));
13105|      0|                    *(fps + j) = *(fps + (j + 1UL));
13106|      0|                    j++;
13107|      0|                }
13108|      0|while_break___0:
13109|      0|                ;
13110|      0|            }
13111|      0|        }
13112|      0|while_break:
13113|      0|        i = (size_t)0;
13114|      0|        while (1) {
13115|       |
13116|      0|            if (!(i < nfiles)) {
13117|      0|                goto while_break___1;
13118|      0|            }
13119|      0|            *(ord + i) = i;
13120|      0|            i++;
13121|      0|        }
13122|      0|while_break___1:
13123|      0|        i = (size_t)1;
13124|      0|        while (1) {
13125|       |
13126|      0|            if (!(i < nfiles)) {
13127|      0|                goto while_break___2;
13128|      0|            }
13129|      0|            tmp___6 = compare(*(cur + *(ord + (i - 1UL))), *(cur + *(ord + i)));
13130|      0|            if (0 < tmp___6) {
13131|      0|                t = *(ord + (i - 1UL));
13132|      0|                *(ord + (i - 1UL)) = *(ord + i);
13133|      0|                *(ord + i) = t;
13134|      0|                i = (size_t)0;
13135|      0|            }
13136|      0|            i++;
13137|      0|        }
13138|      0|while_break___2:
13139|      0|        ;
13140|      0|        while (1) {
13141|      0|while_continue___3:
13142|      0|            ;
13143|      0|            if (!nfiles) {
13144|      0|                goto while_break___3;
13145|      0|            }
13146|      0|            smallest = *(cur + *(ord + 0));
13147|      0|            if (unique) {
13148|      0|                if (savedline) {
13149|      0|                    tmp___7 = compare(savedline, smallest);
13150|      0|                    if (tmp___7) {
13151|      0|                        savedline = (struct line const *)((void *)0);
13152|      0|                        write_line((struct line const *)(&saved___0), ofp, output_file);
13153|      0|                    }
13154|      0|                }
13155|      0|                if (!savedline) {
13156|      0|                    savedline = (struct line const *)(&saved___0);
13157|      0|                    if (savealloc < (size_t)smallest->length) {
13158|      0|                        while (1) {
13159|       |
13160|      0|                            if (!savealloc) {
13161|      0|                                savealloc = (size_t)smallest->length;
13162|      0|                                goto while_break___4;
13163|      0|                            }
13164|      0|                            savealloc *= 2UL;
13165|      0|                            if (!(savealloc < (size_t)smallest->length)) {
13166|      0|                                goto while_break___4;
13167|      0|                            }
13168|      0|                        }
13169|      0|while_break___4:
13170|      0|                        free((void *)saved___0.text);
13171|      0|                        saved___0.text = (char *)xmalloc(savealloc);
13172|      0|                    }
13173|      0|                    saved___0.length = (size_t)smallest->length;
13174|      0|                    memcpy((void *)saved___0.text, (void const *)smallest->text,
13175|      0|                           saved___0.length);
13176|      0|                    if (key) {
13177|      0|                        saved___0.keybeg =
13178|      0|                            saved___0.text + (smallest->keybeg - smallest->text);
13179|      0|                        saved___0.keylim =
13180|      0|                            saved___0.text + (smallest->keylim - smallest->text);
13181|      0|                    }
13182|      0|                }
13183|      0|            }
13184|      0|            else {
13185|      0|                write_line(smallest, ofp, output_file);
13186|      0|            }
13187|      0|            if ((unsigned long)*(base + *(ord + 0)) < (unsigned long)smallest) {
13188|      0|                *(cur + *(ord + 0)) = smallest - 1;
13189|      0|            }
13190|      0|            else {
13191|      0|                tmp___9 = fillbuf___7(buffer + *(ord + 0), *(fps + *(ord + 0)),
13192|      0|                                      (files + *(ord + 0))->name);
13193|      0|                if (tmp___9) {
13194|      0|                    tmp___8 = (struct line const *)buffer_linelim(
13195|      0|                                  (struct buffer const *)(buffer + *(ord + 0)));
13196|      0|                    linelim___0 = tmp___8;
13197|      0|                    *(cur + *(ord + 0)) = linelim___0 - 1;
13198|      0|                    *(base + *(ord + 0)) = linelim___0 - (buffer + *(ord + 0))->nlines;
13199|      0|                }
13200|      0|                else {
13201|      0|                    i = (size_t)1;
13202|      0|                    while (1) {
13203|       |
13204|      0|                        if (!(i < nfiles)) {
13205|      0|                            goto while_break___5;
13206|      0|                        }
13207|      0|                        if (*(ord + i) > *(ord + 0)) {
13208|      0|                            (*(ord + i))--;
13209|      0|                        }
13210|      0|                        i++;
13211|      0|                    }
13212|      0|while_break___5:
13213|      0|                    nfiles--;
13214|      0|                    xfclose(*(fps + *(ord + 0)), (files + *(ord + 0))->name);
13215|      0|                    if (*(ord + 0) < ntemps) {
13216|      0|                        ntemps--;
13217|      0|                        zaptemp((files + *(ord + 0))->name);
13218|      0|                    }
13219|      0|                    free((void *)(buffer + *(ord + 0))->buf);
13220|      0|                    i = *(ord + 0);
13221|      0|                    while (1) {
13222|       |
13223|      0|                        if (!(i < nfiles)) {
13224|      0|                            goto while_break___6;
13225|      0|                        }
13226|      0|                        *(fps + i) = *(fps + (i + 1UL));
13227|      0|                        *(files + i) = *(files + (i + 1UL));
13228|      0|                        *(buffer + i) = *(buffer + (i + 1UL));
13229|      0|                        *(cur + i) = *(cur + (i + 1UL));
13230|      0|                        *(base + i) = *(base + (i + 1UL));
13231|      0|                        i++;
13232|      0|                    }
13233|      0|while_break___6:
13234|      0|                    i = (size_t)0;
13235|      0|                    while (1) {
13236|       |
13237|      0|                        if (!(i < nfiles)) {
13238|      0|                            goto while_break___7;
13239|      0|                        }
13240|      0|                        *(ord + i) = *(ord + (i + 1UL));
13241|      0|                        i++;
13242|      0|                    }
13243|      0|while_break___7:
13244|      0|                    ;
13245|      0|                    goto while_continue___3;
13246|      0|                }
13247|      0|            }
13248|      0|            lo = (size_t)1;
13249|      0|            hi = nfiles;
13250|      0|            probe = lo;
13251|      0|            ord0 = *(ord + 0);
13252|      0|            while (1) {
13253|       |
13254|      0|                if (!(lo < hi)) {
13255|      0|                    goto while_break___8;
13256|      0|                }
13257|      0|                tmp___10 = compare(*(cur + ord0), *(cur + *(ord + probe)));
13258|      0|                cmp = tmp___10;
13259|      0|                if (cmp < 0) {
13260|      0|                    hi = probe;
13261|      0|                }
13262|      0|                else {
13263|      0|                    if (cmp == 0) {
13264|      0|                        if (ord0 < *(ord + probe)) {
13265|      0|                            hi = probe;
13266|      0|                        }
13267|      0|                        else {
13268|      0|                            lo = probe + 1UL;
13269|      0|                        }
13270|      0|                    }
13271|      0|                    else {
13272|      0|                        lo = probe + 1UL;
13273|      0|                    }
13274|      0|                }
13275|      0|                probe = (lo + hi) / 2UL;
13276|      0|            }
13277|      0|while_break___8:
13278|      0|            count_of_smaller_lines = lo - 1UL;
13279|      0|            j = (size_t)0;
13280|      0|            while (1) {
13281|       |
13282|      0|                if (!(j < count_of_smaller_lines)) {
13283|      0|                    goto while_break___9;
13284|      0|                }
13285|      0|                *(ord + j) = *(ord + (j + 1UL));
13286|      0|                j++;
13287|      0|            }
13288|      0|while_break___9:
13289|      0|            *(ord + count_of_smaller_lines) = ord0;
13290|      0|        }
13291|      0|while_break___3:
13292|      0|        ;
13293|      0|        if (unique) {
13294|      0|            if (savedline) {
13295|      0|                write_line((struct line const *)(&saved___0), ofp, output_file);
13296|      0|                free((void *)saved___0.text);
13297|      0|            }
13298|      0|        }
13299|      0|        xfclose(ofp, output_file);
13300|      0|        free((void *)fps);
13301|      0|        free((void *)buffer);
13302|      0|        free((void *)ord);
13303|      0|        free((void *)base);
13304|      0|        free((void *)cur);
13305|      0|        return;
13306|      0|    }
13307|      0|}
13308|       |static size_t mergefiles(struct sortfile *files, size_t ntemps, size_t nfiles,
13309|       |                         FILE *ofp, char const *output_file)
13310|      0|{
13311|      0|    FILE **fps;
13312|      0|    size_t nopened;
13313|      0|    size_t tmp;
13314|      0|    char *tmp___0;
13315|       |
13316|      0|    {
13317|      0|        tmp = open_input_files(files, nfiles, &fps);
13318|      0|        nopened = tmp;
13319|      0|        if (nopened < nfiles) {
13320|      0|            if (nopened < 2UL) {
13321|      0|                tmp___0 = gettext("open failed");
13322|      0|                die((char const *)tmp___0, (files + nopened)->name);
13323|      0|            }
13324|      0|        }
13325|      0|        mergefps(files, ntemps, nopened, ofp, output_file, fps);
13326|      0|        return (nopened);
13327|      0|    }
13328|      0|}
13329|       |static void mergelines(struct line *__restrict t, size_t nlines,
13330|       |                       struct line const *__restrict lo)
13331|  8.22k|{
13332|  8.22k|    size_t nlo;
13333|  8.22k|    size_t nhi;
13334|  8.22k|    struct line *hi;
13335|  8.22k|    int tmp;
13336|       |
13337|  8.22k|    {
13338|  8.22k|        nlo = nlines / 2UL;
13339|  8.22k|        nhi = nlines - nlo;
13340|  8.22k|        hi = (struct line *)(t - nlo);
13341|   173k|        while (1) {
13342|   173k|            tmp =
13343|   173k|                compare((struct line const *)(lo - 1), (struct line const *)(hi - 1));
13344|   173k|            if (tmp <= 0) {
13345|  86.4k|                t--;
13346|  86.4k|                lo--;
13347|  86.4k|                *t = (struct line) * lo;
13348|  86.4k|                nlo--;
13349|  86.4k|                if (!nlo) {
13350|  4.60k|                    return;
13351|  4.60k|                }
13352|  86.4k|            }
13353|  86.7k|            else {
13354|  86.7k|                t--;
13355|  86.7k|                hi--;
13356|  86.7k|                *t = *hi;
13357|  86.7k|                nhi--;
13358|  86.7k|                if (!nhi) {
13359|  5.75k|                    while (1) {
13360|  5.75k|                        t--;
13361|  5.75k|                        lo--;
13362|  5.75k|                        *t = (struct line) * lo;
13363|  5.75k|                        nlo--;
13364|  5.75k|                        if (!nlo) {
13365|  3.61k|                            goto while_break___0;
13366|  3.61k|                        }
13367|  5.75k|                    }
13368|  3.61k|while_break___0:
13369|  3.61k|                    ;
13370|  3.61k|                    return;
13371|  3.61k|                }
13372|  86.7k|            }
13373|   173k|        }
13374|       |
13375|      0|        return;
13376|  8.22k|    }
13377|  8.22k|}
13378|       |static void sequential_sort(struct line *__restrict lines, size_t nlines,
13379|       |                            struct line *__restrict temp, _Bool to_temp)
13380|  15.6k|{
13381|  15.6k|    int swap___1;
13382|  15.6k|    int tmp;
13383|  15.6k|    size_t nlo;
13384|  15.6k|    size_t nhi;
13385|  15.6k|    struct line *lo;
13386|  15.6k|    struct line *hi;
13387|  15.6k|    size_t tmp___0;
13388|  15.6k|    struct line *dest;
13389|  15.6k|    struct line const *sorted_lo;
13390|       |
13391|  15.6k|    {
13392|  15.6k|        if (nlines == 2UL) {
13393|  7.43k|            tmp = compare((struct line const *)(lines + -1),
13394|  7.43k|                          (struct line const *)(lines + -2));
13395|  7.43k|            swap___1 = 0 < tmp;
13396|  7.43k|            if (to_temp) {
13397|  3.71k|                *(temp + -1) = *(lines + (-1 - swap___1));
13398|  3.71k|                *(temp + -2) = *(lines + (-2 + swap___1));
13399|  3.71k|            }
13400|  3.71k|            else {
13401|  3.71k|                if (swap___1) {
13402|  1.68k|                    *(temp + -1) = *(lines + -1);
13403|  1.68k|                    *(lines + -1) = *(lines + -2);
13404|  1.68k|                    *(lines + -2) = *(temp + -1);
13405|  1.68k|                }
13406|  3.71k|            }
13407|  7.43k|        }
13408|  8.22k|        else {
13409|  8.22k|            nlo = nlines / 2UL;
13410|  8.22k|            nhi = nlines - nlo;
13411|  8.22k|            lo = (struct line *)lines;
13412|  8.22k|            hi = (struct line *)(lines - nlo);
13413|  8.22k|            if (to_temp) {
13414|  4.10k|                tmp___0 = nlo;
13415|  4.10k|            }
13416|  4.11k|            else {
13417|  4.11k|                tmp___0 = (size_t)0;
13418|  4.11k|            }
13419|  8.22k|            sequential_sort(hi, nhi, temp - tmp___0, to_temp);
13420|  8.22k|            if (1UL < nlo) {
13421|  7.42k|                sequential_sort(lo, nlo, temp, (_Bool)(!to_temp));
13422|  7.42k|            }
13423|    793|            else {
13424|    793|                if (!to_temp) {
13425|    396|                    *(temp + -1) = *(lo + -1);
13426|    396|                }
13427|    793|            }
13428|  8.22k|            if (to_temp) {
13429|  4.10k|                dest = (struct line *)temp;
13430|  4.10k|                sorted_lo = (struct line const *)lines;
13431|  4.10k|            }
13432|  4.11k|            else {
13433|  4.11k|                dest = (struct line *)lines;
13434|  4.11k|                sorted_lo = (struct line const *)temp;
13435|  4.11k|            }
13436|  8.22k|            mergelines(dest, nlines, sorted_lo);
13437|  8.22k|        }
13438|  15.6k|        return;
13439|  15.6k|    }
13440|  15.6k|}
13441|       |static struct merge_node *init_node(struct merge_node *__restrict parent,
13442|       |                                    struct merge_node *__restrict node_pool,
13443|       |                                    struct line *dest, size_t nthreads,
13444|       |                                    size_t total_lines, _Bool is_lo_child);
13445|       |static struct merge_node *merge_tree_init(size_t nthreads, size_t nlines,
13446|       |        struct line *dest)
13447|      2|{
13448|      2|    struct merge_node *merge_tree;
13449|      2|    struct merge_node *tmp;
13450|      2|    struct merge_node *root;
13451|      2|    struct line *tmp___0;
13452|      2|    struct line *tmp___1;
13453|      2|    struct line *tmp___2;
13454|      2|    size_t tmp___3;
13455|       |
13456|      2|    {
13457|      2|        tmp = (struct merge_node *)xmalloc((2UL * sizeof(*merge_tree)) * nthreads);
13458|      2|        merge_tree = tmp;
13459|      2|        root = merge_tree;
13460|      2|        tmp___2 = (struct line *)((void *)0);
13461|      2|        root->end_hi = tmp___2;
13462|      2|        tmp___1 = tmp___2;
13463|      2|        root->end_lo = tmp___1;
13464|      2|        tmp___0 = tmp___1;
13465|      2|        root->hi = tmp___0;
13466|      2|        root->lo = tmp___0;
13467|      2|        root->dest = (struct line **)((void *)0);
13468|      2|        tmp___3 = nlines;
13469|      2|        root->nhi = tmp___3;
13470|      2|        root->nlo = tmp___3;
13471|      2|        root->parent = (struct merge_node *)((void *)0);
13472|      2|        root->level = 0U;
13473|      2|        root->queued = (_Bool)0;
13474|      2|        pthread_mutex_init(&root->lock, (pthread_mutexattr_t const *)((void *)0));
13475|      2|        init_node(root, root + 1, dest, nthreads, nlines, (_Bool)0);
13476|      2|        return (merge_tree);
13477|      2|    }
13478|      2|}
13479|       |static void merge_tree_destroy(struct merge_node *merge_tree)
13480|      2|{
13481|       |
13482|      2|    {
13483|      2|        free((void *)merge_tree);
13484|      2|        return;
13485|      2|    }
13486|      2|}
13487|       |static struct merge_node *init_node(struct merge_node *__restrict parent,
13488|       |                                    struct merge_node *__restrict node_pool,
13489|       |                                    struct line *dest, size_t nthreads,
13490|       |                                    size_t total_lines, _Bool is_lo_child)
13491|     30|{
13492|     30|    size_t nlines;
13493|     30|    size_t tmp;
13494|     30|    size_t nlo;
13495|     30|    size_t nhi;
13496|     30|    struct line *lo;
13497|     30|    struct line *hi;
13498|     30|    struct line **parent_end;
13499|     30|    struct line **tmp___0;
13500|     30|    struct merge_node *node;
13501|     30|    struct merge_node *__restrict tmp___1;
13502|     30|    struct line *tmp___2;
13503|     30|    struct line *tmp___3;
13504|     30|    size_t lo_threads;
13505|     30|    size_t hi_threads;
13506|     30|    struct merge_node *tmp___4;
13507|     30|    struct merge_node *tmp___5;
13508|       |
13509|     30|    {
13510|     30|        if (is_lo_child) {
13511|     14|            tmp = parent->nlo;
13512|     14|        }
13513|     16|        else {
13514|     16|            tmp = parent->nhi;
13515|     16|        }
13516|     30|        nlines = tmp;
13517|     30|        nlo = nlines / 2UL;
13518|     30|        nhi = nlines - nlo;
13519|     30|        lo = dest - total_lines;
13520|     30|        hi = lo - nlo;
13521|     30|        if (is_lo_child) {
13522|     14|            tmp___0 = &parent->end_lo;
13523|     14|        }
13524|     16|        else {
13525|     16|            tmp___0 = &parent->end_hi;
13526|     16|        }
13527|     30|        parent_end = tmp___0;
13528|     30|        tmp___1 = node_pool;
13529|     30|        node_pool++;
13530|     30|        node = (struct merge_node *)tmp___1;
13531|     30|        tmp___2 = lo;
13532|     30|        node->end_lo = tmp___2;
13533|     30|        node->lo = tmp___2;
13534|     30|        tmp___3 = hi;
13535|     30|        node->end_hi = tmp___3;
13536|     30|        node->hi = tmp___3;
13537|     30|        node->dest = parent_end;
13538|     30|        node->nlo = nlo;
13539|     30|        node->nhi = nhi;
13540|     30|        node->parent = (struct merge_node *)parent;
13541|     30|        node->level = parent->level + 1U;
13542|     30|        node->queued = (_Bool)0;
13543|     30|        pthread_mutex_init(&node->lock, (pthread_mutexattr_t const *)((void *)0));
13544|     30|        if (nthreads > 1UL) {
13545|     14|            lo_threads = nthreads / 2UL;
13546|     14|            hi_threads = nthreads - lo_threads;
13547|     14|            node->lo_child = (struct merge_node *)node_pool;
13548|     14|            tmp___4 =
13549|     14|                init_node(node, node_pool, lo, lo_threads, total_lines, (_Bool)1);
13550|     14|            node_pool = tmp___4;
13551|     14|            node->hi_child = (struct merge_node *)node_pool;
13552|     14|            tmp___5 =
13553|     14|                init_node(node, node_pool, hi, hi_threads, total_lines, (_Bool)0);
13554|     14|            node_pool = tmp___5;
13555|     14|        }
13556|     16|        else {
13557|     16|            node->lo_child = (struct merge_node *)((void *)0);
13558|     16|            node->hi_child = (struct merge_node *)((void *)0);
13559|     16|        }
13560|     30|        return ((struct merge_node *)node_pool);
13561|     30|    }
13562|     30|}
13563|       |static int compare_nodes(void const *a, void const *b)
13564|      0|{
13565|      0|    struct merge_node const *nodea;
13566|      0|    struct merge_node const *nodeb;
13567|       |
13568|      0|    {
13569|      0|        nodea = (struct merge_node const *)a;
13570|      0|        nodeb = (struct merge_node const *)b;
13571|      0|        if (nodea->level == nodeb->level) {
13572|      0|            return (nodea->nlo + nodea->nhi < nodeb->nlo + nodeb->nhi);
13573|      0|        }
13574|      0|        return (nodea->level < nodeb->level);
13575|      0|    }
13576|      0|}
13577|       |__inline static void lock_node(struct merge_node *node)
13578|     33|{
13579|       |
13580|     33|    {
13581|     33|        pthread_mutex_lock(&node->lock);
13582|     33|        return;
13583|     33|    }
13584|     33|}
13585|       |__inline static void unlock_node(struct merge_node *node)
13586|     33|{
13587|       |
13588|     33|    {
13589|     33|        pthread_mutex_unlock(&node->lock);
13590|     33|        return;
13591|     33|    }
13592|     33|}
13593|       |static void queue_destroy(struct merge_node_queue *queue)
13594|      2|{
13595|       |
13596|      2|    {
13597|      2|        heap_free(queue->priority_queue);
13598|      2|        pthread_cond_destroy(&queue->cond);
13599|      2|        pthread_mutex_destroy(&queue->mutex);
13600|      2|        return;
13601|      2|    }
13602|      2|}
13603|       |static void queue_init(struct merge_node_queue *queue, size_t nthreads)
13604|      2|{
13605|       |
13606|      2|    {
13607|      2|        queue->priority_queue = heap_alloc(&compare_nodes, 2UL * nthreads);
13608|      2|        pthread_mutex_init(&queue->mutex, (pthread_mutexattr_t const *)((void *)0));
13609|      2|        pthread_cond_init(&queue->cond, (pthread_condattr_t const *)((void *)0));
13610|      2|        return;
13611|      2|    }
13612|      2|}
13613|       |static void queue_insert(struct merge_node_queue *queue,
13614|       |                         struct merge_node *node)
13615|     35|{
13616|       |
13617|     35|    {
13618|     35|        pthread_mutex_lock(&queue->mutex);
13619|     35|        heap_insert(queue->priority_queue, (void *)node);
13620|     35|        node->queued = (_Bool)1;
13621|     35|        pthread_mutex_unlock(&queue->mutex);
13622|     35|        pthread_cond_signal(&queue->cond);
13623|     35|        return;
13624|     35|    }
13625|     35|}
13626|       |static struct merge_node *queue_pop(struct merge_node_queue *queue)
13627|     33|{
13628|     33|    struct merge_node *node;
13629|       |
13630|     33|    {
13631|     33|        pthread_mutex_lock(&queue->mutex);
13632|     33|        while (1) {
13633|     33|            node = (struct merge_node *)heap_remove_top(queue->priority_queue);
13634|     33|            if (node) {
13635|     33|                goto while_break;
13636|     33|            }
13637|      0|            pthread_cond_wait(&queue->cond, &queue->mutex);
13638|      0|        }
13639|     33|while_break:
13640|     33|        pthread_mutex_unlock(&queue->mutex);
13641|     33|        lock_node(node);
13642|     33|        node->queued = (_Bool)0;
13643|     33|        return (node);
13644|     33|    }
13645|     33|}
13646|       |static struct line saved;
13647|       |static void write_unique(struct line const *line, FILE *tfp,
13648|       |                         char const *temp_output)
13649|  15.6k|{
13650|  15.6k|    int tmp;
13651|       |
13652|  15.6k|    {
13653|  15.6k|        if (unique) {
13654|      0|            if (saved.text) {
13655|      0|                tmp = compare(line, (struct line const *)(&saved));
13656|      0|                if (!tmp) {
13657|      0|                    return;
13658|      0|                }
13659|      0|            }
13660|      0|            saved = (struct line) * line;
13661|      0|        }
13662|  15.6k|        write_line(line, tfp, temp_output);
13663|  15.6k|        return;
13664|  15.6k|    }
13665|  15.6k|}
13666|       |static void mergelines_node(struct merge_node *__restrict node,
13667|       |                            size_t total_lines, FILE *tfp,
13668|       |                            char const *temp_output)
13669|     31|{
13670|     31|    struct line *lo_orig;
13671|     31|    struct line *hi_orig;
13672|     31|    size_t to_merge;
13673|     31|    size_t merged_lo;
13674|     31|    size_t merged_hi;
13675|     31|    struct line *dest;
13676|     31|    int tmp;
13677|     31|    size_t tmp___0;
13678|     31|    size_t tmp___1;
13679|     31|    size_t tmp___2;
13680|     31|    int tmp___3;
13681|     31|    size_t tmp___4;
13682|     31|    size_t tmp___5;
13683|     31|    size_t tmp___6;
13684|       |
13685|     31|    {
13686|     31|        lo_orig = node->lo;
13687|     31|        hi_orig = node->hi;
13688|     31|        to_merge = (total_lines >> 2U * (node->level + 1U)) + 1UL;
13689|     31|        if (node->level > 1U) {
13690|      0|            dest = *(node->dest);
13691|      0|            while (1) {
13692|       |
13693|      0|                if ((unsigned long)node->lo != (unsigned long)node->end_lo) {
13694|      0|                    if ((unsigned long)node->hi != (unsigned long)node->end_hi) {
13695|      0|                        tmp___0 = to_merge;
13696|      0|                        to_merge--;
13697|      0|                        if (!tmp___0) {
13698|      0|                            goto while_break;
13699|      0|                        }
13700|      0|                    }
13701|      0|                    else {
13702|      0|                        goto while_break;
13703|      0|                    }
13704|      0|                }
13705|      0|                else {
13706|      0|                    goto while_break;
13707|      0|                }
13708|      0|                tmp = compare((struct line const *)(node->lo - 1),
13709|      0|                              (struct line const *)(node->hi - 1));
13710|      0|                if (tmp <= 0) {
13711|      0|                    dest--;
13712|      0|                    (node->lo)--;
13713|      0|                    *dest = *(node->lo);
13714|      0|                }
13715|      0|                else {
13716|      0|                    dest--;
13717|      0|                    (node->hi)--;
13718|      0|                    *dest = *(node->hi);
13719|      0|                }
13720|      0|            }
13721|      0|while_break:
13722|      0|            merged_lo = (size_t)(lo_orig - node->lo);
13723|      0|            merged_hi = (size_t)(hi_orig - node->hi);
13724|      0|            if (node->nhi == merged_hi) {
13725|      0|                while (1) {
13726|       |
13727|      0|                    if ((unsigned long)node->lo != (unsigned long)node->end_lo) {
13728|      0|                        tmp___1 = to_merge;
13729|      0|                        to_merge--;
13730|      0|                        if (!tmp___1) {
13731|      0|                            goto while_break___0;
13732|      0|                        }
13733|      0|                    }
13734|      0|                    else {
13735|      0|                        goto while_break___0;
13736|      0|                    }
13737|      0|                    dest--;
13738|      0|                    (node->lo)--;
13739|      0|                    *dest = *(node->lo);
13740|      0|                }
13741|      0|while_break___0:
13742|      0|                ;
13743|      0|            }
13744|      0|            else {
13745|      0|                if (node->nlo == merged_lo) {
13746|      0|                    while (1) {
13747|       |
13748|      0|                        if ((unsigned long)node->hi != (unsigned long)node->end_hi) {
13749|      0|                            tmp___2 = to_merge;
13750|      0|                            to_merge--;
13751|      0|                            if (!tmp___2) {
13752|      0|                                goto while_break___1;
13753|      0|                            }
13754|      0|                        }
13755|      0|                        else {
13756|      0|                            goto while_break___1;
13757|      0|                        }
13758|      0|                        dest--;
13759|      0|                        (node->hi)--;
13760|      0|                        *dest = *(node->hi);
13761|      0|                    }
13762|      0|while_break___1:
13763|      0|                    ;
13764|      0|                }
13765|      0|            }
13766|      0|            *(node->dest) = dest;
13767|      0|        }
13768|     31|        else {
13769|  15.6k|            while (1) {
13770|       |
13771|  15.6k|                if ((unsigned long)node->lo != (unsigned long)node->end_lo) {
13772|  15.6k|                    if ((unsigned long)node->hi != (unsigned long)node->end_hi) {
13773|  15.6k|                        tmp___4 = to_merge;
13774|  15.6k|                        to_merge--;
13775|  15.6k|                        if (!tmp___4) {
13776|     24|                            goto while_break___2;
13777|     24|                        }
13778|  15.6k|                    }
13779|      6|                    else {
13780|      6|                        goto while_break___2;
13781|      6|                    }
13782|  15.6k|                }
13783|      1|                else {
13784|      1|                    goto while_break___2;
13785|      1|                }
13786|  15.6k|                tmp___3 = compare((struct line const *)(node->lo - 1),
13787|  15.6k|                                  (struct line const *)(node->hi - 1));
13788|  15.6k|                if (tmp___3 <= 0) {
13789|  7.80k|                    (node->lo)--;
13790|  7.80k|                    write_unique((struct line const *)node->lo, tfp, temp_output);
13791|  7.80k|                }
13792|  7.82k|                else {
13793|  7.82k|                    (node->hi)--;
13794|  7.82k|                    write_unique((struct line const *)node->hi, tfp, temp_output);
13795|  7.82k|                }
13796|  15.6k|            }
13797|     31|while_break___2:
13798|     31|            merged_lo = (size_t)(lo_orig - node->lo);
13799|     31|            merged_hi = (size_t)(hi_orig - node->hi);
13800|     31|            if (node->nhi == merged_hi) {
13801|     26|                while (1) {
13802|       |
13803|     26|                    if ((unsigned long)node->lo != (unsigned long)node->end_lo) {
13804|     25|                        tmp___5 = to_merge;
13805|     25|                        to_merge--;
13806|     25|                        if (!tmp___5) {
13807|      5|                            goto while_break___3;
13808|      5|                        }
13809|     25|                    }
13810|      1|                    else {
13811|      1|                        goto while_break___3;
13812|      1|                    }
13813|     20|                    (node->lo)--;
13814|     20|                    write_unique((struct line const *)node->lo, tfp, temp_output);
13815|     20|                }
13816|      6|while_break___3:
13817|      6|                ;
13818|      6|            }
13819|     25|            else {
13820|     25|                if (node->nlo == merged_lo) {
13821|      6|                    while (1) {
13822|       |
13823|      6|                        if ((unsigned long)node->hi != (unsigned long)node->end_hi) {
13824|      5|                            tmp___6 = to_merge;
13825|      5|                            to_merge--;
13826|      5|                            if (!tmp___6) {
13827|      0|                                goto while_break___4;
13828|      0|                            }
13829|      5|                        }
13830|      1|                        else {
13831|      1|                            goto while_break___4;
13832|      1|                        }
13833|      5|                        (node->hi)--;
13834|      5|                        write_unique((struct line const *)node->hi, tfp, temp_output);
13835|      5|                    }
13836|      1|while_break___4:
13837|      1|                    ;
13838|      1|                }
13839|     25|            }
13840|     31|        }
13841|     31|        merged_lo = (size_t)(lo_orig - node->lo);
13842|     31|        merged_hi = (size_t)(hi_orig - node->hi);
13843|     31|        node->nlo -= merged_lo;
13844|     31|        node->nhi -= merged_hi;
13845|     31|        return;
13846|     31|    }
13847|     31|}
13848|       |static void queue_check_insert(struct merge_node_queue *queue,
13849|       |                               struct merge_node *node)
13850|     31|{
13851|     31|    _Bool lo_avail;
13852|     31|    _Bool hi_avail;
13853|     31|    int tmp;
13854|     31|    int tmp___0;
13855|     31|    int tmp___1;
13856|       |
13857|     31|    {
13858|     31|        if (!node->queued) {
13859|     31|            lo_avail = (_Bool)(node->lo - node->end_lo != 0L);
13860|     31|            hi_avail = (_Bool)(node->hi - node->end_hi != 0L);
13861|     31|            if (lo_avail) {
13862|     29|                if (hi_avail) {
13863|     24|                    tmp = 1;
13864|     24|                }
13865|      5|                else {
13866|      5|                    if (!node->nhi) {
13867|      5|                        tmp = 1;
13868|      5|                    }
13869|      0|                    else {
13870|      0|                        tmp = 0;
13871|      0|                    }
13872|      5|                }
13873|     29|                tmp___1 = tmp;
13874|     29|            }
13875|      2|            else {
13876|      2|                if (hi_avail) {
13877|      0|                    if (!node->nlo) {
13878|      0|                        tmp___0 = 1;
13879|      0|                    }
13880|      0|                    else {
13881|      0|                        tmp___0 = 0;
13882|      0|                    }
13883|      0|                }
13884|      2|                else {
13885|      2|                    tmp___0 = 0;
13886|      2|                }
13887|      2|                tmp___1 = tmp___0;
13888|      2|            }
13889|     31|            if (tmp___1) {
13890|     29|                queue_insert(queue, node);
13891|     29|            }
13892|     31|        }
13893|     31|        return;
13894|     31|    }
13895|     31|}
13896|       |static void queue_check_insert_parent(struct merge_node_queue *queue,
13897|       |                                      struct merge_node *node)
13898|     31|{
13899|       |
13900|     31|    {
13901|     31|        if (node->level > 1U) {
13902|      0|            lock_node(node->parent);
13903|      0|            queue_check_insert(queue, node->parent);
13904|      0|            unlock_node(node->parent);
13905|      0|        }
13906|     31|        else {
13907|     31|            if (node->nlo + node->nhi == 0UL) {
13908|      2|                queue_insert(queue, node->parent);
13909|      2|            }
13910|     31|        }
13911|     31|        return;
13912|     31|    }
13913|     31|}
13914|       |static void merge_loop(struct merge_node_queue *queue, size_t total_lines,
13915|       |                       FILE *tfp, char const *temp_output)
13916|      2|{
13917|      2|    struct merge_node *node;
13918|      2|    struct merge_node *tmp;
13919|       |
13920|      2|    {
13921|     33|        while (1) {
13922|     33|            tmp = queue_pop(queue);
13923|     33|            node = tmp;
13924|     33|            if (node->level == 0U) {
13925|      2|                unlock_node(node);
13926|      2|                queue_insert(queue, node);
13927|      2|                goto while_break;
13928|      2|            }
13929|     31|            mergelines_node(node, total_lines, tfp, temp_output);
13930|     31|            queue_check_insert(queue, node);
13931|     31|            queue_check_insert_parent(queue, node);
13932|     31|            unlock_node(node);
13933|     31|        }
13934|      2|while_break:
13935|      2|        ;
13936|      2|        return;
13937|      2|    }
13938|      2|}
13939|       |static void sortlines(struct line *__restrict lines, size_t nthreads,
13940|       |                      size_t total_lines, struct merge_node *node,
13941|       |                      struct merge_node_queue *queue, FILE *tfp,
13942|       |                      char const *temp_output);
13943|       |static void *sortlines_thread(void *data)
13944|      0|{
13945|      0|    struct thread_args const *args;
13946|       |
13947|      0|    {
13948|      0|        args = (struct thread_args const *)data;
13949|      0|        sortlines((struct line *)args->lines, (size_t)args->nthreads,
13950|      0|                  (size_t)args->total_lines, (struct merge_node *)args->node,
13951|      0|                  (struct merge_node_queue *)args->queue, (FILE *)args->tfp,
13952|      0|                  (char const *)args->output_temp);
13953|      0|        return ((void *)0);
13954|      0|    }
13955|      0|}
13956|       |static void sortlines(struct line *__restrict lines, size_t nthreads,
13957|       |                      size_t total_lines, struct merge_node *node,
13958|       |                      struct merge_node_queue *queue, FILE *tfp,
13959|       |                      char const *temp_output)
13960|      2|{
13961|      2|    size_t nlines;
13962|      2|    size_t lo_threads;
13963|      2|    size_t hi_threads;
13964|      2|    pthread_t thread;
13965|      2|    struct thread_args args;
13966|      2|    size_t nlo;
13967|      2|    size_t nhi;
13968|      2|    struct line *temp;
13969|      2|    int tmp;
13970|       |
13971|      2|    {
13972|      2|        nlines = node->nlo + node->nhi;
13973|      2|        lo_threads = nthreads / 2UL;
13974|      2|        hi_threads = nthreads - lo_threads;
13975|      2|        args.lines = (struct line *)lines;
13976|      2|        args.nthreads = lo_threads;
13977|      2|        args.total_lines = total_lines;
13978|      2|        args.node = node->lo_child;
13979|      2|        args.queue = queue;
13980|      2|        args.tfp = tfp;
13981|      2|        args.output_temp = temp_output;
13982|      2|        if (nthreads > 1UL) {
13983|      2|            if (131072UL <= nlines) {
13984|      0|                tmp = pthread_create(&thread, (pthread_attr_t const *)((void *)0),
13985|      0|                                     &sortlines_thread, (void *)(&args));
13986|      0|                if (tmp == 0) {
13987|      0|                    sortlines(lines - node->nlo, hi_threads, total_lines, node->hi_child,
13988|      0|                              queue, tfp, temp_output);
13989|      0|                    pthread_join(thread, (void **)((void *)0));
13990|      0|                }
13991|      0|                else {
13992|      0|                    goto _L___0;
13993|      0|                }
13994|      0|            }
13995|      2|            else {
13996|      2|                goto _L___0;
13997|      2|            }
13998|      2|        }
13999|      0|        else {
14000|      2|_L___0:
14001|      2|            nlo = node->nlo;
14002|      2|            nhi = node->nhi;
14003|      2|            temp = (struct line *)(lines - total_lines);
14004|      2|            if (1UL < nhi) {
14005|      2|                sequential_sort(lines - nlo, nhi, temp - nlo / 2UL, (_Bool)0);
14006|      2|            }
14007|      2|            if (1UL < nlo) {
14008|      2|                sequential_sort(lines, nlo, temp, (_Bool)0);
14009|      2|            }
14010|      2|            node->lo = (struct line *)lines;
14011|      2|            node->hi = (struct line *)(lines - nlo);
14012|      2|            node->end_lo = (struct line *)(lines - nlo);
14013|      2|            node->end_hi = (struct line *)((lines - nlo) - nhi);
14014|      2|            queue_insert(queue, node);
14015|      2|            merge_loop(queue, total_lines, tfp, temp_output);
14016|      2|        }
14017|      2|        pthread_mutex_destroy(&node->lock);
14018|      2|        return;
14019|      2|    }
14020|      2|}
14021|       |static void avoid_trashing_input(struct sortfile *files, size_t ntemps,
14022|       |                                 size_t nfiles, char const *outfile)
14023|      0|{
14024|      0|    size_t i;
14025|      0|    _Bool got_outstat;
14026|      0|    struct stat outstat;
14027|      0|    struct tempnode *tempcopy;
14028|      0|    _Bool is_stdin;
14029|      0|    int tmp;
14030|      0|    _Bool same;
14031|      0|    struct stat instat;
14032|      0|    int tmp___0;
14033|      0|    int tmp___1;
14034|      0|    int tmp___2;
14035|      0|    int tmp___3;
14036|      0|    int tmp___4;
14037|      0|    int tmp___5;
14038|      0|    int tmp___6;
14039|      0|    int tmp___7;
14040|      0|    FILE *tftp;
14041|       |
14042|      0|    {
14043|      0|        got_outstat = (_Bool)0;
14044|      0|        tempcopy = (struct tempnode *)((void *)0);
14045|      0|        i = ntemps;
14046|      0|        while (1) {
14047|       |
14048|      0|            if (!(i < nfiles)) {
14049|      0|                goto while_break;
14050|      0|            }
14051|      0|            tmp = strcmp((files + i)->name, "-");
14052|      0|            is_stdin = (_Bool)(tmp == 0);
14053|      0|            if (outfile) {
14054|      0|                tmp___7 = strcmp(outfile, (files + i)->name);
14055|      0|                if (tmp___7 == 0) {
14056|      0|                    if (!is_stdin) {
14057|      0|                        same = (_Bool)1;
14058|      0|                    }
14059|      0|                    else {
14060|      0|                        goto _L___0;
14061|      0|                    }
14062|      0|                }
14063|      0|                else {
14064|      0|                    goto _L___0;
14065|      0|                }
14066|      0|            }
14067|      0|            else {
14068|      0|_L___0:
14069|      0|                if (!got_outstat) {
14070|      0|                    if (outfile) {
14071|      0|                        tmp___0 = stat(outfile, &outstat);
14072|      0|                        tmp___2 = tmp___0;
14073|      0|                    }
14074|      0|                    else {
14075|      0|                        tmp___1 = fstat(1, &outstat);
14076|      0|                        tmp___2 = tmp___1;
14077|      0|                    }
14078|      0|                    if (tmp___2 != 0) {
14079|      0|                        goto while_break;
14080|      0|                    }
14081|      0|                    got_outstat = (_Bool)1;
14082|      0|                }
14083|      0|                if (is_stdin) {
14084|      0|                    tmp___3 = fstat(0, &instat);
14085|      0|                    tmp___5 = tmp___3;
14086|      0|                }
14087|      0|                else {
14088|      0|                    tmp___4 = stat((files + i)->name, &instat);
14089|      0|                    tmp___5 = tmp___4;
14090|      0|                }
14091|      0|                if (tmp___5 == 0) {
14092|      0|                    if (instat.st_ino == outstat.st_ino) {
14093|      0|                        if (instat.st_dev == outstat.st_dev) {
14094|      0|                            tmp___6 = 1;
14095|      0|                        }
14096|      0|                        else {
14097|      0|                            tmp___6 = 0;
14098|      0|                        }
14099|      0|                    }
14100|      0|                    else {
14101|      0|                        tmp___6 = 0;
14102|      0|                    }
14103|      0|                }
14104|      0|                else {
14105|      0|                    tmp___6 = 0;
14106|      0|                }
14107|      0|                same = (_Bool)tmp___6;
14108|      0|            }
14109|      0|            if (same) {
14110|      0|                if (!tempcopy) {
14111|      0|                    tempcopy = create_temp(&tftp);
14112|      0|                    mergefiles(files + i, (size_t)0, (size_t)1, tftp,
14113|      0|                               (char const *)(tempcopy->name));
14114|      0|                }
14115|      0|                (files + i)->name = (char const *)(tempcopy->name);
14116|      0|                (files + i)->temp = tempcopy;
14117|      0|            }
14118|      0|            i++;
14119|      0|        }
14120|      0|while_break:
14121|      0|        ;
14122|      0|        return;
14123|      0|    }
14124|      0|}
14125|       |static void merge(struct sortfile *files, size_t ntemps, size_t nfiles,
14126|       |                  char const *output_file)
14127|      0|{
14128|      0|    size_t in;
14129|      0|    size_t out;
14130|      0|    size_t remainder;
14131|      0|    size_t cheap_slots;
14132|      0|    FILE *tfp;
14133|      0|    struct tempnode *temp;
14134|      0|    struct tempnode *tmp;
14135|      0|    size_t num_merged;
14136|      0|    size_t tmp___0;
14137|      0|    size_t tmp___1;
14138|      0|    size_t tmp___2;
14139|      0|    size_t nshortmerge;
14140|      0|    FILE *tfp___0;
14141|      0|    struct tempnode *temp___0;
14142|      0|    struct tempnode *tmp___3;
14143|      0|    size_t num_merged___0;
14144|      0|    size_t tmp___4;
14145|      0|    size_t tmp___5;
14146|      0|    size_t tmp___6;
14147|      0|    size_t tmp___7;
14148|      0|    FILE **fps;
14149|      0|    size_t nopened;
14150|      0|    size_t tmp___8;
14151|      0|    FILE *ofp;
14152|      0|    FILE *tmp___9;
14153|      0|    char *tmp___10;
14154|      0|    int *tmp___11;
14155|      0|    char *tmp___12;
14156|      0|    FILE *tfp___1;
14157|      0|    struct tempnode *temp___1;
14158|      0|    size_t tmp___13;
14159|      0|    size_t tmp___14;
14160|       |
14161|      0|    {
14162|      0|        while (1) {
14163|       |
14164|      0|            if (!((size_t)nmerge < nfiles)) {
14165|      0|                goto while_break;
14166|      0|            }
14167|      0|            in = (size_t)0;
14168|      0|            out = in;
14169|      0|            while (1) {
14170|       |
14171|      0|                if (!((size_t)nmerge <= nfiles - in)) {
14172|      0|                    goto while_break___0;
14173|      0|                }
14174|      0|                tmp = create_temp(&tfp);
14175|      0|                temp = tmp;
14176|      0|                if (ntemps < (size_t)nmerge) {
14177|      0|                    tmp___0 = ntemps;
14178|      0|                }
14179|      0|                else {
14180|      0|                    tmp___0 = (size_t)nmerge;
14181|      0|                }
14182|      0|                tmp___1 = mergefiles(files + in, tmp___0, (size_t)nmerge, tfp,
14183|      0|                                     (char const *)(temp->name));
14184|      0|                num_merged = tmp___1;
14185|      0|                if (ntemps < num_merged) {
14186|      0|                    tmp___2 = ntemps;
14187|      0|                }
14188|      0|                else {
14189|      0|                    tmp___2 = num_merged;
14190|      0|                }
14191|      0|                ntemps -= tmp___2;
14192|      0|                (files + out)->name = (char const *)(temp->name);
14193|      0|                (files + out)->temp = temp;
14194|      0|                in += num_merged;
14195|      0|                out++;
14196|      0|            }
14197|      0|while_break___0:
14198|      0|            remainder = nfiles - in;
14199|      0|            cheap_slots = (unsigned long)nmerge - out % (unsigned long)nmerge;
14200|      0|            if (cheap_slots < remainder) {
14201|      0|                nshortmerge = (remainder - cheap_slots) + 1UL;
14202|      0|                tmp___3 = create_temp(&tfp___0);
14203|      0|                temp___0 = tmp___3;
14204|      0|                if (ntemps < nshortmerge) {
14205|      0|                    tmp___4 = ntemps;
14206|      0|                }
14207|      0|                else {
14208|      0|                    tmp___4 = nshortmerge;
14209|      0|                }
14210|      0|                tmp___5 = mergefiles(files + in, tmp___4, nshortmerge, tfp___0,
14211|      0|                                     (char const *)(temp___0->name));
14212|      0|                num_merged___0 = tmp___5;
14213|      0|                if (ntemps < num_merged___0) {
14214|      0|                    tmp___6 = ntemps;
14215|      0|                }
14216|      0|                else {
14217|      0|                    tmp___6 = num_merged___0;
14218|      0|                }
14219|      0|                ntemps -= tmp___6;
14220|      0|                (files + out)->name = (char const *)(temp___0->name);
14221|      0|                tmp___7 = out;
14222|      0|                out++;
14223|      0|                (files + tmp___7)->temp = temp___0;
14224|      0|                in += num_merged___0;
14225|      0|            }
14226|      0|            memmove((void *)(files + out), (void const *)(files + in),
14227|      0|                    (nfiles - in) * sizeof(*files));
14228|      0|            ntemps += out;
14229|      0|            nfiles -= in - out;
14230|      0|        }
14231|      0|while_break:
14232|      0|        avoid_trashing_input(files, ntemps, nfiles, output_file);
14233|      0|        while (1) {
14234|      0|            tmp___8 = open_input_files(files, nfiles, &fps);
14235|      0|            nopened = tmp___8;
14236|      0|            if (nopened == nfiles) {
14237|      0|                tmp___9 = stream_open(output_file, "w");
14238|      0|                ofp = tmp___9;
14239|      0|                if (ofp) {
14240|      0|                    mergefps(files, ntemps, nfiles, ofp, output_file, fps);
14241|      0|                    goto while_break___1;
14242|      0|                }
14243|      0|                tmp___11 = __errno_location();
14244|      0|                if (*tmp___11 != 24) {
14245|      0|                    tmp___10 = gettext("open failed");
14246|      0|                    die((char const *)tmp___10, output_file);
14247|      0|                }
14248|      0|                else {
14249|      0|                    if (nopened <= 2UL) {
14250|      0|                        tmp___10 = gettext("open failed");
14251|      0|                        die((char const *)tmp___10, output_file);
14252|      0|                    }
14253|      0|                }
14254|      0|            }
14255|      0|            else {
14256|      0|                if (nopened <= 2UL) {
14257|      0|                    tmp___12 = gettext("open failed");
14258|      0|                    die((char const *)tmp___12, (files + nopened)->name);
14259|      0|                }
14260|      0|            }
14261|      0|            while (1) {
14262|      0|                nopened--;
14263|      0|                xfclose(*(fps + nopened), (files + nopened)->name);
14264|      0|                temp___1 = maybe_create_temp(&tfp___1, (_Bool)(!(nopened <= 2UL)));
14265|      0|                if (!(!temp___1)) {
14266|      0|                    goto while_break___2;
14267|      0|                }
14268|      0|            }
14269|      0|while_break___2:
14270|      0|            ;
14271|      0|            if (ntemps < nopened) {
14272|      0|                tmp___13 = ntemps;
14273|      0|            }
14274|      0|            else {
14275|      0|                tmp___13 = nopened;
14276|      0|            }
14277|      0|            mergefps(files + 0, tmp___13, nopened, tfp___1,
14278|      0|                     (char const *)(temp___1->name), fps);
14279|      0|            if (ntemps < nopened) {
14280|      0|                tmp___14 = ntemps;
14281|      0|            }
14282|      0|            else {
14283|      0|                tmp___14 = nopened;
14284|      0|            }
14285|      0|            ntemps -= tmp___14;
14286|      0|            (files + 0)->name = (char const *)(temp___1->name);
14287|      0|            (files + 0)->temp = temp___1;
14288|      0|            memmove((void *)(files + 1), (void const *)(files + nopened),
14289|      0|                    (nfiles - nopened) * sizeof(*files));
14290|      0|            ntemps++;
14291|      0|            nfiles -= nopened - 1UL;
14292|      0|        }
14293|      0|while_break___1:
14294|      0|        ;
14295|      0|        return;
14296|      0|    }
14297|      0|}
14298|       |static void sort(char *const *files, size_t nfiles, char const *output_file,
14299|       |                 size_t nthreads)
14300|      2|{
14301|      2|    struct buffer buf___1;
14302|      2|    size_t ntemps;
14303|      2|    _Bool output_file_created;
14304|      2|    char const *temp_output;
14305|      2|    char const *file;
14306|      2|    FILE *fp;
14307|      2|    FILE *tmp;
14308|      2|    FILE *tfp;
14309|      2|    size_t bytes_per_line;
14310|      2|    size_t tmp___0;
14311|      2|    size_t mult;
14312|      2|    size_t tmp___1;
14313|      2|    struct line *line;
14314|      2|    struct tempnode *tmp___2;
14315|      2|    struct merge_node_queue queue;
14316|      2|    struct merge_node *merge_tree;
14317|      2|    struct merge_node *tmp___3;
14318|      2|    struct merge_node *root;
14319|      2|    _Bool tmp___4;
14320|      2|    size_t i;
14321|      2|    struct tempnode *node;
14322|      2|    struct sortfile *tempfiles;
14323|      2|    struct sortfile *tmp___5;
14324|       |
14325|      2|    {
14326|      2|        ntemps = (size_t)0;
14327|      2|        output_file_created = (_Bool)0;
14328|      2|        buf___1.alloc = (size_t)0;
14329|      4|        while (1) {
14330|       |
14331|      4|            if (!nfiles) {
14332|      0|                goto while_break;
14333|      0|            }
14334|      4|            file = (char const *)*files;
14335|      4|            tmp = xfopen(file, "r");
14336|      4|            fp = tmp;
14337|      4|            if (nthreads > 1UL) {
14338|      4|                tmp___0 = (size_t)1;
14339|      4|                mult = (size_t)1;
14340|     16|                while (1) {
14341|       |
14342|     16|                    if (!(tmp___0 < nthreads)) {
14343|      4|                        goto while_break___0;
14344|      4|                    }
14345|     12|                    tmp___0 *= 2UL;
14346|     12|                    mult++;
14347|     12|                }
14348|      4|while_break___0:
14349|      4|                bytes_per_line = mult * sizeof(struct line);
14350|      4|            }
14351|      0|            else {
14352|      0|                bytes_per_line = (sizeof(struct line) * 3UL) / 2UL;
14353|      0|            }
14354|      4|            if (!buf___1.alloc) {
14355|      2|                tmp___1 = sort_buffer_size((FILE *const *)(&fp), (size_t)1, files,
14356|      2|                                           nfiles, bytes_per_line);
14357|      2|                initbuf(&buf___1, bytes_per_line, tmp___1);
14358|      2|            }
14359|      4|            buf___1.eof = (_Bool)0;
14360|      4|            files++;
14361|      4|            nfiles--;
14362|      4|            while (1) {
14363|      4|                tmp___4 = fillbuf___7(&buf___1, fp, file);
14364|      4|                if (!tmp___4) {
14365|      0|                    goto while_break___1;
14366|      0|                }
14367|      4|                if (buf___1.eof) {
14368|      4|                    if (nfiles) {
14369|      2|                        if (bytes_per_line + 1UL < (buf___1.alloc - buf___1.used) -
14370|      2|                                bytes_per_line * buf___1.nlines) {
14371|      2|                            buf___1.left = buf___1.used;
14372|      2|                            goto while_break___1;
14373|      2|                        }
14374|      2|                    }
14375|      4|                }
14376|      2|                line = buffer_linelim((struct buffer const *)(&buf___1));
14377|      2|                if (buf___1.eof) {
14378|      2|                    if (!nfiles) {
14379|      2|                        if (!ntemps) {
14380|      2|                            if (!buf___1.left) {
14381|      2|                                xfclose(fp, file);
14382|      2|                                tfp = xfopen(output_file, "w");
14383|      2|                                temp_output = output_file;
14384|      2|                                output_file_created = (_Bool)1;
14385|      2|                            }
14386|      0|                            else {
14387|      0|                                ntemps++;
14388|      0|                                tmp___2 = create_temp(&tfp);
14389|      0|                                temp_output = (char const *)(tmp___2->name);
14390|      0|                            }
14391|      2|                        }
14392|      0|                        else {
14393|      0|                            ntemps++;
14394|      0|                            tmp___2 = create_temp(&tfp);
14395|      0|                            temp_output = (char const *)(tmp___2->name);
14396|      0|                        }
14397|      2|                    }
14398|      0|                    else {
14399|      0|                        ntemps++;
14400|      0|                        tmp___2 = create_temp(&tfp);
14401|      0|                        temp_output = (char const *)(tmp___2->name);
14402|      0|                    }
14403|      2|                }
14404|      0|                else {
14405|      0|                    ntemps++;
14406|      0|                    tmp___2 = create_temp(&tfp);
14407|      0|                    temp_output = (char const *)(tmp___2->name);
14408|      0|                }
14409|      2|                if (1UL < buf___1.nlines) {
14410|      2|                    queue_init(&queue, nthreads);
14411|      2|                    tmp___3 = merge_tree_init(nthreads, buf___1.nlines, line);
14412|      2|                    merge_tree = tmp___3;
14413|      2|                    root = merge_tree + 1;
14414|      2|                    sortlines(line, nthreads, buf___1.nlines, root, &queue, tfp,
14415|      2|                              temp_output);
14416|      2|                    queue_destroy(&queue);
14417|      2|                    pthread_mutex_destroy(&root->lock);
14418|      2|                    merge_tree_destroy(merge_tree);
14419|      2|                }
14420|      0|                else {
14421|      0|                    write_unique((struct line const *)(line - 1), tfp, temp_output);
14422|      0|                }
14423|      2|                xfclose(tfp, temp_output);
14424|      2|                if (output_file_created) {
14425|      2|                    goto finish;
14426|      2|                }
14427|      2|            }
14428|      2|while_break___1:
14429|      2|            xfclose(fp, file);
14430|      2|        }
14431|      0|while_break:
14432|      0|        ;
14433|      2|finish:
14434|      2|        free((void *)buf___1.buf);
14435|      2|        if (!output_file_created) {
14436|      0|            node = (struct tempnode *)temphead;
14437|      0|            tmp___5 = (struct sortfile *)xnmalloc(ntemps, sizeof(*tempfiles));
14438|      0|            tempfiles = tmp___5;
14439|      0|            i = (size_t)0;
14440|      0|            while (1) {
14441|       |
14442|      0|                if (!node) {
14443|      0|                    goto while_break___2;
14444|      0|                }
14445|      0|                (tempfiles + i)->name = (char const *)(node->name);
14446|      0|                (tempfiles + i)->temp = node;
14447|      0|                node = (struct tempnode *)node->next;
14448|      0|                i++;
14449|      0|            }
14450|      0|while_break___2:
14451|      0|            merge(tempfiles, ntemps, ntemps, output_file);
14452|      0|            free((void *)tempfiles);
14453|      0|        }
14454|      2|        reap_all();
14455|      2|        return;
14456|      2|    }
14457|      2|}
14458|       |static void insertkey(struct keyfield *key_arg)
14459|      2|{
14460|      2|    struct keyfield **p;
14461|      2|    struct keyfield *key;
14462|      2|    struct keyfield *tmp;
14463|       |
14464|      2|    {
14465|      2|        tmp = (struct keyfield *)xmemdup((void const *)key_arg, sizeof(*key));
14466|      2|        key = tmp;
14467|      2|        p = &keylist;
14468|      2|        while (1) {
14469|       |
14470|      2|            if (!*p) {
14471|      2|                goto while_break;
14472|      2|            }
14473|      0|            goto __Cont;
14474|      0|__Cont:
14475|      0|            p = &(*p)->next;
14476|      0|        }
14477|      2|while_break:
14478|      2|        *p = key;
14479|      2|        key->next = (struct keyfield *)((void *)0);
14480|      2|        return;
14481|      2|    }
14482|      2|}
14483|       |static __attribute__((__noreturn__)) void badfieldspec(char const *spec,
14484|       |        char const *msgid);
14485|       |static __attribute__((__noreturn__)) void badfieldspec(char const *spec,
14486|       |        char const *msgid);
14487|       |static void badfieldspec(char const *spec, char const *msgid)
14488|      0|{
14489|      0|    char const *tmp;
14490|      0|    char *tmp___0;
14491|      0|    char *tmp___1;
14492|       |
14493|      0|    {
14494|      0|        tmp = quote(spec);
14495|      0|        tmp___0 = gettext(msgid);
14496|      0|        tmp___1 = gettext("%s: invalid field specification %s");
14497|      0|        error(2, 0, (char const *)tmp___1, tmp___0, tmp);
14498|      0|        abort();
14499|      0|    }
14500|      0|}
14501|       |static __attribute__((__noreturn__)) void
14502|       |incompatible_options(char const *opts___1);
14503|       |static __attribute__((__noreturn__)) void
14504|       |incompatible_options(char const *opts___1);
14505|       |static void incompatible_options(char const *opts___1)
14506|      0|{
14507|      0|    char *tmp;
14508|       |
14509|      0|    {
14510|      0|        tmp = gettext("options \'-%s\' are incompatible");
14511|      0|        error(2, 0, (char const *)tmp, opts___1);
14512|      0|        abort();
14513|      0|    }
14514|      0|}
14515|       |static void check_ordering_compatibility(void)
14516|      2|{
14517|      2|    struct keyfield *key;
14518|      2|    char opts___1[sizeof(short_options)];
14519|      2|    _Bool tmp;
14520|      2|    _Bool tmp___0;
14521|       |
14522|      2|    {
14523|      2|        key = keylist;
14524|      4|        while (1) {
14525|       |
14526|      4|            if (!key) {
14527|      2|                goto while_break;
14528|      2|            }
14529|      2|            if (1 < ((((int)key->numeric + (int)key->general_numeric) +
14530|      2|                      (int)key->human_numeric) +
14531|      2|                     (int)key->month) +
14532|      2|                    (((int)key->version | (int)key->random) | !(!key->ignore))) {
14533|      0|                tmp___0 = (_Bool)0;
14534|      0|                key->reverse = tmp___0;
14535|      0|                tmp = tmp___0;
14536|      0|                key->skipeblanks = tmp;
14537|      0|                key->skipsblanks = tmp;
14538|      0|                key_to_opts((struct keyfield const *)key, opts___1);
14539|      0|                incompatible_options((char const *)(opts___1));
14540|      0|            }
14541|      2|            key = key->next;
14542|      2|        }
14543|      2|while_break:
14544|      2|        ;
14545|      2|        return;
14546|      2|    }
14547|      2|}
14548|       |static char const *parse_field_count(char const *string, size_t *val,
14549|       |                                     char const *msgid)
14550|      0|{
14551|      0|    char *suffix;
14552|      0|    uintmax_t n;
14553|      0|    strtol_error tmp;
14554|      0|    char const *tmp___0;
14555|      0|    char *tmp___1;
14556|      0|    char *tmp___2;
14557|       |
14558|      0|    {
14559|      0|        tmp = xstrtoumax(string, &suffix, 10, &n, "");
14560|      0|        if ((unsigned int)tmp == 0U) {
14561|      0|            goto case_0;
14562|      0|        }
14563|      0|        if ((unsigned int)tmp == 2U) {
14564|      0|            goto case_0;
14565|      0|        }
14566|      0|        if ((unsigned int)tmp == 1U) {
14567|      0|            goto case_1;
14568|      0|        }
14569|      0|        if ((unsigned int)tmp == 3U) {
14570|      0|            goto case_1;
14571|      0|        }
14572|      0|        if ((unsigned int)tmp == 4U) {
14573|      0|            goto case_4;
14574|      0|        }
14575|      0|        goto switch_break;
14576|      0|case_0:
14577|      0|        *val = n;
14578|      0|        if (*val == n) {
14579|      0|            goto switch_break;
14580|      0|        }
14581|      0|case_1:
14582|      0|        *val = 0xffffffffffffffffUL;
14583|      0|        goto switch_break;
14584|      0|case_4:
14585|      0|        if (msgid) {
14586|      0|            tmp___0 = quote(string);
14587|      0|            tmp___1 = gettext(msgid);
14588|      0|            tmp___2 = gettext("%s: invalid count at start of %s");
14589|      0|            error(2, 0, (char const *)tmp___2, tmp___1, tmp___0);
14590|      0|        }
14591|      0|        return ((char const *)((void *)0));
14592|      0|switch_break:
14593|      0|        ;
14594|      0|        return ((char const *)suffix);
14595|      0|    }
14596|      0|}
14597|       |static char *set_ordering(char const *s, struct keyfield *key,
14598|       |                          enum blanktype blanktype)
14599|      3|{
14600|       |
14601|      3|    {
14602|      6|        while (1) {
14603|       |
14604|      6|            if (!*s) {
14605|      3|                goto while_break;
14606|      3|            }
14607|      3|            if ((int const) * s == 98) {
14608|      0|                goto case_98;
14609|      0|            }
14610|      3|            if ((int const) * s == 100) {
14611|      0|                goto case_100;
14612|      0|            }
14613|      3|            if ((int const) * s == 102) {
14614|      2|                goto case_102;
14615|      2|            }
14616|      1|            if ((int const) * s == 103) {
14617|      0|                goto case_103;
14618|      0|            }
14619|      1|            if ((int const) * s == 104) {
14620|      0|                goto case_104;
14621|      0|            }
14622|      1|            if ((int const) * s == 105) {
14623|      0|                goto case_105;
14624|      0|            }
14625|      1|            if ((int const) * s == 77) {
14626|      0|                goto case_77;
14627|      0|            }
14628|      1|            if ((int const) * s == 110) {
14629|      1|                goto case_110;
14630|      1|            }
14631|      0|            if ((int const) * s == 82) {
14632|      0|                goto case_82;
14633|      0|            }
14634|      0|            if ((int const) * s == 114) {
14635|      0|                goto case_114;
14636|      0|            }
14637|      0|            if ((int const) * s == 86) {
14638|      0|                goto case_86;
14639|      0|            }
14640|      0|            goto switch_default;
14641|      0|case_98:
14642|      0|            if ((unsigned int)blanktype == 0U) {
14643|      0|                key->skipsblanks = (_Bool)1;
14644|      0|            }
14645|      0|            else {
14646|      0|                if ((unsigned int)blanktype == 2U) {
14647|      0|                    key->skipsblanks = (_Bool)1;
14648|      0|                }
14649|      0|            }
14650|      0|            if ((unsigned int)blanktype == 1U) {
14651|      0|                key->skipeblanks = (_Bool)1;
14652|      0|            }
14653|      0|            else {
14654|      0|                if ((unsigned int)blanktype == 2U) {
14655|      0|                    key->skipeblanks = (_Bool)1;
14656|      0|                }
14657|      0|            }
14658|      0|            goto switch_break;
14659|      0|case_100:
14660|      0|            key->ignore = (_Bool const *)(nondictionary);
14661|      0|            goto switch_break;
14662|      2|case_102:
14663|      2|            key->translate = (char const *)(fold_toupper);
14664|      2|            goto switch_break;
14665|      0|case_103:
14666|      0|            key->general_numeric = (_Bool)1;
14667|      0|            goto switch_break;
14668|      0|case_104:
14669|      0|            key->human_numeric = (_Bool)1;
14670|      0|            goto switch_break;
14671|      0|case_105:
14672|      0|            if (!key->ignore) {
14673|      0|                key->ignore = (_Bool const *)(nonprinting);
14674|      0|            }
14675|      0|            goto switch_break;
14676|      0|case_77:
14677|      0|            key->month = (_Bool)1;
14678|      0|            goto switch_break;
14679|      1|case_110:
14680|      1|            key->numeric = (_Bool)1;
14681|      1|            goto switch_break;
14682|      0|case_82:
14683|      0|            key->random = (_Bool)1;
14684|      0|            goto switch_break;
14685|      0|case_114:
14686|      0|            key->reverse = (_Bool)1;
14687|      0|            goto switch_break;
14688|      0|case_86:
14689|      0|            key->version = (_Bool)1;
14690|      0|            goto switch_break;
14691|      0|switch_default:
14692|      0|            return ((char *)s);
14693|      3|switch_break:
14694|      3|            s++;
14695|      3|        }
14696|      3|while_break:
14697|      3|        ;
14698|      3|        return ((char *)s);
14699|      3|    }
14700|      3|}
14701|       |static struct keyfield *key_init(struct keyfield *key)
14702|      2|{
14703|       |
14704|      2|    {
14705|      2|        memset((void *)key, 0, sizeof(*key));
14706|      2|        key->eword = 0xffffffffffffffffUL;
14707|      2|        return (key);
14708|      2|    }
14709|      2|}
14710|       |static void sighandler(int sig___0)
14711|      0|{
14712|       |
14713|      0|    {
14714|      0|        cleanup();
14715|      0|        signal(sig___0, (void (*)(int))0);
14716|      0|        raise(sig___0);
14717|      0|        return;
14718|      0|    }
14719|      0|}
14720|       |int main(int argc, char **argv);
14721|       |static int const sig[11] = {(int const)14, (int const)1,  (int const)2,
14722|       |                            (int const)13, (int const)3,  (int const)15,
14723|       |                            (int const)29, (int const)27, (int const)26,
14724|       |                            (int const)24, (int const)25
14725|       |                           };
14726|       |static char opts[10] = {(char)'X', (char)' ',   (char)'-', (char)'-',
14727|       |                        (char)'d', (char)'e',   (char)'b', (char)'u',
14728|       |                        (char)'g', (char)'\000'
14729|       |                       };
14730|       |static char *minus = (char *)"-";
14731|       |static char opts___0[3] = {(char)0, (char)'o', (char)0};
14732|       |int main(int argc, char **argv)
14733|      2|{
14734|      2|    struct keyfield *key;
14735|      2|    struct keyfield key_buf;
14736|      2|    struct keyfield gkey;
14737|      2|    _Bool gkey_only;
14738|      2|    char const *s;
14739|      2|    int c;
14740|      2|    char checkonly;
14741|      2|    _Bool mergeonly;
14742|      2|    char *random_source;
14743|      2|    _Bool need_random;
14744|      2|    size_t nthreads;
14745|      2|    size_t nfiles;
14746|      2|    _Bool posixly_correct;
14747|      2|    char *tmp;
14748|      2|    _Bool obsolete_usage;
14749|      2|    int tmp___0;
14750|      2|    char **files;
14751|      2|    char *files_from;
14752|      2|    struct Tokens tok;
14753|      2|    char const *outfile;
14754|      2|    struct lconv const *locale;
14755|      2|    struct lconv const *tmp___1;
14756|      2|    size_t i;
14757|      2|    struct sigaction act;
14758|      2|    int tmp___2;
14759|      2|    int oi;
14760|      2|    size_t tmp___3;
14761|      2|    int tmp___4;
14762|      2|    _Bool minus_pos_usage;
14763|      2|    int tmp___5;
14764|      2|    int tmp___6;
14765|      2|    char const *optarg1;
14766|      2|    int tmp___7;
14767|      2|    char *tmp___8;
14768|      2|    char *tmp___9;
14769|      2|    size_t tmp___10;
14770|      2|    ptrdiff_t tmp___11;
14771|      2|    char str[2];
14772|      2|    ptrdiff_t tmp___12;
14773|      2|    char *tmp___13;
14774|      2|    int tmp___14;
14775|      2|    size_t tmp___15;
14776|      2|    size_t tmp___16;
14777|      2|    size_t tmp___17;
14778|      2|    char *tmp___18;
14779|      2|    int tmp___19;
14780|      2|    char *tmp___20;
14781|      2|    int tmp___21;
14782|      2|    char newtab;
14783|      2|    char *tmp___22;
14784|      2|    char const *tmp___23;
14785|      2|    char *tmp___24;
14786|      2|    int tmp___25;
14787|      2|    char *tmp___26;
14788|      2|    char const *p;
14789|      2|    FILE *stream;
14790|      2|    char const *tmp___27;
14791|      2|    char *tmp___28;
14792|      2|    char *tmp___29;
14793|      2|    char const *tmp___30;
14794|      2|    char *tmp___31;
14795|      2|    int *tmp___32;
14796|      2|    int tmp___33;
14797|      2|    char const *tmp___34;
14798|      2|    char *tmp___35;
14799|      2|    _Bool tmp___36;
14800|      2|    int tmp___37;
14801|      2|    size_t i___0;
14802|      2|    char const *tmp___38;
14803|      2|    char *tmp___39;
14804|      2|    unsigned long file_number;
14805|      2|    char *tmp___40;
14806|      2|    char *tmp___41;
14807|      2|    int tmp___42;
14808|      2|    char const *tmp___43;
14809|      2|    char *tmp___44;
14810|      2|    _Bool tmp___45;
14811|      2|    _Bool tmp___46;
14812|      2|    char *tmp___47;
14813|      2|    char const *tmp___48;
14814|      2|    char *tmp___49;
14815|      2|    char *tmp___50;
14816|      2|    char const *tmp_dir;
14817|      2|    char const *tmp___51;
14818|      2|    char const *tmp___52;
14819|      2|    char const *tmp___53;
14820|      2|    char *tmp___54;
14821|      2|    int tmp___56;
14822|      2|    _Bool tmp___57;
14823|      2|    struct sortfile *sortfiles;
14824|      2|    struct sortfile *tmp___58;
14825|      2|    size_t i___1;
14826|      2|    unsigned long np;
14827|      2|    unsigned long tmp___59;
14828|      2|    size_t nthreads_max;
14829|      2|    char *tmp___60;
14830|      2|    int tmp___61;
14831|       |
14832|      2|    {
14833|      2|        gkey_only = (_Bool)0;
14834|      2|        c = 0;
14835|      2|        checkonly = (char)0;
14836|      2|        mergeonly = (_Bool)0;
14837|      2|        random_source = (char *)((void *)0);
14838|      2|        need_random = (_Bool)0;
14839|      2|        nthreads = (size_t)0;
14840|      2|        nfiles = (size_t)0;
14841|      2|        tmp = getenv("POSIXLY_CORRECT");
14842|      2|        posixly_correct = (_Bool)((unsigned long)tmp != (unsigned long)((void *)0));
14843|      2|        tmp___0 = posix2_version();
14844|      2|        obsolete_usage = (_Bool)(tmp___0 < 200112);
14845|      2|        files_from = (char *)((void *)0);
14846|      2|        outfile = (char const *)((void *)0);
14847|      2|        set_program_name((char const *)*(argv + 0));
14848|      2|        setlocale(6, "");
14849|      2|        bindtextdomain("coreutils", "/usr/local/share/locale");
14850|      2|        textdomain("coreutils");
14851|      2|        initialize_exit_failure(2);
14852|      2|        hard_LC_COLLATE = hard_locale(3);
14853|      2|        hard_LC_TIME = hard_locale(2);
14854|      2|        tmp___1 = (struct lconv const *)localeconv();
14855|      2|        locale = tmp___1;
14856|      2|        decimal_point = (int)to_uchar(*(locale->decimal_point + 0));
14857|      2|        if (!decimal_point) {
14858|      0|            decimal_point = '.';
14859|      0|        }
14860|      2|        else {
14861|      2|            if (*(locale->decimal_point + 1)) {
14862|      0|                decimal_point = '.';
14863|      0|            }
14864|      2|        }
14865|      2|        thousands_sep = (int)to_uchar(*(locale->thousands_sep));
14866|      2|        if (!thousands_sep) {
14867|      0|            thousands_sep = -1;
14868|      0|        }
14869|      2|        else {
14870|      2|            if (*(locale->thousands_sep + 1)) {
14871|      0|                thousands_sep = -1;
14872|      0|            }
14873|      2|        }
14874|      2|        have_read_stdin = (_Bool)0;
14875|      2|        inittables();
14876|      2|        sigemptyset(&caught_signals);
14877|      2|        i = (size_t)0;
14878|     24|        while (1) {
14879|       |
14880|     24|            if (!(i < 11UL)) {
14881|      2|                goto while_break;
14882|      2|            }
14883|     22|            sigaction((int)sig[i], (struct sigaction const *)((void *)0), &act);
14884|     22|            if ((unsigned long)act.__sigaction_handler.sa_handler !=
14885|     22|                    (unsigned long)((void (*)(int))1)) {
14886|     22|                sigaddset(&caught_signals, (int)sig[i]);
14887|     22|            }
14888|     22|            i++;
14889|     22|        }
14890|      2|while_break:
14891|      2|        act.__sigaction_handler.sa_handler = &sighandler;
14892|      2|        act.sa_mask = caught_signals;
14893|      2|        act.sa_flags = 0;
14894|      2|        i = (size_t)0;
14895|     24|        while (1) {
14896|       |
14897|     24|            if (!(i < 11UL)) {
14898|      2|                goto while_break___0;
14899|      2|            }
14900|     22|            tmp___2 = sigismember((sigset_t const *)(&caught_signals), (int)sig[i]);
14901|     22|            if (tmp___2) {
14902|     22|                sigaction((int)sig[i], (struct sigaction const *)(&act),
14903|     22|                          (struct sigaction *)((void *)0));
14904|     22|            }
14905|     22|            i++;
14906|     22|        }
14907|      2|while_break___0:
14908|      2|        signal(17, (void (*)(int))0);
14909|      2|        atexit(&exit_cleanup);
14910|      2|        key_init(&gkey);
14911|      2|        gkey.sword = 0xffffffffffffffffUL;
14912|      2|        files = (char **)xnmalloc((size_t)argc, sizeof(*files));
14913|      9|        while (1) {
14914|      9|            oi = -1;
14915|      9|            if (c == -1) {
14916|      0|                goto _L;
14917|      0|            }
14918|      9|            else {
14919|      9|                if (posixly_correct) {
14920|      0|                    if (nfiles != 0UL) {
14921|      0|                        if (obsolete_usage) {
14922|      0|                            if (!checkonly) {
14923|      0|                                if (optind != argc) {
14924|      0|                                    if ((int)*(*(argv + optind) + 0) == 45) {
14925|      0|                                        if ((int)*(*(argv + optind) + 1) == 111) {
14926|      0|                                            if (*(*(argv + optind) + 2)) {
14927|      0|                                                goto _L___1;
14928|      0|                                            }
14929|      0|                                            else {
14930|      0|                                                if (optind + 1 != argc) {
14931|      0|                                                    goto _L___1;
14932|      0|                                                }
14933|      0|                                                else {
14934|      0|                                                    goto _L;
14935|      0|                                                }
14936|      0|                                            }
14937|      0|                                        }
14938|      0|                                        else {
14939|      0|                                            goto _L;
14940|      0|                                        }
14941|      0|                                    }
14942|      0|                                    else {
14943|      0|                                        goto _L;
14944|      0|                                    }
14945|      0|                                }
14946|      0|                                else {
14947|      0|                                    goto _L;
14948|      0|                                }
14949|      0|                            }
14950|      0|                            else {
14951|      0|                                goto _L;
14952|      0|                            }
14953|      0|                        }
14954|      0|                        else {
14955|      0|                            goto _L;
14956|      0|                        }
14957|      0|                    }
14958|      0|                    else {
14959|      0|                        goto _L___1;
14960|      0|                    }
14961|      0|                }
14962|      9|                else {
14963|      9|_L___1:
14964|      9|                    c = getopt_long(argc, (char *const *)argv, short_options,
14965|      9|                                    long_options___1, &oi);
14966|      9|                    if (c == -1) {
14967|      2|_L:
14968|      2|                        if (argc <= optind) {
14969|      2|                            goto while_break___1;
14970|      2|                        }
14971|      0|                        tmp___3 = nfiles;
14972|      0|                        nfiles++;
14973|      0|                        tmp___4 = optind;
14974|      0|                        optind++;
14975|      0|                        *(files + tmp___3) = *(argv + tmp___4);
14976|      0|                    }
14977|      7|                    else {
14978|      7|                        if (c == 1) {
14979|      4|                            goto case_1;
14980|      4|                        }
14981|      3|                        if (c == 134) {
14982|      0|                            goto case_134;
14983|      0|                        }
14984|      3|                        if (c == 98) {
14985|      0|                            goto case_98;
14986|      0|                        }
14987|      3|                        if (c == 100) {
14988|      0|                            goto case_98;
14989|      0|                        }
14990|      3|                        if (c == 102) {
14991|      2|                            goto case_98;
14992|      2|                        }
14993|      1|                        if (c == 103) {
14994|      0|                            goto case_98;
14995|      0|                        }
14996|      1|                        if (c == 104) {
14997|      0|                            goto case_98;
14998|      0|                        }
14999|      1|                        if (c == 105) {
15000|      0|                            goto case_98;
15001|      0|                        }
15002|      1|                        if (c == 77) {
15003|      0|                            goto case_98;
15004|      0|                        }
15005|      1|                        if (c == 110) {
15006|      1|                            goto case_98;
15007|      1|                        }
15008|      0|                        if (c == 114) {
15009|      0|                            goto case_98;
15010|      0|                        }
15011|      0|                        if (c == 82) {
15012|      0|                            goto case_98;
15013|      0|                        }
15014|      0|                        if (c == 86) {
15015|      0|                            goto case_98;
15016|      0|                        }
15017|      0|                        if (c == 128) {
15018|      0|                            goto case_128;
15019|      0|                        }
15020|      0|                        if (c == 99) {
15021|      0|                            goto case_99;
15022|      0|                        }
15023|      0|                        if (c == 67) {
15024|      0|                            goto case_99;
15025|      0|                        }
15026|      0|                        if (c == 129) {
15027|      0|                            goto case_129;
15028|      0|                        }
15029|      0|                        if (c == 130) {
15030|      0|                            goto case_130;
15031|      0|                        }
15032|      0|                        if (c == 131) {
15033|      0|                            goto case_131;
15034|      0|                        }
15035|      0|                        if (c == 107) {
15036|      0|                            goto case_107;
15037|      0|                        }
15038|      0|                        if (c == 109) {
15039|      0|                            goto case_109;
15040|      0|                        }
15041|      0|                        if (c == 132) {
15042|      0|                            goto case_132;
15043|      0|                        }
15044|      0|                        if (c == 111) {
15045|      0|                            goto case_111;
15046|      0|                        }
15047|      0|                        if (c == 133) {
15048|      0|                            goto case_133;
15049|      0|                        }
15050|      0|                        if (c == 115) {
15051|      0|                            goto case_115;
15052|      0|                        }
15053|      0|                        if (c == 83) {
15054|      0|                            goto case_83;
15055|      0|                        }
15056|      0|                        if (c == 116) {
15057|      0|                            goto case_116;
15058|      0|                        }
15059|      0|                        if (c == 84) {
15060|      0|                            goto case_84;
15061|      0|                        }
15062|      0|                        if (c == 135) {
15063|      0|                            goto case_135;
15064|      0|                        }
15065|      0|                        if (c == 117) {
15066|      0|                            goto case_117;
15067|      0|                        }
15068|      0|                        if (c == 121) {
15069|      0|                            goto case_121;
15070|      0|                        }
15071|      0|                        if (c == 122) {
15072|      0|                            goto case_122;
15073|      0|                        }
15074|      0|                        if (c == -130) {
15075|      0|                            goto case_neg_130;
15076|      0|                        }
15077|      0|                        if (c == -131) {
15078|      0|                            goto case_neg_131;
15079|      0|                        }
15080|      0|                        goto switch_default;
15081|      4|case_1:
15082|      4|                        key = (struct keyfield *)((void *)0);
15083|      4|                        if ((int)*(optarg + 0) == 43) {
15084|      0|                            if (optind != argc) {
15085|      0|                                if ((int)*(*(argv + optind) + 0) == 45) {
15086|      0|                                    if ((unsigned int)*(*(argv + optind) + 1) - 48U <= 9U) {
15087|      0|                                        tmp___5 = 1;
15088|      0|                                    }
15089|      0|                                    else {
15090|      0|                                        tmp___5 = 0;
15091|      0|                                    }
15092|      0|                                }
15093|      0|                                else {
15094|      0|                                    tmp___5 = 0;
15095|      0|                                }
15096|      0|                            }
15097|      0|                            else {
15098|      0|                                tmp___5 = 0;
15099|      0|                            }
15100|      0|                            minus_pos_usage = (_Bool)tmp___5;
15101|      0|                            if (minus_pos_usage) {
15102|      0|                                if (!posixly_correct) {
15103|      0|                                    tmp___6 = 1;
15104|      0|                                }
15105|      0|                                else {
15106|      0|                                    tmp___6 = 0;
15107|      0|                                }
15108|      0|                            }
15109|      0|                            else {
15110|      0|                                tmp___6 = 0;
15111|      0|                            }
15112|      0|                            obsolete_usage = (_Bool)((int)obsolete_usage | tmp___6);
15113|      0|                            if (obsolete_usage) {
15114|      0|                                key = key_init(&key_buf);
15115|      0|                                s = parse_field_count((char const *)(optarg + 1), &key->sword,
15116|      0|                                                      (char const *)((void *)0));
15117|      0|                                if (s) {
15118|      0|                                    if ((int const) * s == 46) {
15119|      0|                                        s = parse_field_count(s + 1, &key->schar,
15120|      0|                                                              (char const *)((void *)0));
15121|      0|                                    }
15122|      0|                                }
15123|      0|                                if (!key->sword) {
15124|      0|                                    if (!key->schar) {
15125|      0|                                        key->sword = 0xffffffffffffffffUL;
15126|      0|                                    }
15127|      0|                                }
15128|      0|                                if (!s) {
15129|      0|                                    key = (struct keyfield *)((void *)0);
15130|      0|                                }
15131|      0|                                else {
15132|      0|                                    tmp___9 = set_ordering(s, key, (enum blanktype)0);
15133|      0|                                    if (*tmp___9) {
15134|      0|                                        key = (struct keyfield *)((void *)0);
15135|      0|                                    }
15136|      0|                                    else {
15137|      0|                                        if (minus_pos_usage) {
15138|      0|                                            tmp___7 = optind;
15139|      0|                                            optind++;
15140|      0|                                            optarg1 = (char const *)*(argv + tmp___7);
15141|      0|                                            s = parse_field_count(optarg1 + 1, &key->eword,
15142|      0|                                                                  "invalid number after \'-\'");
15143|      0|                                            if ((int const) * s == 46) {
15144|      0|                                                s = parse_field_count(s + 1, &key->echar,
15145|      0|                                                                      "invalid number after \'.\'");
15146|      0|                                            }
15147|      0|                                            if (!key->echar) {
15148|      0|                                                if (key->eword) {
15149|      0|                                                    (key->eword)--;
15150|      0|                                                }
15151|      0|                                            }
15152|      0|                                            tmp___8 = set_ordering(s, key, (enum blanktype)1);
15153|      0|                                            if (*tmp___8) {
15154|      0|                                                badfieldspec(optarg1, "stray character in field spec");
15155|      0|                                            }
15156|      0|                                        }
15157|      0|                                        key->obsolete_used = (_Bool)1;
15158|      0|                                        insertkey(key);
15159|      0|                                    }
15160|      0|                                }
15161|      0|                            }
15162|      0|                        }
15163|      4|                        if (!key) {
15164|      4|                            tmp___10 = nfiles;
15165|      4|                            nfiles++;
15166|      4|                            *(files + tmp___10) = optarg;
15167|      4|                        }
15168|      4|                        goto switch_break;
15169|      0|case_134:
15170|      0|                        tmp___11 = __xargmatch_internal(
15171|      0|                                       "--sort", (char const *)optarg, sort_args, sort_types,
15172|      0|                                       sizeof(sort_types[0]), argmatch_die);
15173|      0|                        c = (int)sort_types[tmp___11];
15174|      3|case_98:
15175|      3|                        str[0] = (char)c;
15176|      3|                        str[1] = (char)'\000';
15177|      3|                        set_ordering((char const *)(str), &gkey, (enum blanktype)2);
15178|      3|                        goto switch_break;
15179|      0|case_128:
15180|      0|                        if (optarg) {
15181|      0|                            tmp___12 = __xargmatch_internal(
15182|      0|                                           "--check", (char const *)optarg, check_args, check_types,
15183|      0|                                           sizeof(check_types[0]), argmatch_die);
15184|      0|                            c = (int)check_types[tmp___12];
15185|      0|                        }
15186|      0|                        else {
15187|      0|                            c = 'c';
15188|      0|                        }
15189|      0|case_99:
15190|      0|                        if (checkonly) {
15191|      0|                            if ((int)checkonly != c) {
15192|      0|                                incompatible_options("cC");
15193|      0|                            }
15194|      0|                        }
15195|      0|                        checkonly = (char)c;
15196|      0|                        goto switch_break;
15197|      0|case_129:
15198|      0|                        if (compress_program) {
15199|      0|                            tmp___14 = strcmp(compress_program, (char const *)optarg);
15200|      0|                            if (!(tmp___14 == 0)) {
15201|      0|                                tmp___13 = gettext("multiple compress programs specified");
15202|      0|                                error(2, 0, (char const *)tmp___13);
15203|      0|                            }
15204|      0|                        }
15205|      0|                        compress_program = (char const *)optarg;
15206|      0|                        goto switch_break;
15207|      0|case_130:
15208|      0|                        debug = (_Bool)1;
15209|      0|                        goto switch_break;
15210|      0|case_131:
15211|      0|                        files_from = optarg;
15212|      0|                        goto switch_break;
15213|      0|case_107:
15214|      0|                        key = key_init(&key_buf);
15215|      0|                        s = parse_field_count((char const *)optarg, &key->sword,
15216|      0|                                              "invalid number at field start");
15217|      0|                        tmp___15 = key->sword;
15218|      0|                        (key->sword)--;
15219|      0|                        if (!tmp___15) {
15220|      0|                            badfieldspec((char const *)optarg, "field number is zero");
15221|      0|                        }
15222|      0|                        if ((int const) * s == 46) {
15223|      0|                            s = parse_field_count(s + 1, &key->schar,
15224|      0|                                                  "invalid number after \'.\'");
15225|      0|                            tmp___16 = key->schar;
15226|      0|                            (key->schar)--;
15227|      0|                            if (!tmp___16) {
15228|      0|                                badfieldspec((char const *)optarg, "character offset is zero");
15229|      0|                            }
15230|      0|                        }
15231|      0|                        if (!key->sword) {
15232|      0|                            if (!key->schar) {
15233|      0|                                key->sword = 0xffffffffffffffffUL;
15234|      0|                            }
15235|      0|                        }
15236|      0|                        s = (char const *)set_ordering(s, key, (enum blanktype)0);
15237|      0|                        if ((int const) * s != 44) {
15238|      0|                            key->eword = 0xffffffffffffffffUL;
15239|      0|                            key->echar = (size_t)0;
15240|      0|                        }
15241|      0|                        else {
15242|      0|                            s = parse_field_count(s + 1, &key->eword,
15243|      0|                                                  "invalid number after \',\'");
15244|      0|                            tmp___17 = key->eword;
15245|      0|                            (key->eword)--;
15246|      0|                            if (!tmp___17) {
15247|      0|                                badfieldspec((char const *)optarg, "field number is zero");
15248|      0|                            }
15249|      0|                            if ((int const) * s == 46) {
15250|      0|                                s = parse_field_count(s + 1, &key->echar,
15251|      0|                                                      "invalid number after \'.\'");
15252|      0|                            }
15253|      0|                            s = (char const *)set_ordering(s, key, (enum blanktype)1);
15254|      0|                        }
15255|      0|                        if (*s) {
15256|      0|                            badfieldspec((char const *)optarg,
15257|      0|                                         "stray character in field spec");
15258|      0|                        }
15259|      0|                        insertkey(key);
15260|      0|                        goto switch_break;
15261|      0|case_109:
15262|      0|                        mergeonly = (_Bool)1;
15263|      0|                        goto switch_break;
15264|      0|case_132:
15265|      0|                        specify_nmerge(oi, (char)c, (char const *)optarg);
15266|      0|                        goto switch_break;
15267|      0|case_111:
15268|      0|                        if (outfile) {
15269|      0|                            tmp___19 = strcmp(outfile, (char const *)optarg);
15270|      0|                            if (!(tmp___19 == 0)) {
15271|      0|                                tmp___18 = gettext("multiple output files specified");
15272|      0|                                error(2, 0, (char const *)tmp___18);
15273|      0|                            }
15274|      0|                        }
15275|      0|                        outfile = (char const *)optarg;
15276|      0|                        goto switch_break;
15277|      0|case_133:
15278|      0|                        if (random_source) {
15279|      0|                            tmp___21 =
15280|      0|                                strcmp((char const *)random_source, (char const *)optarg);
15281|      0|                            if (!(tmp___21 == 0)) {
15282|      0|                                tmp___20 = gettext("multiple random sources specified");
15283|      0|                                error(2, 0, (char const *)tmp___20);
15284|      0|                            }
15285|      0|                        }
15286|      0|                        random_source = optarg;
15287|      0|                        goto switch_break;
15288|      0|case_115:
15289|      0|                        stable = (_Bool)1;
15290|      0|                        goto switch_break;
15291|      0|case_83:
15292|      0|                        specify_sort_size(oi, (char)c, (char const *)optarg);
15293|      0|                        goto switch_break;
15294|      0|case_116:
15295|      0|                        newtab = *(optarg + 0);
15296|      0|                        if (!newtab) {
15297|      0|                            tmp___22 = gettext("empty tab");
15298|      0|                            error(2, 0, (char const *)tmp___22);
15299|      0|                        }
15300|      0|                        if (*(optarg + 1)) {
15301|      0|                            tmp___25 = strcmp((char const *)optarg, "\\0");
15302|      0|                            if (tmp___25 == 0) {
15303|      0|                                newtab = (char)'\000';
15304|      0|                            }
15305|      0|                            else {
15306|      0|                                tmp___23 = quote((char const *)optarg);
15307|      0|                                tmp___24 = gettext("multi-character tab %s");
15308|      0|                                error(2, 0, (char const *)tmp___24, tmp___23);
15309|      0|                            }
15310|      0|                        }
15311|      0|                        if (tab != 128) {
15312|      0|                            if (tab != (int)newtab) {
15313|      0|                                tmp___26 = gettext("incompatible tabs");
15314|      0|                                error(2, 0, (char const *)tmp___26);
15315|      0|                            }
15316|      0|                        }
15317|      0|                        tab = (int)newtab;
15318|      0|                        goto switch_break;
15319|      0|case_84:
15320|      0|                        add_temp_dir((char const *)optarg);
15321|      0|                        goto switch_break;
15322|      0|case_135:
15323|      0|                        nthreads = specify_nthreads(oi, (char)c, (char const *)optarg);
15324|      0|                        goto switch_break;
15325|      0|case_117:
15326|      0|                        unique = (_Bool)1;
15327|      0|                        goto switch_break;
15328|      0|case_121:
15329|      0|                        if ((unsigned long)optarg ==
15330|      0|                                (unsigned long)*(argv + (optind - 1))) {
15331|      0|                            p = (char const *)optarg;
15332|      0|                            while (1) {
15333|       |
15334|      0|                                if (!((unsigned int)*p - 48U <= 9U)) {
15335|      0|                                    goto while_break___2;
15336|      0|                                }
15337|      0|                                goto __Cont;
15338|      0|__Cont:
15339|      0|                                p++;
15340|      0|                            }
15341|      0|while_break___2:
15342|      0|                            optind -= (int const) * p != 0;
15343|      0|                        }
15344|      0|                        goto switch_break;
15345|      0|case_122:
15346|      0|                        eolchar = (char)0;
15347|      0|                        goto switch_break;
15348|      0|case_neg_130:
15349|      0|                        usage(0);
15350|      0|                        goto switch_break;
15351|      0|case_neg_131:
15352|      0|                        version_etc(stdout, "sort", "GNU coreutils", Version,
15353|      0|                                    "Mike Haertel", "Paul Eggert", (char *)((void *)0));
15354|      0|                        exit(0);
15355|      0|                        goto switch_break;
15356|      0|switch_default:
15357|      0|                        usage(2);
15358|      7|switch_break:
15359|      7|                        ;
15360|      7|                    }
15361|      9|                }
15362|      9|            }
15363|      9|        }
15364|      2|while_break___1:
15365|      2|        ;
15366|      2|        if (files_from) {
15367|      0|            if (nfiles) {
15368|      0|                tmp___27 = quote((char const *)*(files + 0));
15369|      0|                tmp___28 = gettext("extra operand %s");
15370|      0|                error(0, 0, (char const *)tmp___28, tmp___27);
15371|      0|                tmp___29 =
15372|      0|                    gettext("file operands cannot be combined with --files0-from");
15373|      0|                fprintf(stderr, "%s\n", tmp___29);
15374|      0|                usage(2);
15375|      0|            }
15376|      0|            tmp___33 = strcmp((char const *)files_from, "-");
15377|      0|            if (tmp___33 == 0) {
15378|      0|                stream = stdin;
15379|      0|            }
15380|      0|            else {
15381|      0|                stream = fopen_safer((char const *)files_from, "r");
15382|      0|                if ((unsigned long)stream == (unsigned long)((void *)0)) {
15383|      0|                    tmp___30 = quote((char const *)files_from);
15384|      0|                    tmp___31 = gettext("cannot open %s for reading");
15385|      0|                    tmp___32 = __errno_location();
15386|      0|                    error(2, *tmp___32, (char const *)tmp___31, tmp___30);
15387|      0|                }
15388|      0|            }
15389|      0|            readtokens0_init(&tok);
15390|      0|            tmp___36 = readtokens0(stream, &tok);
15391|      0|            if (tmp___36) {
15392|      0|                tmp___37 = rpl_fclose(stream);
15393|      0|                if (tmp___37 != 0) {
15394|      0|                    tmp___34 = quote((char const *)files_from);
15395|      0|                    tmp___35 = gettext("cannot read file names from %s");
15396|      0|                    error(2, 0, (char const *)tmp___35, tmp___34);
15397|      0|                }
15398|      0|            }
15399|      0|            else {
15400|      0|                tmp___34 = quote((char const *)files_from);
15401|      0|                tmp___35 = gettext("cannot read file names from %s");
15402|      0|                error(2, 0, (char const *)tmp___35, tmp___34);
15403|      0|            }
15404|      0|            if (tok.n_tok) {
15405|      0|                free((void *)files);
15406|      0|                files = tok.tok;
15407|      0|                nfiles = tok.n_tok;
15408|      0|                i___0 = (size_t)0;
15409|      0|                while (1) {
15410|       |
15411|      0|                    if (!(i___0 < nfiles)) {
15412|      0|                        goto while_break___3;
15413|      0|                    }
15414|      0|                    tmp___42 = strcmp((char const *)*(files + i___0), "-");
15415|      0|                    if (tmp___42 == 0) {
15416|      0|                        tmp___38 = quote((char const *)*(files + i___0));
15417|      0|                        tmp___39 = gettext("when reading file names from stdin, no file "
15418|      0|                                           "name of %s allowed");
15419|      0|                        error(2, 0, (char const *)tmp___39, tmp___38);
15420|      0|                    }
15421|      0|                    else {
15422|      0|                        if ((int)*(*(files + i___0) + 0) == 0) {
15423|      0|                            file_number = i___0 + 1UL;
15424|      0|                            tmp___40 = quotearg_colon((char const *)files_from);
15425|      0|                            tmp___41 = gettext("%s:%lu: invalid zero-length file name");
15426|      0|                            error(2, 0, (char const *)tmp___41, tmp___40, file_number);
15427|      0|                        }
15428|      0|                    }
15429|      0|                    i___0++;
15430|      0|                }
15431|      0|while_break___3:
15432|      0|                ;
15433|      0|            }
15434|      0|            else {
15435|      0|                tmp___43 = quote((char const *)files_from);
15436|      0|                tmp___44 = gettext("no input from %s");
15437|      0|                error(2, 0, (char const *)tmp___44, tmp___43);
15438|      0|            }
15439|      0|        }
15440|      2|        key = keylist;
15441|      2|        while (1) {
15442|       |
15443|      2|            if (!key) {
15444|      2|                goto while_break___4;
15445|      2|            }
15446|      0|            tmp___45 = default_key_compare((struct keyfield const *)key);
15447|      0|            if (tmp___45) {
15448|      0|                if (!key->reverse) {
15449|      0|                    key->ignore = gkey.ignore;
15450|      0|                    key->translate = gkey.translate;
15451|      0|                    key->skipsblanks = gkey.skipsblanks;
15452|      0|                    key->skipeblanks = gkey.skipeblanks;
15453|      0|                    key->month = gkey.month;
15454|      0|                    key->numeric = gkey.numeric;
15455|      0|                    key->general_numeric = gkey.general_numeric;
15456|      0|                    key->human_numeric = gkey.human_numeric;
15457|      0|                    key->version = gkey.version;
15458|      0|                    key->random = gkey.random;
15459|      0|                    key->reverse = gkey.reverse;
15460|      0|                }
15461|      0|            }
15462|      0|            need_random = (_Bool)((int)need_random | (int)key->random);
15463|      0|            key = key->next;
15464|      0|        }
15465|      2|while_break___4:
15466|      2|        ;
15467|      2|        if (!keylist) {
15468|      2|            tmp___46 = default_key_compare((struct keyfield const *)(&gkey));
15469|      2|            if (!tmp___46) {
15470|      2|                gkey_only = (_Bool)1;
15471|      2|                insertkey(&gkey);
15472|      2|                need_random = (_Bool)((int)need_random | (int)gkey.random);
15473|      2|            }
15474|      2|        }
15475|      2|        check_ordering_compatibility();
15476|      2|        if (debug) {
15477|      0|            if (checkonly) {
15478|      0|                goto _L___2;
15479|      0|            }
15480|      0|            else {
15481|      0|                if (outfile) {
15482|      0|_L___2:
15483|      0|                    if (checkonly) {
15484|      0|                        opts[0] = checkonly;
15485|      0|                    }
15486|      0|                    else {
15487|      0|                        opts[0] = (char)'o';
15488|      0|                    }
15489|      0|                    incompatible_options((char const *)(opts));
15490|      0|                }
15491|      0|            }
15492|      0|            if (hard_LC_COLLATE) {
15493|      0|                tmp___47 = setlocale(3, (char const *)((void *)0));
15494|      0|                tmp___48 = quote((char const *)tmp___47);
15495|      0|                tmp___49 = gettext("using %s sorting rules");
15496|      0|                error(0, 0, (char const *)tmp___49, tmp___48);
15497|      0|            }
15498|      0|            else {
15499|      0|                tmp___50 = gettext("using simple byte comparison");
15500|      0|                error(0, 0, (char const *)tmp___50);
15501|      0|            }
15502|      0|            key_warnings((struct keyfield const *)(&gkey), gkey_only);
15503|      0|        }
15504|      2|        reverse = gkey.reverse;
15505|      2|        if (need_random) {
15506|      0|            random_md5_state_init((char const *)random_source);
15507|      0|        }
15508|      2|        if (temp_dir_count == 0UL) {
15509|      2|            tmp___51 = (char const *)getenv("TMPDIR");
15510|      2|            tmp_dir = tmp___51;
15511|      2|            if (tmp_dir) {
15512|      0|                tmp___52 = tmp_dir;
15513|      0|            }
15514|      2|            else {
15515|      2|                tmp___52 = "/tmp";
15516|      2|            }
15517|      2|            add_temp_dir(tmp___52);
15518|      2|        }
15519|      2|        if (nfiles == 0UL) {
15520|      0|            nfiles = (size_t)1;
15521|      0|            free((void *)files);
15522|      0|            files = &minus;
15523|      0|        }
15524|      2|        if (0UL < sort_size) {
15525|      0|            if (sort_size > (unsigned long)nmerge * (2UL + sizeof(struct line))) {
15526|      0|                sort_size = sort_size;
15527|      0|            }
15528|      0|            else {
15529|      0|                sort_size = (unsigned long)nmerge * (2UL + sizeof(struct line));
15530|      0|            }
15531|      0|        }
15532|      2|        if (checkonly) {
15533|      0|            if (nfiles > 1UL) {
15534|      0|                tmp___53 = quote((char const *)*(files + 1));
15535|      0|                tmp___54 = gettext("extra operand %s not allowed with -%c");
15536|      0|                error(2, 0, (char const *)tmp___54, tmp___53, (int)checkonly);
15537|      0|            }
15538|      0|            if (outfile) {
15539|      0|                opts___0[0] = checkonly;
15540|      0|                incompatible_options((char const *)(opts___0));
15541|      0|            }
15542|      0|            tmp___57 = check((char const *)*(files + 0), checkonly);
15543|      0|            if (tmp___57) {
15544|      0|                tmp___56 = 0;
15545|      0|            }
15546|      0|            else {
15547|      0|                tmp___56 = 1;
15548|      0|            }
15549|      0|            exit(tmp___56);
15550|      0|        }
15551|      2|        if (mergeonly) {
15552|      0|            tmp___58 = (struct sortfile *)xcalloc(nfiles, sizeof(*sortfiles));
15553|      0|            sortfiles = tmp___58;
15554|      0|            i___1 = (size_t)0;
15555|      0|            while (1) {
15556|       |
15557|      0|                if (!(i___1 < nfiles)) {
15558|      0|                    goto while_break___5;
15559|      0|                }
15560|      0|                (sortfiles + i___1)->name = (char const *)*(files + i___1);
15561|      0|                i___1++;
15562|      0|            }
15563|      0|while_break___5:
15564|      0|            merge(sortfiles, (size_t)0, nfiles, outfile);
15565|      0|        }
15566|      2|        else {
15567|      2|            if (!nthreads) {
15568|      2|                tmp___59 = num_processors((enum nproc_query)2);
15569|      2|                np = tmp___59;
15570|      2|                if (np < 8UL) {
15571|      0|                    nthreads = np;
15572|      0|                }
15573|      2|                else {
15574|      2|                    nthreads = (size_t)8;
15575|      2|                }
15576|      2|            }
15577|      2|            nthreads_max = 0xffffffffffffffffUL / (2UL * sizeof(struct merge_node));
15578|      2|            if (nthreads < nthreads_max) {
15579|      2|                nthreads = nthreads;
15580|      2|            }
15581|      0|            else {
15582|      0|                nthreads = nthreads_max;
15583|      0|            }
15584|      2|            sort((char *const *)files, nfiles, outfile, nthreads);
15585|      2|        }
15586|      2|        if (have_read_stdin) {
15587|      0|            tmp___61 = rpl_fclose(stdin);
15588|      0|            if (tmp___61 == -1) {
15589|      0|                tmp___60 = gettext("close failed");
15590|      0|                die((char const *)tmp___60, "-");
15591|      0|            }
15592|      0|        }
15593|      2|        exit(0);
15594|      2|    }
15595|      2|}


    1|       |typedef unsigned long size_t;
    2|       |typedef long __off_t;
    3|       |typedef long __off64_t;
    4|       |struct _IO_FILE;
    5|       |struct _IO_FILE;
    6|       |struct _IO_FILE;
    7|       |typedef struct _IO_FILE FILE;
    8|       |typedef void _IO_lock_t;
    9|       |struct _IO_marker {
   10|       |    struct _IO_marker *_next;
   11|       |    struct _IO_FILE *_sbuf;
   12|       |    int _pos;
   13|       |};
   14|       |struct _IO_FILE {
   15|       |    int _flags;
   16|       |    char *_IO_read_ptr;
   17|       |    char *_IO_read_end;
   18|       |    char *_IO_read_base;
   19|       |    char *_IO_write_base;
   20|       |    char *_IO_write_ptr;
   21|       |    char *_IO_write_end;
   22|       |    char *_IO_buf_base;
   23|       |    char *_IO_buf_end;
   24|       |    char *_IO_save_base;
   25|       |    char *_IO_backup_base;
   26|       |    char *_IO_save_end;
   27|       |    struct _IO_marker *_markers;
   28|       |    struct _IO_FILE *_chain;
   29|       |    int _fileno;
   30|       |    int _flags2;
   31|       |    __off_t _old_offset;
   32|       |    unsigned short _cur_column;
   33|       |    signed char _vtable_offset;
   34|       |    char _shortbuf[1];
   35|       |    _IO_lock_t *_lock;
   36|       |    __off64_t _offset;
   37|       |    void *__pad1;
   38|       |    void *__pad2;
   39|       |    void *__pad3;
   40|       |    void *__pad4;
   41|       |    size_t __pad5;
   42|       |    int _mode;
   43|       |    char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
   44|       |};
   45|       |typedef long __time_t;
   46|       |typedef unsigned long __dev_t;
   47|       |typedef unsigned int __uid_t;
   48|       |typedef unsigned int __gid_t;
   49|       |typedef unsigned long __ino_t;
   50|       |typedef unsigned int __mode_t;
   51|       |typedef unsigned long __nlink_t;
   52|       |typedef long __blksize_t;
   53|       |typedef long __blkcnt_t;
   54|       |typedef long __syscall_slong_t;
   55|       |typedef __mode_t mode_t;
   56|       |struct timespec {
   57|       |    __time_t tv_sec;
   58|       |    __syscall_slong_t tv_nsec;
   59|       |};
   60|       |struct stat {
   61|       |    __dev_t st_dev;
   62|       |    __ino_t st_ino;
   63|       |    __nlink_t st_nlink;
   64|       |    __mode_t st_mode;
   65|       |    __uid_t st_uid;
   66|       |    __gid_t st_gid;
   67|       |    int __pad0;
   68|       |    __dev_t st_rdev;
   69|       |    __off_t st_size;
   70|       |    __blksize_t st_blksize;
   71|       |    __blkcnt_t st_blocks;
   72|       |    struct timespec st_atim;
   73|       |    struct timespec st_mtim;
   74|       |    struct timespec st_ctim;
   75|       |    __syscall_slong_t __glibc_reserved[3];
   76|       |};
   77|       |typedef __ino_t ino_t;
   78|       |typedef __dev_t dev_t;
   79|       |struct hash_table;
   80|       |struct hash_table;
   81|       |struct hash_table;
   82|       |typedef struct hash_table Hash_table;
   83|       |struct F_triple {
   84|       |    char *name;
   85|       |    ino_t st_ino;
   86|       |    dev_t st_dev;
   87|       |};
   88|       |typedef __off_t off_t;
   89|       |typedef __builtin_va_list __gnuc_va_list;
   90|       |typedef __gnuc_va_list va_list;
   91|       |typedef int wchar_t;
   92|       |union __anonunion___value_4 {
   93|       |    unsigned int __wch;
   94|       |    char __wchb[4];
   95|       |};
   96|       |struct __anonstruct___mbstate_t_3 {
   97|       |    int __count;
   98|       |    union __anonunion___value_4 __value;
   99|       |};
  100|       |typedef struct __anonstruct___mbstate_t_3 __mbstate_t;
  101|       |typedef unsigned int wint_t;
  102|       |struct hash_tuning {
  103|       |    float shrink_threshold;
  104|       |    float shrink_factor;
  105|       |    float growth_threshold;
  106|       |    float growth_factor;
  107|       |    _Bool is_n_buckets;
  108|       |};
  109|       |typedef struct hash_tuning Hash_tuning;
  110|       |typedef __mbstate_t mbstate_t;
  111|       |struct mbchar {
  112|       |    char const *ptr;
  113|       |    size_t bytes;
  114|       |    _Bool wc_valid;
  115|       |    wchar_t wc;
  116|       |    char buf[24];
  117|       |};
  118|       |struct mbuiter_multi {
  119|       |    _Bool in_shift;
  120|       |    mbstate_t state;
  121|       |    _Bool next_done;
  122|       |    struct mbchar cur;
  123|       |};
  124|       |typedef struct mbuiter_multi mbui_iterator_t;
  125|       |typedef __gid_t gid_t;
  126|       |typedef __uid_t uid_t;
  127|       |typedef unsigned long uintmax_t;
  128|       |struct dev_ino {
  129|       |    ino_t st_ino;
  130|       |    dev_t st_dev;
  131|       |};
  132|       |struct cycle_check_state {
  133|       |    struct dev_ino dev_ino;
  134|       |    uintmax_t chdir_counter;
  135|       |    int magic;
  136|       |};
  137|       |typedef long ptrdiff_t;
  138|       |struct dirent {
  139|       |    __ino_t d_ino;
  140|       |    __off_t d_off;
  141|       |    unsigned short d_reclen;
  142|       |    unsigned char d_type;
  143|       |    char d_name[256];
  144|       |};
  145|       |struct __dirstream;
  146|       |struct __dirstream;
  147|       |struct __dirstream;
  148|       |typedef struct __dirstream DIR;
  149|       |typedef long __ssize_t;
  150|       |typedef __ssize_t ssize_t;
  151|       |enum quoting_style {
  152|       |    literal_quoting_style = 0,
  153|       |    shell_quoting_style = 1,
  154|       |    shell_always_quoting_style = 2,
  155|       |    c_quoting_style = 3,
  156|       |    c_maybe_quoting_style = 4,
  157|       |    escape_quoting_style = 5,
  158|       |    locale_quoting_style = 6,
  159|       |    clocale_quoting_style = 7,
  160|       |    custom_quoting_style = 8
  161|       |};
  162|       |struct option {
  163|       |    char const *name;
  164|       |    int has_arg;
  165|       |    int *flag;
  166|       |    int val;
  167|       |};
  168|       |typedef __nlink_t nlink_t;
  169|       |struct I_ring {
  170|       |    int ir_data[4];
  171|       |    int ir_default_val;
  172|       |    unsigned int ir_front;
  173|       |    unsigned int ir_back;
  174|       |    _Bool ir_empty;
  175|       |};
  176|       |typedef struct I_ring I_ring;
  177|       |struct _ftsent;
  178|       |struct _ftsent;
  179|       |struct _ftsent;
  180|       |union __anonunion_fts_cycle_26 {
  181|       |    struct hash_table *ht;
  182|       |    struct cycle_check_state *state;
  183|       |};
  184|       |struct __anonstruct_FTS_25 {
  185|       |    struct _ftsent *fts_cur;
  186|       |    struct _ftsent *fts_child;
  187|       |    struct _ftsent **fts_array;
  188|       |    dev_t fts_dev;
  189|       |    char *fts_path;
  190|       |    int fts_rfd;
  191|       |    int fts_cwd_fd;
  192|       |    size_t fts_pathlen;
  193|       |    size_t fts_nitems;
  194|       |    int (*fts_compar)(struct _ftsent const **, struct _ftsent const **);
  195|       |    int fts_options;
  196|       |    struct hash_table *fts_leaf_optimization_works_ht;
  197|       |    union __anonunion_fts_cycle_26 fts_cycle;
  198|       |    I_ring fts_fd_ring;
  199|       |};
  200|       |typedef struct __anonstruct_FTS_25 FTS;
  201|       |struct _ftsent {
  202|       |    struct _ftsent *fts_cycle;
  203|       |    struct _ftsent *fts_parent;
  204|       |    struct _ftsent *fts_link;
  205|       |    long fts_number;
  206|       |    void *fts_pointer;
  207|       |    char *fts_accpath;
  208|       |    char *fts_path;
  209|       |    int fts_errno;
  210|       |    int fts_symfd;
  211|       |    size_t fts_pathlen;
  212|       |    FTS *fts_fts;
  213|       |    ptrdiff_t fts_level;
  214|       |    size_t fts_namelen;
  215|       |    nlink_t fts_n_dirs_remaining;
  216|       |    unsigned short fts_info;
  217|       |    unsigned short fts_flags;
  218|       |    unsigned short fts_instr;
  219|       |    struct stat fts_statp[1];
  220|       |    char fts_name[1];
  221|       |};
  222|       |typedef struct _ftsent FTSENT;
  223|       |typedef unsigned long reg_syntax_t;
  224|       |struct quoting_options;
  225|       |struct quoting_options;
  226|       |struct quoting_options;
  227|       |struct quoting_options {
  228|       |    enum quoting_style style;
  229|       |    int flags;
  230|       |    unsigned int quote_these_too[255UL / (sizeof(int) * 8UL) + 1UL];
  231|       |    char const *left_quote;
  232|       |    char const *right_quote;
  233|       |};
  234|       |struct slotvec {
  235|       |    size_t size;
  236|       |    char *val;
  237|       |};
  238|       |struct hash_entry {
  239|       |    void *data;
  240|       |    struct hash_entry *next;
  241|       |};
  242|       |struct hash_table {
  243|       |    struct hash_entry *bucket;
  244|       |    struct hash_entry const *bucket_limit;
  245|       |    size_t n_buckets;
  246|       |    size_t n_buckets_used;
  247|       |    size_t n_entries;
  248|       |    Hash_tuning const *tuning;
  249|       |    size_t (*hasher)(void const *, size_t);
  250|       |    _Bool (*comparator)(void const *, void const *);
  251|       |    void (*data_freer)(void *);
  252|       |    struct hash_entry *free_entry_list;
  253|       |};
  254|       |struct __anonstruct___fsid_t_1 {
  255|       |    int __val[2];
  256|       |};
  257|       |typedef struct __anonstruct___fsid_t_1 __fsid_t;
  258|       |typedef unsigned long __fsblkcnt_t;
  259|       |typedef unsigned long __fsfilcnt_t;
  260|       |typedef long __fsword_t;
  261|       |struct Active_dir {
  262|       |    dev_t dev;
  263|       |    ino_t ino;
  264|       |    FTSENT *fts_ent;
  265|       |};
  266|       |struct statfs {
  267|       |    __fsword_t f_type;
  268|       |    __fsword_t f_bsize;
  269|       |    __fsblkcnt_t f_blocks;
  270|       |    __fsblkcnt_t f_bfree;
  271|       |    __fsblkcnt_t f_bavail;
  272|       |    __fsfilcnt_t f_files;
  273|       |    __fsfilcnt_t f_ffree;
  274|       |    __fsid_t f_fsid;
  275|       |    __fsword_t f_namelen;
  276|       |    __fsword_t f_frsize;
  277|       |    __fsword_t f_flags;
  278|       |    __fsword_t f_spare[4];
  279|       |};
  280|       |struct LCO_ent {
  281|       |    dev_t st_dev;
  282|       |    _Bool opt_ok;
  283|       |};
  284|       |enum rm_interactive { RMI_ALWAYS = 3,
  285|       |                      RMI_SOMETIMES = 4,
  286|       |                      RMI_NEVER = 5
  287|       |                    };
  288|       |struct rm_options {
  289|       |    _Bool ignore_missing_files;
  290|       |    enum rm_interactive interactive;
  291|       |    _Bool one_file_system;
  292|       |    _Bool recursive;
  293|       |    struct dev_ino *root_dev_ino;
  294|       |    _Bool stdin_tty;
  295|       |    _Bool verbose;
  296|       |    _Bool require_restore_cwd;
  297|       |};
  298|       |enum RM_status {
  299|       |    RM_OK = 2,
  300|       |    RM_USER_DECLINED = 3,
  301|       |    RM_ERROR = 4,
  302|       |    RM_NONEMPTY_DIR = 5
  303|       |};
  304|       |enum Ternary { T_UNKNOWN = 2,
  305|       |               T_NO = 3,
  306|       |               T_YES = 4
  307|       |             };
  308|       |typedef enum Ternary Ternary;
  309|       |enum Prompt_action { PA_DESCEND_INTO_DIR = 2,
  310|       |                     PA_REMOVE_DIR = 3
  311|       |                   };
  312|       |enum interactive_type {
  313|       |    interactive_never = 0,
  314|       |    interactive_once = 1,
  315|       |    interactive_always = 2
  316|       |};
  317|       |size_t freadahead(FILE *fp);
  318|       |size_t freadahead(FILE *fp)
  319|      2|{
  320|      2|    long tmp;
  321|       |
  322|      2|    {
  323|      2|        if ((unsigned long)fp->_IO_write_ptr > (unsigned long)fp->_IO_write_base) {
  324|      0|            return ((size_t)0);
  325|      0|        }
  326|      2|        if (fp->_flags & 256) {
  327|      0|            tmp = fp->_IO_save_end - fp->_IO_save_base;
  328|      0|        }
  329|      2|        else {
  330|      2|            tmp = 0L;
  331|      2|        }
  332|      2|        return ((size_t)((fp->_IO_read_end - fp->_IO_read_ptr) + tmp));
  333|      2|    }
  334|      2|}
  335|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  336|       |                                        tolower)(int __c);
  337|       |extern __attribute__((__nothrow__))
  338|       |size_t(__attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s)
  339|       |__attribute__((__pure__));
  340|       |extern int fclose(FILE *__stream);
  341|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  342|       |                                        fileno)(FILE *__stream);
  343|       |extern __attribute__((__nothrow__)) int *(
  344|       |    __attribute__((__leaf__)) __errno_location)(void)__attribute__((__const__));
  345|       |extern int close(int __fd);
  346|       |int dup_safer(int fd);
  347|       |extern __attribute__((__nothrow__)) int(
  348|       |    __attribute__((__nonnull__(1, 2), __leaf__))
  349|       |    strcmp)(char const *__s1, char const *__s2) __attribute__((__pure__));
  350|       |extern __attribute__((__nothrow__)) int(
  351|       |    __attribute__((__nonnull__(1, 2), __leaf__))
  352|       |    strncmp)(char const *__s1, char const *__s2, size_t __n)
  353|       |__attribute__((__pure__));
  354|       |__attribute__((__noreturn__)) void xalloc_die(void);
  355|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
  356|       |        malloc)(size_t __size)
  357|       |__attribute__((__malloc__));
  358|       |size_t base_len(char const *name);
  359|       |char *last_component(char const *name);
  360|       |char const *file_type(struct stat const *st);
  361|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
  362|       |        gettext)(char const *__msgid)
  363|       |__attribute__((__format_arg__(1)));
  364|       |char const *file_type(struct stat const *st)
  365|      0|{
  366|      0|    char *tmp;
  367|      0|    char *tmp___0;
  368|      0|    char *tmp___1;
  369|      0|    char const *tmp___2;
  370|      0|    char const *tmp___3;
  371|      0|    char const *tmp___4;
  372|      0|    char const *tmp___5;
  373|      0|    char const *tmp___6;
  374|      0|    char const *tmp___7;
  375|      0|    char const *tmp___8;
  376|      0|    char const *tmp___9;
  377|      0|    char const *tmp___10;
  378|      0|    char const *tmp___12;
  379|       |
  380|      0|    {
  381|      0|        if ((st->st_mode & 61440U) == 32768U) {
  382|      0|            if (st->st_size == 0L) {
  383|      0|                tmp = gettext("regular empty file");
  384|      0|                tmp___1 = tmp;
  385|      0|            }
  386|      0|            else {
  387|      0|                tmp___0 = gettext("regular file");
  388|      0|                tmp___1 = tmp___0;
  389|      0|            }
  390|      0|            return ((char const *)tmp___1);
  391|      0|        }
  392|      0|        if ((st->st_mode & 61440U) == 16384U) {
  393|      0|            tmp___2 = (char const *)gettext("directory");
  394|      0|            return (tmp___2);
  395|      0|        }
  396|      0|        if ((st->st_mode & 61440U) == 24576U) {
  397|      0|            tmp___3 = (char const *)gettext("block special file");
  398|      0|            return (tmp___3);
  399|      0|        }
  400|      0|        if ((st->st_mode & 61440U) == 8192U) {
  401|      0|            tmp___4 = (char const *)gettext("character special file");
  402|      0|            return (tmp___4);
  403|      0|        }
  404|      0|        if ((st->st_mode & 61440U) == 4096U) {
  405|      0|            tmp___5 = (char const *)gettext("fifo");
  406|      0|            return (tmp___5);
  407|      0|        }
  408|      0|        if ((st->st_mode & 61440U) == 40960U) {
  409|      0|            tmp___6 = (char const *)gettext("symbolic link");
  410|      0|            return (tmp___6);
  411|      0|        }
  412|      0|        if ((st->st_mode & 61440U) == 49152U) {
  413|      0|            tmp___7 = (char const *)gettext("socket");
  414|      0|            return (tmp___7);
  415|      0|        }
  416|      0|        if (st->st_mode - st->st_mode) {
  417|      0|            tmp___8 = (char const *)gettext("message queue");
  418|      0|            return (tmp___8);
  419|      0|        }
  420|      0|        if (st->st_mode - st->st_mode) {
  421|      0|            tmp___9 = (char const *)gettext("semaphore");
  422|      0|            return (tmp___9);
  423|      0|        }
  424|      0|        if (st->st_mode - st->st_mode) {
  425|      0|            tmp___10 = (char const *)gettext("shared memory object");
  426|      0|            return (tmp___10);
  427|      0|        }
  428|      0|        tmp___12 = (char const *)gettext("weird file");
  429|      0|        return (tmp___12);
  430|      0|    }
  431|      0|}
  432|       |void *hash_lookup(Hash_table const *table___0, void const *entry);
  433|       |void *(__attribute__((__warn_unused_result__))
  434|       |       hash_insert)(Hash_table *table___0, void const *entry);
  435|       |void triple_free(void *x);
  436|       |void *xmalloc(size_t n) __attribute__((__malloc__));
  437|       |extern int fflush(FILE *__stream);
  438|       |int rpl_fflush(FILE *stream);
  439|       |int(__attribute__((__nonnull__(1))) rpl_fseeko)(FILE *fp, off_t offset,
  440|       |        int whence);
  441|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  442|       |                                        __freading)(FILE *__fp);
  443|       |__inline static void clear_ungetc_buffer_preserving_position(FILE *fp)
  444|      0|{
  445|       |
  446|      0|    {
  447|      0|        if (fp->_flags & 256) {
  448|      0|            rpl_fseeko(fp, (off_t)0, 1);
  449|      0|        }
  450|      0|        return;
  451|      0|    }
  452|      0|}
  453|       |int rpl_fflush(FILE *stream)
  454|      0|{
  455|      0|    int tmp;
  456|      0|    int tmp___0;
  457|      0|    int tmp___1;
  458|       |
  459|      0|    {
  460|      0|        if ((unsigned long)stream == (unsigned long)((void *)0)) {
  461|      0|            tmp = fflush(stream);
  462|      0|            return (tmp);
  463|      0|        }
  464|      0|        else {
  465|      0|            tmp___0 = __freading(stream);
  466|      0|            if (!(tmp___0 != 0)) {
  467|      0|                tmp = fflush(stream);
  468|      0|                return (tmp);
  469|      0|            }
  470|      0|        }
  471|      0|        clear_ungetc_buffer_preserving_position(stream);
  472|      0|        tmp___1 = fflush(stream);
  473|      0|        return (tmp___1);
  474|      0|    }
  475|      0|}
  476|       |int fd_safer(int fd);
  477|       |int fd_safer(int fd)
  478|     14|{
  479|     14|    int f;
  480|     14|    int tmp;
  481|     14|    int e;
  482|     14|    int *tmp___0;
  483|     14|    int *tmp___1;
  484|       |
  485|     14|    {
  486|     14|        if (0 <= fd) {
  487|     14|            if (fd <= 2) {
  488|      0|                tmp = dup_safer(fd);
  489|      0|                f = tmp;
  490|      0|                tmp___0 = __errno_location();
  491|      0|                e = *tmp___0;
  492|      0|                close(fd);
  493|      0|                tmp___1 = __errno_location();
  494|      0|                *tmp___1 = e;
  495|      0|                fd = f;
  496|      0|            }
  497|     14|        }
  498|     14|        return (fd);
  499|     14|    }
  500|     14|}
  501|       |extern int(__attribute__((__nonnull__(1))) open)(char const *__file,
  502|       |        int __oflag, ...);
  503|       |extern int fcntl(int __fd, int __cmd, ...);
  504|       |int rpl_fcntl(int fd, int action, ...);
  505|       |static int have_dupfd_cloexec = 0;
  506|       |int rpl_fcntl(int fd, int action, ...)
  507|     58|{
  508|     58|    va_list arg;
  509|     58|    int result;
  510|     58|    int target;
  511|     58|    int tmp;
  512|     58|    int *tmp___0;
  513|     58|    int flags;
  514|     58|    int tmp___1;
  515|     58|    int saved_errno;
  516|     58|    int *tmp___2;
  517|     58|    int *tmp___3;
  518|     58|    int tmp___4;
  519|     58|    void *p;
  520|     58|    void *tmp___5;
  521|       |
  522|     58|    {
  523|     58|        result = -1;
  524|     58|        __builtin_va_start(arg, action);
  525|     58|        if (action == 1030) {
  526|      0|            goto case_1030;
  527|      0|        }
  528|     58|        goto switch_default;
  529|     58|case_1030:
  530|      0|        tmp = __builtin_va_arg(arg, int);
  531|      0|        target = tmp;
  532|      0|        if (0 <= have_dupfd_cloexec) {
  533|      0|            result = fcntl(fd, action, target);
  534|      0|            if (0 <= result) {
  535|      0|                have_dupfd_cloexec = 1;
  536|      0|            }
  537|      0|            else {
  538|      0|                tmp___0 = __errno_location();
  539|      0|                if (*tmp___0 != 22) {
  540|      0|                    have_dupfd_cloexec = 1;
  541|      0|                }
  542|      0|                else {
  543|      0|                    result = rpl_fcntl(fd, 0, target);
  544|      0|                    if (result < 0) {
  545|      0|                        goto switch_break;
  546|      0|                    }
  547|      0|                    have_dupfd_cloexec = -1;
  548|      0|                }
  549|      0|            }
  550|      0|        }
  551|      0|        else {
  552|      0|            result = rpl_fcntl(fd, 0, target);
  553|      0|        }
  554|      0|        if (0 <= result) {
  555|      0|            if (have_dupfd_cloexec == -1) {
  556|      0|                tmp___1 = fcntl(result, 1);
  557|      0|                flags = tmp___1;
  558|      0|                if (flags < 0) {
  559|      0|                    goto _L;
  560|      0|                }
  561|      0|                else {
  562|      0|                    tmp___4 = fcntl(result, 2, flags | 1);
  563|      0|                    if (tmp___4 == -1) {
  564|      0|_L:
  565|      0|                        tmp___2 = __errno_location();
  566|      0|                        saved_errno = *tmp___2;
  567|      0|                        close(result);
  568|      0|                        tmp___3 = __errno_location();
  569|      0|                        *tmp___3 = saved_errno;
  570|      0|                        result = -1;
  571|      0|                    }
  572|      0|                }
  573|      0|            }
  574|      0|        }
  575|      0|        goto switch_break;
  576|     58|switch_default:
  577|     58|        tmp___5 = __builtin_va_arg(arg, void *);
  578|     58|        p = tmp___5;
  579|     58|        result = fcntl(fd, action, p);
  580|     58|        goto switch_break;
  581|     58|switch_break:
  582|     58|        __builtin_va_end(arg);
  583|     58|        return (result);
  584|      0|    }
  585|      0|}
  586|       |int volatile exit_failure;
  587|       |int volatile exit_failure = (int volatile)1;
  588|       |extern __attribute__((__nothrow__)) unsigned short const **(
  589|       |    __attribute__((__leaf__)) __ctype_b_loc)(void)__attribute__((__const__));
  590|       |extern struct _IO_FILE *stdin;
  591|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  592|       |                                        ferror_unlocked)(FILE *__stream);
  593|       |extern __attribute__((__nothrow__))
  594|       |size_t(__attribute__((__leaf__)) __ctype_get_mb_cur_max)(void);
  595|       |extern __attribute__((__nothrow__)) void(__attribute__((__leaf__))
  596|       |        free)(void *__ptr);
  597|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__))
  598|       |        abort)(void);
  599|       |extern
  600|       |__attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1),
  601|       |                                    __leaf__))
  602|       |                                    memset)(void *__s, int __c, size_t __n);
  603|       |extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1),
  604|       |        __leaf__))
  605|       |        strrchr)(char const *__s, int __c)
  606|       |__attribute__((__pure__));
  607|       |int(__attribute__((__nonnull__(1, 2))) mbscasecmp)(char const *s1,
  608|       |        char const *s2);
  609|       |extern __attribute__((__nothrow__))
  610|       |wint_t(__attribute__((__leaf__)) towlower)(wint_t __wc);
  611|       |size_t hash_string(char const *string, size_t n_buckets);
  612|       |Hash_table *(__attribute__((__warn_unused_result__))
  613|       |             hash_initialize)(size_t candidate, Hash_tuning const *tuning,
  614|       |                              size_t (*hasher)(void const *, size_t),
  615|       |                              _Bool (*comparator)(void const *, void const *),
  616|       |                              void (*data_freer)(void *));
  617|       |void hash_free(Hash_table *table___0);
  618|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((
  619|       |            __leaf__)) __assert_fail)(char const *__assertion, char const *__file,
  620|       |                                      unsigned int __line, char const *__function);
  621|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  622|       |                                        mbsinit)(mbstate_t const *__ps)
  623|       |__attribute__((__pure__));
  624|       |extern __attribute__((__nothrow__))
  625|       |size_t(__attribute__((__leaf__))
  626|       |       mbrtowc)(wchar_t *__restrict __pwc, char const *__restrict __s,
  627|       |                size_t __n, mbstate_t *__restrict __p);
  628|       |unsigned int const is_basic_table[8];
  629|       |__inline static _Bool is_basic(char c)
  630|      0|{
  631|       |
  632|      0|    {
  633|      0|        return ((_Bool)((is_basic_table[(int)((unsigned char)c) >> 5] >>
  634|      0|                         ((int)((unsigned char)c) & 31)) &
  635|      0|                        1U));
  636|      0|    }
  637|      0|}
  638|       |size_t strnlen1(char const *string, size_t maxlen);
  639|       |__inline static void mbuiter_multi_next(struct mbuiter_multi *iter)
  640|      0|{
  641|      0|    int tmp;
  642|      0|    size_t tmp___0;
  643|      0|    size_t tmp___1;
  644|      0|    int tmp___2;
  645|      0|    _Bool tmp___3;
  646|       |
  647|      0|    {
  648|      0|        if (iter->next_done) {
  649|      0|            return;
  650|      0|        }
  651|      0|        if (iter->in_shift) {
  652|      0|            goto with_shift;
  653|      0|        }
  654|      0|        tmp___3 = is_basic((char)*(iter->cur.ptr));
  655|      0|        if (tmp___3) {
  656|      0|            iter->cur.bytes = (size_t)1;
  657|      0|            iter->cur.wc = (wchar_t) * (iter->cur.ptr);
  658|      0|            iter->cur.wc_valid = (_Bool)1;
  659|      0|        }
  660|      0|        else {
  661|      0|            tmp = mbsinit((mbstate_t const *)(&iter->state));
  662|      0|            if (!tmp) {
  663|      0|                __assert_fail(
  664|      0|                    "mbsinit (&iter->state)",
  665|      0|                    "/home/khheo/project/benchmark/coreutils-8.4/lib/mbuiter.h", 142U,
  666|      0|                    "mbuiter_multi_next");
  667|      0|            }
  668|      0|            iter->in_shift = (_Bool)1;
  669|      0|with_shift:
  670|      0|            tmp___0 = __ctype_get_mb_cur_max();
  671|      0|            tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
  672|      0|            iter->cur.bytes =
  673|      0|                mbrtowc(&iter->cur.wc, iter->cur.ptr, tmp___1, &iter->state);
  674|      0|            if (iter->cur.bytes == 0xffffffffffffffffUL) {
  675|      0|                iter->cur.bytes = (size_t)1;
  676|      0|                iter->cur.wc_valid = (_Bool)0;
  677|      0|            }
  678|      0|            else {
  679|      0|                if (iter->cur.bytes == 0xfffffffffffffffeUL) {
  680|      0|                    iter->cur.bytes = strlen(iter->cur.ptr);
  681|      0|                    iter->cur.wc_valid = (_Bool)0;
  682|      0|                }
  683|      0|                else {
  684|      0|                    if (iter->cur.bytes == 0UL) {
  685|      0|                        iter->cur.bytes = (size_t)1;
  686|      0|                        if (!((int const) * (iter->cur.ptr) == 0)) {
  687|      0|                            __assert_fail(
  688|      0|                                "*iter->cur.ptr == \'\\0\'",
  689|      0|                                "/home/khheo/project/benchmark/coreutils-8.4/lib/mbuiter.h",
  690|      0|                                170U, "mbuiter_multi_next");
  691|      0|                        }
  692|      0|                        if (!(iter->cur.wc == 0)) {
  693|      0|                            __assert_fail(
  694|      0|                                "iter->cur.wc == 0",
  695|      0|                                "/home/khheo/project/benchmark/coreutils-8.4/lib/mbuiter.h",
  696|      0|                                171U, "mbuiter_multi_next");
  697|      0|                        }
  698|      0|                    }
  699|      0|                    iter->cur.wc_valid = (_Bool)1;
  700|      0|                    tmp___2 = mbsinit((mbstate_t const *)(&iter->state));
  701|      0|                    if (tmp___2) {
  702|      0|                        iter->in_shift = (_Bool)0;
  703|      0|                    }
  704|      0|                }
  705|      0|            }
  706|      0|        }
  707|      0|        iter->next_done = (_Bool)1;
  708|      0|        return;
  709|      0|    }
  710|      0|}
  711|       |void *xrealloc(void *p, size_t n);
  712|       |_Bool euidaccess_stat(struct stat const *st, int mode);
  713|       |extern __attribute__((__nothrow__))
  714|       |__uid_t(__attribute__((__leaf__)) geteuid)(void);
  715|       |extern __attribute__((__nothrow__))
  716|       |__gid_t(__attribute__((__leaf__)) getegid)(void);
  717|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  718|       |                                        group_member)(__gid_t __gid);
  719|       |_Bool euidaccess_stat(struct stat const *st, int mode)
  720|      0|{
  721|      0|    uid_t euid;
  722|      0|    unsigned int granted;
  723|      0|    int tmp___2;
  724|      0|    int tmp___3;
  725|      0|    int tmp___4;
  726|      0|    int tmp___5;
  727|      0|    int tmp___6;
  728|      0|    int tmp___7;
  729|      0|    int tmp___8;
  730|      0|    int tmp___9;
  731|      0|    int tmp___10;
  732|      0|    gid_t egid;
  733|      0|    gid_t tmp___11;
  734|      0|    int tmp___12;
  735|       |
  736|      0|    {
  737|      0|        mode &= 7;
  738|      0|        if (mode == 0) {
  739|      0|            return ((_Bool)1);
  740|      0|        }
  741|      0|        euid = geteuid();
  742|      0|        if (euid == 0U) {
  743|      0|            if ((mode & 1) == 0) {
  744|      0|                return ((_Bool)1);
  745|      0|            }
  746|      0|            else {
  747|      0|                if (st->st_mode &
  748|      0|                        (unsigned int const)((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
  749|      0|                    return ((_Bool)1);
  750|      0|                }
  751|      0|            }
  752|      0|        }
  753|      0|        if (256 == 4 << 6) {
  754|      0|            if (128 == 2 << 6) {
  755|      0|                if (64 == 1 << 6) {
  756|      0|                    if (256 >> 3 == 4 << 3) {
  757|      0|                        if (128 >> 3 == 2 << 3) {
  758|      0|                            if (64 >> 3 == 1 << 3) {
  759|      0|                                if ((256 >> 3) >> 3 == 4) {
  760|      0|                                    if ((128 >> 3) >> 3 == 2) {
  761|      0|                                        if ((64 >> 3) >> 3 == 1) {
  762|      0|                                            granted = (unsigned int)st->st_mode;
  763|      0|                                        }
  764|      0|                                        else {
  765|      0|                                            goto _L___6;
  766|      0|                                        }
  767|      0|                                    }
  768|      0|                                    else {
  769|      0|                                        goto _L___6;
  770|      0|                                    }
  771|      0|                                }
  772|      0|                                else {
  773|      0|                                    goto _L___6;
  774|      0|                                }
  775|      0|                            }
  776|      0|                            else {
  777|      0|                                goto _L___6;
  778|      0|                            }
  779|      0|                        }
  780|      0|                        else {
  781|      0|                            goto _L___6;
  782|      0|                        }
  783|      0|                    }
  784|      0|                    else {
  785|      0|                        goto _L___6;
  786|      0|                    }
  787|      0|                }
  788|      0|                else {
  789|      0|                    goto _L___6;
  790|      0|                }
  791|      0|            }
  792|      0|            else {
  793|      0|                goto _L___6;
  794|      0|            }
  795|      0|        }
  796|      0|        else {
  797|      0|_L___6:
  798|      0|            if (st->st_mode & 256U) {
  799|      0|                tmp___2 = 4 << 6;
  800|      0|            }
  801|      0|            else {
  802|      0|                tmp___2 = 0;
  803|      0|            }
  804|      0|            if (st->st_mode & 128U) {
  805|      0|                tmp___3 = 2 << 6;
  806|      0|            }
  807|      0|            else {
  808|      0|                tmp___3 = 0;
  809|      0|            }
  810|      0|            if (st->st_mode & 64U) {
  811|      0|                tmp___4 = 1 << 6;
  812|      0|            }
  813|      0|            else {
  814|      0|                tmp___4 = 0;
  815|      0|            }
  816|      0|            if (st->st_mode & (unsigned int const)(256 >> 3)) {
  817|      0|                tmp___5 = 4 << 3;
  818|      0|            }
  819|      0|            else {
  820|      0|                tmp___5 = 0;
  821|      0|            }
  822|      0|            if (st->st_mode & (unsigned int const)(128 >> 3)) {
  823|      0|                tmp___6 = 2 << 3;
  824|      0|            }
  825|      0|            else {
  826|      0|                tmp___6 = 0;
  827|      0|            }
  828|      0|            if (st->st_mode & (unsigned int const)(64 >> 3)) {
  829|      0|                tmp___7 = 1 << 3;
  830|      0|            }
  831|      0|            else {
  832|      0|                tmp___7 = 0;
  833|      0|            }
  834|      0|            if (st->st_mode & (unsigned int const)((256 >> 3) >> 3)) {
  835|      0|                tmp___8 = 4;
  836|      0|            }
  837|      0|            else {
  838|      0|                tmp___8 = 0;
  839|      0|            }
  840|      0|            if (st->st_mode & (unsigned int const)((128 >> 3) >> 3)) {
  841|      0|                tmp___9 = 2;
  842|      0|            }
  843|      0|            else {
  844|      0|                tmp___9 = 0;
  845|      0|            }
  846|      0|            if (st->st_mode & (unsigned int const)((64 >> 3) >> 3)) {
  847|      0|                tmp___10 = 1;
  848|      0|            }
  849|      0|            else {
  850|      0|                tmp___10 = 0;
  851|      0|            }
  852|      0|            granted = (unsigned int)((((((((tmp___2 + tmp___3) + tmp___4) + tmp___5) +
  853|      0|                                         tmp___6) +
  854|      0|                                        tmp___7) +
  855|      0|                                       tmp___8) +
  856|      0|                                      tmp___9) +
  857|      0|                                     tmp___10);
  858|      0|        }
  859|      0|        if (euid == (uid_t)st->st_uid) {
  860|      0|            granted >>= 6;
  861|      0|        }
  862|      0|        else {
  863|      0|            tmp___11 = getegid();
  864|      0|            egid = tmp___11;
  865|      0|            if (egid == (gid_t)st->st_gid) {
  866|      0|                granted >>= 3;
  867|      0|            }
  868|      0|            else {
  869|      0|                tmp___12 = group_member((__gid_t)st->st_gid);
  870|      0|                if (tmp___12) {
  871|      0|                    granted >>= 3;
  872|      0|                }
  873|      0|            }
  874|      0|        }
  875|      0|        if (((unsigned int)mode & ~granted) == 0U) {
  876|      0|            return ((_Bool)1);
  877|      0|        }
  878|      0|        return ((_Bool)0);
  879|      0|    }
  880|      0|}
  881|       |int dup_safer(int fd)
  882|     10|{
  883|     10|    int tmp;
  884|       |
  885|     10|    {
  886|     10|        tmp = rpl_fcntl(fd, 0, 3);
  887|     10|        return (tmp);
  888|     10|    }
  889|     10|}
  890|       |extern __attribute__((__nothrow__)) int(
  891|       |    __attribute__((__nonnull__(1, 2), __leaf__))
  892|       |    stat)(char const *__restrict __file, struct stat *__restrict __buf);
  893|       |extern
  894|       |__attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
  895|       |                                 fstat)(int __fd, struct stat *__buf);
  896|       |char const diacrit_base[256];
  897|       |char const diacrit_diac[256];
  898|       |char const diacrit_base[256] = {
  899|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  900|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  901|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  902|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  903|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  904|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  905|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  906|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  907|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  908|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  909|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  910|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  911|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  912|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  913|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  914|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  915|       |    (char const)0, (char const)'A', (char const)'B', (char const)'C',
  916|       |    (char const)'D', (char const)'E', (char const)'F', (char const)'G',
  917|       |    (char const)'H', (char const)'I', (char const)'J', (char const)'K',
  918|       |    (char const)'L', (char const)'M', (char const)'N', (char const)'O',
  919|       |    (char const)'P', (char const)'Q', (char const)'R', (char const)'S',
  920|       |    (char const)'T', (char const)'U', (char const)'V', (char const)'W',
  921|       |    (char const)'X', (char const)'Y', (char const)'Z', (char const)0,
  922|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  923|       |    (char const)0, (char const)'a', (char const)'b', (char const)'c',
  924|       |    (char const)'d', (char const)'e', (char const)'f', (char const)'g',
  925|       |    (char const)'h', (char const)'i', (char const)'j', (char const)'k',
  926|       |    (char const)'l', (char const)'m', (char const)'n', (char const)'o',
  927|       |    (char const)'p', (char const)'q', (char const)'r', (char const)'s',
  928|       |    (char const)'t', (char const)'u', (char const)'v', (char const)'w',
  929|       |    (char const)'x', (char const)'y', (char const)'z', (char const)0,
  930|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  931|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  932|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  933|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  934|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  935|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  936|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  937|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  938|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  939|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  940|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  941|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  942|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  943|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  944|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  945|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  946|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  947|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'A',
  948|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'C',
  949|       |    (char const)'E', (char const)'E', (char const)'E', (char const)'E',
  950|       |    (char const)'I', (char const)'I', (char const)'I', (char const)'I',
  951|       |    (char const)0, (char const)'N', (char const)'O', (char const)'O',
  952|       |    (char const)'O', (char const)'O', (char const)'O', (char const)0,
  953|       |    (char const)'O', (char const)'U', (char const)'U', (char const)'U',
  954|       |    (char const)'U', (char const)'Y', (char const)0, (char const)0,
  955|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'a',
  956|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'c',
  957|       |    (char const)'e', (char const)'e', (char const)'e', (char const)'e',
  958|       |    (char const)'i', (char const)'i', (char const)'i', (char const)'i',
  959|       |    (char const)0, (char const)'n', (char const)'o', (char const)'o',
  960|       |    (char const)'o', (char const)'o', (char const)'o', (char const)0,
  961|       |    (char const)'o', (char const)'u', (char const)'u', (char const)'u',
  962|       |    (char const)'u', (char const)'y', (char const)0, (char const)'y'
  963|       |};
  964|       |char const diacrit_diac[256] = {
  965|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  966|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  967|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  968|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  969|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  970|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  971|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  972|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  973|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  974|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  975|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  976|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  977|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  978|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  979|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  980|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  981|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  982|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  983|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)4,
  984|       |    (char const)0, (char const)3, (char const)0, (char const)0, (char const)0,
  985|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  986|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  987|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  988|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  989|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  990|       |    (char const)0, (char const)6, (char const)0, (char const)0, (char const)0,
  991|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  992|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  993|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  994|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  995|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  996|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  997|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  998|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  999|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
 1000|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
 1001|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
 1002|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
 1003|       |    (char const)0, (char const)0, (char const)3, (char const)2, (char const)4,
 1004|       |    (char const)6, (char const)5, (char const)8, (char const)1, (char const)7,
 1005|       |    (char const)3, (char const)2, (char const)4, (char const)5, (char const)3,
 1006|       |    (char const)2, (char const)4, (char const)5, (char const)0, (char const)6,
 1007|       |    (char const)3, (char const)2, (char const)4, (char const)6, (char const)5,
 1008|       |    (char const)0, (char const)9, (char const)3, (char const)2, (char const)4,
 1009|       |    (char const)5, (char const)2, (char const)0, (char const)0, (char const)3,
 1010|       |    (char const)2, (char const)4, (char const)6, (char const)5, (char const)8,
 1011|       |    (char const)1, (char const)7, (char const)3, (char const)2, (char const)4,
 1012|       |    (char const)5, (char const)3, (char const)2, (char const)4, (char const)5,
 1013|       |    (char const)0, (char const)6, (char const)3, (char const)2, (char const)4,
 1014|       |    (char const)6, (char const)5, (char const)0, (char const)9, (char const)3,
 1015|       |    (char const)2, (char const)4, (char const)5, (char const)2, (char const)0,
 1016|       |    (char const)0
 1017|       |};
 1018|       |void cycle_check_init(struct cycle_check_state *state);
 1019|       |_Bool cycle_check(struct cycle_check_state *state, struct stat const *sb);
 1020|       |__inline static _Bool is_zero_or_power_of_two(uintmax_t i)
 1021|     10|{
 1022|       |
 1023|     10|    {
 1024|     10|        return ((_Bool)((i & (i - 1UL)) == 0UL));
 1025|     10|    }
 1026|     10|}
 1027|       |void cycle_check_init(struct cycle_check_state *state)
 1028|      6|{
 1029|       |
 1030|      6|    {
 1031|      6|        state->chdir_counter = (uintmax_t)0;
 1032|      6|        state->magic = 9827862;
 1033|      6|        return;
 1034|      6|    }
 1035|      6|}
 1036|       |_Bool cycle_check(struct cycle_check_state *state, struct stat const *sb)
 1037|     10|{
 1038|     10|    _Bool tmp;
 1039|       |
 1040|     10|    {
 1041|     10|        if (!(state->magic == 9827862)) {
 1042|      0|            __assert_fail(
 1043|      0|                "state->magic == 9827862",
 1044|      0|                "/home/khheo/project/benchmark/coreutils-8.4/lib/cycle-check.c", 60U,
 1045|      0|                "cycle_check");
 1046|      0|        }
 1047|     10|        if (state->chdir_counter) {
 1048|      8|            if (sb->st_ino == (__ino_t const)state->dev_ino.st_ino) {
 1049|      0|                if (sb->st_dev == (__dev_t const)state->dev_ino.st_dev) {
 1050|      0|                    return ((_Bool)1);
 1051|      0|                }
 1052|      0|            }
 1053|      8|        }
 1054|     10|        (state->chdir_counter)++;
 1055|     10|        tmp = is_zero_or_power_of_two(state->chdir_counter);
 1056|     10|        if (tmp) {
 1057|      5|            if (state->chdir_counter == 0UL) {
 1058|      0|                return ((_Bool)1);
 1059|      0|            }
 1060|      5|            state->dev_ino.st_dev = (dev_t)sb->st_dev;
 1061|      5|            state->dev_ino.st_ino = (ino_t)sb->st_ino;
 1062|      5|        }
 1063|     10|        return ((_Bool)0);
 1064|     10|    }
 1065|     10|}
 1066|       |extern void error(int __status, int __errnum, char const *__format, ...);
 1067|       |char const *quote(char const *name);
 1068|       |void close_stdout(void);
 1069|       |extern struct _IO_FILE *stdout;
 1070|       |extern struct _IO_FILE *stderr;
 1071|       |extern __attribute__((__noreturn__)) void _exit(int __status);
 1072|       |int close_stream(FILE *stream);
 1073|       |char *quotearg_colon(char const *arg);
 1074|       |static char const *file_name;
 1075|       |static _Bool ignore_EPIPE;
 1076|       |void close_stdout(void)
 1077|      2|{
 1078|      2|    char const *write_error;
 1079|      2|    char const *tmp;
 1080|      2|    char *tmp___0;
 1081|      2|    int *tmp___1;
 1082|      2|    int *tmp___2;
 1083|      2|    int tmp___3;
 1084|      2|    int *tmp___4;
 1085|      2|    int tmp___5;
 1086|       |
 1087|      2|    {
 1088|      2|        tmp___3 = close_stream(stdout);
 1089|      2|        if (tmp___3 != 0) {
 1090|      0|            if (ignore_EPIPE) {
 1091|      0|                tmp___4 = __errno_location();
 1092|      0|                if (!(*tmp___4 == 32)) {
 1093|      0|                    goto _L;
 1094|      0|                }
 1095|      0|            }
 1096|      0|            else {
 1097|      0|_L:
 1098|      0|                tmp = (char const *)gettext("write error");
 1099|      0|                write_error = tmp;
 1100|      0|                if (file_name) {
 1101|      0|                    tmp___0 = quotearg_colon(file_name);
 1102|      0|                    tmp___1 = __errno_location();
 1103|      0|                    error(0, *tmp___1, "%s: %s", tmp___0, write_error);
 1104|      0|                }
 1105|      0|                else {
 1106|      0|                    tmp___2 = __errno_location();
 1107|      0|                    error(0, *tmp___2, "%s", write_error);
 1108|      0|                }
 1109|      0|                _exit((int)exit_failure);
 1110|      0|            }
 1111|      0|        }
 1112|      2|        tmp___5 = close_stream(stderr);
 1113|      2|        if (tmp___5 != 0) {
 1114|      0|            _exit((int)exit_failure);
 1115|      0|        }
 1116|      2|        return;
 1117|      2|    }
 1118|      2|}
 1119|       |void close_stdin(void);
 1120|       |static char const *file_name___0;
 1121|       |void close_stdin(void)
 1122|      2|{
 1123|      2|    _Bool fail;
 1124|      2|    int tmp;
 1125|      2|    int tmp___0;
 1126|      2|    size_t tmp___1;
 1127|      2|    int tmp___2;
 1128|      2|    char const *close_error;
 1129|      2|    char const *tmp___3;
 1130|      2|    char *tmp___4;
 1131|      2|    int *tmp___5;
 1132|      2|    int *tmp___6;
 1133|       |
 1134|      2|    {
 1135|      2|        fail = (_Bool)0;
 1136|      2|        tmp___1 = freadahead(stdin);
 1137|      2|        if (tmp___1 > 0UL) {
 1138|      0|            tmp = rpl_fseeko(stdin, (off_t)0, 1);
 1139|      0|            if (tmp == 0) {
 1140|      0|                tmp___0 = rpl_fflush(stdin);
 1141|      0|                if (tmp___0 != 0) {
 1142|      0|                    fail = (_Bool)1;
 1143|      0|                }
 1144|      0|            }
 1145|      0|        }
 1146|      2|        tmp___2 = close_stream(stdin);
 1147|      2|        if (tmp___2 != 0) {
 1148|      0|            fail = (_Bool)1;
 1149|      0|        }
 1150|      2|        if (fail) {
 1151|      0|            tmp___3 = (char const *)gettext("error closing file");
 1152|      0|            close_error = tmp___3;
 1153|      0|            if (file_name___0) {
 1154|      0|                tmp___4 = quotearg_colon(file_name___0);
 1155|      0|                tmp___5 = __errno_location();
 1156|      0|                error(0, *tmp___5, "%s: %s", tmp___4, close_error);
 1157|      0|            }
 1158|      0|            else {
 1159|      0|                tmp___6 = __errno_location();
 1160|      0|                error(0, *tmp___6, "%s", close_error);
 1161|      0|            }
 1162|      0|        }
 1163|      2|        close_stdout();
 1164|      2|        if (fail) {
 1165|      0|            _exit((int)exit_failure);
 1166|      0|        }
 1167|      2|        return;
 1168|      2|    }
 1169|      2|}
 1170|       |extern __attribute__((__nothrow__))
 1171|       |size_t(__attribute__((__leaf__)) __fpending)(FILE *__fp);
 1172|       |int close_stream(FILE *stream)
 1173|      6|{
 1174|      6|    _Bool some_pending;
 1175|      6|    size_t tmp;
 1176|      6|    _Bool prev_fail;
 1177|      6|    int tmp___0;
 1178|      6|    _Bool fclose_fail;
 1179|      6|    int tmp___1;
 1180|      6|    int *tmp___2;
 1181|      6|    int *tmp___3;
 1182|       |
 1183|      6|    {
 1184|      6|        tmp = __fpending(stream);
 1185|      6|        some_pending = (_Bool)(tmp != 0UL);
 1186|      6|        tmp___0 = ferror_unlocked(stream);
 1187|      6|        prev_fail = (_Bool)(tmp___0 != 0);
 1188|      6|        tmp___1 = fclose(stream);
 1189|      6|        fclose_fail = (_Bool)(tmp___1 != 0);
 1190|      6|        if (prev_fail) {
 1191|      0|            goto _L___0;
 1192|      0|        }
 1193|      6|        else {
 1194|      6|            if (fclose_fail) {
 1195|      0|                if (some_pending) {
 1196|      0|                    goto _L___0;
 1197|      0|                }
 1198|      0|                else {
 1199|      0|                    tmp___3 = __errno_location();
 1200|      0|                    if (*tmp___3 != 9) {
 1201|      0|_L___0:
 1202|      0|                        if (!fclose_fail) {
 1203|      0|                            tmp___2 = __errno_location();
 1204|      0|                            *tmp___2 = 0;
 1205|      0|                        }
 1206|      0|                        return (-1);
 1207|      0|                    }
 1208|      0|                }
 1209|      0|            }
 1210|      6|        }
 1211|      6|        return (0);
 1212|      6|    }
 1213|      6|}
 1214|       |int set_cloexec_flag(int desc, _Bool value);
 1215|       |int set_cloexec_flag(int desc, _Bool value)
 1216|     24|{
 1217|     24|    int flags;
 1218|     24|    int tmp;
 1219|     24|    int newflags;
 1220|     24|    int tmp___0;
 1221|     24|    int tmp___1;
 1222|       |
 1223|     24|    {
 1224|     24|        tmp = rpl_fcntl(desc, 1, 0);
 1225|     24|        flags = tmp;
 1226|     24|        if (0 <= flags) {
 1227|     24|            if (value) {
 1228|     24|                tmp___0 = flags | 1;
 1229|     24|            }
 1230|      0|            else {
 1231|      0|                tmp___0 = flags & -2;
 1232|      0|            }
 1233|     24|            newflags = tmp___0;
 1234|     24|            if (flags == newflags) {
 1235|      0|                return (0);
 1236|      0|            }
 1237|     24|            else {
 1238|     24|                tmp___1 = rpl_fcntl(desc, 2, newflags);
 1239|     24|                if (tmp___1 != -1) {
 1240|     24|                    return (0);
 1241|     24|                }
 1242|     24|            }
 1243|     24|        }
 1244|      0|        return (-1);
 1245|     24|    }
 1246|     24|}
 1247|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
 1248|       |                                        fchdir)(int __fd);
 1249|       |extern int(__attribute__((__nonnull__(2))) openat)(int __fd, char const *__file,
 1250|       |        int __oflag, ...);
 1251|       |extern __attribute__((__nothrow__)) void *(
 1252|       |    __attribute__((__nonnull__(1), __leaf__))
 1253|       |    memchr)(void const *__s, int __c, size_t __n) __attribute__((__pure__));
 1254|       |extern __attribute__((__nothrow__)) void *(
 1255|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 1256|       |    memmove)(void *__dest, void const *__src, size_t __n);
 1257|       |extern __attribute__((__nothrow__)) int(
 1258|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 1259|       |    lstat)(char const *__restrict __file, struct stat *__restrict __buf);
 1260|       |size_t triple_hash(void const *x, size_t table_size);
 1261|       |_Bool triple_compare_ino_str(void const *x, void const *y);
 1262|       |char *last_component(char const *name)
 1263|      4|{
 1264|      4|    char const *base;
 1265|      4|    char const *p;
 1266|      4|    _Bool saw_slash;
 1267|       |
 1268|      4|    {
 1269|      4|        base = name + 0;
 1270|      4|        saw_slash = (_Bool)0;
 1271|     12|        while (1) {
 1272|       |
 1273|     12|            if (!((int const) * base == 47)) {
 1274|      4|                goto while_break;
 1275|      4|            }
 1276|      8|            base++;
 1277|      8|        }
 1278|      4|while_break:
 1279|      4|        p = base;
 1280|    166|        while (1) {
 1281|       |
 1282|    166|            if (!*p) {
 1283|      4|                goto while_break___0;
 1284|      4|            }
 1285|    162|            if ((int const) * p == 47) {
 1286|     24|                saw_slash = (_Bool)1;
 1287|     24|            }
 1288|    138|            else {
 1289|    138|                if (saw_slash) {
 1290|     24|                    base = p;
 1291|     24|                    saw_slash = (_Bool)0;
 1292|     24|                }
 1293|    138|            }
 1294|    162|            p++;
 1295|    162|        }
 1296|      4|while_break___0:
 1297|      4|        ;
 1298|      4|        return ((char *)base);
 1299|      4|    }
 1300|      4|}
 1301|       |size_t base_len(char const *name)
 1302|      2|{
 1303|      2|    size_t len;
 1304|      2|    size_t prefix_len;
 1305|       |
 1306|      2|    {
 1307|      2|        prefix_len = (size_t)0;
 1308|      2|        len = strlen(name);
 1309|      2|        while (1) {
 1310|       |
 1311|      2|            if (1UL < len) {
 1312|      2|                if (!((int const) * (name + (len - 1UL)) == 47)) {
 1313|      2|                    goto while_break;
 1314|      2|                }
 1315|      2|            }
 1316|      0|            else {
 1317|      0|                goto while_break;
 1318|      0|            }
 1319|      0|            goto __Cont;
 1320|      0|__Cont:
 1321|      0|            len--;
 1322|      0|        }
 1323|      2|while_break:
 1324|      2|        ;
 1325|      2|        return (len);
 1326|      2|    }
 1327|      2|}
 1328|       |char const *simple_backup_suffix;
 1329|       |void (*argmatch_die)(void);
 1330|       |ptrdiff_t __xargmatch_internal(char const *context, char const *arg,
 1331|       |                               char const *const *arglist, char const *vallist,
 1332|       |                               size_t valsize, void (*exit_fn)(void));
 1333|       |extern __attribute__((__nothrow__)) int(
 1334|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 1335|       |    memcmp)(void const *__s1, void const *__s2, size_t __n)
 1336|       |__attribute__((__pure__));
 1337|       |extern int(__attribute__((__nonnull__(1))) closedir)(DIR *__dirp);
 1338|       |extern struct dirent *(__attribute__((__nonnull__(1))) readdir)(DIR *__dirp);
 1339|       |DIR *opendir_safer(char const *name);
 1340|       |char const *simple_backup_suffix = "~";
 1341|       |ptrdiff_t argmatch(char const *arg, char const *const *arglist,
 1342|       |                   char const *vallist, size_t valsize);
 1343|       |void argmatch_invalid(char const *context, char const *value,
 1344|       |                      ptrdiff_t problem);
 1345|       |void argmatch_valid(char const *const *arglist, char const *vallist,
 1346|       |                    size_t valsize);
 1347|       |extern int fprintf(FILE *__restrict __stream, char const *__restrict __format,
 1348|       |                   ...);
 1349|       |extern int putc_unlocked(int __c, FILE *__stream);
 1350|       |char *quotearg_n_style(int n, enum quoting_style s, char const *arg);
 1351|       |char const *quote_n(int n, char const *name);
 1352|       |__attribute__((__noreturn__)) void usage(int status);
 1353|       |static void __argmatch_die(void)
 1354|      0|{
 1355|       |
 1356|      0|    {
 1357|      0|        usage(1);
 1358|      0|        return;
 1359|      0|    }
 1360|      0|}
 1361|       |void (*argmatch_die)(void) = &__argmatch_die;
 1362|       |ptrdiff_t argmatch(char const *arg, char const *const *arglist,
 1363|       |                   char const *vallist, size_t valsize)
 1364|      0|{
 1365|      0|    size_t i;
 1366|      0|    size_t arglen;
 1367|      0|    ptrdiff_t matchind;
 1368|      0|    _Bool ambiguous;
 1369|      0|    int tmp;
 1370|      0|    size_t tmp___0;
 1371|      0|    int tmp___1;
 1372|       |
 1373|      0|    {
 1374|      0|        matchind = (ptrdiff_t)-1;
 1375|      0|        ambiguous = (_Bool)0;
 1376|      0|        arglen = strlen(arg);
 1377|      0|        i = (size_t)0;
 1378|      0|        while (1) {
 1379|       |
 1380|      0|            if (!*(arglist + i)) {
 1381|      0|                goto while_break;
 1382|      0|            }
 1383|      0|            tmp___1 = strncmp((char const *)*(arglist + i), arg, arglen);
 1384|      0|            if (!tmp___1) {
 1385|      0|                tmp___0 = strlen((char const *)*(arglist + i));
 1386|      0|                if (tmp___0 == arglen) {
 1387|      0|                    return ((ptrdiff_t)i);
 1388|      0|                }
 1389|      0|                else {
 1390|      0|                    if (matchind == -1L) {
 1391|      0|                        matchind = (ptrdiff_t)i;
 1392|      0|                    }
 1393|      0|                    else {
 1394|      0|                        if ((unsigned long)vallist == (unsigned long)((void *)0)) {
 1395|      0|                            ambiguous = (_Bool)1;
 1396|      0|                        }
 1397|      0|                        else {
 1398|      0|                            tmp = memcmp((void const *)(vallist + valsize * (size_t)matchind),
 1399|      0|                                         (void const *)(vallist + valsize * i), valsize);
 1400|      0|                            if (tmp) {
 1401|      0|                                ambiguous = (_Bool)1;
 1402|      0|                            }
 1403|      0|                        }
 1404|      0|                    }
 1405|      0|                }
 1406|      0|            }
 1407|      0|            i++;
 1408|      0|        }
 1409|      0|while_break:
 1410|      0|        ;
 1411|      0|        if (ambiguous) {
 1412|      0|            return ((ptrdiff_t)-2);
 1413|      0|        }
 1414|      0|        else {
 1415|      0|            return (matchind);
 1416|      0|        }
 1417|      0|    }
 1418|      0|}
 1419|       |void argmatch_invalid(char const *context, char const *value,
 1420|       |                      ptrdiff_t problem)
 1421|      0|{
 1422|      0|    char const *format;
 1423|      0|    char *tmp;
 1424|      0|    char *tmp___0;
 1425|      0|    char *tmp___1;
 1426|      0|    char const *tmp___2;
 1427|      0|    char *tmp___3;
 1428|       |
 1429|      0|    {
 1430|      0|        if (problem == -1L) {
 1431|      0|            tmp = gettext("invalid argument %s for %s");
 1432|      0|            tmp___1 = tmp;
 1433|      0|        }
 1434|      0|        else {
 1435|      0|            tmp___0 = gettext("ambiguous argument %s for %s");
 1436|      0|            tmp___1 = tmp___0;
 1437|      0|        }
 1438|      0|        format = (char const *)tmp___1;
 1439|      0|        tmp___2 = quote_n(1, context);
 1440|      0|        tmp___3 = quotearg_n_style(0, (enum quoting_style)6, value);
 1441|      0|        error(0, 0, format, tmp___3, tmp___2);
 1442|      0|        return;
 1443|      0|    }
 1444|      0|}
 1445|       |void argmatch_valid(char const *const *arglist, char const *vallist,
 1446|       |                    size_t valsize)
 1447|      0|{
 1448|      0|    size_t i;
 1449|      0|    char const *last_val;
 1450|      0|    char *tmp;
 1451|      0|    int tmp___0;
 1452|       |
 1453|      0|    {
 1454|      0|        last_val = (char const *)((void *)0);
 1455|      0|        tmp = gettext("Valid arguments are:");
 1456|      0|        fprintf(stderr, (char const *)tmp);
 1457|      0|        i = (size_t)0;
 1458|      0|        while (1) {
 1459|       |
 1460|      0|            if (!*(arglist + i)) {
 1461|      0|                goto while_break;
 1462|      0|            }
 1463|      0|            if (i == 0UL) {
 1464|      0|                fprintf(stderr, "\n  - `%s\'", *(arglist + i));
 1465|      0|                last_val = vallist + valsize * i;
 1466|      0|            }
 1467|      0|            else {
 1468|      0|                tmp___0 = memcmp((void const *)last_val,
 1469|      0|                                 (void const *)(vallist + valsize * i), valsize);
 1470|      0|                if (tmp___0) {
 1471|      0|                    fprintf(stderr, "\n  - `%s\'", *(arglist + i));
 1472|      0|                    last_val = vallist + valsize * i;
 1473|      0|                }
 1474|      0|                else {
 1475|      0|                    fprintf(stderr, ", `%s\'", *(arglist + i));
 1476|      0|                }
 1477|      0|            }
 1478|      0|            i++;
 1479|      0|        }
 1480|      0|while_break:
 1481|      0|        putc_unlocked('\n', stderr);
 1482|      0|        return;
 1483|      0|    }
 1484|      0|}
 1485|       |ptrdiff_t __xargmatch_internal(char const *context, char const *arg,
 1486|       |                               char const *const *arglist, char const *vallist,
 1487|       |                               size_t valsize, void (*exit_fn)(void))
 1488|      0|{
 1489|      0|    ptrdiff_t res;
 1490|      0|    ptrdiff_t tmp;
 1491|       |
 1492|      0|    {
 1493|      0|        tmp = argmatch(arg, arglist, vallist, valsize);
 1494|      0|        res = tmp;
 1495|      0|        if (res >= 0L) {
 1496|      0|            return (res);
 1497|      0|        }
 1498|      0|        argmatch_invalid(context, arg, res);
 1499|      0|        argmatch_valid(arglist, vallist, valsize);
 1500|      0|        (*exit_fn)();
 1501|      0|        return ((ptrdiff_t)-1);
 1502|      0|    }
 1503|      0|}
 1504|       |extern
 1505|       |__attribute__((__nothrow__)) void *(__attribute__((__warn_unused_result__,
 1506|       |                                    __leaf__))
 1507|       |                                    realloc)(void *__ptr, size_t __size);
 1508|       |_Bool yesno(void);
 1509|       |extern
 1510|       |__attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 1511|       |                                 rpmatch)(char const *__response);
 1512|       |extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n,
 1513|       |                         FILE *__restrict __stream);
 1514|       |_Bool yesno(void)
 1515|      0|{
 1516|      0|    _Bool yes;
 1517|      0|    char *response;
 1518|      0|    size_t response_size;
 1519|      0|    ssize_t response_len;
 1520|      0|    ssize_t tmp;
 1521|      0|    int tmp___0;
 1522|       |
 1523|      0|    {
 1524|      0|        response = (char *)((void *)0);
 1525|      0|        response_size = (size_t)0;
 1526|      0|        tmp = getline(&response, &response_size, stdin);
 1527|      0|        response_len = tmp;
 1528|      0|        if (response_len <= 0L) {
 1529|      0|            yes = (_Bool)0;
 1530|      0|        }
 1531|      0|        else {
 1532|      0|            *(response + (response_len - 1L)) = (char)'\000';
 1533|      0|            tmp___0 = rpmatch((char const *)response);
 1534|      0|            yes = (_Bool)(0 < tmp___0);
 1535|      0|        }
 1536|      0|        free((void *)response);
 1537|      0|        return (yes);
 1538|      0|    }
 1539|      0|}
 1540|       |__inline static void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__));
 1541|       |__inline static void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__));
 1542|       |__inline static void *xnmalloc(size_t n, size_t s)
 1543|      0|{
 1544|      0|    int tmp;
 1545|      0|    void *tmp___0;
 1546|      0|
 1547|      0|    {
 1548|      0|        if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 1549|      0|            tmp = -1;
 1550|      0|        }
 1551|      0|        else {
 1552|      0|            tmp = -2;
 1553|      0|        }
 1554|      0|        if ((size_t)tmp / s < n) {
 1555|      0|            xalloc_die();
 1556|      0|        }
 1557|      0|        tmp___0 = xmalloc(n * s);
 1558|      0|        return (tmp___0);
 1559|      0|    }
 1560|      0|}
 1561|       |extern
 1562|       |__attribute__((__nothrow__)) void *(__attribute__((__leaf__))
 1563|       |                                    calloc)(size_t __nmemb, size_t __size)
 1564|       |__attribute__((__malloc__));
 1565|       |void *xmalloc(size_t n) __attribute__((__malloc__));
 1566|       |void *xmalloc(size_t n)
 1567|      0|{
 1568|      0|    void *p;
 1569|      0|    void *tmp;
 1570|       |
 1571|      0|    {
 1572|      0|        tmp = malloc(n);
 1573|      0|        p = tmp;
 1574|      0|        if (!p) {
 1575|      0|            if (n != 0UL) {
 1576|      0|                xalloc_die();
 1577|      0|            }
 1578|      0|        }
 1579|      0|        return (p);
 1580|      0|    }
 1581|      0|}
 1582|       |void *xrealloc(void *p, size_t n)
 1583|      0|{
 1584|       |
 1585|      0|    {
 1586|      0|        p = realloc(p, n);
 1587|      0|        if (!p) {
 1588|      0|            if (n != 0UL) {
 1589|      0|                xalloc_die();
 1590|      0|            }
 1591|      0|        }
 1592|      0|        return (p);
 1593|      0|    }
 1594|      0|}
 1595|       |__attribute__((__nothrow__))
 1596|       |FTS *(__attribute__((__warn_unused_result__, __leaf__))
 1597|       |      fts_open)(char *const *argv, int options,
 1598|       |                int (*compar)(FTSENT const **, FTSENT const **));
 1599|       |FTS *xfts_open(char *const *argv, int options,
 1600|       |               int (*compar)(FTSENT const **, FTSENT const **));
 1601|       |FTS *xfts_open(char *const *argv, int options,
 1602|       |               int (*compar)(FTSENT const **, FTSENT const **))
 1603|      2|{
 1604|      2|    FTS *fts;
 1605|      2|    FTS *tmp;
 1606|      2|    int *tmp___0;
 1607|       |
 1608|      2|    {
 1609|      2|        tmp = fts_open(argv, options | 512, compar);
 1610|      2|        fts = tmp;
 1611|      2|        if ((unsigned long)fts == (unsigned long)((void *)0)) {
 1612|      0|            tmp___0 = __errno_location();
 1613|      0|            if (!(*tmp___0 != 22)) {
 1614|      0|                __assert_fail("(*__errno_location ()) != 22",
 1615|      0|                              "/home/khheo/project/benchmark/coreutils-8.4/lib/xfts.c",
 1616|      0|                              41U, "xfts_open");
 1617|      0|            }
 1618|      0|            xalloc_die();
 1619|      0|        }
 1620|      2|        return (fts);
 1621|      2|    }
 1622|      2|}
 1623|       |__attribute__((__noreturn__)) void xalloc_die(void);
 1624|       |void xalloc_die(void)
 1625|      0|{
 1626|      0|    char *tmp;
 1627|       |
 1628|      0|    {
 1629|      0|        tmp = gettext("memory exhausted");
 1630|      0|        error((int)exit_failure, 0, "%s", tmp);
 1631|      0|        abort();
 1632|      0|    }
 1633|      0|}
 1634|       |_Bool can_write_any_file(void);
 1635|       |static _Bool initialized;
 1636|       |static _Bool can_write;
 1637|       |_Bool can_write_any_file(void)
 1638|      0|{
 1639|      0|    _Bool can;
 1640|      0|    __uid_t tmp;
 1641|       |
 1642|      0|    {
 1643|      0|        if (!initialized) {
 1644|      0|            can = (_Bool)0;
 1645|      0|            tmp = geteuid();
 1646|      0|            can = (_Bool)(tmp == 0U);
 1647|      0|            can_write = can;
 1648|      0|            initialized = (_Bool)1;
 1649|      0|        }
 1650|      0|        return (can_write);
 1651|      0|    }
 1652|      0|}
 1653|       |extern int printf(char const *__restrict __format, ...);
 1654|       |extern int fputs_unlocked(char const *__restrict __s,
 1655|       |                          FILE *__restrict __stream);
 1656|       |char const version_etc_copyright[47];
 1657|       |void version_etc_arn(FILE *stream, char const *command_name,
 1658|       |                     char const *package, char const *version,
 1659|       |                     char const *const *authors, size_t n_authors);
 1660|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 1661|       |                    char const *version, va_list authors);
 1662|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1663|       |                 char const *version, ...) __attribute__((__sentinel__));
 1664|       |void version_etc_arn(FILE *stream, char const *command_name,
 1665|       |                     char const *package, char const *version,
 1666|       |                     char const *const *authors, size_t n_authors)
 1667|      0|{
 1668|      0|    char *tmp;
 1669|      0|    char *tmp___0;
 1670|      0|    char *tmp___1;
 1671|      0|    char *tmp___2;
 1672|      0|    char *tmp___3;
 1673|      0|    char *tmp___4;
 1674|      0|    char *tmp___5;
 1675|      0|    char *tmp___6;
 1676|      0|    char *tmp___7;
 1677|      0|    char *tmp___8;
 1678|      0|    char *tmp___9;
 1679|      0|    char *tmp___10;
 1680|       |
 1681|      0|    {
 1682|      0|        if (command_name) {
 1683|      0|            fprintf(stream, "%s (%s) %s\n", command_name, package, version);
 1684|      0|        }
 1685|      0|        else {
 1686|      0|            fprintf(stream, "%s %s\n", package, version);
 1687|      0|        }
 1688|      0|        tmp = gettext("(C)");
 1689|      0|        fprintf(stream, version_etc_copyright, tmp, 2010);
 1690|      0|        tmp___0 =
 1691|      0|            gettext("\nLicense GPLv3+: GNU GPL version 3 or later "
 1692|      0|                    "<http://gnu.org/licenses/gpl.html>.\nThis is free software: "
 1693|      0|                    "you are free to change and redistribute it.\nThere is NO "
 1694|      0|                    "WARRANTY, to the extent permitted by law.\n\n");
 1695|      0|        fputs_unlocked((char const *)tmp___0, stream);
 1696|      0|        if (n_authors == 0UL) {
 1697|      0|            goto case_0;
 1698|      0|        }
 1699|      0|        if (n_authors == 1UL) {
 1700|      0|            goto case_1;
 1701|      0|        }
 1702|      0|        if (n_authors == 2UL) {
 1703|      0|            goto case_2;
 1704|      0|        }
 1705|      0|        if (n_authors == 3UL) {
 1706|      0|            goto case_3;
 1707|      0|        }
 1708|      0|        if (n_authors == 4UL) {
 1709|      0|            goto case_4;
 1710|      0|        }
 1711|      0|        if (n_authors == 5UL) {
 1712|      0|            goto case_5;
 1713|      0|        }
 1714|      0|        if (n_authors == 6UL) {
 1715|      0|            goto case_6;
 1716|      0|        }
 1717|      0|        if (n_authors == 7UL) {
 1718|      0|            goto case_7;
 1719|      0|        }
 1720|      0|        if (n_authors == 8UL) {
 1721|      0|            goto case_8;
 1722|      0|        }
 1723|      0|        if (n_authors == 9UL) {
 1724|      0|            goto case_9;
 1725|      0|        }
 1726|      0|        goto switch_default;
 1727|      0|case_0:
 1728|      0|        abort();
 1729|      0|case_1:
 1730|      0|        tmp___1 = gettext("Written by %s.\n");
 1731|      0|        fprintf(stream, (char const *)tmp___1, *(authors + 0));
 1732|      0|        goto switch_break;
 1733|      0|case_2:
 1734|      0|        tmp___2 = gettext("Written by %s and %s.\n");
 1735|      0|        fprintf(stream, (char const *)tmp___2, *(authors + 0), *(authors + 1));
 1736|      0|        goto switch_break;
 1737|      0|case_3:
 1738|      0|        tmp___3 = gettext("Written by %s, %s, and %s.\n");
 1739|      0|        fprintf(stream, (char const *)tmp___3, *(authors + 0), *(authors + 1),
 1740|      0|                *(authors + 2));
 1741|      0|        goto switch_break;
 1742|      0|case_4:
 1743|      0|        tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
 1744|      0|        fprintf(stream, (char const *)tmp___4, *(authors + 0), *(authors + 1),
 1745|      0|                *(authors + 2), *(authors + 3));
 1746|      0|        goto switch_break;
 1747|      0|case_5:
 1748|      0|        tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
 1749|      0|        fprintf(stream, (char const *)tmp___5, *(authors + 0), *(authors + 1),
 1750|      0|                *(authors + 2), *(authors + 3), *(authors + 4));
 1751|      0|        goto switch_break;
 1752|      0|case_6:
 1753|      0|        tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
 1754|      0|        fprintf(stream, (char const *)tmp___6, *(authors + 0), *(authors + 1),
 1755|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5));
 1756|      0|        goto switch_break;
 1757|      0|case_7:
 1758|      0|        tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
 1759|      0|        fprintf(stream, (char const *)tmp___7, *(authors + 0), *(authors + 1),
 1760|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1761|      0|                *(authors + 6));
 1762|      0|        goto switch_break;
 1763|      0|case_8:
 1764|      0|        tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
 1765|      0|        fprintf(stream, (char const *)tmp___8, *(authors + 0), *(authors + 1),
 1766|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1767|      0|                *(authors + 6), *(authors + 7));
 1768|      0|        goto switch_break;
 1769|      0|case_9:
 1770|      0|        tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
 1771|      0|        fprintf(stream, (char const *)tmp___9, *(authors + 0), *(authors + 1),
 1772|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1773|      0|                *(authors + 6), *(authors + 7), *(authors + 8));
 1774|      0|        goto switch_break;
 1775|      0|switch_default:
 1776|      0|        tmp___10 = gettext(
 1777|      0|                       "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
 1778|      0|        fprintf(stream, (char const *)tmp___10, *(authors + 0), *(authors + 1),
 1779|      0|                *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1780|      0|                *(authors + 6), *(authors + 7), *(authors + 8));
 1781|      0|        goto switch_break;
 1782|      0|switch_break:
 1783|      0|        ;
 1784|      0|        return;
 1785|      0|    }
 1786|      0|}
 1787|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 1788|       |                    char const *version, va_list authors)
 1789|      0|{
 1790|      0|    size_t n_authors;
 1791|      0|    char const *authtab[10];
 1792|      0|    char const *tmp;
 1793|       |
 1794|      0|    {
 1795|      0|        n_authors = (size_t)0;
 1796|      0|        while (1) {
 1797|       |
 1798|      0|            if (n_authors < 10UL) {
 1799|      0|                tmp = __builtin_va_arg(authors, char const *);
 1800|      0|                authtab[n_authors] = tmp;
 1801|      0|                if (!((unsigned long)tmp != (unsigned long)((void *)0))) {
 1802|      0|                    goto while_break;
 1803|      0|                }
 1804|      0|            }
 1805|      0|            else {
 1806|      0|                goto while_break;
 1807|      0|            }
 1808|      0|            n_authors++;
 1809|      0|        }
 1810|      0|while_break:
 1811|      0|        version_etc_arn(stream, command_name, package, version,
 1812|      0|                        (char const *const *)(authtab), n_authors);
 1813|      0|        return;
 1814|      0|    }
 1815|      0|}
 1816|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1817|       |                 char const *version, ...) __attribute__((__sentinel__));
 1818|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1819|       |                 char const *version, ...)
 1820|      0|{
 1821|      0|    va_list authors;
 1822|       |
 1823|      0|    {
 1824|      0|        __builtin_va_start(authors, version);
 1825|      0|        version_etc_va(stream, command_name, package, version, authors);
 1826|      0|        __builtin_va_end(authors);
 1827|      0|        return;
 1828|      0|    }
 1829|      0|}
 1830|       |char const version_etc_copyright[47] = {
 1831|       |    (char const)'C', (char const)'o', (char const)'p', (char const)'y',
 1832|       |    (char const)'r', (char const)'i', (char const)'g', (char const)'h',
 1833|       |    (char const)'t', (char const)' ', (char const)'%', (char const)'s',
 1834|       |    (char const)' ', (char const)'%', (char const)'d', (char const)' ',
 1835|       |    (char const)'F', (char const)'r', (char const)'e', (char const)'e',
 1836|       |    (char const)' ', (char const)'S', (char const)'o', (char const)'f',
 1837|       |    (char const)'t', (char const)'w', (char const)'a', (char const)'r',
 1838|       |    (char const)'e', (char const)' ', (char const)'F', (char const)'o',
 1839|       |    (char const)'u', (char const)'n', (char const)'d', (char const)'a',
 1840|       |    (char const)'t', (char const)'i', (char const)'o', (char const)'n',
 1841|       |    (char const)',', (char const)' ', (char const)'I', (char const)'n',
 1842|       |    (char const)'c', (char const)'.', (char const)'\000'
 1843|       |};
 1844|       |size_t strnlen1(char const *string, size_t maxlen)
 1845|      0|{
 1846|      0|    char const *end;
 1847|      0|    char const *tmp;
 1848|       |
 1849|      0|    {
 1850|      0|        tmp = (char const *)memchr((void const *)string, '\000', maxlen);
 1851|      0|        end = tmp;
 1852|      0|        if ((unsigned long)end != (unsigned long)((void *)0)) {
 1853|      0|            return ((size_t)((end - string) + 1L));
 1854|      0|        }
 1855|      0|        else {
 1856|      0|            return (maxlen);
 1857|      0|        }
 1858|      0|    }
 1859|      0|}
 1860|       |_Bool strip_trailing_slashes(char *file);
 1861|       |_Bool strip_trailing_slashes(char *file)
 1862|      2|{
 1863|      2|    char *base;
 1864|      2|    char *tmp;
 1865|      2|    char *base_lim;
 1866|      2|    _Bool had_slash;
 1867|      2|    size_t tmp___0;
 1868|       |
 1869|      2|    {
 1870|      2|        tmp = last_component((char const *)file);
 1871|      2|        base = tmp;
 1872|      2|        if (!*base) {
 1873|      0|            base = file;
 1874|      0|        }
 1875|      2|        tmp___0 = base_len((char const *)base);
 1876|      2|        base_lim = base + tmp___0;
 1877|      2|        had_slash = (_Bool)((int)*base_lim != 0);
 1878|      2|        *base_lim = (char)'\000';
 1879|      2|        return (had_slash);
 1880|      2|    }
 1881|      2|}
 1882|       |int open_safer(char const *file, int flags, ...);
 1883|       |extern DIR *fdopendir(int __fd);
 1884|       |struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i);
 1885|       |struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i)
 1886|      2|{
 1887|      2|    struct stat statbuf;
 1888|      2|    int tmp;
 1889|       |
 1890|      2|    {
 1891|      2|        tmp = lstat("/", &statbuf);
 1892|      2|        if (tmp) {
 1893|      0|            return ((struct dev_ino *)((void *)0));
 1894|      0|        }
 1895|      2|        root_d_i->st_ino = statbuf.st_ino;
 1896|      2|        root_d_i->st_dev = statbuf.st_dev;
 1897|      2|        return (root_d_i);
 1898|      2|    }
 1899|      2|}
 1900|       |reg_syntax_t rpl_re_syntax_options;
 1901|       |char const *const quoting_style_args[9];
 1902|       |enum quoting_style const quoting_style_vals[8];
 1903|       |int set_char_quoting(struct quoting_options *o, char c, int i);
 1904|       |char *quotearg_char(char const *arg, char ch);
 1905|       |char *quotearg_char_mem(char const *arg, size_t argsize, char ch);
 1906|       |__inline static char *xcharalloc(size_t n) __attribute__((__malloc__));
 1907|       |__inline static char *xcharalloc(size_t n) __attribute__((__malloc__));
 1908|       |__inline static char *xcharalloc(size_t n)
 1909|      0|{
 1910|      0|    void *tmp;
 1911|      0|    void *tmp___0;
 1912|      0|    void *tmp___1;
 1913|       |
 1914|      0|    {
 1915|      0|        if (sizeof(char) == 1UL) {
 1916|      0|            tmp = xmalloc(n);
 1917|      0|            tmp___1 = tmp;
 1918|      0|        }
 1919|      0|        else {
 1920|      0|            tmp___0 = xnmalloc(n, sizeof(char));
 1921|      0|            tmp___1 = tmp___0;
 1922|      0|        }
 1923|      0|        return ((char *)tmp___1);
 1924|      0|    }
 1925|      0|}
 1926|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
 1927|       |                                        iswprint)(wint_t __wc);
 1928|       |char const *const quoting_style_args[9] = {
 1929|       |    "literal", "shell", "shell-always", "c", "c-maybe", "escape",
 1930|       |    "locale", "clocale", (char const *)0
 1931|       |};
 1932|       |enum quoting_style const quoting_style_vals[8] = {
 1933|       |    (enum quoting_style const)0, (enum quoting_style const)1,
 1934|       |    (enum quoting_style const)2, (enum quoting_style const)3,
 1935|       |    (enum quoting_style const)4, (enum quoting_style const)5,
 1936|       |    (enum quoting_style const)6, (enum quoting_style const)7
 1937|       |};
 1938|       |static struct quoting_options default_quoting_options;
 1939|       |int set_char_quoting(struct quoting_options *o, char c, int i)
 1940|      0|{
 1941|      0|    unsigned char uc;
 1942|      0|    unsigned int *p;
 1943|      0|    struct quoting_options *tmp;
 1944|      0|    int shift;
 1945|      0|    int r;
 1946|       |
 1947|      0|    {
 1948|      0|        uc = (unsigned char)c;
 1949|      0|        if (o) {
 1950|      0|            tmp = o;
 1951|      0|        }
 1952|      0|        else {
 1953|      0|            tmp = &default_quoting_options;
 1954|      0|        }
 1955|      0|        p = tmp->quote_these_too + (unsigned long)uc / (sizeof(int) * 8UL);
 1956|      0|        shift = (int)((unsigned long)uc % (sizeof(int) * 8UL));
 1957|      0|        r = (int)((*p >> shift) & 1U);
 1958|      0|        *p ^= (unsigned int)(((i & 1) ^ r) << shift);
 1959|      0|        return (r);
 1960|      0|    }
 1961|      0|}
 1962|       |static struct quoting_options
 1963|       |quoting_options_from_style(enum quoting_style style)
 1964|      0|{
 1965|      0|    struct quoting_options o;
 1966|       |
 1967|      0|    {
 1968|      0|        o.style = style;
 1969|      0|        o.flags = 0;
 1970|      0|        memset((void *)(o.quote_these_too), 0, sizeof(o.quote_these_too));
 1971|      0|        return (o);
 1972|      0|    }
 1973|      0|}
 1974|       |static char const *gettext_quote(char const *msgid, enum quoting_style s)
 1975|      0|{
 1976|      0|    char const *translation;
 1977|      0|    char const *tmp;
 1978|       |
 1979|      0|    {
 1980|      0|        tmp = (char const *)gettext(msgid);
 1981|      0|        translation = tmp;
 1982|      0|        if ((unsigned long)translation == (unsigned long)msgid) {
 1983|      0|            if ((unsigned int)s == 7U) {
 1984|      0|                translation = "\"";
 1985|      0|            }
 1986|      0|        }
 1987|      0|        return (translation);
 1988|      0|    }
 1989|      0|}
 1990|       |static size_t
 1991|       |quotearg_buffer_restyled(char *buffer, size_t buffersize, char const *arg,
 1992|       |                         size_t argsize, enum quoting_style quoting_style,
 1993|       |                         int flags, unsigned int const *quote_these_too,
 1994|       |                         char const *left_quote, char const *right_quote)
 1995|      0|{
 1996|      0|    size_t i;
 1997|      0|    size_t len;
 1998|      0|    char const *quote_string;
 1999|      0|    size_t quote_string_len;
 2000|      0|    _Bool backslash_escapes;
 2001|      0|    _Bool unibyte_locale;
 2002|      0|    size_t tmp;
 2003|      0|    _Bool elide_outer_quotes;
 2004|      0|    unsigned char c;
 2005|      0|    unsigned char esc;
 2006|      0|    _Bool is_right_quote;
 2007|      0|    int tmp___0;
 2008|      0|    int tmp___1;
 2009|      0|    size_t m;
 2010|      0|    _Bool printable;
 2011|      0|    unsigned short const **tmp___2;
 2012|      0|    mbstate_t mbstate;
 2013|      0|    wchar_t w;
 2014|      0|    size_t bytes;
 2015|      0|    size_t tmp___3;
 2016|      0|    size_t j;
 2017|      0|    int tmp___4;
 2018|      0|    int tmp___5;
 2019|      0|    size_t ilim;
 2020|      0|    int tmp___6;
 2021|      0|    size_t tmp___7;
 2022|       |
 2023|      0|    {
 2024|      0|        len = (size_t)0;
 2025|      0|        quote_string = (char const *)0;
 2026|      0|        quote_string_len = (size_t)0;
 2027|      0|        backslash_escapes = (_Bool)0;
 2028|      0|        tmp = __ctype_get_mb_cur_max();
 2029|      0|        unibyte_locale = (_Bool)(tmp == 1UL);
 2030|      0|        elide_outer_quotes = (_Bool)((flags & 2) != 0);
 2031|      0|        if ((unsigned int)quoting_style == 4U) {
 2032|      0|            goto case_4;
 2033|      0|        }
 2034|      0|        if ((unsigned int)quoting_style == 3U) {
 2035|      0|            goto case_3;
 2036|      0|        }
 2037|      0|        if ((unsigned int)quoting_style == 5U) {
 2038|      0|            goto case_5;
 2039|      0|        }
 2040|      0|        if ((unsigned int)quoting_style == 6U) {
 2041|      0|            goto case_6;
 2042|      0|        }
 2043|      0|        if ((unsigned int)quoting_style == 7U) {
 2044|      0|            goto case_6;
 2045|      0|        }
 2046|      0|        if ((unsigned int)quoting_style == 8U) {
 2047|      0|            goto case_6;
 2048|      0|        }
 2049|      0|        if ((unsigned int)quoting_style == 1U) {
 2050|      0|            goto case_1;
 2051|      0|        }
 2052|      0|        if ((unsigned int)quoting_style == 2U) {
 2053|      0|            goto case_2;
 2054|      0|        }
 2055|      0|        if ((unsigned int)quoting_style == 0U) {
 2056|      0|            goto case_0;
 2057|      0|        }
 2058|      0|        goto switch_default;
 2059|      0|case_4:
 2060|      0|        quoting_style = (enum quoting_style)3;
 2061|      0|        elide_outer_quotes = (_Bool)1;
 2062|      0|case_3:
 2063|      0|        if (!elide_outer_quotes) {
 2064|      0|            while (1) {
 2065|       |
 2066|      0|                if (len < buffersize) {
 2067|      0|                    *(buffer + len) = (char)'\"';
 2068|      0|                }
 2069|      0|                len++;
 2070|      0|                goto while_break;
 2071|      0|            }
 2072|      0|while_break:
 2073|      0|            ;
 2074|      0|        }
 2075|      0|        backslash_escapes = (_Bool)1;
 2076|      0|        quote_string = "\"";
 2077|      0|        quote_string_len = (size_t)1;
 2078|      0|        goto switch_break;
 2079|      0|case_5:
 2080|      0|        backslash_escapes = (_Bool)1;
 2081|      0|        elide_outer_quotes = (_Bool)0;
 2082|      0|        goto switch_break;
 2083|      0|case_6:
 2084|      0|        if ((unsigned int)quoting_style != 8U) {
 2085|      0|            left_quote = gettext_quote("`", quoting_style);
 2086|      0|            right_quote = gettext_quote("\'", quoting_style);
 2087|      0|        }
 2088|      0|        if (!elide_outer_quotes) {
 2089|      0|            quote_string = left_quote;
 2090|      0|            while (1) {
 2091|       |
 2092|      0|                if (!*quote_string) {
 2093|      0|                    goto while_break___0;
 2094|      0|                }
 2095|      0|                while (1) {
 2096|       |
 2097|      0|                    if (len < buffersize) {
 2098|      0|                        *(buffer + len) = (char)*quote_string;
 2099|      0|                    }
 2100|      0|                    len++;
 2101|      0|                    goto while_break___1;
 2102|      0|                }
 2103|      0|while_break___1:
 2104|      0|                quote_string++;
 2105|      0|            }
 2106|      0|while_break___0:
 2107|      0|            ;
 2108|      0|        }
 2109|      0|        backslash_escapes = (_Bool)1;
 2110|      0|        quote_string = right_quote;
 2111|      0|        quote_string_len = strlen(quote_string);
 2112|      0|        goto switch_break;
 2113|      0|case_1:
 2114|      0|        quoting_style = (enum quoting_style)2;
 2115|      0|        elide_outer_quotes = (_Bool)1;
 2116|      0|case_2:
 2117|      0|        if (!elide_outer_quotes) {
 2118|      0|            while (1) {
 2119|       |
 2120|      0|                if (len < buffersize) {
 2121|      0|                    *(buffer + len) = (char)'\'';
 2122|      0|                }
 2123|      0|                len++;
 2124|      0|                goto while_break___2;
 2125|      0|            }
 2126|      0|while_break___2:
 2127|      0|            ;
 2128|      0|        }
 2129|      0|        quote_string = "\'";
 2130|      0|        quote_string_len = (size_t)1;
 2131|      0|        goto switch_break;
 2132|      0|case_0:
 2133|      0|        elide_outer_quotes = (_Bool)0;
 2134|      0|        goto switch_break;
 2135|      0|switch_default:
 2136|      0|        abort();
 2137|      0|switch_break:
 2138|      0|        i = (size_t)0;
 2139|      0|        while (1) {
 2140|       |
 2141|      0|            if (argsize == 0xffffffffffffffffUL) {
 2142|      0|                tmp___6 = (int const) * (arg + i) == 0;
 2143|      0|            }
 2144|      0|            else {
 2145|      0|                tmp___6 = i == argsize;
 2146|      0|            }
 2147|      0|            if (tmp___6) {
 2148|      0|                goto while_break___3;
 2149|      0|            }
 2150|      0|            is_right_quote = (_Bool)0;
 2151|      0|            if (backslash_escapes) {
 2152|      0|                if (quote_string_len) {
 2153|      0|                    if (i + quote_string_len <= argsize) {
 2154|      0|                        tmp___0 = memcmp((void const *)(arg + i),
 2155|      0|                                         (void const *)quote_string, quote_string_len);
 2156|      0|                        if (tmp___0 == 0) {
 2157|      0|                            if (elide_outer_quotes) {
 2158|      0|                                goto force_outer_quoting_style;
 2159|      0|                            }
 2160|      0|                            is_right_quote = (_Bool)1;
 2161|      0|                        }
 2162|      0|                    }
 2163|      0|                }
 2164|      0|            }
 2165|      0|            c = (unsigned char)*(arg + i);
 2166|      0|            if ((int)c == 0) {
 2167|      0|                goto case_0___0;
 2168|      0|            }
 2169|      0|            if ((int)c == 63) {
 2170|      0|                goto case_63;
 2171|      0|            }
 2172|      0|            if ((int)c == 7) {
 2173|      0|                goto case_7___0;
 2174|      0|            }
 2175|      0|            if ((int)c == 8) {
 2176|      0|                goto case_8___0;
 2177|      0|            }
 2178|      0|            if ((int)c == 12) {
 2179|      0|                goto case_12;
 2180|      0|            }
 2181|      0|            if ((int)c == 10) {
 2182|      0|                goto case_10;
 2183|      0|            }
 2184|      0|            if ((int)c == 13) {
 2185|      0|                goto case_13;
 2186|      0|            }
 2187|      0|            if ((int)c == 9) {
 2188|      0|                goto case_9;
 2189|      0|            }
 2190|      0|            if ((int)c == 11) {
 2191|      0|                goto case_11;
 2192|      0|            }
 2193|      0|            if ((int)c == 92) {
 2194|      0|                goto case_92;
 2195|      0|            }
 2196|      0|            if ((int)c == 123) {
 2197|      0|                goto case_123;
 2198|      0|            }
 2199|      0|            if ((int)c == 125) {
 2200|      0|                goto case_123;
 2201|      0|            }
 2202|      0|            if ((int)c == 35) {
 2203|      0|                goto case_35;
 2204|      0|            }
 2205|      0|            if ((int)c == 126) {
 2206|      0|                goto case_35;
 2207|      0|            }
 2208|      0|            if ((int)c == 32) {
 2209|      0|                goto case_32;
 2210|      0|            }
 2211|      0|            if ((int)c == 33) {
 2212|      0|                goto case_32;
 2213|      0|            }
 2214|      0|            if ((int)c == 34) {
 2215|      0|                goto case_32;
 2216|      0|            }
 2217|      0|            if ((int)c == 36) {
 2218|      0|                goto case_32;
 2219|      0|            }
 2220|      0|            if ((int)c == 38) {
 2221|      0|                goto case_32;
 2222|      0|            }
 2223|      0|            if ((int)c == 40) {
 2224|      0|                goto case_32;
 2225|      0|            }
 2226|      0|            if ((int)c == 41) {
 2227|      0|                goto case_32;
 2228|      0|            }
 2229|      0|            if ((int)c == 42) {
 2230|      0|                goto case_32;
 2231|      0|            }
 2232|      0|            if ((int)c == 59) {
 2233|      0|                goto case_32;
 2234|      0|            }
 2235|      0|            if ((int)c == 60) {
 2236|      0|                goto case_32;
 2237|      0|            }
 2238|      0|            if ((int)c == 61) {
 2239|      0|                goto case_32;
 2240|      0|            }
 2241|      0|            if ((int)c == 62) {
 2242|      0|                goto case_32;
 2243|      0|            }
 2244|      0|            if ((int)c == 91) {
 2245|      0|                goto case_32;
 2246|      0|            }
 2247|      0|            if ((int)c == 94) {
 2248|      0|                goto case_32;
 2249|      0|            }
 2250|      0|            if ((int)c == 96) {
 2251|      0|                goto case_32;
 2252|      0|            }
 2253|      0|            if ((int)c == 124) {
 2254|      0|                goto case_32;
 2255|      0|            }
 2256|      0|            if ((int)c == 39) {
 2257|      0|                goto case_39___0;
 2258|      0|            }
 2259|      0|            if ((int)c == 37) {
 2260|      0|                goto case_37;
 2261|      0|            }
 2262|      0|            if ((int)c == 43) {
 2263|      0|                goto case_37;
 2264|      0|            }
 2265|      0|            if ((int)c == 44) {
 2266|      0|                goto case_37;
 2267|      0|            }
 2268|      0|            if ((int)c == 45) {
 2269|      0|                goto case_37;
 2270|      0|            }
 2271|      0|            if ((int)c == 46) {
 2272|      0|                goto case_37;
 2273|      0|            }
 2274|      0|            if ((int)c == 47) {
 2275|      0|                goto case_37;
 2276|      0|            }
 2277|      0|            if ((int)c == 48) {
 2278|      0|                goto case_37;
 2279|      0|            }
 2280|      0|            if ((int)c == 49) {
 2281|      0|                goto case_37;
 2282|      0|            }
 2283|      0|            if ((int)c == 50) {
 2284|      0|                goto case_37;
 2285|      0|            }
 2286|      0|            if ((int)c == 51) {
 2287|      0|                goto case_37;
 2288|      0|            }
 2289|      0|            if ((int)c == 52) {
 2290|      0|                goto case_37;
 2291|      0|            }
 2292|      0|            if ((int)c == 53) {
 2293|      0|                goto case_37;
 2294|      0|            }
 2295|      0|            if ((int)c == 54) {
 2296|      0|                goto case_37;
 2297|      0|            }
 2298|      0|            if ((int)c == 55) {
 2299|      0|                goto case_37;
 2300|      0|            }
 2301|      0|            if ((int)c == 56) {
 2302|      0|                goto case_37;
 2303|      0|            }
 2304|      0|            if ((int)c == 57) {
 2305|      0|                goto case_37;
 2306|      0|            }
 2307|      0|            if ((int)c == 58) {
 2308|      0|                goto case_37;
 2309|      0|            }
 2310|      0|            if ((int)c == 65) {
 2311|      0|                goto case_37;
 2312|      0|            }
 2313|      0|            if ((int)c == 66) {
 2314|      0|                goto case_37;
 2315|      0|            }
 2316|      0|            if ((int)c == 67) {
 2317|      0|                goto case_37;
 2318|      0|            }
 2319|      0|            if ((int)c == 68) {
 2320|      0|                goto case_37;
 2321|      0|            }
 2322|      0|            if ((int)c == 69) {
 2323|      0|                goto case_37;
 2324|      0|            }
 2325|      0|            if ((int)c == 70) {
 2326|      0|                goto case_37;
 2327|      0|            }
 2328|      0|            if ((int)c == 71) {
 2329|      0|                goto case_37;
 2330|      0|            }
 2331|      0|            if ((int)c == 72) {
 2332|      0|                goto case_37;
 2333|      0|            }
 2334|      0|            if ((int)c == 73) {
 2335|      0|                goto case_37;
 2336|      0|            }
 2337|      0|            if ((int)c == 74) {
 2338|      0|                goto case_37;
 2339|      0|            }
 2340|      0|            if ((int)c == 75) {
 2341|      0|                goto case_37;
 2342|      0|            }
 2343|      0|            if ((int)c == 76) {
 2344|      0|                goto case_37;
 2345|      0|            }
 2346|      0|            if ((int)c == 77) {
 2347|      0|                goto case_37;
 2348|      0|            }
 2349|      0|            if ((int)c == 78) {
 2350|      0|                goto case_37;
 2351|      0|            }
 2352|      0|            if ((int)c == 79) {
 2353|      0|                goto case_37;
 2354|      0|            }
 2355|      0|            if ((int)c == 80) {
 2356|      0|                goto case_37;
 2357|      0|            }
 2358|      0|            if ((int)c == 81) {
 2359|      0|                goto case_37;
 2360|      0|            }
 2361|      0|            if ((int)c == 82) {
 2362|      0|                goto case_37;
 2363|      0|            }
 2364|      0|            if ((int)c == 83) {
 2365|      0|                goto case_37;
 2366|      0|            }
 2367|      0|            if ((int)c == 84) {
 2368|      0|                goto case_37;
 2369|      0|            }
 2370|      0|            if ((int)c == 85) {
 2371|      0|                goto case_37;
 2372|      0|            }
 2373|      0|            if ((int)c == 86) {
 2374|      0|                goto case_37;
 2375|      0|            }
 2376|      0|            if ((int)c == 87) {
 2377|      0|                goto case_37;
 2378|      0|            }
 2379|      0|            if ((int)c == 88) {
 2380|      0|                goto case_37;
 2381|      0|            }
 2382|      0|            if ((int)c == 89) {
 2383|      0|                goto case_37;
 2384|      0|            }
 2385|      0|            if ((int)c == 90) {
 2386|      0|                goto case_37;
 2387|      0|            }
 2388|      0|            if ((int)c == 93) {
 2389|      0|                goto case_37;
 2390|      0|            }
 2391|      0|            if ((int)c == 95) {
 2392|      0|                goto case_37;
 2393|      0|            }
 2394|      0|            if ((int)c == 97) {
 2395|      0|                goto case_37;
 2396|      0|            }
 2397|      0|            if ((int)c == 98) {
 2398|      0|                goto case_37;
 2399|      0|            }
 2400|      0|            if ((int)c == 99) {
 2401|      0|                goto case_37;
 2402|      0|            }
 2403|      0|            if ((int)c == 100) {
 2404|      0|                goto case_37;
 2405|      0|            }
 2406|      0|            if ((int)c == 101) {
 2407|      0|                goto case_37;
 2408|      0|            }
 2409|      0|            if ((int)c == 102) {
 2410|      0|                goto case_37;
 2411|      0|            }
 2412|      0|            if ((int)c == 103) {
 2413|      0|                goto case_37;
 2414|      0|            }
 2415|      0|            if ((int)c == 104) {
 2416|      0|                goto case_37;
 2417|      0|            }
 2418|      0|            if ((int)c == 105) {
 2419|      0|                goto case_37;
 2420|      0|            }
 2421|      0|            if ((int)c == 106) {
 2422|      0|                goto case_37;
 2423|      0|            }
 2424|      0|            if ((int)c == 107) {
 2425|      0|                goto case_37;
 2426|      0|            }
 2427|      0|            if ((int)c == 108) {
 2428|      0|                goto case_37;
 2429|      0|            }
 2430|      0|            if ((int)c == 109) {
 2431|      0|                goto case_37;
 2432|      0|            }
 2433|      0|            if ((int)c == 110) {
 2434|      0|                goto case_37;
 2435|      0|            }
 2436|      0|            if ((int)c == 111) {
 2437|      0|                goto case_37;
 2438|      0|            }
 2439|      0|            if ((int)c == 112) {
 2440|      0|                goto case_37;
 2441|      0|            }
 2442|      0|            if ((int)c == 113) {
 2443|      0|                goto case_37;
 2444|      0|            }
 2445|      0|            if ((int)c == 114) {
 2446|      0|                goto case_37;
 2447|      0|            }
 2448|      0|            if ((int)c == 115) {
 2449|      0|                goto case_37;
 2450|      0|            }
 2451|      0|            if ((int)c == 116) {
 2452|      0|                goto case_37;
 2453|      0|            }
 2454|      0|            if ((int)c == 117) {
 2455|      0|                goto case_37;
 2456|      0|            }
 2457|      0|            if ((int)c == 118) {
 2458|      0|                goto case_37;
 2459|      0|            }
 2460|      0|            if ((int)c == 119) {
 2461|      0|                goto case_37;
 2462|      0|            }
 2463|      0|            if ((int)c == 120) {
 2464|      0|                goto case_37;
 2465|      0|            }
 2466|      0|            if ((int)c == 121) {
 2467|      0|                goto case_37;
 2468|      0|            }
 2469|      0|            if ((int)c == 122) {
 2470|      0|                goto case_37;
 2471|      0|            }
 2472|      0|            goto switch_default___2;
 2473|      0|case_0___0:
 2474|      0|            if (backslash_escapes) {
 2475|      0|                if (elide_outer_quotes) {
 2476|      0|                    goto force_outer_quoting_style;
 2477|      0|                }
 2478|      0|                while (1) {
 2479|       |
 2480|      0|                    if (len < buffersize) {
 2481|      0|                        *(buffer + len) = (char)'\\';
 2482|      0|                    }
 2483|      0|                    len++;
 2484|      0|                    goto while_break___4;
 2485|      0|                }
 2486|      0|while_break___4:
 2487|      0|                ;
 2488|      0|                if (i + 1UL < argsize) {
 2489|      0|                    if (48 <= (int)*(arg + (i + 1UL))) {
 2490|      0|                        if ((int const) * (arg + (i + 1UL)) <= 57) {
 2491|      0|                            while (1) {
 2492|       |
 2493|      0|                                if (len < buffersize) {
 2494|      0|                                    *(buffer + len) = (char)'0';
 2495|      0|                                }
 2496|      0|                                len++;
 2497|      0|                                goto while_break___5;
 2498|      0|                            }
 2499|      0|while_break___5:
 2500|      0|                            ;
 2501|      0|                            while (1) {
 2502|       |
 2503|      0|                                if (len < buffersize) {
 2504|      0|                                    *(buffer + len) = (char)'0';
 2505|      0|                                }
 2506|      0|                                len++;
 2507|      0|                                goto while_break___6;
 2508|      0|                            }
 2509|      0|while_break___6:
 2510|      0|                            ;
 2511|      0|                        }
 2512|      0|                    }
 2513|      0|                }
 2514|      0|                c = (unsigned char)'0';
 2515|      0|            }
 2516|      0|            else {
 2517|      0|                if (flags & 1) {
 2518|      0|                    goto __Cont;
 2519|      0|                }
 2520|      0|            }
 2521|      0|            goto switch_break___0;
 2522|      0|case_63:
 2523|      0|            if ((unsigned int)quoting_style == 2U) {
 2524|      0|                goto case_2___0;
 2525|      0|            }
 2526|      0|            if ((unsigned int)quoting_style == 3U) {
 2527|      0|                goto case_3___0;
 2528|      0|            }
 2529|      0|            goto switch_default___1;
 2530|      0|case_2___0:
 2531|      0|            if (elide_outer_quotes) {
 2532|      0|                goto force_outer_quoting_style;
 2533|      0|            }
 2534|      0|            goto switch_break___1;
 2535|      0|case_3___0:
 2536|      0|            if (flags & 4) {
 2537|      0|                if (i + 2UL < argsize) {
 2538|      0|                    if ((int const) * (arg + (i + 1UL)) == 63) {
 2539|      0|                        if ((int const) * (arg + (i + 2UL)) == 33) {
 2540|      0|                            goto case_33;
 2541|      0|                        }
 2542|      0|                        if ((int const) * (arg + (i + 2UL)) == 39) {
 2543|      0|                            goto case_33;
 2544|      0|                        }
 2545|      0|                        if ((int const) * (arg + (i + 2UL)) == 40) {
 2546|      0|                            goto case_33;
 2547|      0|                        }
 2548|      0|                        if ((int const) * (arg + (i + 2UL)) == 41) {
 2549|      0|                            goto case_33;
 2550|      0|                        }
 2551|      0|                        if ((int const) * (arg + (i + 2UL)) == 45) {
 2552|      0|                            goto case_33;
 2553|      0|                        }
 2554|      0|                        if ((int const) * (arg + (i + 2UL)) == 47) {
 2555|      0|                            goto case_33;
 2556|      0|                        }
 2557|      0|                        if ((int const) * (arg + (i + 2UL)) == 60) {
 2558|      0|                            goto case_33;
 2559|      0|                        }
 2560|      0|                        if ((int const) * (arg + (i + 2UL)) == 61) {
 2561|      0|                            goto case_33;
 2562|      0|                        }
 2563|      0|                        if ((int const) * (arg + (i + 2UL)) == 62) {
 2564|      0|                            goto case_33;
 2565|      0|                        }
 2566|      0|                        goto switch_default___0;
 2567|      0|case_33:
 2568|      0|                        if (elide_outer_quotes) {
 2569|      0|                            goto force_outer_quoting_style;
 2570|      0|                        }
 2571|      0|                        c = (unsigned char)*(arg + (i + 2UL));
 2572|      0|                        i += 2UL;
 2573|      0|                        while (1) {
 2574|       |
 2575|      0|                            if (len < buffersize) {
 2576|      0|                                *(buffer + len) = (char)'?';
 2577|      0|                            }
 2578|      0|                            len++;
 2579|      0|                            goto while_break___7;
 2580|      0|                        }
 2581|      0|while_break___7:
 2582|      0|                        ;
 2583|      0|                        while (1) {
 2584|       |
 2585|      0|                            if (len < buffersize) {
 2586|      0|                                *(buffer + len) = (char)'\"';
 2587|      0|                            }
 2588|      0|                            len++;
 2589|      0|                            goto while_break___8;
 2590|      0|                        }
 2591|      0|while_break___8:
 2592|      0|                        ;
 2593|      0|                        while (1) {
 2594|       |
 2595|      0|                            if (len < buffersize) {
 2596|      0|                                *(buffer + len) = (char)'\"';
 2597|      0|                            }
 2598|      0|                            len++;
 2599|      0|                            goto while_break___9;
 2600|      0|                        }
 2601|      0|while_break___9:
 2602|      0|                        ;
 2603|      0|                        while (1) {
 2604|       |
 2605|      0|                            if (len < buffersize) {
 2606|      0|                                *(buffer + len) = (char)'?';
 2607|      0|                            }
 2608|      0|                            len++;
 2609|      0|                            goto while_break___10;
 2610|      0|                        }
 2611|      0|while_break___10:
 2612|      0|                        ;
 2613|      0|                        goto switch_break___2;
 2614|      0|switch_default___0:
 2615|      0|                        goto switch_break___2;
 2616|      0|switch_break___2:
 2617|      0|                        ;
 2618|      0|                    }
 2619|      0|                }
 2620|      0|            }
 2621|      0|            goto switch_break___1;
 2622|      0|switch_default___1:
 2623|      0|            goto switch_break___1;
 2624|      0|switch_break___1:
 2625|      0|            ;
 2626|      0|            goto switch_break___0;
 2627|      0|case_7___0:
 2628|      0|            esc = (unsigned char)'a';
 2629|      0|            goto c_escape;
 2630|      0|case_8___0:
 2631|      0|            esc = (unsigned char)'b';
 2632|      0|            goto c_escape;
 2633|      0|case_12:
 2634|      0|            esc = (unsigned char)'f';
 2635|      0|            goto c_escape;
 2636|      0|case_10:
 2637|      0|            esc = (unsigned char)'n';
 2638|      0|            goto c_and_shell_escape;
 2639|      0|case_13:
 2640|      0|            esc = (unsigned char)'r';
 2641|      0|            goto c_and_shell_escape;
 2642|      0|case_9:
 2643|      0|            esc = (unsigned char)'t';
 2644|      0|            goto c_and_shell_escape;
 2645|      0|case_11:
 2646|      0|            esc = (unsigned char)'v';
 2647|      0|            goto c_escape;
 2648|      0|case_92:
 2649|      0|            esc = c;
 2650|      0|            if (backslash_escapes) {
 2651|      0|                if (elide_outer_quotes) {
 2652|      0|                    if (quote_string_len) {
 2653|      0|                        goto store_c;
 2654|      0|                    }
 2655|      0|                }
 2656|      0|            }
 2657|      0|c_and_shell_escape:
 2658|      0|            if ((unsigned int)quoting_style == 2U) {
 2659|      0|                if (elide_outer_quotes) {
 2660|      0|                    goto force_outer_quoting_style;
 2661|      0|                }
 2662|      0|            }
 2663|      0|c_escape:
 2664|      0|            if (backslash_escapes) {
 2665|      0|                c = esc;
 2666|      0|                goto store_escape;
 2667|      0|            }
 2668|      0|            goto switch_break___0;
 2669|      0|case_123:
 2670|      0|            if (argsize == 0xffffffffffffffffUL) {
 2671|      0|                tmp___1 = (int const) * (arg + 1) == 0;
 2672|      0|            }
 2673|      0|            else {
 2674|      0|                tmp___1 = argsize == 1UL;
 2675|      0|            }
 2676|      0|            if (!tmp___1) {
 2677|      0|                goto switch_break___0;
 2678|      0|            }
 2679|      0|case_35:
 2680|      0|            if (i != 0UL) {
 2681|      0|                goto switch_break___0;
 2682|      0|            }
 2683|      0|case_32:
 2684|      0|            if ((unsigned int)quoting_style == 2U) {
 2685|      0|                if (elide_outer_quotes) {
 2686|      0|                    goto force_outer_quoting_style;
 2687|      0|                }
 2688|      0|            }
 2689|      0|            goto switch_break___0;
 2690|      0|case_39___0:
 2691|      0|            if ((unsigned int)quoting_style == 2U) {
 2692|      0|                if (elide_outer_quotes) {
 2693|      0|                    goto force_outer_quoting_style;
 2694|      0|                }
 2695|      0|                while (1) {
 2696|       |
 2697|      0|                    if (len < buffersize) {
 2698|      0|                        *(buffer + len) = (char)'\'';
 2699|      0|                    }
 2700|      0|                    len++;
 2701|      0|                    goto while_break___11;
 2702|      0|                }
 2703|      0|while_break___11:
 2704|      0|                ;
 2705|      0|                while (1) {
 2706|       |
 2707|      0|                    if (len < buffersize) {
 2708|      0|                        *(buffer + len) = (char)'\\';
 2709|      0|                    }
 2710|      0|                    len++;
 2711|      0|                    goto while_break___12;
 2712|      0|                }
 2713|      0|while_break___12:
 2714|      0|                ;
 2715|      0|                while (1) {
 2716|       |
 2717|      0|                    if (len < buffersize) {
 2718|      0|                        *(buffer + len) = (char)'\'';
 2719|      0|                    }
 2720|      0|                    len++;
 2721|      0|                    goto while_break___13;
 2722|      0|                }
 2723|      0|while_break___13:
 2724|      0|                ;
 2725|      0|            }
 2726|      0|            goto switch_break___0;
 2727|      0|case_37:
 2728|      0|            goto switch_break___0;
 2729|      0|switch_default___2:
 2730|      0|            if (unibyte_locale) {
 2731|      0|                m = (size_t)1;
 2732|      0|                tmp___2 = __ctype_b_loc();
 2733|      0|                printable = (_Bool)(((int const) * (*tmp___2 + (int)c) & 16384) != 0);
 2734|      0|            }
 2735|      0|            else {
 2736|      0|                memset((void *)(&mbstate), 0, sizeof(mbstate));
 2737|      0|                m = (size_t)0;
 2738|      0|                printable = (_Bool)1;
 2739|      0|                if (argsize == 0xffffffffffffffffUL) {
 2740|      0|                    argsize = strlen(arg);
 2741|      0|                }
 2742|      0|                while (1) {
 2743|      0|                    tmp___3 = mbrtowc(&w, arg + (i + m), argsize - (i + m), &mbstate);
 2744|      0|                    bytes = tmp___3;
 2745|      0|                    if (bytes == 0UL) {
 2746|      0|                        goto while_break___14;
 2747|      0|                    }
 2748|      0|                    else {
 2749|      0|                        if (bytes == 0xffffffffffffffffUL) {
 2750|      0|                            printable = (_Bool)0;
 2751|      0|                            goto while_break___14;
 2752|      0|                        }
 2753|      0|                        else {
 2754|      0|                            if (bytes == 0xfffffffffffffffeUL) {
 2755|      0|                                printable = (_Bool)0;
 2756|      0|                                while (1) {
 2757|       |
 2758|      0|                                    if (i + m < argsize) {
 2759|      0|                                        if (!*(arg + (i + m))) {
 2760|      0|                                            goto while_break___15;
 2761|      0|                                        }
 2762|      0|                                    }
 2763|      0|                                    else {
 2764|      0|                                        goto while_break___15;
 2765|      0|                                    }
 2766|      0|                                    m++;
 2767|      0|                                }
 2768|      0|while_break___15:
 2769|      0|                                ;
 2770|      0|                                goto while_break___14;
 2771|      0|                            }
 2772|      0|                            else {
 2773|      0|                                if (elide_outer_quotes) {
 2774|      0|                                    if ((unsigned int)quoting_style == 2U) {
 2775|      0|                                        j = (size_t)1;
 2776|      0|                                        while (1) {
 2777|       |
 2778|      0|                                            if (!(j < bytes)) {
 2779|      0|                                                goto while_break___16;
 2780|      0|                                            }
 2781|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 91) {
 2782|      0|                                                goto case_91___0;
 2783|      0|                                            }
 2784|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 92) {
 2785|      0|                                                goto case_91___0;
 2786|      0|                                            }
 2787|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 94) {
 2788|      0|                                                goto case_91___0;
 2789|      0|                                            }
 2790|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 96) {
 2791|      0|                                                goto case_91___0;
 2792|      0|                                            }
 2793|      0|                                            if ((int const) * (arg + ((i + m) + j)) == 124) {
 2794|      0|                                                goto case_91___0;
 2795|      0|                                            }
 2796|      0|                                            goto switch_default___3;
 2797|      0|case_91___0:
 2798|      0|                                            goto force_outer_quoting_style;
 2799|      0|switch_default___3:
 2800|      0|                                            goto switch_break___3;
 2801|      0|switch_break___3:
 2802|      0|                                            j++;
 2803|      0|                                        }
 2804|      0|while_break___16:
 2805|      0|                                        ;
 2806|      0|                                    }
 2807|      0|                                }
 2808|      0|                                tmp___4 = iswprint((wint_t)w);
 2809|      0|                                if (!tmp___4) {
 2810|      0|                                    printable = (_Bool)0;
 2811|      0|                                }
 2812|      0|                                m += bytes;
 2813|      0|                            }
 2814|      0|                        }
 2815|      0|                    }
 2816|      0|                    tmp___5 = mbsinit((mbstate_t const *)(&mbstate));
 2817|      0|                    if (tmp___5) {
 2818|      0|                        goto while_break___14;
 2819|      0|                    }
 2820|      0|                }
 2821|      0|while_break___14:
 2822|      0|                ;
 2823|      0|            }
 2824|      0|            if (1UL < m) {
 2825|      0|                goto _L___0;
 2826|      0|            }
 2827|      0|            else {
 2828|      0|                if (backslash_escapes) {
 2829|      0|                    if (!printable) {
 2830|      0|_L___0:
 2831|      0|                        ilim = i + m;
 2832|      0|                        while (1) {
 2833|       |
 2834|      0|                            if (backslash_escapes) {
 2835|      0|                                if (!printable) {
 2836|      0|                                    if (elide_outer_quotes) {
 2837|      0|                                        goto force_outer_quoting_style;
 2838|      0|                                    }
 2839|      0|                                    while (1) {
 2840|       |
 2841|      0|                                        if (len < buffersize) {
 2842|      0|                                            *(buffer + len) = (char)'\\';
 2843|      0|                                        }
 2844|      0|                                        len++;
 2845|      0|                                        goto while_break___18;
 2846|      0|                                    }
 2847|      0|while_break___18:
 2848|      0|                                    ;
 2849|      0|                                    while (1) {
 2850|       |
 2851|      0|                                        if (len < buffersize) {
 2852|      0|                                            *(buffer + len) = (char)(48 + ((int)c >> 6));
 2853|      0|                                        }
 2854|      0|                                        len++;
 2855|      0|                                        goto while_break___19;
 2856|      0|                                    }
 2857|      0|while_break___19:
 2858|      0|                                    ;
 2859|      0|                                    while (1) {
 2860|       |
 2861|      0|                                        if (len < buffersize) {
 2862|      0|                                            *(buffer + len) = (char)(48 + (((int)c >> 3) & 7));
 2863|      0|                                        }
 2864|      0|                                        len++;
 2865|      0|                                        goto while_break___20;
 2866|      0|                                    }
 2867|      0|while_break___20:
 2868|      0|                                    c = (unsigned char)(48 + ((int)c & 7));
 2869|      0|                                }
 2870|      0|                                else {
 2871|      0|                                    goto _L;
 2872|      0|                                }
 2873|      0|                            }
 2874|      0|                            else {
 2875|      0|_L:
 2876|      0|                                if (is_right_quote) {
 2877|      0|                                    while (1) {
 2878|       |
 2879|      0|                                        if (len < buffersize) {
 2880|      0|                                            *(buffer + len) = (char)'\\';
 2881|      0|                                        }
 2882|      0|                                        len++;
 2883|      0|                                        goto while_break___21;
 2884|      0|                                    }
 2885|      0|while_break___21:
 2886|      0|                                    is_right_quote = (_Bool)0;
 2887|      0|                                }
 2888|      0|                            }
 2889|      0|                            if (ilim <= i + 1UL) {
 2890|      0|                                goto while_break___17;
 2891|      0|                            }
 2892|      0|                            while (1) {
 2893|       |
 2894|      0|                                if (len < buffersize) {
 2895|      0|                                    *(buffer + len) = (char)c;
 2896|      0|                                }
 2897|      0|                                len++;
 2898|      0|                                goto while_break___22;
 2899|      0|                            }
 2900|      0|while_break___22:
 2901|      0|                            i++;
 2902|      0|                            c = (unsigned char)*(arg + i);
 2903|      0|                        }
 2904|      0|while_break___17:
 2905|      0|                        ;
 2906|      0|                        goto store_c;
 2907|      0|                    }
 2908|      0|                }
 2909|      0|            }
 2910|      0|switch_break___0:
 2911|      0|            ;
 2912|      0|            if (backslash_escapes) {
 2913|      0|                goto _L___3;
 2914|      0|            }
 2915|      0|            else {
 2916|      0|                if (elide_outer_quotes) {
 2917|      0|_L___3:
 2918|      0|                    if (quote_these_too) {
 2919|      0|                        if (!(*(quote_these_too + (unsigned long)c / (sizeof(int) * 8UL)) &
 2920|      0|                                (unsigned int const)(1 << (unsigned long)c %
 2921|      0|                                                     (sizeof(int) * 8UL)))) {
 2922|      0|                            goto _L___2;
 2923|      0|                        }
 2924|      0|                    }
 2925|      0|                    else {
 2926|      0|                        goto _L___2;
 2927|      0|                    }
 2928|      0|                }
 2929|      0|                else {
 2930|      0|_L___2:
 2931|      0|                    if (!is_right_quote) {
 2932|      0|                        goto store_c;
 2933|      0|                    }
 2934|      0|                }
 2935|      0|            }
 2936|      0|store_escape:
 2937|      0|            if (elide_outer_quotes) {
 2938|      0|                goto force_outer_quoting_style;
 2939|      0|            }
 2940|      0|            while (1) {
 2941|       |
 2942|      0|                if (len < buffersize) {
 2943|      0|                    *(buffer + len) = (char)'\\';
 2944|      0|                }
 2945|      0|                len++;
 2946|      0|                goto while_break___23;
 2947|      0|            }
 2948|      0|while_break___23:
 2949|      0|            ;
 2950|      0|store_c:
 2951|      0|            while (1) {
 2952|       |
 2953|      0|                if (len < buffersize) {
 2954|      0|                    *(buffer + len) = (char)c;
 2955|      0|                }
 2956|      0|                len++;
 2957|      0|                goto while_break___24;
 2958|      0|            }
 2959|      0|while_break___24:
 2960|      0|            ;
 2961|      0|__Cont:
 2962|      0|            i++;
 2963|      0|        }
 2964|      0|while_break___3:
 2965|      0|        ;
 2966|      0|        if (len == 0UL) {
 2967|      0|            if ((unsigned int)quoting_style == 2U) {
 2968|      0|                if (elide_outer_quotes) {
 2969|      0|                    goto force_outer_quoting_style;
 2970|      0|                }
 2971|      0|            }
 2972|      0|        }
 2973|      0|        if (quote_string) {
 2974|      0|            if (!elide_outer_quotes) {
 2975|      0|                while (1) {
 2976|       |
 2977|      0|                    if (!*quote_string) {
 2978|      0|                        goto while_break___25;
 2979|      0|                    }
 2980|      0|                    while (1) {
 2981|       |
 2982|      0|                        if (len < buffersize) {
 2983|      0|                            *(buffer + len) = (char)*quote_string;
 2984|      0|                        }
 2985|      0|                        len++;
 2986|      0|                        goto while_break___26;
 2987|      0|                    }
 2988|      0|while_break___26:
 2989|      0|                    quote_string++;
 2990|      0|                }
 2991|      0|while_break___25:
 2992|      0|                ;
 2993|      0|            }
 2994|      0|        }
 2995|      0|        if (len < buffersize) {
 2996|      0|            *(buffer + len) = (char)'\000';
 2997|      0|        }
 2998|      0|        return (len);
 2999|      0|force_outer_quoting_style:
 3000|      0|        tmp___7 = quotearg_buffer_restyled(
 3001|      0|                      buffer, buffersize, arg, argsize, quoting_style, flags & -3,
 3002|      0|                      (unsigned int const *)((void *)0), left_quote, right_quote);
 3003|      0|        return (tmp___7);
 3004|      0|    }
 3005|      0|}
 3006|       |static char slot0[256];
 3007|       |static unsigned int nslots = 1U;
 3008|       |static struct slotvec slotvec0 = {sizeof(slot0), slot0};
 3009|       |static struct slotvec *slotvec = &slotvec0;
 3010|       |static char *quotearg_n_options(int n, char const *arg, size_t argsize,
 3011|       |                                struct quoting_options const *options)
 3012|      0|{
 3013|      0|    int e;
 3014|      0|    int *tmp;
 3015|      0|    unsigned int n0;
 3016|      0|    struct slotvec *sv;
 3017|      0|    size_t n1;
 3018|      0|    _Bool preallocated;
 3019|      0|    int tmp___0;
 3020|      0|    struct slotvec *tmp___1;
 3021|      0|    size_t size;
 3022|      0|    char *val;
 3023|      0|    int flags;
 3024|      0|    size_t qsize;
 3025|      0|    size_t tmp___2;
 3026|      0|    int *tmp___3;
 3027|       |
 3028|      0|    {
 3029|      0|        tmp = __errno_location();
 3030|      0|        e = *tmp;
 3031|      0|        n0 = (unsigned int)n;
 3032|      0|        sv = slotvec;
 3033|      0|        if (n < 0) {
 3034|      0|            abort();
 3035|      0|        }
 3036|      0|        if (nslots <= n0) {
 3037|      0|            n1 = (size_t)(n0 + 1U);
 3038|      0|            preallocated = (_Bool)((unsigned long)sv == (unsigned long)(&slotvec0));
 3039|      0|            if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 3040|      0|                tmp___0 = -1;
 3041|      0|            }
 3042|      0|            else {
 3043|      0|                tmp___0 = -2;
 3044|      0|            }
 3045|      0|            if ((size_t)tmp___0 / sizeof(*sv) < n1) {
 3046|      0|                xalloc_die();
 3047|      0|            }
 3048|      0|            if (preallocated) {
 3049|      0|                tmp___1 = (struct slotvec *)((void *)0);
 3050|      0|            }
 3051|      0|            else {
 3052|      0|                tmp___1 = sv;
 3053|      0|            }
 3054|      0|            sv = (struct slotvec *)xrealloc((void *)tmp___1, n1 * sizeof(*sv));
 3055|      0|            slotvec = sv;
 3056|      0|            if (preallocated) {
 3057|      0|                *sv = slotvec0;
 3058|      0|            }
 3059|      0|            memset((void *)(sv + nslots), 0, (n1 - (size_t)nslots) * sizeof(*sv));
 3060|      0|            nslots = (unsigned int)n1;
 3061|      0|        }
 3062|      0|        size = (sv + n)->size;
 3063|      0|        val = (sv + n)->val;
 3064|      0|        flags = (int)(options->flags | 1);
 3065|      0|        tmp___2 = quotearg_buffer_restyled(
 3066|      0|                      val, size, arg, argsize, (enum quoting_style)options->style, flags,
 3067|      0|                      (unsigned int const *)(options->quote_these_too),
 3068|      0|                      (char const *)options->left_quote, (char const *)options->right_quote);
 3069|      0|        qsize = tmp___2;
 3070|      0|        if (size <= qsize) {
 3071|      0|            size = qsize + 1UL;
 3072|      0|            (sv + n)->size = size;
 3073|      0|            if ((unsigned long)val != (unsigned long)(slot0)) {
 3074|      0|                free((void *)val);
 3075|      0|            }
 3076|      0|            val = xcharalloc(size);
 3077|      0|            (sv + n)->val = val;
 3078|      0|            quotearg_buffer_restyled(val, size, arg, argsize,
 3079|      0|                                     (enum quoting_style)options->style, flags,
 3080|      0|                                     (unsigned int const *)(options->quote_these_too),
 3081|      0|                                     (char const *)options->left_quote,
 3082|      0|                                     (char const *)options->right_quote);
 3083|      0|        }
 3084|      0|        tmp___3 = __errno_location();
 3085|      0|        *tmp___3 = e;
 3086|      0|        return (val);
 3087|      0|    }
 3088|      0|}
 3089|       |char *quotearg_n_style(int n, enum quoting_style s, char const *arg)
 3090|      0|{
 3091|      0|    struct quoting_options o;
 3092|      0|    struct quoting_options tmp;
 3093|      0|    char *tmp___0;
 3094|       |
 3095|      0|    {
 3096|      0|        tmp = quoting_options_from_style(s);
 3097|      0|        o = tmp;
 3098|      0|        tmp___0 = quotearg_n_options(n, arg, (size_t)-1,
 3099|      0|                                     (struct quoting_options const *)(&o));
 3100|      0|        return (tmp___0);
 3101|      0|    }
 3102|      0|}
 3103|       |char *quotearg_char_mem(char const *arg, size_t argsize, char ch)
 3104|      0|{
 3105|      0|    struct quoting_options options;
 3106|      0|    char *tmp;
 3107|       |
 3108|      0|    {
 3109|      0|        options = default_quoting_options;
 3110|      0|        set_char_quoting(&options, ch, 1);
 3111|      0|        tmp = quotearg_n_options(0, arg, argsize,
 3112|      0|                                 (struct quoting_options const *)(&options));
 3113|      0|        return (tmp);
 3114|      0|    }
 3115|      0|}
 3116|       |char *quotearg_char(char const *arg, char ch)
 3117|      0|{
 3118|      0|    char *tmp;
 3119|       |
 3120|      0|    {
 3121|      0|        tmp = quotearg_char_mem(arg, (size_t)-1, ch);
 3122|      0|        return (tmp);
 3123|      0|    }
 3124|      0|}
 3125|       |char *quotearg_colon(char const *arg)
 3126|      0|{
 3127|      0|    char *tmp;
 3128|       |
 3129|      0|    {
 3130|      0|        tmp = quotearg_char(arg, (char)':');
 3131|      0|        return (tmp);
 3132|      0|    }
 3133|      0|}
 3134|       |char const *quote_n(int n, char const *name)
 3135|      0|{
 3136|      0|    char const *tmp;
 3137|       |
 3138|      0|    {
 3139|      0|        tmp = (char const *)quotearg_n_style(n, (enum quoting_style)6, name);
 3140|      0|        return (tmp);
 3141|      0|    }
 3142|      0|}
 3143|       |char const *quote(char const *name)
 3144|      0|{
 3145|      0|    char const *tmp;
 3146|       |
 3147|      0|    {
 3148|      0|        tmp = quote_n(0, name);
 3149|      0|        return (tmp);
 3150|      0|    }
 3151|      0|}
 3152|       |char const *program_name;
 3153|       |void set_program_name(char const *argv0);
 3154|       |extern char *program_invocation_name;
 3155|       |extern char *program_invocation_short_name;
 3156|       |extern int fputs(char const *__restrict __s, FILE *__restrict __stream);
 3157|       |char const *program_name = (char const *)((void *)0);
 3158|       |void set_program_name(char const *argv0)
 3159|      2|{
 3160|      2|    char const *slash;
 3161|      2|    char const *base;
 3162|      2|    int tmp;
 3163|      2|    int tmp___0;
 3164|       |
 3165|      2|    {
 3166|      2|        if ((unsigned long)argv0 == (unsigned long)((void *)0)) {
 3167|      0|            fputs("A NULL argv[0] was passed through an exec system call.\n", stderr);
 3168|      0|            abort();
 3169|      0|        }
 3170|      2|        slash = (char const *)strrchr(argv0, '/');
 3171|      2|        if ((unsigned long)slash != (unsigned long)((void *)0)) {
 3172|      2|            base = slash + 1;
 3173|      2|        }
 3174|      0|        else {
 3175|      0|            base = argv0;
 3176|      0|        }
 3177|      2|        if (base - argv0 >= 7L) {
 3178|      0|            tmp___0 = strncmp(base - 7, "/.libs/", (size_t)7);
 3179|      0|            if (tmp___0 == 0) {
 3180|      0|                argv0 = base;
 3181|      0|                tmp = strncmp(base, "lt-", (size_t)3);
 3182|      0|                if (tmp == 0) {
 3183|      0|                    argv0 = base + 3;
 3184|      0|                    program_invocation_short_name = (char *)argv0;
 3185|      0|                }
 3186|      0|            }
 3187|      0|        }
 3188|      2|        program_name = argv0;
 3189|      2|        program_invocation_name = (char *)argv0;
 3190|      2|        return;
 3191|      2|    }
 3192|      2|}
 3193|       |extern DIR *(__attribute__((__nonnull__(1))) opendir)(char const *__name);
 3194|       |extern
 3195|       |__attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 3196|       |                                 dirfd)(DIR *__dirp);
 3197|       |DIR *opendir_safer(char const *name)
 3198|      0|{
 3199|      0|    DIR *dp;
 3200|      0|    DIR *tmp;
 3201|      0|    int fd;
 3202|      0|    int tmp___0;
 3203|      0|    DIR *newdp;
 3204|      0|    int e;
 3205|      0|    int f;
 3206|      0|    int tmp___1;
 3207|      0|    int *tmp___2;
 3208|      0|    int *tmp___3;
 3209|       |
 3210|      0|    {
 3211|      0|        tmp = opendir(name);
 3212|      0|        dp = tmp;
 3213|      0|        if (dp) {
 3214|      0|            tmp___0 = dirfd(dp);
 3215|      0|            fd = tmp___0;
 3216|      0|            if (0 <= fd) {
 3217|      0|                if (fd <= 2) {
 3218|      0|                    tmp___1 = dup_safer(fd);
 3219|      0|                    f = tmp___1;
 3220|      0|                    newdp = fdopendir(f);
 3221|      0|                    tmp___2 = __errno_location();
 3222|      0|                    e = *tmp___2;
 3223|      0|                    if (!newdp) {
 3224|      0|                        close(f);
 3225|      0|                    }
 3226|      0|                    closedir(dp);
 3227|      0|                    tmp___3 = __errno_location();
 3228|      0|                    *tmp___3 = e;
 3229|      0|                    dp = newdp;
 3230|      0|                }
 3231|      0|            }
 3232|      0|        }
 3233|      0|        return (dp);
 3234|      0|    }
 3235|      0|}
 3236|       |int openat_safer(int fd, char const *file, int flags, ...);
 3237|       |int openat_safer(int fd, char const *file, int flags, ...)
 3238|     14|{
 3239|     14|    mode_t mode;
 3240|     14|    va_list ap;
 3241|     14|    int tmp;
 3242|     14|    int tmp___0;
 3243|       |
 3244|     14|    {
 3245|     14|        mode = (mode_t)0;
 3246|     14|        if (flags & 64) {
 3247|      0|            __builtin_va_start(ap, flags);
 3248|      0|            mode = __builtin_va_arg(ap, mode_t);
 3249|      0|            __builtin_va_end(ap);
 3250|      0|        }
 3251|     14|        tmp = openat(fd, file, flags, mode);
 3252|     14|        tmp___0 = fd_safer(tmp);
 3253|     14|        return (tmp___0);
 3254|     14|    }
 3255|     14|}
 3256|       |int open_safer(char const *file, int flags, ...)
 3257|      0|{
 3258|      0|    mode_t mode;
 3259|      0|    va_list ap;
 3260|      0|    int tmp;
 3261|      0|    int tmp___0;
 3262|       |
 3263|      0|    {
 3264|      0|        mode = (mode_t)0;
 3265|      0|        if (flags & 64) {
 3266|      0|            __builtin_va_start(ap, flags);
 3267|      0|            mode = __builtin_va_arg(ap, mode_t);
 3268|      0|            __builtin_va_end(ap);
 3269|      0|        }
 3270|      0|        tmp = open(file, flags, mode);
 3271|      0|        tmp___0 = fd_safer(tmp);
 3272|      0|        return (tmp___0);
 3273|      0|    }
 3274|      0|}
 3275|       |int(__attribute__((__nonnull__(1, 2))) mbscasecmp)(char const *s1,
 3276|       |        char const *s2)
 3277|      0|{
 3278|      0|    mbui_iterator_t iter1;
 3279|      0|    mbui_iterator_t iter2;
 3280|      0|    int cmp;
 3281|      0|    wint_t tmp;
 3282|      0|    wint_t tmp___0;
 3283|      0|    int tmp___1;
 3284|      0|    int tmp___2;
 3285|      0|    int tmp___4;
 3286|      0|    int tmp___5;
 3287|      0|    int tmp___7;
 3288|      0|    int tmp___8;
 3289|      0|    int tmp___9;
 3290|      0|    int tmp___10;
 3291|      0|    int tmp___11;
 3292|      0|    int tmp___12;
 3293|      0|    int tmp___13;
 3294|      0|    int tmp___14;
 3295|      0|    int tmp___15;
 3296|      0|    int tmp___16;
 3297|      0|    unsigned char const *p1;
 3298|      0|    unsigned char const *p2;
 3299|      0|    unsigned char c1;
 3300|      0|    unsigned char c2;
 3301|      0|    int tmp___18;
 3302|      0|    unsigned short const **tmp___19;
 3303|      0|    int tmp___21;
 3304|      0|    unsigned short const **tmp___22;
 3305|      0|    size_t tmp___25;
 3306|       |
 3307|      0|    {
 3308|      0|        if ((unsigned long)s1 == (unsigned long)s2) {
 3309|      0|            return (0);
 3310|      0|        }
 3311|      0|        tmp___25 = __ctype_get_mb_cur_max();
 3312|      0|        if (tmp___25 > 1UL) {
 3313|      0|            iter1.cur.ptr = s1;
 3314|      0|            iter1.in_shift = (_Bool)0;
 3315|      0|            memset((void *)(&iter1.state), '\000', sizeof(mbstate_t));
 3316|      0|            iter1.next_done = (_Bool)0;
 3317|      0|            iter2.cur.ptr = s2;
 3318|      0|            iter2.in_shift = (_Bool)0;
 3319|      0|            memset((void *)(&iter2.state), '\000', sizeof(mbstate_t));
 3320|      0|            iter2.next_done = (_Bool)0;
 3321|      0|            while (1) {
 3322|      0|                mbuiter_multi_next(&iter1);
 3323|      0|                if (iter1.cur.wc_valid) {
 3324|      0|                    if (iter1.cur.wc == 0) {
 3325|      0|                        tmp___13 = 0;
 3326|      0|                    }
 3327|      0|                    else {
 3328|      0|                        tmp___13 = 1;
 3329|      0|                    }
 3330|      0|                }
 3331|      0|                else {
 3332|      0|                    tmp___13 = 1;
 3333|      0|                }
 3334|      0|                if (tmp___13) {
 3335|      0|                    mbuiter_multi_next(&iter2);
 3336|      0|                    if (iter2.cur.wc_valid) {
 3337|      0|                        if (iter2.cur.wc == 0) {
 3338|      0|                            tmp___14 = 0;
 3339|      0|                        }
 3340|      0|                        else {
 3341|      0|                            tmp___14 = 1;
 3342|      0|                        }
 3343|      0|                    }
 3344|      0|                    else {
 3345|      0|                        tmp___14 = 1;
 3346|      0|                    }
 3347|      0|                    if (!tmp___14) {
 3348|      0|                        goto while_break;
 3349|      0|                    }
 3350|      0|                }
 3351|      0|                else {
 3352|      0|                    goto while_break;
 3353|      0|                }
 3354|      0|                if (iter1.cur.wc_valid) {
 3355|      0|                    if (iter2.cur.wc_valid) {
 3356|      0|                        tmp = towlower((wint_t)iter1.cur.wc);
 3357|      0|                        tmp___0 = towlower((wint_t)iter2.cur.wc);
 3358|      0|                        tmp___1 = (int)tmp - (int)tmp___0;
 3359|      0|                    }
 3360|      0|                    else {
 3361|      0|                        tmp___1 = -1;
 3362|      0|                    }
 3363|      0|                    tmp___12 = tmp___1;
 3364|      0|                }
 3365|      0|                else {
 3366|      0|                    if (iter2.cur.wc_valid) {
 3367|      0|                        tmp___11 = 1;
 3368|      0|                    }
 3369|      0|                    else {
 3370|      0|                        if (iter1.cur.bytes == iter2.cur.bytes) {
 3371|      0|                            tmp___2 = memcmp((void const *)iter1.cur.ptr,
 3372|      0|                                             (void const *)iter2.cur.ptr, iter1.cur.bytes);
 3373|      0|                            tmp___10 = tmp___2;
 3374|      0|                        }
 3375|      0|                        else {
 3376|      0|                            if (iter1.cur.bytes < iter2.cur.bytes) {
 3377|      0|                                tmp___5 = memcmp((void const *)iter1.cur.ptr,
 3378|      0|                                                 (void const *)iter2.cur.ptr, iter1.cur.bytes);
 3379|      0|                                if (tmp___5 > 0) {
 3380|      0|                                    tmp___4 = 1;
 3381|      0|                                }
 3382|      0|                                else {
 3383|      0|                                    tmp___4 = -1;
 3384|      0|                                }
 3385|      0|                                tmp___9 = tmp___4;
 3386|      0|                            }
 3387|      0|                            else {
 3388|      0|                                tmp___8 = memcmp((void const *)iter1.cur.ptr,
 3389|      0|                                                 (void const *)iter2.cur.ptr, iter2.cur.bytes);
 3390|      0|                                if (tmp___8 >= 0) {
 3391|      0|                                    tmp___7 = 1;
 3392|      0|                                }
 3393|      0|                                else {
 3394|      0|                                    tmp___7 = -1;
 3395|      0|                                }
 3396|      0|                                tmp___9 = tmp___7;
 3397|      0|                            }
 3398|      0|                            tmp___10 = tmp___9;
 3399|      0|                        }
 3400|      0|                        tmp___11 = tmp___10;
 3401|      0|                    }
 3402|      0|                    tmp___12 = tmp___11;
 3403|      0|                }
 3404|      0|                cmp = tmp___12;
 3405|      0|                if (cmp != 0) {
 3406|      0|                    return (cmp);
 3407|      0|                }
 3408|      0|                iter1.cur.ptr += iter1.cur.bytes;
 3409|      0|                iter1.next_done = (_Bool)0;
 3410|      0|                iter2.cur.ptr += iter2.cur.bytes;
 3411|      0|                iter2.next_done = (_Bool)0;
 3412|      0|            }
 3413|      0|while_break:
 3414|      0|            mbuiter_multi_next(&iter1);
 3415|      0|            if (iter1.cur.wc_valid) {
 3416|      0|                if (iter1.cur.wc == 0) {
 3417|      0|                    tmp___15 = 0;
 3418|      0|                }
 3419|      0|                else {
 3420|      0|                    tmp___15 = 1;
 3421|      0|                }
 3422|      0|            }
 3423|      0|            else {
 3424|      0|                tmp___15 = 1;
 3425|      0|            }
 3426|      0|            if (tmp___15) {
 3427|      0|                return (1);
 3428|      0|            }
 3429|      0|            mbuiter_multi_next(&iter2);
 3430|      0|            if (iter2.cur.wc_valid) {
 3431|      0|                if (iter2.cur.wc == 0) {
 3432|      0|                    tmp___16 = 0;
 3433|      0|                }
 3434|      0|                else {
 3435|      0|                    tmp___16 = 1;
 3436|      0|                }
 3437|      0|            }
 3438|      0|            else {
 3439|      0|                tmp___16 = 1;
 3440|      0|            }
 3441|      0|            if (tmp___16) {
 3442|      0|                return (-1);
 3443|      0|            }
 3444|      0|            return (0);
 3445|      0|        }
 3446|      0|        else {
 3447|      0|            p1 = (unsigned char const *)s1;
 3448|      0|            p2 = (unsigned char const *)s2;
 3449|      0|            while (1) {
 3450|      0|                tmp___19 = __ctype_b_loc();
 3451|      0|                if ((int const) * (*tmp___19 + (int)*p1) & 256) {
 3452|      0|                    tmp___18 = tolower((int)*p1);
 3453|      0|                    c1 = (unsigned char)tmp___18;
 3454|      0|                }
 3455|      0|                else {
 3456|      0|                    c1 = (unsigned char)*p1;
 3457|      0|                }
 3458|      0|                tmp___22 = __ctype_b_loc();
 3459|      0|                if ((int const) * (*tmp___22 + (int)*p2) & 256) {
 3460|      0|                    tmp___21 = tolower((int)*p2);
 3461|      0|                    c2 = (unsigned char)tmp___21;
 3462|      0|                }
 3463|      0|                else {
 3464|      0|                    c2 = (unsigned char)*p2;
 3465|      0|                }
 3466|      0|                if ((int)c1 == 0) {
 3467|      0|                    goto while_break___0;
 3468|      0|                }
 3469|      0|                p1++;
 3470|      0|                p2++;
 3471|      0|                if (!((int)c1 == (int)c2)) {
 3472|      0|                    goto while_break___0;
 3473|      0|                }
 3474|      0|            }
 3475|      0|while_break___0:
 3476|      0|            ;
 3477|      0|            return ((int)c1 - (int)c2);
 3478|      0|        }
 3479|      0|    }
 3480|      0|}
 3481|       |unsigned int const is_basic_table[8] = {
 3482|       |    (unsigned int const)6656, (unsigned int const)4294967279U,
 3483|       |    (unsigned int const)4294967294U, (unsigned int const)2147483646
 3484|       |};
 3485|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__))
 3486|       |        exit)(int __status);
 3487|       |extern int optind;
 3488|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) getopt_long)(
 3489|       |    int ___argc, char *const *___argv, char const *__shortopts,
 3490|       |    struct option const *__longopts, int *__longind);
 3491|       |void i_ring_init(I_ring *ir, int default_val);
 3492|       |int i_ring_push(I_ring *ir, int val);
 3493|       |int i_ring_pop(I_ring *ir);
 3494|       |_Bool i_ring_empty(I_ring const *ir);
 3495|       |void i_ring_init(I_ring *ir, int default_val)
 3496|      2|{
 3497|      2|    int i;
 3498|       |
 3499|      2|    {
 3500|      2|        ir->ir_empty = (_Bool)1;
 3501|      2|        ir->ir_front = 0U;
 3502|      2|        ir->ir_back = 0U;
 3503|      2|        i = 0;
 3504|     10|        while (1) {
 3505|       |
 3506|     10|            if (!(i < 4)) {
 3507|      2|                goto while_break;
 3508|      2|            }
 3509|      8|            ir->ir_data[i] = default_val;
 3510|      8|            i++;
 3511|      8|        }
 3512|      2|while_break:
 3513|      2|        ir->ir_default_val = default_val;
 3514|      2|        return;
 3515|      2|    }
 3516|      2|}
 3517|       |_Bool i_ring_empty(I_ring const *ir)
 3518|     32|{
 3519|       |
 3520|     32|    {
 3521|     32|        return ((_Bool)ir->ir_empty);
 3522|     32|    }
 3523|     32|}
 3524|       |int i_ring_push(I_ring *ir, int val)
 3525|     16|{
 3526|     16|    unsigned int dest_idx;
 3527|     16|    int old_val;
 3528|       |
 3529|     16|    {
 3530|     16|        dest_idx = (ir->ir_front + (unsigned int)(!ir->ir_empty)) % 4U;
 3531|     16|        old_val = ir->ir_data[dest_idx];
 3532|     16|        ir->ir_data[dest_idx] = val;
 3533|     16|        ir->ir_front = dest_idx;
 3534|     16|        if (dest_idx == ir->ir_back) {
 3535|     12|            ir->ir_back = (ir->ir_back + (unsigned int)(!ir->ir_empty)) % 4U;
 3536|     12|        }
 3537|     16|        ir->ir_empty = (_Bool)0;
 3538|     16|        return (old_val);
 3539|     16|    }
 3540|     16|}
 3541|       |int i_ring_pop(I_ring *ir)
 3542|     10|{
 3543|     10|    int top_val;
 3544|     10|    _Bool tmp;
 3545|       |
 3546|     10|    {
 3547|     10|        tmp = i_ring_empty((I_ring const *)ir);
 3548|     10|        if (tmp) {
 3549|      0|            abort();
 3550|      0|        }
 3551|     10|        top_val = ir->ir_data[ir->ir_front];
 3552|     10|        ir->ir_data[ir->ir_front] = ir->ir_default_val;
 3553|     10|        if (ir->ir_front == ir->ir_back) {
 3554|      6|            ir->ir_empty = (_Bool)1;
 3555|      6|        }
 3556|      4|        else {
 3557|      4|            ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
 3558|      4|        }
 3559|     10|        return (top_val);
 3560|     10|    }
 3561|     10|}
 3562|       |_Bool(__attribute__((__warn_unused_result__))
 3563|       |      hash_rehash)(Hash_table *table___0, size_t candidate);
 3564|       |void *hash_delete(Hash_table *table___0, void const *entry);
 3565|       |__inline static size_t rotr_sz(size_t x, int n)
 3566|      0|{
 3567|       |
 3568|      0|    {
 3569|      0|        return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long)n))) &
 3570|      0|                0xffffffffffffffffUL);
 3571|      0|    }
 3572|      0|}
 3573|       |static struct hash_tuning const default_tuning = {
 3574|       |    (float)0.0, (float)1.0, (float)0.8, (float)1.414, (_Bool)0
 3575|       |};
 3576|       |void *hash_lookup(Hash_table const *table___0, void const *entry)
 3577|      0|{
 3578|      0|    struct hash_entry const *bucket;
 3579|      0|    size_t tmp;
 3580|      0|    struct hash_entry const *cursor;
 3581|      0|    _Bool tmp___0;
 3582|       |
 3583|      0|    {
 3584|      0|        tmp = (*(table___0->hasher))(entry, (size_t)table___0->n_buckets);
 3585|      0|        bucket = (struct hash_entry const *)(table___0->bucket + tmp);
 3586|      0|        if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3587|      0|            abort();
 3588|      0|        }
 3589|      0|        if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
 3590|      0|            return ((void *)0);
 3591|      0|        }
 3592|      0|        cursor = bucket;
 3593|      0|        while (1) {
 3594|       |
 3595|      0|            if (!cursor) {
 3596|      0|                goto while_break;
 3597|      0|            }
 3598|      0|            if ((unsigned long)entry == (unsigned long)cursor->data) {
 3599|      0|                return ((void *)cursor->data);
 3600|      0|            }
 3601|      0|            else {
 3602|      0|                tmp___0 = (*(table___0->comparator))(entry, (void const *)cursor->data);
 3603|      0|                if (tmp___0) {
 3604|      0|                    return ((void *)cursor->data);
 3605|      0|                }
 3606|      0|            }
 3607|      0|            cursor = (struct hash_entry const *)cursor->next;
 3608|      0|        }
 3609|      0|while_break:
 3610|      0|        ;
 3611|      0|        return ((void *)0);
 3612|      0|    }
 3613|      0|}
 3614|       |size_t hash_string(char const *string, size_t n_buckets)
 3615|      0|{
 3616|      0|    size_t value;
 3617|      0|    unsigned char ch;
 3618|       |
 3619|      0|    {
 3620|      0|        value = (size_t)0;
 3621|      0|        while (1) {
 3622|      0|            ch = (unsigned char)*string;
 3623|      0|            if (!ch) {
 3624|      0|                goto while_break;
 3625|      0|            }
 3626|      0|            value = (value * 31UL + (size_t)ch) % n_buckets;
 3627|      0|            string++;
 3628|      0|        }
 3629|      0|while_break:
 3630|      0|        ;
 3631|      0|        return (value);
 3632|      0|    }
 3633|      0|}
 3634|       |static _Bool is_prime(size_t candidate)
 3635|      0|{
 3636|      0|    size_t divisor;
 3637|      0|    size_t square;
 3638|      0|    int tmp;
 3639|       |
 3640|      0|    {
 3641|      0|        divisor = (size_t)3;
 3642|      0|        square = divisor * divisor;
 3643|      0|        while (1) {
 3644|       |
 3645|      0|            if (square < candidate) {
 3646|      0|                if (!(candidate % divisor)) {
 3647|      0|                    goto while_break;
 3648|      0|                }
 3649|      0|            }
 3650|      0|            else {
 3651|      0|                goto while_break;
 3652|      0|            }
 3653|      0|            divisor++;
 3654|      0|            square += 4UL * divisor;
 3655|      0|            divisor++;
 3656|      0|        }
 3657|      0|while_break:
 3658|      0|        ;
 3659|      0|        if (candidate % divisor) {
 3660|      0|            tmp = 1;
 3661|      0|        }
 3662|      0|        else {
 3663|      0|            tmp = 0;
 3664|      0|        }
 3665|      0|        return ((_Bool)tmp);
 3666|      0|    }
 3667|      0|}
 3668|       |static size_t next_prime(size_t candidate)
 3669|      0|{
 3670|      0|    _Bool tmp;
 3671|       |
 3672|      0|    {
 3673|      0|        if (candidate < 10UL) {
 3674|      0|            candidate = (size_t)10;
 3675|      0|        }
 3676|      0|        candidate |= 1UL;
 3677|      0|        while (1) {
 3678|       |
 3679|      0|            if (0xffffffffffffffffUL != candidate) {
 3680|      0|                tmp = is_prime(candidate);
 3681|      0|                if (tmp) {
 3682|      0|                    goto while_break;
 3683|      0|                }
 3684|      0|            }
 3685|      0|            else {
 3686|      0|                goto while_break;
 3687|      0|            }
 3688|      0|            candidate += 2UL;
 3689|      0|        }
 3690|      0|while_break:
 3691|      0|        ;
 3692|      0|        return (candidate);
 3693|      0|    }
 3694|      0|}
 3695|       |static size_t raw_hasher(void const *data, size_t n)
 3696|      0|{
 3697|      0|    size_t val;
 3698|      0|    size_t tmp;
 3699|       |
 3700|      0|    {
 3701|      0|        tmp = rotr_sz((size_t)data, 3);
 3702|      0|        val = tmp;
 3703|      0|        return (val % n);
 3704|      0|    }
 3705|      0|}
 3706|       |static _Bool raw_comparator(void const *a, void const *b)
 3707|      0|{
 3708|       |
 3709|      0|    {
 3710|      0|        return ((_Bool)((unsigned long)a == (unsigned long)b));
 3711|      0|    }
 3712|      0|}
 3713|       |static _Bool check_tuning(Hash_table *table___0)
 3714|      0|{
 3715|      0|    Hash_tuning const *tuning;
 3716|      0|    float epsilon;
 3717|       |
 3718|      0|    {
 3719|      0|        tuning = table___0->tuning;
 3720|      0|        if ((unsigned long)tuning == (unsigned long)(&default_tuning)) {
 3721|      0|            return ((_Bool)1);
 3722|      0|        }
 3723|      0|        epsilon = 0.1f;
 3724|      0|        if (epsilon < (float)tuning->growth_threshold) {
 3725|      0|            if (tuning->growth_threshold < (float const)((float)1 - epsilon)) {
 3726|      0|                if ((float)1 + epsilon < (float)tuning->growth_factor) {
 3727|      0|                    if ((float const)0 <= tuning->shrink_threshold) {
 3728|      0|                        if (tuning->shrink_threshold + (float const)epsilon <
 3729|      0|                                tuning->shrink_factor) {
 3730|      0|                            if (tuning->shrink_factor <= (float const)1) {
 3731|      0|                                if (tuning->shrink_threshold + (float const)epsilon <
 3732|      0|                                        tuning->growth_threshold) {
 3733|      0|                                    return ((_Bool)1);
 3734|      0|                                }
 3735|      0|                            }
 3736|      0|                        }
 3737|      0|                    }
 3738|      0|                }
 3739|      0|            }
 3740|      0|        }
 3741|      0|        table___0->tuning = &default_tuning;
 3742|      0|        return ((_Bool)0);
 3743|      0|    }
 3744|      0|}
 3745|       |static size_t compute_bucket_size(size_t candidate, Hash_tuning const *tuning)
 3746|      0|{
 3747|      0|    float new_candidate;
 3748|      0|    int tmp;
 3749|       |
 3750|      0|    {
 3751|      0|        if (!tuning->is_n_buckets) {
 3752|      0|            new_candidate =
 3753|      0|                (float)((float const)candidate / tuning->growth_threshold);
 3754|      0|            if ((float)0xffffffffffffffffUL <= new_candidate) {
 3755|      0|                return ((size_t)0);
 3756|      0|            }
 3757|      0|            candidate = (size_t)new_candidate;
 3758|      0|        }
 3759|      0|        candidate = next_prime(candidate);
 3760|      0|        if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 3761|      0|            tmp = -1;
 3762|      0|        }
 3763|      0|        else {
 3764|      0|            tmp = -2;
 3765|      0|        }
 3766|      0|        if ((size_t)tmp / sizeof(struct hash_entry *) < candidate) {
 3767|      0|            return ((size_t)0);
 3768|      0|        }
 3769|      0|        return (candidate);
 3770|      0|    }
 3771|      0|}
 3772|       |Hash_table *(__attribute__((__warn_unused_result__))
 3773|       |             hash_initialize)(size_t candidate, Hash_tuning const *tuning,
 3774|       |                              size_t (*hasher)(void const *, size_t),
 3775|       |                              _Bool (*comparator)(void const *, void const *),
 3776|       |                              void (*data_freer)(void *))
 3777|      0|{
 3778|      0|    Hash_table *table___0;
 3779|      0|    _Bool tmp;
 3780|       |
 3781|      0|    {
 3782|      0|        if ((unsigned long)hasher == (unsigned long)((void *)0)) {
 3783|      0|            hasher = &raw_hasher;
 3784|      0|        }
 3785|      0|        if ((unsigned long)comparator == (unsigned long)((void *)0)) {
 3786|      0|            comparator = &raw_comparator;
 3787|      0|        }
 3788|      0|        table___0 = (Hash_table *)malloc(sizeof(*table___0));
 3789|      0|        if ((unsigned long)table___0 == (unsigned long)((void *)0)) {
 3790|      0|            return ((Hash_table *)((void *)0));
 3791|      0|        }
 3792|      0|        if (!tuning) {
 3793|      0|            tuning = &default_tuning;
 3794|      0|        }
 3795|      0|        table___0->tuning = tuning;
 3796|      0|        tmp = check_tuning(table___0);
 3797|      0|        if (!tmp) {
 3798|      0|            goto fail;
 3799|      0|        }
 3800|      0|        table___0->n_buckets = compute_bucket_size(candidate, tuning);
 3801|      0|        if (!table___0->n_buckets) {
 3802|      0|            goto fail;
 3803|      0|        }
 3804|      0|        table___0->bucket = (struct hash_entry *)calloc(
 3805|      0|                                table___0->n_buckets, sizeof(*(table___0->bucket)));
 3806|      0|        if ((unsigned long)table___0->bucket == (unsigned long)((void *)0)) {
 3807|      0|            goto fail;
 3808|      0|        }
 3809|      0|        table___0->bucket_limit =
 3810|      0|            (struct hash_entry const *)(table___0->bucket + table___0->n_buckets);
 3811|      0|        table___0->n_buckets_used = (size_t)0;
 3812|      0|        table___0->n_entries = (size_t)0;
 3813|      0|        table___0->hasher = hasher;
 3814|      0|        table___0->comparator = comparator;
 3815|      0|        table___0->data_freer = data_freer;
 3816|      0|        table___0->free_entry_list = (struct hash_entry *)((void *)0);
 3817|      0|        return (table___0);
 3818|      0|fail:
 3819|      0|        free((void *)table___0);
 3820|      0|        return ((Hash_table *)((void *)0));
 3821|      0|    }
 3822|      0|}
 3823|       |void hash_free(Hash_table *table___0)
 3824|      0|{
 3825|      0|    struct hash_entry *bucket;
 3826|      0|    struct hash_entry *cursor;
 3827|      0|    struct hash_entry *next;
 3828|       |
 3829|      0|    {
 3830|      0|        if (table___0->data_freer) {
 3831|      0|            if (table___0->n_entries) {
 3832|      0|                bucket = table___0->bucket;
 3833|      0|                while (1) {
 3834|       |
 3835|      0|                    if (!((unsigned long)bucket <
 3836|      0|                            (unsigned long)table___0->bucket_limit)) {
 3837|      0|                        goto while_break;
 3838|      0|                    }
 3839|      0|                    if (bucket->data) {
 3840|      0|                        cursor = bucket;
 3841|      0|                        while (1) {
 3842|       |
 3843|      0|                            if (!cursor) {
 3844|      0|                                goto while_break___0;
 3845|      0|                            }
 3846|      0|                            (*(table___0->data_freer))(cursor->data);
 3847|      0|                            cursor = cursor->next;
 3848|      0|                        }
 3849|      0|while_break___0:
 3850|      0|                        ;
 3851|      0|                    }
 3852|      0|                    bucket++;
 3853|      0|                }
 3854|      0|while_break:
 3855|      0|                ;
 3856|      0|            }
 3857|      0|        }
 3858|      0|        bucket = table___0->bucket;
 3859|      0|        while (1) {
 3860|       |
 3861|      0|            if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3862|      0|                goto while_break___1;
 3863|      0|            }
 3864|      0|            cursor = bucket->next;
 3865|      0|            while (1) {
 3866|       |
 3867|      0|                if (!cursor) {
 3868|      0|                    goto while_break___2;
 3869|      0|                }
 3870|      0|                next = cursor->next;
 3871|      0|                free((void *)cursor);
 3872|      0|                cursor = next;
 3873|      0|            }
 3874|      0|while_break___2:
 3875|      0|            bucket++;
 3876|      0|        }
 3877|      0|while_break___1:
 3878|      0|        cursor = table___0->free_entry_list;
 3879|      0|        while (1) {
 3880|       |
 3881|      0|            if (!cursor) {
 3882|      0|                goto while_break___3;
 3883|      0|            }
 3884|      0|            next = cursor->next;
 3885|      0|            free((void *)cursor);
 3886|      0|            cursor = next;
 3887|      0|        }
 3888|      0|while_break___3:
 3889|      0|        free((void *)table___0->bucket);
 3890|      0|        free((void *)table___0);
 3891|      0|        return;
 3892|      0|    }
 3893|      0|}
 3894|       |static struct hash_entry *allocate_entry(Hash_table *table___0)
 3895|      0|{
 3896|      0|    struct hash_entry *new;
 3897|       |
 3898|      0|    {
 3899|      0|        if (table___0->free_entry_list) {
 3900|      0|            new = table___0->free_entry_list;
 3901|      0|            table___0->free_entry_list = new->next;
 3902|      0|        }
 3903|      0|        else {
 3904|      0|            new = (struct hash_entry *)malloc(sizeof(*new));
 3905|      0|        }
 3906|      0|        return (new);
 3907|      0|    }
 3908|      0|}
 3909|       |static void free_entry(Hash_table *table___0, struct hash_entry *entry)
 3910|      0|{
 3911|       |
 3912|      0|    {
 3913|      0|        entry->data = (void *)0;
 3914|      0|        entry->next = table___0->free_entry_list;
 3915|      0|        table___0->free_entry_list = entry;
 3916|      0|        return;
 3917|      0|    }
 3918|      0|}
 3919|       |static void *hash_find_entry(Hash_table *table___0, void const *entry,
 3920|       |                             struct hash_entry **bucket_head, _Bool delete)
 3921|      0|{
 3922|      0|    struct hash_entry *bucket;
 3923|      0|    size_t tmp;
 3924|      0|    struct hash_entry *cursor;
 3925|      0|    void *data;
 3926|      0|    struct hash_entry *next;
 3927|      0|    _Bool tmp___0;
 3928|      0|    void *data___0;
 3929|      0|    struct hash_entry *next___0;
 3930|      0|    _Bool tmp___1;
 3931|       |
 3932|      0|    {
 3933|      0|        tmp = (*(table___0->hasher))(entry, table___0->n_buckets);
 3934|      0|        bucket = table___0->bucket + tmp;
 3935|      0|        if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3936|      0|            abort();
 3937|      0|        }
 3938|      0|        *bucket_head = bucket;
 3939|      0|        if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
 3940|      0|            return ((void *)0);
 3941|      0|        }
 3942|      0|        if ((unsigned long)entry == (unsigned long)bucket->data) {
 3943|      0|            goto _L;
 3944|      0|        }
 3945|      0|        else {
 3946|      0|            tmp___0 = (*(table___0->comparator))(entry, (void const *)bucket->data);
 3947|      0|            if (tmp___0) {
 3948|      0|_L:
 3949|      0|                data = bucket->data;
 3950|      0|                if (delete) {
 3951|      0|                    if (bucket->next) {
 3952|      0|                        next = bucket->next;
 3953|      0|                        *bucket = *next;
 3954|      0|                        free_entry(table___0, next);
 3955|      0|                    }
 3956|      0|                    else {
 3957|      0|                        bucket->data = (void *)0;
 3958|      0|                    }
 3959|      0|                }
 3960|      0|                return (data);
 3961|      0|            }
 3962|      0|        }
 3963|      0|        cursor = bucket;
 3964|      0|        while (1) {
 3965|       |
 3966|      0|            if (!cursor->next) {
 3967|      0|                goto while_break;
 3968|      0|            }
 3969|      0|            if ((unsigned long)entry == (unsigned long)(cursor->next)->data) {
 3970|      0|                goto _L___0;
 3971|      0|            }
 3972|      0|            else {
 3973|      0|                tmp___1 = (*(table___0->comparator))(
 3974|      0|                              entry, (void const *)(cursor->next)->data);
 3975|      0|                if (tmp___1) {
 3976|      0|_L___0:
 3977|      0|                    data___0 = (cursor->next)->data;
 3978|      0|                    if (delete) {
 3979|      0|                        next___0 = cursor->next;
 3980|      0|                        cursor->next = next___0->next;
 3981|      0|                        free_entry(table___0, next___0);
 3982|      0|                    }
 3983|      0|                    return (data___0);
 3984|      0|                }
 3985|      0|            }
 3986|      0|            cursor = cursor->next;
 3987|      0|        }
 3988|      0|while_break:
 3989|      0|        ;
 3990|      0|        return ((void *)0);
 3991|      0|    }
 3992|      0|}
 3993|       |static _Bool transfer_entries(Hash_table *dst, Hash_table *src, _Bool safe)
 3994|      0|{
 3995|      0|    struct hash_entry *bucket;
 3996|      0|    struct hash_entry *cursor;
 3997|      0|    struct hash_entry *next;
 3998|      0|    void *data;
 3999|      0|    struct hash_entry *new_bucket;
 4000|      0|    size_t tmp;
 4001|      0|    size_t tmp___0;
 4002|      0|    struct hash_entry *new_entry;
 4003|      0|    struct hash_entry *tmp___1;
 4004|       |
 4005|      0|    {
 4006|      0|        bucket = src->bucket;
 4007|      0|        while (1) {
 4008|       |
 4009|      0|            if (!((unsigned long)bucket < (unsigned long)src->bucket_limit)) {
 4010|      0|                goto while_break;
 4011|      0|            }
 4012|      0|            if (bucket->data) {
 4013|      0|                cursor = bucket->next;
 4014|      0|                while (1) {
 4015|       |
 4016|      0|                    if (!cursor) {
 4017|      0|                        goto while_break___0;
 4018|      0|                    }
 4019|      0|                    data = cursor->data;
 4020|      0|                    tmp = (*(dst->hasher))((void const *)data, dst->n_buckets);
 4021|      0|                    new_bucket = dst->bucket + tmp;
 4022|      0|                    if (!((unsigned long)new_bucket < (unsigned long)dst->bucket_limit)) {
 4023|      0|                        abort();
 4024|      0|                    }
 4025|      0|                    next = cursor->next;
 4026|      0|                    if (new_bucket->data) {
 4027|      0|                        cursor->next = new_bucket->next;
 4028|      0|                        new_bucket->next = cursor;
 4029|      0|                    }
 4030|      0|                    else {
 4031|      0|                        new_bucket->data = data;
 4032|      0|                        (dst->n_buckets_used)++;
 4033|      0|                        free_entry(dst, cursor);
 4034|      0|                    }
 4035|      0|                    cursor = next;
 4036|      0|                }
 4037|      0|while_break___0:
 4038|      0|                data = bucket->data;
 4039|      0|                bucket->next = (struct hash_entry *)((void *)0);
 4040|      0|                if (safe) {
 4041|      0|                    goto __Cont;
 4042|      0|                }
 4043|      0|                tmp___0 = (*(dst->hasher))((void const *)data, dst->n_buckets);
 4044|      0|                new_bucket = dst->bucket + tmp___0;
 4045|      0|                if (!((unsigned long)new_bucket < (unsigned long)dst->bucket_limit)) {
 4046|      0|                    abort();
 4047|      0|                }
 4048|      0|                if (new_bucket->data) {
 4049|      0|                    tmp___1 = allocate_entry(dst);
 4050|      0|                    new_entry = tmp___1;
 4051|      0|                    if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 4052|      0|                        return ((_Bool)0);
 4053|      0|                    }
 4054|      0|                    new_entry->data = data;
 4055|      0|                    new_entry->next = new_bucket->next;
 4056|      0|                    new_bucket->next = new_entry;
 4057|      0|                }
 4058|      0|                else {
 4059|      0|                    new_bucket->data = data;
 4060|      0|                    (dst->n_buckets_used)++;
 4061|      0|                }
 4062|      0|                bucket->data = (void *)0;
 4063|      0|                (src->n_buckets_used)--;
 4064|      0|            }
 4065|      0|__Cont:
 4066|      0|            bucket++;
 4067|      0|        }
 4068|      0|while_break:
 4069|      0|        ;
 4070|      0|        return ((_Bool)1);
 4071|      0|    }
 4072|      0|}
 4073|       |_Bool(__attribute__((__warn_unused_result__))
 4074|       |      hash_rehash)(Hash_table *table___0, size_t candidate)
 4075|      0|{
 4076|      0|    Hash_table storage;
 4077|      0|    Hash_table *new_table;
 4078|      0|    size_t new_size;
 4079|      0|    size_t tmp;
 4080|      0|    _Bool tmp___0;
 4081|      0|    _Bool tmp___1;
 4082|      0|    _Bool tmp___2;
 4083|       |
 4084|      0|    {
 4085|      0|        tmp = compute_bucket_size(candidate, table___0->tuning);
 4086|      0|        new_size = tmp;
 4087|      0|        if (!new_size) {
 4088|      0|            return ((_Bool)0);
 4089|      0|        }
 4090|      0|        if (new_size == table___0->n_buckets) {
 4091|      0|            return ((_Bool)1);
 4092|      0|        }
 4093|      0|        new_table = &storage;
 4094|      0|        new_table->bucket =
 4095|      0|            (struct hash_entry *)calloc(new_size, sizeof(*(new_table->bucket)));
 4096|      0|        if ((unsigned long)new_table->bucket == (unsigned long)((void *)0)) {
 4097|      0|            return ((_Bool)0);
 4098|      0|        }
 4099|      0|        new_table->n_buckets = new_size;
 4100|      0|        new_table->bucket_limit =
 4101|      0|            (struct hash_entry const *)(new_table->bucket + new_size);
 4102|      0|        new_table->n_buckets_used = (size_t)0;
 4103|      0|        new_table->n_entries = (size_t)0;
 4104|      0|        new_table->tuning = table___0->tuning;
 4105|      0|        new_table->hasher = table___0->hasher;
 4106|      0|        new_table->comparator = table___0->comparator;
 4107|      0|        new_table->data_freer = table___0->data_freer;
 4108|      0|        new_table->free_entry_list = table___0->free_entry_list;
 4109|      0|        tmp___0 = transfer_entries(new_table, table___0, (_Bool)0);
 4110|      0|        if (tmp___0) {
 4111|      0|            free((void *)table___0->bucket);
 4112|      0|            table___0->bucket = new_table->bucket;
 4113|      0|            table___0->bucket_limit = new_table->bucket_limit;
 4114|      0|            table___0->n_buckets = new_table->n_buckets;
 4115|      0|            table___0->n_buckets_used = new_table->n_buckets_used;
 4116|      0|            table___0->free_entry_list = new_table->free_entry_list;
 4117|      0|            return ((_Bool)1);
 4118|      0|        }
 4119|      0|        table___0->free_entry_list = new_table->free_entry_list;
 4120|      0|        tmp___1 = transfer_entries(table___0, new_table, (_Bool)1);
 4121|      0|        if (tmp___1) {
 4122|      0|            tmp___2 = transfer_entries(table___0, new_table, (_Bool)0);
 4123|      0|            if (!tmp___2) {
 4124|      0|                abort();
 4125|      0|            }
 4126|      0|        }
 4127|      0|        else {
 4128|      0|            abort();
 4129|      0|        }
 4130|      0|        free((void *)new_table->bucket);
 4131|      0|        return ((_Bool)0);
 4132|      0|    }
 4133|      0|}
 4134|       |void *(__attribute__((__warn_unused_result__))
 4135|       |       hash_insert)(Hash_table *table___0, void const *entry)
 4136|      0|{
 4137|      0|    void *data;
 4138|      0|    struct hash_entry *bucket;
 4139|      0|    Hash_tuning const *tuning;
 4140|      0|    float candidate;
 4141|      0|    float tmp;
 4142|      0|    _Bool tmp___0;
 4143|      0|    void *tmp___1;
 4144|      0|    struct hash_entry *new_entry;
 4145|      0|    struct hash_entry *tmp___2;
 4146|       |
 4147|      0|    {
 4148|      0|        if (!entry) {
 4149|      0|            abort();
 4150|      0|        }
 4151|      0|        data = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 4152|      0|        if ((unsigned long)data != (unsigned long)((void *)0)) {
 4153|      0|            return (data);
 4154|      0|        }
 4155|      0|        if ((float const)table___0->n_buckets_used >
 4156|      0|                (table___0->tuning)->growth_threshold *
 4157|      0|                (float const)table___0->n_buckets) {
 4158|      0|            check_tuning(table___0);
 4159|      0|            if ((float const)table___0->n_buckets_used >
 4160|      0|                    (table___0->tuning)->growth_threshold *
 4161|      0|                    (float const)table___0->n_buckets) {
 4162|      0|                tuning = table___0->tuning;
 4163|      0|                if (tuning->is_n_buckets) {
 4164|      0|                    tmp = (float)((float const)table___0->n_buckets *
 4165|      0|                                  tuning->growth_factor);
 4166|      0|                }
 4167|      0|                else {
 4168|      0|                    tmp = (float)(((float const)table___0->n_buckets *
 4169|      0|                                   tuning->growth_factor) *
 4170|      0|                                  tuning->growth_threshold);
 4171|      0|                }
 4172|      0|                candidate = tmp;
 4173|      0|                if ((float)0xffffffffffffffffUL <= candidate) {
 4174|      0|                    return ((void *)0);
 4175|      0|                }
 4176|      0|                tmp___0 = hash_rehash(table___0, (size_t)candidate);
 4177|      0|                if (!tmp___0) {
 4178|      0|                    return ((void *)0);
 4179|      0|                }
 4180|      0|                tmp___1 = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 4181|      0|                if ((unsigned long)tmp___1 != (unsigned long)((void *)0)) {
 4182|      0|                    abort();
 4183|      0|                }
 4184|      0|            }
 4185|      0|        }
 4186|      0|        if (bucket->data) {
 4187|      0|            tmp___2 = allocate_entry(table___0);
 4188|      0|            new_entry = tmp___2;
 4189|      0|            if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 4190|      0|                return ((void *)0);
 4191|      0|            }
 4192|      0|            new_entry->data = (void *)entry;
 4193|      0|            new_entry->next = bucket->next;
 4194|      0|            bucket->next = new_entry;
 4195|      0|            (table___0->n_entries)++;
 4196|      0|            return ((void *)entry);
 4197|      0|        }
 4198|      0|        bucket->data = (void *)entry;
 4199|      0|        (table___0->n_entries)++;
 4200|      0|        (table___0->n_buckets_used)++;
 4201|      0|        return ((void *)entry);
 4202|      0|    }
 4203|      0|}
 4204|       |void *hash_delete(Hash_table *table___0, void const *entry)
 4205|      0|{
 4206|      0|    void *data;
 4207|      0|    struct hash_entry *bucket;
 4208|      0|    Hash_tuning const *tuning;
 4209|      0|    size_t candidate;
 4210|      0|    float tmp;
 4211|      0|    struct hash_entry *cursor;
 4212|      0|    struct hash_entry *next;
 4213|      0|    _Bool tmp___0;
 4214|       |
 4215|      0|    {
 4216|      0|        data = hash_find_entry(table___0, entry, &bucket, (_Bool)1);
 4217|      0|        if (!data) {
 4218|      0|            return ((void *)0);
 4219|      0|        }
 4220|      0|        (table___0->n_entries)--;
 4221|      0|        if (!bucket->data) {
 4222|      0|            (table___0->n_buckets_used)--;
 4223|      0|            if ((float const)table___0->n_buckets_used <
 4224|      0|                    (table___0->tuning)->shrink_threshold *
 4225|      0|                    (float const)table___0->n_buckets) {
 4226|      0|                check_tuning(table___0);
 4227|      0|                if ((float const)table___0->n_buckets_used <
 4228|      0|                        (table___0->tuning)->shrink_threshold *
 4229|      0|                        (float const)table___0->n_buckets) {
 4230|      0|                    tuning = table___0->tuning;
 4231|      0|                    if (tuning->is_n_buckets) {
 4232|      0|                        tmp = (float)((float const)table___0->n_buckets *
 4233|      0|                                      tuning->shrink_factor);
 4234|      0|                    }
 4235|      0|                    else {
 4236|      0|                        tmp = (float)(((float const)table___0->n_buckets *
 4237|      0|                                       tuning->shrink_factor) *
 4238|      0|                                      tuning->growth_threshold);
 4239|      0|                    }
 4240|      0|                    candidate = (size_t)tmp;
 4241|      0|                    tmp___0 = hash_rehash(table___0, candidate);
 4242|      0|                    if (!tmp___0) {
 4243|      0|                        cursor = table___0->free_entry_list;
 4244|      0|                        while (1) {
 4245|       |
 4246|      0|                            if (!cursor) {
 4247|      0|                                goto while_break;
 4248|      0|                            }
 4249|      0|                            next = cursor->next;
 4250|      0|                            free((void *)cursor);
 4251|      0|                            cursor = next;
 4252|      0|                        }
 4253|      0|while_break:
 4254|      0|                        table___0->free_entry_list = (struct hash_entry *)((void *)0);
 4255|      0|                    }
 4256|      0|                }
 4257|      0|            }
 4258|      0|        }
 4259|      0|        return (data);
 4260|      0|    }
 4261|      0|}
 4262|       |size_t hash_pjw(void const *x, size_t tablesize);
 4263|       |size_t triple_hash(void const *x, size_t table_size)
 4264|      0|{
 4265|      0|    struct F_triple const *p;
 4266|      0|    size_t tmp;
 4267|      0|    size_t tmp___0;
 4268|       |
 4269|      0|    {
 4270|      0|        p = (struct F_triple const *)x;
 4271|      0|        tmp___0 = hash_pjw((void const *)p->name, table_size);
 4272|      0|        tmp = tmp___0;
 4273|      0|        return ((tmp ^ (unsigned long)p->st_ino) % table_size);
 4274|      0|    }
 4275|      0|}
 4276|       |_Bool triple_compare_ino_str(void const *x, void const *y)
 4277|      0|{
 4278|      0|    struct F_triple const *a;
 4279|      0|    struct F_triple const *b;
 4280|      0|    int tmp___0;
 4281|      0|    int tmp___1;
 4282|       |
 4283|      0|    {
 4284|      0|        a = (struct F_triple const *)x;
 4285|      0|        b = (struct F_triple const *)y;
 4286|      0|        if (a->st_ino == b->st_ino) {
 4287|      0|            if (a->st_dev == b->st_dev) {
 4288|      0|                tmp___1 = strcmp((char const *)a->name, (char const *)b->name);
 4289|      0|                if (tmp___1 == 0) {
 4290|      0|                    tmp___0 = 1;
 4291|      0|                }
 4292|      0|                else {
 4293|      0|                    tmp___0 = 0;
 4294|      0|                }
 4295|      0|            }
 4296|      0|            else {
 4297|      0|                tmp___0 = 0;
 4298|      0|            }
 4299|      0|        }
 4300|      0|        else {
 4301|      0|            tmp___0 = 0;
 4302|      0|        }
 4303|      0|        return ((_Bool)tmp___0);
 4304|      0|    }
 4305|      0|}
 4306|       |void triple_free(void *x)
 4307|      0|{
 4308|      0|    struct F_triple *a;
 4309|       |
 4310|      0|    {
 4311|      0|        a = (struct F_triple *)x;
 4312|      0|        free((void *)a->name);
 4313|      0|        free((void *)a);
 4314|      0|        return;
 4315|      0|    }
 4316|      0|}
 4317|       |size_t hash_pjw(void const *x, size_t tablesize)
 4318|      0|{
 4319|      0|    char const *s;
 4320|      0|    size_t h;
 4321|       |
 4322|      0|    {
 4323|      0|        h = (size_t)0;
 4324|      0|        s = (char const *)x;
 4325|      0|        while (1) {
 4326|       |
 4327|      0|            if (!*s) {
 4328|      0|                goto while_break;
 4329|      0|            }
 4330|      0|            h = (unsigned long)*s + ((h << 9) | (h >> (sizeof(size_t) * 8UL - 9UL)));
 4331|      0|            s++;
 4332|      0|        }
 4333|      0|while_break:
 4334|      0|        ;
 4335|      0|        return (h % tablesize);
 4336|      0|    }
 4337|      0|}
 4338|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
 4339|       |        setlocale)(int __category,
 4340|       |                   char const *__locale);
 4341|       |extern __attribute__((__nothrow__)) int(
 4342|       |    __attribute__((__nonnull__(2, 3), __leaf__))
 4343|       |    fstatat)(int __fd, char const *__restrict __file,
 4344|       |             struct stat *__restrict __buf, int __flag);
 4345|       |__attribute__((__nothrow__)) int(__attribute__((__warn_unused_result__,
 4346|       |                                 __leaf__)) fts_close)(FTS *sp);
 4347|       |__attribute__((__nothrow__))
 4348|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp);
 4349|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__))
 4350|       |                                 fts_set)(FTS *sp __attribute__((__unused__)),
 4351|       |                                         FTSENT *p, int instr);
 4352|       |extern void(__attribute__((__nonnull__(1, 4)))
 4353|       |            qsort)(void *__base, size_t __nmemb, size_t __size,
 4354|       |                   int (*__compar)(void const *, void const *));
 4355|       |static FTSENT *fts_alloc(FTS *sp, char const *name, size_t namelen);
 4356|       |static FTSENT *fts_build(FTS *sp, int type);
 4357|       |static void fts_lfree(FTSENT *head);
 4358|       |static void fts_load(FTS *sp, FTSENT *p);
 4359|       |static size_t fts_maxarglen(char *const *argv);
 4360|       |static void fts_padjust(FTS *sp, FTSENT *head);
 4361|       |static _Bool fts_palloc(FTS *sp, size_t more);
 4362|       |static FTSENT *fts_sort(FTS *sp, FTSENT *head, size_t nitems);
 4363|       |static unsigned short fts_stat(FTS *sp, FTSENT *p, _Bool follow);
 4364|       |static int fts_safe_changedir(FTS *sp, FTSENT *p, int fd, char const *dir);
 4365|       |static _Bool AD_compare(void const *x, void const *y)
 4366|      0|{
 4367|      0|    struct Active_dir const *ax;
 4368|      0|    struct Active_dir const *ay;
 4369|      0|    int tmp;
 4370|       |
 4371|      0|    {
 4372|      0|        ax = (struct Active_dir const *)x;
 4373|      0|        ay = (struct Active_dir const *)y;
 4374|      0|        if (ax->ino == ay->ino) {
 4375|      0|            if (ax->dev == ay->dev) {
 4376|      0|                tmp = 1;
 4377|      0|            }
 4378|      0|            else {
 4379|      0|                tmp = 0;
 4380|      0|            }
 4381|      0|        }
 4382|      0|        else {
 4383|      0|            tmp = 0;
 4384|      0|        }
 4385|      0|        return ((_Bool)tmp);
 4386|      0|    }
 4387|      0|}
 4388|       |static size_t AD_hash(void const *x, size_t table_size)
 4389|      0|{
 4390|      0|    struct Active_dir const *ax;
 4391|       |
 4392|      0|    {
 4393|      0|        ax = (struct Active_dir const *)x;
 4394|      0|        return ((uintmax_t)ax->ino % table_size);
 4395|      0|    }
 4396|      0|}
 4397|       |static _Bool setup_dir(FTS *fts)
 4398|      6|{
 4399|       |
 4400|      6|    {
 4401|      6|        if (fts->fts_options & 258) {
 4402|      0|            fts->fts_cycle.ht =
 4403|      0|                hash_initialize((size_t)31, (Hash_tuning const *)((void *)0),
 4404|      0|                                &AD_hash, &AD_compare, (void (*)(void *))(&free));
 4405|      0|            if (!fts->fts_cycle.ht) {
 4406|      0|                return ((_Bool)0);
 4407|      0|            }
 4408|      0|        }
 4409|      6|        else {
 4410|      6|            fts->fts_cycle.state =
 4411|      6|                (struct cycle_check_state *)malloc(sizeof(*(fts->fts_cycle.state)));
 4412|      6|            if (!fts->fts_cycle.state) {
 4413|      0|                return ((_Bool)0);
 4414|      0|            }
 4415|      6|            cycle_check_init(fts->fts_cycle.state);
 4416|      6|        }
 4417|      6|        return ((_Bool)1);
 4418|      6|    }
 4419|      6|}
 4420|       |static _Bool enter_dir(FTS *fts, FTSENT *ent)
 4421|     10|{
 4422|     10|    struct stat const *st;
 4423|     10|    struct Active_dir *ad;
 4424|     10|    struct Active_dir *tmp;
 4425|     10|    struct Active_dir *ad_from_table;
 4426|     10|    _Bool tmp___0;
 4427|       |
 4428|     10|    {
 4429|     10|        if (fts->fts_options & 258) {
 4430|      0|            st = (struct stat const *)(ent->fts_statp);
 4431|      0|            tmp = (struct Active_dir *)malloc(sizeof(*ad));
 4432|      0|            ad = tmp;
 4433|      0|            if (!ad) {
 4434|      0|                return ((_Bool)0);
 4435|      0|            }
 4436|      0|            ad->dev = (dev_t)st->st_dev;
 4437|      0|            ad->ino = (ino_t)st->st_ino;
 4438|      0|            ad->fts_ent = ent;
 4439|      0|            ad_from_table =
 4440|      0|                (struct Active_dir *)hash_insert(fts->fts_cycle.ht, (void const *)ad);
 4441|      0|            if ((unsigned long)ad_from_table != (unsigned long)ad) {
 4442|      0|                free((void *)ad);
 4443|      0|                if (!ad_from_table) {
 4444|      0|                    return ((_Bool)0);
 4445|      0|                }
 4446|      0|                ent->fts_cycle = ad_from_table->fts_ent;
 4447|      0|                ent->fts_info = (unsigned short)2;
 4448|      0|            }
 4449|      0|        }
 4450|     10|        else {
 4451|     10|            tmp___0 = cycle_check(fts->fts_cycle.state,
 4452|     10|                                  (struct stat const *)(ent->fts_statp));
 4453|     10|            if (tmp___0) {
 4454|      0|                ent->fts_cycle = ent;
 4455|      0|                ent->fts_info = (unsigned short)2;
 4456|      0|            }
 4457|     10|        }
 4458|     10|        return ((_Bool)1);
 4459|     10|    }
 4460|     10|}
 4461|       |static void leave_dir(FTS *fts, FTSENT *ent)
 4462|     10|{
 4463|     10|    struct stat const *st;
 4464|     10|    struct Active_dir obj;
 4465|     10|    void *found;
 4466|     10|    FTSENT *parent;
 4467|       |
 4468|     10|    {
 4469|     10|        st = (struct stat const *)(ent->fts_statp);
 4470|     10|        if (fts->fts_options & 258) {
 4471|      0|            obj.dev = (dev_t)st->st_dev;
 4472|      0|            obj.ino = (ino_t)st->st_ino;
 4473|      0|            found = hash_delete(fts->fts_cycle.ht, (void const *)(&obj));
 4474|      0|            if (!found) {
 4475|      0|                abort();
 4476|      0|            }
 4477|      0|            free(found);
 4478|      0|        }
 4479|     10|        else {
 4480|     10|            parent = ent->fts_parent;
 4481|     10|            if ((unsigned long)parent != (unsigned long)((void *)0)) {
 4482|     10|                if (0L <= parent->fts_level) {
 4483|      8|                    while (1) {
 4484|       |
 4485|      8|                        if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
 4486|      0|                            abort();
 4487|      0|                        }
 4488|      8|                        if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t)st->st_ino) {
 4489|      7|                            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t)st->st_dev) {
 4490|      7|                                (fts->fts_cycle.state)->dev_ino.st_dev =
 4491|      7|                                    parent->fts_statp[0].st_dev;
 4492|      7|                                (fts->fts_cycle.state)->dev_ino.st_ino =
 4493|      7|                                    parent->fts_statp[0].st_ino;
 4494|      7|                            }
 4495|      7|                        }
 4496|      8|                        goto while_break;
 4497|      8|                    }
 4498|      8|while_break:
 4499|      8|                    ;
 4500|      8|                }
 4501|     10|            }
 4502|     10|        }
 4503|     10|        return;
 4504|     10|    }
 4505|     10|}
 4506|       |static void free_dir(FTS *sp)
 4507|      6|{
 4508|       |
 4509|      6|    {
 4510|      6|        if (sp->fts_options & 258) {
 4511|      0|            if (sp->fts_cycle.ht) {
 4512|      0|                hash_free(sp->fts_cycle.ht);
 4513|      0|            }
 4514|      0|        }
 4515|      6|        else {
 4516|      6|            free((void *)sp->fts_cycle.state);
 4517|      6|        }
 4518|      6|        return;
 4519|      6|    }
 4520|      6|}
 4521|       |static void fd_ring_clear(I_ring *fd_ring)
 4522|      8|{
 4523|      8|    int fd;
 4524|      8|    int tmp;
 4525|      8|    _Bool tmp___0;
 4526|       |
 4527|      8|    {
 4528|     14|        while (1) {
 4529|     14|            tmp___0 = i_ring_empty((I_ring const *)fd_ring);
 4530|     14|            if (tmp___0) {
 4531|      8|                goto while_break;
 4532|      8|            }
 4533|      6|            tmp = i_ring_pop(fd_ring);
 4534|      6|            fd = tmp;
 4535|      6|            if (0 <= fd) {
 4536|      2|                close(fd);
 4537|      2|            }
 4538|      6|        }
 4539|      8|while_break:
 4540|      8|        ;
 4541|      8|        return;
 4542|      8|    }
 4543|      8|}
 4544|       |static void fts_set_stat_required(FTSENT *p, _Bool required)
 4545|     14|{
 4546|       |
 4547|     14|    {
 4548|     14|        while (1) {
 4549|       |
 4550|     14|            if (!((int)p->fts_info == 11)) {
 4551|      0|                abort();
 4552|      0|            }
 4553|     14|            goto while_break;
 4554|     14|        }
 4555|     14|while_break:
 4556|     14|        ;
 4557|     14|        if (required) {
 4558|     10|            p->fts_statp[0].st_size = (__off_t)2;
 4559|     10|        }
 4560|      4|        else {
 4561|      4|            p->fts_statp[0].st_size = (__off_t)1;
 4562|      4|        }
 4563|     14|        return;
 4564|     14|    }
 4565|     14|}
 4566|       |__inline static DIR *opendirat(int fd, char const *dir)
 4567|     10|{
 4568|     10|    int new_fd;
 4569|     10|    int tmp;
 4570|     10|    DIR *dirp;
 4571|     10|    int saved_errno;
 4572|     10|    int *tmp___0;
 4573|     10|    int *tmp___1;
 4574|       |
 4575|     10|    {
 4576|     10|        tmp = openat_safer(fd, dir, 67840);
 4577|     10|        new_fd = tmp;
 4578|     10|        if (new_fd < 0) {
 4579|      0|            return ((DIR *)((void *)0));
 4580|      0|        }
 4581|     10|        set_cloexec_flag(new_fd, (_Bool)1);
 4582|     10|        dirp = fdopendir(new_fd);
 4583|     10|        if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 4584|      0|            tmp___0 = __errno_location();
 4585|      0|            saved_errno = *tmp___0;
 4586|      0|            close(new_fd);
 4587|      0|            tmp___1 = __errno_location();
 4588|      0|            *tmp___1 = saved_errno;
 4589|      0|        }
 4590|     10|        return (dirp);
 4591|     10|    }
 4592|     10|}
 4593|       |static void cwd_advance_fd(FTS *sp, int fd, _Bool chdir_down_one)
 4594|     24|{
 4595|     24|    int old;
 4596|     24|    int prev_fd_in_slot;
 4597|     24|    int tmp;
 4598|       |
 4599|     24|    {
 4600|     24|        old = sp->fts_cwd_fd;
 4601|     24|        while (1) {
 4602|       |
 4603|     24|            if (!(old != fd)) {
 4604|      4|                if (!(old == -100)) {
 4605|      0|                    abort();
 4606|      0|                }
 4607|      4|            }
 4608|     24|            goto while_break;
 4609|     24|        }
 4610|     24|while_break:
 4611|     24|        ;
 4612|     24|        if (chdir_down_one) {
 4613|     16|            tmp = i_ring_push(&sp->fts_fd_ring, old);
 4614|     16|            prev_fd_in_slot = tmp;
 4615|     16|            if (0 <= prev_fd_in_slot) {
 4616|      4|                close(prev_fd_in_slot);
 4617|      4|            }
 4618|     16|        }
 4619|      8|        else {
 4620|      8|            if (!(sp->fts_options & 4)) {
 4621|      8|                if (0 <= old) {
 4622|      8|                    close(old);
 4623|      8|                }
 4624|      8|            }
 4625|      8|        }
 4626|     24|        sp->fts_cwd_fd = fd;
 4627|     24|        return;
 4628|     24|    }
 4629|     24|}
 4630|       |__inline static int diropen(FTS const *sp, char const *dir)
 4631|      4|{
 4632|      4|    int open_flags;
 4633|      4|    int tmp;
 4634|      4|    int fd;
 4635|      4|    int tmp___0;
 4636|      4|    int tmp___1;
 4637|      4|    int tmp___2;
 4638|       |
 4639|      4|    {
 4640|      4|        if (sp->fts_options & 16) {
 4641|      4|            tmp = 131072;
 4642|      4|        }
 4643|      0|        else {
 4644|      0|            tmp = 0;
 4645|      0|        }
 4646|      4|        open_flags = 67840 | tmp;
 4647|      4|        if (sp->fts_options & 512) {
 4648|      4|            tmp___0 = openat_safer((int)sp->fts_cwd_fd, dir, open_flags);
 4649|      4|            tmp___2 = tmp___0;
 4650|      4|        }
 4651|      0|        else {
 4652|      0|            tmp___1 = open_safer(dir, open_flags);
 4653|      0|            tmp___2 = tmp___1;
 4654|      0|        }
 4655|      4|        fd = tmp___2;
 4656|      4|        if (0 <= fd) {
 4657|      4|            set_cloexec_flag(fd, (_Bool)1);
 4658|      4|        }
 4659|      4|        return (fd);
 4660|      4|    }
 4661|      4|}
 4662|       |__attribute__((__nothrow__))
 4663|       |FTS *(__attribute__((__warn_unused_result__, __leaf__))
 4664|       |      fts_open)(char *const *argv, int options,
 4665|       |                int (*compar)(FTSENT const **, FTSENT const **));
 4666|       |FTS *(__attribute__((__warn_unused_result__, __leaf__))
 4667|       |      fts_open)(char *const *argv, int options,
 4668|       |                int (*compar)(FTSENT const **, FTSENT const **))
 4669|      2|{
 4670|      2|    register FTS *sp;
 4671|      2|    register FTSENT *p;
 4672|      2|    register FTSENT *root;
 4673|      2|    register size_t nitems;
 4674|      2|    FTSENT *parent;
 4675|      2|    FTSENT *tmp;
 4676|      2|    _Bool defer_stat;
 4677|      2|    int *tmp___0;
 4678|      2|    int *tmp___1;
 4679|      2|    int *tmp___2;
 4680|      2|    size_t maxarglen;
 4681|      2|    size_t tmp___4;
 4682|      2|    size_t tmp___5;
 4683|      2|    _Bool tmp___6;
 4684|      2|    int tmp___7;
 4685|      2|    size_t len;
 4686|      2|    size_t tmp___8;
 4687|      2|    struct _ftsent *tmp___9;
 4688|      2|    _Bool tmp___10;
 4689|      2|    int tmp___11;
 4690|       |
 4691|      2|    {
 4692|      2|        parent = (FTSENT *)((void *)0);
 4693|      2|        tmp = (FTSENT *)((void *)0);
 4694|      2|        if (options & -2048) {
 4695|      0|            tmp___0 = __errno_location();
 4696|      0|            *tmp___0 = 22;
 4697|      0|            return ((FTS *)((void *)0));
 4698|      0|        }
 4699|      2|        if (options & 4) {
 4700|      0|            if (options & 512) {
 4701|      0|                tmp___1 = __errno_location();
 4702|      0|                *tmp___1 = 22;
 4703|      0|                return ((FTS *)((void *)0));
 4704|      0|            }
 4705|      0|        }
 4706|      2|        if (!(options & 18)) {
 4707|      0|            tmp___2 = __errno_location();
 4708|      0|            *tmp___2 = 22;
 4709|      0|            return ((FTS *)((void *)0));
 4710|      0|        }
 4711|      2|        sp = (FTS *)malloc(sizeof(FTS));
 4712|      2|        if ((unsigned long)sp == (unsigned long)((void *)0)) {
 4713|      0|            return ((FTS *)((void *)0));
 4714|      0|        }
 4715|      2|        memset((void *)sp, 0, sizeof(FTS));
 4716|      2|        sp->fts_compar = compar;
 4717|      2|        sp->fts_options = options;
 4718|      2|        if (sp->fts_options & 2) {
 4719|      0|            sp->fts_options |= 4;
 4720|      0|            sp->fts_options &= -513;
 4721|      0|        }
 4722|      2|        sp->fts_cwd_fd = -100;
 4723|      2|        tmp___4 = fts_maxarglen(argv);
 4724|      2|        maxarglen = tmp___4;
 4725|      2|        if (maxarglen > 4096UL) {
 4726|      0|            tmp___5 = maxarglen;
 4727|      0|        }
 4728|      2|        else {
 4729|      2|            tmp___5 = (size_t)4096;
 4730|      2|        }
 4731|      2|        tmp___6 = fts_palloc(sp, tmp___5);
 4732|      2|        if (!tmp___6) {
 4733|      0|            goto mem1;
 4734|      0|        }
 4735|      2|        if ((unsigned long)*argv != (unsigned long)((void *)0)) {
 4736|      2|            parent = fts_alloc(sp, "", (size_t)0);
 4737|      2|            if ((unsigned long)parent == (unsigned long)((void *)0)) {
 4738|      0|                goto mem2;
 4739|      0|            }
 4740|      2|            parent->fts_level = (ptrdiff_t)-1;
 4741|      2|        }
 4742|      2|        if ((unsigned long)compar == (unsigned long)((void *)0)) {
 4743|      2|            tmp___7 = 1;
 4744|      2|        }
 4745|      0|        else {
 4746|      0|            if (sp->fts_options & 1024) {
 4747|      0|                tmp___7 = 1;
 4748|      0|            }
 4749|      0|            else {
 4750|      0|                tmp___7 = 0;
 4751|      0|            }
 4752|      0|        }
 4753|      2|        defer_stat = (_Bool)tmp___7;
 4754|      2|        root = (FTSENT *)((void *)0);
 4755|      2|        nitems = (size_t)0;
 4756|      6|        while (1) {
 4757|       |
 4758|      6|            if (!((unsigned long)*argv != (unsigned long)((void *)0))) {
 4759|      2|                goto while_break;
 4760|      2|            }
 4761|      4|            tmp___8 = strlen((char const *)*argv);
 4762|      4|            len = tmp___8;
 4763|      4|            p = fts_alloc(sp, (char const *)*argv, len);
 4764|      4|            if ((unsigned long)p == (unsigned long)((void *)0)) {
 4765|      0|                goto mem3;
 4766|      0|            }
 4767|      4|            p->fts_level = (ptrdiff_t)0;
 4768|      4|            p->fts_parent = parent;
 4769|      4|            p->fts_accpath = p->fts_name;
 4770|      4|            if (defer_stat) {
 4771|      4|                if ((unsigned long)root != (unsigned long)((void *)0)) {
 4772|      2|                    p->fts_info = (unsigned short)11;
 4773|      2|                    fts_set_stat_required(p, (_Bool)1);
 4774|      2|                }
 4775|      2|                else {
 4776|      2|                    p->fts_info = fts_stat(sp, p, (_Bool)0);
 4777|      2|                }
 4778|      4|            }
 4779|      0|            else {
 4780|      0|                p->fts_info = fts_stat(sp, p, (_Bool)0);
 4781|      0|            }
 4782|      4|            if (compar) {
 4783|      0|                p->fts_link = root;
 4784|      0|                root = p;
 4785|      0|            }
 4786|      4|            else {
 4787|      4|                p->fts_link = (struct _ftsent *)((void *)0);
 4788|      4|                if ((unsigned long)root == (unsigned long)((void *)0)) {
 4789|      2|                    root = p;
 4790|      2|                    tmp = root;
 4791|      2|                }
 4792|      2|                else {
 4793|      2|                    tmp->fts_link = p;
 4794|      2|                    tmp = p;
 4795|      2|                }
 4796|      4|            }
 4797|      4|            argv++;
 4798|      4|            nitems++;
 4799|      4|        }
 4800|      2|while_break:
 4801|      2|        ;
 4802|      2|        if (compar) {
 4803|      0|            if (nitems > 1UL) {
 4804|      0|                root = fts_sort(sp, root, nitems);
 4805|      0|            }
 4806|      0|        }
 4807|      2|        tmp___9 = fts_alloc(sp, "", (size_t)0);
 4808|      2|        sp->fts_cur = tmp___9;
 4809|      2|        if ((unsigned long)tmp___9 == (unsigned long)((void *)0)) {
 4810|      0|            goto mem3;
 4811|      0|        }
 4812|      2|        (sp->fts_cur)->fts_link = root;
 4813|      2|        (sp->fts_cur)->fts_info = (unsigned short)9;
 4814|      2|        tmp___10 = setup_dir(sp);
 4815|      2|        if (!tmp___10) {
 4816|      0|            goto mem3;
 4817|      0|        }
 4818|      2|        if (!(sp->fts_options & 4)) {
 4819|      2|            if (!(sp->fts_options & 512)) {
 4820|      0|                tmp___11 = diropen((FTS const *)sp, ".");
 4821|      0|                sp->fts_rfd = tmp___11;
 4822|      0|                if (tmp___11 < 0) {
 4823|      0|                    sp->fts_options |= 4;
 4824|      0|                }
 4825|      0|            }
 4826|      2|        }
 4827|      2|        i_ring_init(&sp->fts_fd_ring, -1);
 4828|      2|        return (sp);
 4829|      0|mem3:
 4830|      0|        fts_lfree(root);
 4831|      0|        free((void *)parent);
 4832|      0|mem2:
 4833|      0|        free((void *)sp->fts_path);
 4834|      0|mem1:
 4835|      0|        free((void *)sp);
 4836|      0|        return ((FTS *)((void *)0));
 4837|      0|    }
 4838|      0|}
 4839|       |static void fts_load(FTS *sp, FTSENT *p)
 4840|      4|{
 4841|      4|    register size_t len;
 4842|      4|    register char *cp;
 4843|      4|    size_t tmp;
 4844|      4|    char *tmp___0;
 4845|       |
 4846|      4|    {
 4847|      4|        tmp = p->fts_namelen;
 4848|      4|        p->fts_pathlen = tmp;
 4849|      4|        len = tmp;
 4850|      4|        memmove((void *)sp->fts_path, (void const *)(p->fts_name), len + 1UL);
 4851|      4|        cp = strrchr((char const *)(p->fts_name), '/');
 4852|      4|        if (cp) {
 4853|      4|            if ((unsigned long)cp != (unsigned long)(p->fts_name)) {
 4854|      4|                cp++;
 4855|      4|                len = strlen((char const *)cp);
 4856|      4|                memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
 4857|      4|                p->fts_namelen = len;
 4858|      4|            }
 4859|      0|            else {
 4860|      0|                if (*(cp + 1)) {
 4861|      0|                    cp++;
 4862|      0|                    len = strlen((char const *)cp);
 4863|      0|                    memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
 4864|      0|                    p->fts_namelen = len;
 4865|      0|                }
 4866|      0|            }
 4867|      4|        }
 4868|      4|        tmp___0 = sp->fts_path;
 4869|      4|        p->fts_path = tmp___0;
 4870|      4|        p->fts_accpath = tmp___0;
 4871|      4|        return;
 4872|      4|    }
 4873|      4|}
 4874|       |__attribute__((__nothrow__)) int(__attribute__((__warn_unused_result__,
 4875|       |                                 __leaf__)) fts_close)(FTS *sp);
 4876|       |int(__attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp)
 4877|      2|{
 4878|      2|    register FTSENT *freep;
 4879|      2|    register FTSENT *p;
 4880|      2|    int saved_errno;
 4881|      2|    int *tmp;
 4882|      2|    int tmp___0;
 4883|      2|    int *tmp___1;
 4884|      2|    int tmp___2;
 4885|      2|    int *tmp___3;
 4886|      2|    int tmp___4;
 4887|      2|    int *tmp___5;
 4888|       |
 4889|      2|    {
 4890|      2|        saved_errno = 0;
 4891|      2|        if (sp->fts_cur) {
 4892|      0|            p = sp->fts_cur;
 4893|      0|            while (1) {
 4894|       |
 4895|      0|                if (!(p->fts_level >= 0L)) {
 4896|      0|                    goto while_break;
 4897|      0|                }
 4898|      0|                freep = p;
 4899|      0|                if ((unsigned long)p->fts_link != (unsigned long)((void *)0)) {
 4900|      0|                    p = p->fts_link;
 4901|      0|                }
 4902|      0|                else {
 4903|      0|                    p = p->fts_parent;
 4904|      0|                }
 4905|      0|                free((void *)freep);
 4906|      0|            }
 4907|      0|while_break:
 4908|      0|            free((void *)p);
 4909|      0|        }
 4910|      2|        if (sp->fts_child) {
 4911|      0|            fts_lfree(sp->fts_child);
 4912|      0|        }
 4913|      2|        free((void *)sp->fts_array);
 4914|      2|        free((void *)sp->fts_path);
 4915|      2|        if (sp->fts_options & 512) {
 4916|      2|            if (0 <= sp->fts_cwd_fd) {
 4917|      0|                tmp___0 = close(sp->fts_cwd_fd);
 4918|      0|                if (tmp___0) {
 4919|      0|                    tmp = __errno_location();
 4920|      0|                    saved_errno = *tmp;
 4921|      0|                }
 4922|      0|            }
 4923|      2|        }
 4924|      0|        else {
 4925|      0|            if (!(sp->fts_options & 4)) {
 4926|      0|                tmp___2 = fchdir(sp->fts_rfd);
 4927|      0|                if (tmp___2) {
 4928|      0|                    tmp___1 = __errno_location();
 4929|      0|                    saved_errno = *tmp___1;
 4930|      0|                }
 4931|      0|                tmp___4 = close(sp->fts_rfd);
 4932|      0|                if (tmp___4) {
 4933|      0|                    if (saved_errno == 0) {
 4934|      0|                        tmp___3 = __errno_location();
 4935|      0|                        saved_errno = *tmp___3;
 4936|      0|                    }
 4937|      0|                }
 4938|      0|            }
 4939|      0|        }
 4940|      2|        fd_ring_clear(&sp->fts_fd_ring);
 4941|      2|        if (sp->fts_leaf_optimization_works_ht) {
 4942|      0|            hash_free(sp->fts_leaf_optimization_works_ht);
 4943|      0|        }
 4944|      2|        free_dir(sp);
 4945|      2|        free((void *)sp);
 4946|      2|        if (saved_errno) {
 4947|      0|            tmp___5 = __errno_location();
 4948|      0|            *tmp___5 = saved_errno;
 4949|      0|            return (-1);
 4950|      0|        }
 4951|      2|        return (0);
 4952|      2|    }
 4953|      2|}
 4954|       |extern
 4955|       |__attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
 4956|       |                                 fstatfs)(int __fildes,
 4957|       |                                         struct statfs *__buf);
 4958|       |static _Bool dirent_inode_sort_may_be_useful(int dir_fd)
 4959|      0|{
 4960|      0|    struct statfs fs_buf;
 4961|      0|    int tmp;
 4962|       |
 4963|      0|    {
 4964|      0|        tmp = fstatfs(dir_fd, &fs_buf);
 4965|      0|        if (tmp != 0) {
 4966|      0|            return ((_Bool)1);
 4967|      0|        }
 4968|      0|        if (fs_buf.f_type == 16914836L) {
 4969|      0|            goto case_16914836;
 4970|      0|        }
 4971|      0|        if (fs_buf.f_type == 26985L) {
 4972|      0|            goto case_16914836;
 4973|      0|        }
 4974|      0|        goto switch_default;
 4975|      0|case_16914836:
 4976|      0|        return ((_Bool)0);
 4977|      0|switch_default:
 4978|      0|        return ((_Bool)1);
 4979|       |
 4980|      0|        return ((_Bool)0);
 4981|      0|    }
 4982|      0|}
 4983|       |static _Bool leaf_optimization_applies(int dir_fd)
 4984|      0|{
 4985|      0|    struct statfs fs_buf;
 4986|      0|    int tmp;
 4987|       |
 4988|      0|    {
 4989|      0|        tmp = fstatfs(dir_fd, &fs_buf);
 4990|      0|        if (tmp != 0) {
 4991|      0|            return ((_Bool)0);
 4992|      0|        }
 4993|      0|        if (fs_buf.f_type == 1382369651L) {
 4994|      0|            goto case_1382369651;
 4995|      0|        }
 4996|      0|        goto switch_default;
 4997|      0|case_1382369651:
 4998|      0|        return ((_Bool)1);
 4999|      0|switch_default:
 5000|      0|        return ((_Bool)0);
 5001|       |
 5002|      0|        return ((_Bool)0);
 5003|      0|    }
 5004|      0|}
 5005|       |static size_t LCO_hash(void const *x, size_t table_size)
 5006|      0|{
 5007|      0|    struct LCO_ent const *ax;
 5008|       |
 5009|      0|    {
 5010|      0|        ax = (struct LCO_ent const *)x;
 5011|      0|        return ((uintmax_t)ax->st_dev % table_size);
 5012|      0|    }
 5013|      0|}
 5014|       |static _Bool LCO_compare(void const *x, void const *y)
 5015|      0|{
 5016|      0|    struct LCO_ent const *ax;
 5017|      0|    struct LCO_ent const *ay;
 5018|       |
 5019|      0|    {
 5020|      0|        ax = (struct LCO_ent const *)x;
 5021|      0|        ay = (struct LCO_ent const *)y;
 5022|      0|        return ((_Bool)(ax->st_dev == ay->st_dev));
 5023|      0|    }
 5024|      0|}
 5025|       |static _Bool link_count_optimize_ok(FTSENT const *p)
 5026|      0|{
 5027|      0|    FTS *sp;
 5028|      0|    Hash_table *h;
 5029|      0|    struct LCO_ent tmp;
 5030|      0|    struct LCO_ent *ent;
 5031|      0|    _Bool opt_ok;
 5032|      0|    struct LCO_ent *t2;
 5033|      0|    struct hash_table *tmp___0;
 5034|       |
 5035|      0|    {
 5036|      0|        sp = (FTS *)p->fts_fts;
 5037|      0|        h = sp->fts_leaf_optimization_works_ht;
 5038|      0|        if (!(sp->fts_options & 512)) {
 5039|      0|            return ((_Bool)0);
 5040|      0|        }
 5041|      0|        if ((unsigned long)h == (unsigned long)((void *)0)) {
 5042|      0|            tmp___0 =
 5043|      0|                hash_initialize((size_t)13, (Hash_tuning const *)((void *)0),
 5044|      0|                                &LCO_hash, &LCO_compare, (void (*)(void *))(&free));
 5045|      0|            sp->fts_leaf_optimization_works_ht = tmp___0;
 5046|      0|            h = tmp___0;
 5047|      0|            if ((unsigned long)h == (unsigned long)((void *)0)) {
 5048|      0|                return ((_Bool)0);
 5049|      0|            }
 5050|      0|        }
 5051|      0|        tmp.st_dev = (dev_t)p->fts_statp[0].st_dev;
 5052|      0|        ent = (struct LCO_ent *)hash_lookup((Hash_table const *)h,
 5053|      0|                                            (void const *)(&tmp));
 5054|      0|        if (ent) {
 5055|      0|            return (ent->opt_ok);
 5056|      0|        }
 5057|      0|        t2 = (struct LCO_ent *)malloc(sizeof(*t2));
 5058|      0|        if ((unsigned long)t2 == (unsigned long)((void *)0)) {
 5059|      0|            return ((_Bool)0);
 5060|      0|        }
 5061|      0|        opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
 5062|      0|        t2->opt_ok = opt_ok;
 5063|      0|        t2->st_dev = (dev_t)p->fts_statp[0].st_dev;
 5064|      0|        ent = (struct LCO_ent *)hash_insert(h, (void const *)t2);
 5065|      0|        if ((unsigned long)ent == (unsigned long)((void *)0)) {
 5066|      0|            free((void *)t2);
 5067|      0|            return ((_Bool)0);
 5068|      0|        }
 5069|      0|        while (1) {
 5070|       |
 5071|      0|            if (!((unsigned long)ent == (unsigned long)t2)) {
 5072|      0|                abort();
 5073|      0|            }
 5074|      0|            goto while_break;
 5075|      0|        }
 5076|      0|while_break:
 5077|      0|        ;
 5078|      0|        return (opt_ok);
 5079|      0|    }
 5080|      0|}
 5081|       |__attribute__((__nothrow__))
 5082|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp);
 5083|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp)
 5084|     28|{
 5085|     28|    register FTSENT *p;
 5086|     28|    register FTSENT *tmp;
 5087|     28|    register unsigned short instr;
 5088|     28|    register char *t;
 5089|     28|    int *tmp___0;
 5090|     28|    int tmp___1;
 5091|     28|    int *tmp___2;
 5092|     28|    int tmp___3;
 5093|     28|    struct _ftsent *tmp___4;
 5094|     28|    int tmp___5;
 5095|     28|    int tmp___6;
 5096|     28|    int tmp___7;
 5097|     28|    int tmp___8;
 5098|     28|    int tmp___9;
 5099|     28|    int *tmp___10;
 5100|     28|    int tmp___11;
 5101|     28|    size_t tmp___12;
 5102|     28|    char *tmp___13;
 5103|     28|    FTSENT *parent;
 5104|     28|    _Bool tmp___14;
 5105|     28|    int *tmp___15;
 5106|     28|    _Bool tmp___16;
 5107|     28|    int *tmp___17;
 5108|     28|    struct _ftsent *tmp___18;
 5109|     28|    int *tmp___19;
 5110|     28|    int tmp___20;
 5111|     28|    int tmp___21;
 5112|     28|    int tmp___22;
 5113|     28|    int tmp___23;
 5114|     28|    int tmp___24;
 5115|     28|    int saved_errno;
 5116|     28|    int *tmp___25;
 5117|     28|    int *tmp___26;
 5118|     28|    int *tmp___27;
 5119|     28|    int tmp___28;
 5120|     28|    int tmp___29;
 5121|     28|    int *tmp___30;
 5122|     28|    int tmp___31;
 5123|     28|    FTSENT *tmp___32;
 5124|       |
 5125|     28|    {
 5126|     28|        if ((unsigned long)sp->fts_cur == (unsigned long)((void *)0)) {
 5127|      0|            return ((FTSENT *)((void *)0));
 5128|      0|        }
 5129|     28|        else {
 5130|     28|            if (sp->fts_options & 8192) {
 5131|      0|                return ((FTSENT *)((void *)0));
 5132|      0|            }
 5133|     28|        }
 5134|     28|        p = sp->fts_cur;
 5135|     28|        instr = p->fts_instr;
 5136|     28|        p->fts_instr = (unsigned short)3;
 5137|     28|        if ((int)instr == 1) {
 5138|      0|            p->fts_info = fts_stat(sp, p, (_Bool)0);
 5139|      0|            return (p);
 5140|      0|        }
 5141|     28|        if ((int)instr == 2) {
 5142|      0|            if ((int)p->fts_info == 12) {
 5143|      0|                goto _L;
 5144|      0|            }
 5145|      0|            else {
 5146|      0|                if ((int)p->fts_info == 13) {
 5147|      0|_L:
 5148|      0|                    p->fts_info = fts_stat(sp, p, (_Bool)1);
 5149|      0|                    if ((int)p->fts_info == 1) {
 5150|      0|                        if (!(sp->fts_options & 4)) {
 5151|      0|                            tmp___1 = diropen((FTS const *)sp, ".");
 5152|      0|                            p->fts_symfd = tmp___1;
 5153|      0|                            if (tmp___1 < 0) {
 5154|      0|                                tmp___0 = __errno_location();
 5155|      0|                                p->fts_errno = *tmp___0;
 5156|      0|                                p->fts_info = (unsigned short)7;
 5157|      0|                            }
 5158|      0|                            else {
 5159|      0|                                p->fts_flags = (unsigned short)((int)p->fts_flags | 2);
 5160|      0|                            }
 5161|      0|                        }
 5162|      0|                    }
 5163|      0|                    goto check_for_dir;
 5164|      0|                }
 5165|      0|            }
 5166|      0|        }
 5167|     28|        if ((int)p->fts_info == 1) {
 5168|     10|            if ((int)instr == 4) {
 5169|      0|                goto _L___0;
 5170|      0|            }
 5171|     10|            else {
 5172|     10|                if (sp->fts_options & 64) {
 5173|      0|                    if (p->fts_statp[0].st_dev != sp->fts_dev) {
 5174|      0|_L___0:
 5175|      0|                        if ((int)p->fts_flags & 2) {
 5176|      0|                            close(p->fts_symfd);
 5177|      0|                        }
 5178|      0|                        if (sp->fts_child) {
 5179|      0|                            fts_lfree(sp->fts_child);
 5180|      0|                            sp->fts_child = (struct _ftsent *)((void *)0);
 5181|      0|                        }
 5182|      0|                        p->fts_info = (unsigned short)6;
 5183|      0|                        while (1) {
 5184|      0|                            leave_dir(sp, p);
 5185|      0|                            goto while_break;
 5186|      0|                        }
 5187|      0|while_break:
 5188|      0|                        ;
 5189|      0|                        return (p);
 5190|      0|                    }
 5191|      0|                }
 5192|     10|            }
 5193|     10|            if ((unsigned long)sp->fts_child != (unsigned long)((void *)0)) {
 5194|      0|                if (sp->fts_options & 4096) {
 5195|      0|                    sp->fts_options &= -4097;
 5196|      0|                    fts_lfree(sp->fts_child);
 5197|      0|                    sp->fts_child = (struct _ftsent *)((void *)0);
 5198|      0|                }
 5199|      0|            }
 5200|     10|            if ((unsigned long)sp->fts_child != (unsigned long)((void *)0)) {
 5201|      0|                tmp___3 = fts_safe_changedir(sp, p, -1, (char const *)p->fts_accpath);
 5202|      0|                if (tmp___3) {
 5203|      0|                    tmp___2 = __errno_location();
 5204|      0|                    p->fts_errno = *tmp___2;
 5205|      0|                    p->fts_flags = (unsigned short)((int)p->fts_flags | 1);
 5206|      0|                    p = sp->fts_child;
 5207|      0|                    while (1) {
 5208|       |
 5209|      0|                        if (!((unsigned long)p != (unsigned long)((void *)0))) {
 5210|      0|                            goto while_break___0;
 5211|      0|                        }
 5212|      0|                        p->fts_accpath = (p->fts_parent)->fts_accpath;
 5213|      0|                        p = p->fts_link;
 5214|      0|                    }
 5215|      0|while_break___0:
 5216|      0|                    ;
 5217|      0|                }
 5218|      0|            }
 5219|     10|            else {
 5220|     10|                tmp___4 = fts_build(sp, 3);
 5221|     10|                sp->fts_child = tmp___4;
 5222|     10|                if ((unsigned long)tmp___4 == (unsigned long)((void *)0)) {
 5223|      2|                    if (sp->fts_options & 8192) {
 5224|      0|                        return ((FTSENT *)((void *)0));
 5225|      0|                    }
 5226|      2|                    if (p->fts_errno) {
 5227|      0|                        if ((int)p->fts_info != 4) {
 5228|      0|                            p->fts_info = (unsigned short)7;
 5229|      0|                        }
 5230|      0|                    }
 5231|      2|                    while (1) {
 5232|      2|                        leave_dir(sp, p);
 5233|      2|                        goto while_break___1;
 5234|      2|                    }
 5235|      2|while_break___1:
 5236|      2|                    ;
 5237|      2|                    return (p);
 5238|      2|                }
 5239|     10|            }
 5240|      8|            p = sp->fts_child;
 5241|      8|            sp->fts_child = (struct _ftsent *)((void *)0);
 5242|      8|            goto name;
 5243|     10|        }
 5244|     18|next:
 5245|     18|        tmp = p;
 5246|     18|        p = p->fts_link;
 5247|     18|        if ((unsigned long)p != (unsigned long)((void *)0)) {
 5248|      8|            sp->fts_cur = p;
 5249|      8|            free((void *)tmp);
 5250|      8|            if (p->fts_level == 0L) {
 5251|      4|                fd_ring_clear(&sp->fts_fd_ring);
 5252|      4|                if (!(sp->fts_options & 4)) {
 5253|      4|                    if (sp->fts_options & 512) {
 5254|      4|                        if (sp->fts_options & 512) {
 5255|      4|                            tmp___5 = -100;
 5256|      4|                        }
 5257|      0|                        else {
 5258|      0|                            tmp___5 = sp->fts_rfd;
 5259|      0|                        }
 5260|      4|                        cwd_advance_fd(sp, tmp___5, (_Bool)1);
 5261|      4|                        tmp___8 = 0;
 5262|      4|                    }
 5263|      0|                    else {
 5264|      0|                        if (sp->fts_options & 512) {
 5265|      0|                            tmp___6 = -100;
 5266|      0|                        }
 5267|      0|                        else {
 5268|      0|                            tmp___6 = sp->fts_rfd;
 5269|      0|                        }
 5270|      0|                        tmp___7 = fchdir(tmp___6);
 5271|      0|                        tmp___8 = tmp___7;
 5272|      0|                    }
 5273|      4|                    if (tmp___8) {
 5274|      0|                        tmp___9 = 1;
 5275|      0|                    }
 5276|      4|                    else {
 5277|      4|                        tmp___9 = 0;
 5278|      4|                    }
 5279|      4|                }
 5280|      0|                else {
 5281|      0|                    tmp___9 = 0;
 5282|      0|                }
 5283|      4|                if (tmp___9) {
 5284|      0|                    sp->fts_options |= 8192;
 5285|      0|                    return ((FTSENT *)((void *)0));
 5286|      0|                }
 5287|      4|                free_dir(sp);
 5288|      4|                fts_load(sp, p);
 5289|      4|                setup_dir(sp);
 5290|      4|                goto check_for_dir;
 5291|      4|            }
 5292|      4|            if ((int)p->fts_instr == 4) {
 5293|      0|                goto next;
 5294|      0|            }
 5295|      4|            if ((int)p->fts_instr == 2) {
 5296|      0|                p->fts_info = fts_stat(sp, p, (_Bool)1);
 5297|      0|                if ((int)p->fts_info == 1) {
 5298|      0|                    if (!(sp->fts_options & 4)) {
 5299|      0|                        tmp___11 = diropen((FTS const *)sp, ".");
 5300|      0|                        p->fts_symfd = tmp___11;
 5301|      0|                        if (tmp___11 < 0) {
 5302|      0|                            tmp___10 = __errno_location();
 5303|      0|                            p->fts_errno = *tmp___10;
 5304|      0|                            p->fts_info = (unsigned short)7;
 5305|      0|                        }
 5306|      0|                        else {
 5307|      0|                            p->fts_flags = (unsigned short)((int)p->fts_flags | 2);
 5308|      0|                        }
 5309|      0|                    }
 5310|      0|                }
 5311|      0|                p->fts_instr = (unsigned short)3;
 5312|      0|            }
 5313|     12|name:
 5314|     12|            if ((int)*((p->fts_parent)->fts_path +
 5315|     12|                       ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
 5316|      0|                tmp___12 = (p->fts_parent)->fts_pathlen - 1UL;
 5317|      0|            }
 5318|     12|            else {
 5319|     12|                tmp___12 = (p->fts_parent)->fts_pathlen;
 5320|     12|            }
 5321|     12|            t = sp->fts_path + tmp___12;
 5322|     12|            tmp___13 = t;
 5323|     12|            t++;
 5324|     12|            *tmp___13 = (char)'/';
 5325|     12|            memmove((void *)t, (void const *)(p->fts_name), p->fts_namelen + 1UL);
 5326|     16|check_for_dir:
 5327|     16|            sp->fts_cur = p;
 5328|     16|            if ((int)p->fts_info == 11) {
 5329|     14|                if (p->fts_statp[0].st_size == 2L) {
 5330|     10|                    parent = p->fts_parent;
 5331|     10|                    if (0L < p->fts_level) {
 5332|      8|                        if (parent->fts_n_dirs_remaining == 0UL) {
 5333|      0|                            if (sp->fts_options & 8) {
 5334|      0|                                if (sp->fts_options & 16) {
 5335|      0|                                    tmp___14 = link_count_optimize_ok((FTSENT const *)parent);
 5336|      0|                                    if (!tmp___14) {
 5337|      0|                                        goto _L___4;
 5338|      0|                                    }
 5339|      0|                                }
 5340|      0|                                else {
 5341|      0|                                    goto _L___4;
 5342|      0|                                }
 5343|      0|                            }
 5344|      0|                            else {
 5345|      0|                                goto _L___4;
 5346|      0|                            }
 5347|      0|                        }
 5348|      8|                        else {
 5349|      8|                            goto _L___4;
 5350|      8|                        }
 5351|      8|                    }
 5352|      2|                    else {
 5353|     10|_L___4:
 5354|     10|                        p->fts_info = fts_stat(sp, p, (_Bool)0);
 5355|     10|                        if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
 5356|      8|                            if (p->fts_level != 0L) {
 5357|      8|                                if (parent->fts_n_dirs_remaining) {
 5358|      8|                                    (parent->fts_n_dirs_remaining)--;
 5359|      8|                                }
 5360|      8|                            }
 5361|      8|                        }
 5362|     10|                    }
 5363|     10|                }
 5364|      4|                else {
 5365|      4|                    while (1) {
 5366|       |
 5367|      4|                        if (!(p->fts_statp[0].st_size == 1L)) {
 5368|      0|                            abort();
 5369|      0|                        }
 5370|      4|                        goto while_break___2;
 5371|      4|                    }
 5372|      4|while_break___2:
 5373|      4|                    ;
 5374|      4|                }
 5375|     14|            }
 5376|     16|            if ((int)p->fts_info == 1) {
 5377|     10|                if (p->fts_level == 0L) {
 5378|      2|                    sp->fts_dev = p->fts_statp[0].st_dev;
 5379|      2|                }
 5380|     10|                tmp___16 = enter_dir(sp, p);
 5381|     10|                if (!tmp___16) {
 5382|      0|                    tmp___15 = __errno_location();
 5383|      0|                    *tmp___15 = 12;
 5384|      0|                    return ((FTSENT *)((void *)0));
 5385|      0|                }
 5386|     10|            }
 5387|     16|            return (p);
 5388|     16|        }
 5389|     10|        p = tmp->fts_parent;
 5390|     10|        sp->fts_cur = p;
 5391|     10|        free((void *)tmp);
 5392|     10|        if (p->fts_level == -1L) {
 5393|      2|            free((void *)p);
 5394|      2|            tmp___17 = __errno_location();
 5395|      2|            *tmp___17 = 0;
 5396|      2|            tmp___18 = (struct _ftsent *)((void *)0);
 5397|      2|            sp->fts_cur = tmp___18;
 5398|      2|            return (tmp___18);
 5399|      2|        }
 5400|      8|        while (1) {
 5401|       |
 5402|      8|            if (!((int)p->fts_info != 11)) {
 5403|      0|                abort();
 5404|      0|            }
 5405|      8|            goto while_break___3;
 5406|      8|        }
 5407|      8|while_break___3:
 5408|      8|        *(sp->fts_path + p->fts_pathlen) = (char)'\000';
 5409|      8|        if (p->fts_level == 0L) {
 5410|      1|            fd_ring_clear(&sp->fts_fd_ring);
 5411|      1|            if (!(sp->fts_options & 4)) {
 5412|      1|                if (sp->fts_options & 512) {
 5413|      1|                    if (sp->fts_options & 512) {
 5414|      1|                        tmp___20 = -100;
 5415|      1|                    }
 5416|      0|                    else {
 5417|      0|                        tmp___20 = sp->fts_rfd;
 5418|      0|                    }
 5419|      1|                    cwd_advance_fd(sp, tmp___20, (_Bool)1);
 5420|      1|                    tmp___23 = 0;
 5421|      1|                }
 5422|      0|                else {
 5423|      0|                    if (sp->fts_options & 512) {
 5424|      0|                        tmp___21 = -100;
 5425|      0|                    }
 5426|      0|                    else {
 5427|      0|                        tmp___21 = sp->fts_rfd;
 5428|      0|                    }
 5429|      0|                    tmp___22 = fchdir(tmp___21);
 5430|      0|                    tmp___23 = tmp___22;
 5431|      0|                }
 5432|      1|                if (tmp___23) {
 5433|      0|                    tmp___24 = 1;
 5434|      0|                }
 5435|      1|                else {
 5436|      1|                    tmp___24 = 0;
 5437|      1|                }
 5438|      1|            }
 5439|      0|            else {
 5440|      0|                tmp___24 = 0;
 5441|      0|            }
 5442|      1|            if (tmp___24) {
 5443|      0|                tmp___19 = __errno_location();
 5444|      0|                p->fts_errno = *tmp___19;
 5445|      0|                sp->fts_options |= 8192;
 5446|      0|            }
 5447|      1|        }
 5448|      7|        else {
 5449|      7|            if ((int)p->fts_flags & 2) {
 5450|      0|                if (!(sp->fts_options & 4)) {
 5451|      0|                    if (sp->fts_options & 512) {
 5452|      0|                        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
 5453|      0|                        tmp___29 = 0;
 5454|      0|                    }
 5455|      0|                    else {
 5456|      0|                        tmp___28 = fchdir(p->fts_symfd);
 5457|      0|                        tmp___29 = tmp___28;
 5458|      0|                    }
 5459|      0|                    if (tmp___29) {
 5460|      0|                        tmp___25 = __errno_location();
 5461|      0|                        saved_errno = *tmp___25;
 5462|      0|                        close(p->fts_symfd);
 5463|      0|                        tmp___26 = __errno_location();
 5464|      0|                        *tmp___26 = saved_errno;
 5465|      0|                        tmp___27 = __errno_location();
 5466|      0|                        p->fts_errno = *tmp___27;
 5467|      0|                        sp->fts_options |= 8192;
 5468|      0|                    }
 5469|      0|                }
 5470|      0|                close(p->fts_symfd);
 5471|      0|            }
 5472|      7|            else {
 5473|      7|                if (!((int)p->fts_flags & 1)) {
 5474|      7|                    tmp___31 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
 5475|      7|                    if (tmp___31) {
 5476|      0|                        tmp___30 = __errno_location();
 5477|      0|                        p->fts_errno = *tmp___30;
 5478|      0|                        sp->fts_options |= 8192;
 5479|      0|                    }
 5480|      7|                }
 5481|      7|            }
 5482|      7|        }
 5483|      8|        if (p->fts_errno) {
 5484|      0|            p->fts_info = (unsigned short)7;
 5485|      0|        }
 5486|      8|        else {
 5487|      8|            p->fts_info = (unsigned short)6;
 5488|      8|        }
 5489|      8|        if (p->fts_errno == 0) {
 5490|      8|            while (1) {
 5491|      8|                leave_dir(sp, p);
 5492|      8|                goto while_break___4;
 5493|      8|            }
 5494|      8|while_break___4:
 5495|      8|            ;
 5496|      8|        }
 5497|      8|        if (sp->fts_options & 8192) {
 5498|      0|            tmp___32 = (FTSENT *)((void *)0);
 5499|      0|        }
 5500|      8|        else {
 5501|      8|            tmp___32 = p;
 5502|      8|        }
 5503|      8|        return (tmp___32);
 5504|      8|    }
 5505|      8|}
 5506|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__))
 5507|       |                                 fts_set)(FTS *sp __attribute__((__unused__)),
 5508|       |                                         FTSENT *p, int instr);
 5509|       |int(__attribute__((__leaf__)) fts_set)(FTS *sp __attribute__((__unused__)),
 5510|       |                                       FTSENT *p, int instr)
 5511|      0|{
 5512|      0|    int *tmp;
 5513|       |
 5514|      0|    {
 5515|      0|        if (instr != 0) {
 5516|      0|            if (instr != 1) {
 5517|      0|                if (instr != 2) {
 5518|      0|                    if (instr != 3) {
 5519|      0|                        if (instr != 4) {
 5520|      0|                            tmp = __errno_location();
 5521|      0|                            *tmp = 22;
 5522|      0|                            return (1);
 5523|      0|                        }
 5524|      0|                    }
 5525|      0|                }
 5526|      0|            }
 5527|      0|        }
 5528|      0|        p->fts_instr = (unsigned short)instr;
 5529|      0|        return (0);
 5530|      0|    }
 5531|      0|}
 5532|       |static int fts_compare_ino(struct _ftsent const **a, struct _ftsent const **b)
 5533|      0|{
 5534|      0|    int tmp;
 5535|      0|    int tmp___0;
 5536|       |
 5537|      0|    {
 5538|      0|        if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
 5539|      0|            tmp___0 = -1;
 5540|      0|        }
 5541|      0|        else {
 5542|      0|            if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
 5543|      0|                tmp = 1;
 5544|      0|            }
 5545|      0|            else {
 5546|      0|                tmp = 0;
 5547|      0|            }
 5548|      0|            tmp___0 = tmp;
 5549|      0|        }
 5550|      0|        return (tmp___0);
 5551|      0|    }
 5552|      0|}
 5553|       |static void set_stat_type(struct stat *st, unsigned int dtype)
 5554|     12|{
 5555|     12|    mode_t type;
 5556|       |
 5557|     12|    {
 5558|     12|        if (dtype == 6U) {
 5559|      0|            goto case_6;
 5560|      0|        }
 5561|     12|        if (dtype == 2U) {
 5562|      0|            goto case_2;
 5563|      0|        }
 5564|     12|        if (dtype == 4U) {
 5565|      8|            goto case_4;
 5566|      8|        }
 5567|      4|        if (dtype == 1U) {
 5568|      0|            goto case_1;
 5569|      0|        }
 5570|      4|        if (dtype == 10U) {
 5571|      0|            goto case_10;
 5572|      0|        }
 5573|      4|        if (dtype == 8U) {
 5574|      4|            goto case_8;
 5575|      4|        }
 5576|      0|        if (dtype == 12U) {
 5577|      0|            goto case_12;
 5578|      0|        }
 5579|      0|        goto switch_default;
 5580|      0|case_6:
 5581|      0|        type = (mode_t)24576;
 5582|      0|        goto switch_break;
 5583|      0|case_2:
 5584|      0|        type = (mode_t)8192;
 5585|      0|        goto switch_break;
 5586|      8|case_4:
 5587|      8|        type = (mode_t)16384;
 5588|      8|        goto switch_break;
 5589|      0|case_1:
 5590|      0|        type = (mode_t)4096;
 5591|      0|        goto switch_break;
 5592|      0|case_10:
 5593|      0|        type = (mode_t)40960;
 5594|      0|        goto switch_break;
 5595|      4|case_8:
 5596|      4|        type = (mode_t)32768;
 5597|      4|        goto switch_break;
 5598|      0|case_12:
 5599|      0|        type = (mode_t)49152;
 5600|      0|        goto switch_break;
 5601|      0|switch_default:
 5602|      0|        type = (mode_t)0;
 5603|     12|switch_break:
 5604|     12|        st->st_mode = type;
 5605|     12|        return;
 5606|      0|    }
 5607|      0|}
 5608|       |static FTSENT *fts_build(FTS *sp, int type)
 5609|     10|{
 5610|     10|    register struct dirent *dp;
 5611|     10|    register FTSENT *p;
 5612|     10|    register FTSENT *head;
 5613|     10|    register size_t nitems;
 5614|     10|    FTSENT *cur;
 5615|     10|    FTSENT *tail;
 5616|     10|    DIR *dirp;
 5617|     10|    void *oldaddr;
 5618|     10|    int saved_errno;
 5619|     10|    _Bool descend;
 5620|     10|    _Bool doadjust;
 5621|     10|    ptrdiff_t level;
 5622|     10|    nlink_t nlinks;
 5623|     10|    _Bool nostat;
 5624|     10|    size_t len;
 5625|     10|    size_t maxlen;
 5626|     10|    size_t new_len;
 5627|     10|    char *cp;
 5628|     10|    int *tmp;
 5629|     10|    DIR *tmp___0;
 5630|     10|    DIR *tmp___1;
 5631|     10|    int *tmp___2;
 5632|     10|    _Bool tmp___3;
 5633|     10|    int tmp___4;
 5634|     10|    int dir_fd;
 5635|     10|    int tmp___5;
 5636|     10|    int *tmp___6;
 5637|     10|    int tmp___7;
 5638|     10|    char *tmp___8;
 5639|     10|    _Bool is_dir;
 5640|     10|    size_t tmp___9;
 5641|     10|    int *tmp___10;
 5642|     10|    int *tmp___11;
 5643|     10|    size_t tmp___12;
 5644|     10|    _Bool tmp___13;
 5645|     10|    size_t tmp___14;
 5646|     10|    size_t tmp___15;
 5647|     10|    int *tmp___16;
 5648|     10|    _Bool skip_stat;
 5649|     10|    int tmp___17;
 5650|     10|    int tmp___18;
 5651|     10|    int tmp___19;
 5652|     10|    int tmp___20;
 5653|     10|    int tmp___21;
 5654|     10|    int tmp___22;
 5655|     10|    int tmp___23;
 5656|     10|    int tmp___24;
 5657|     10|    int tmp___25;
 5658|     10|    int tmp___26;
 5659|     10|    _Bool tmp___27;
 5660|       |
 5661|     10|    {
 5662|     10|        cur = sp->fts_cur;
 5663|     10|        if (!(sp->fts_options & 4)) {
 5664|     10|            if (sp->fts_options & 512) {
 5665|     10|                tmp___0 = opendirat(sp->fts_cwd_fd, (char const *)cur->fts_accpath);
 5666|     10|                dirp = tmp___0;
 5667|     10|            }
 5668|      0|            else {
 5669|      0|                tmp___1 = opendir_safer((char const *)cur->fts_accpath);
 5670|      0|                dirp = tmp___1;
 5671|      0|            }
 5672|     10|        }
 5673|      0|        else {
 5674|      0|            tmp___1 = opendir_safer((char const *)cur->fts_accpath);
 5675|      0|            dirp = tmp___1;
 5676|      0|        }
 5677|     10|        if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 5678|      0|            if (type == 3) {
 5679|      0|                cur->fts_info = (unsigned short)4;
 5680|      0|                tmp = __errno_location();
 5681|      0|                cur->fts_errno = *tmp;
 5682|      0|            }
 5683|      0|            return ((FTSENT *)((void *)0));
 5684|      0|        }
 5685|     10|        if ((int)cur->fts_info == 11) {
 5686|      0|            cur->fts_info = fts_stat(sp, cur, (_Bool)0);
 5687|      0|        }
 5688|     10|        else {
 5689|     10|            if (sp->fts_options & 256) {
 5690|      0|                while (1) {
 5691|      0|                    leave_dir(sp, cur);
 5692|      0|                    goto while_break;
 5693|      0|                }
 5694|      0|while_break:
 5695|      0|                fts_stat(sp, cur, (_Bool)0);
 5696|      0|                tmp___3 = enter_dir(sp, cur);
 5697|      0|                if (!tmp___3) {
 5698|      0|                    tmp___2 = __errno_location();
 5699|      0|                    *tmp___2 = 12;
 5700|      0|                    return ((FTSENT *)((void *)0));
 5701|      0|                }
 5702|      0|            }
 5703|     10|        }
 5704|     10|        if (type == 2) {
 5705|      0|            nlinks = (nlink_t)0;
 5706|      0|            nostat = (_Bool)0;
 5707|      0|        }
 5708|     10|        else {
 5709|     10|            if (sp->fts_options & 8) {
 5710|     10|                if (sp->fts_options & 16) {
 5711|     10|                    if (sp->fts_options & 32) {
 5712|      0|                        tmp___4 = 0;
 5713|      0|                    }
 5714|     10|                    else {
 5715|     10|                        tmp___4 = 2;
 5716|     10|                    }
 5717|     10|                    nlinks = cur->fts_statp[0].st_nlink - (__nlink_t)tmp___4;
 5718|     10|                    nostat = (_Bool)1;
 5719|     10|                }
 5720|      0|                else {
 5721|      0|                    nlinks = (nlink_t)-1;
 5722|      0|                    nostat = (_Bool)0;
 5723|      0|                }
 5724|     10|            }
 5725|      0|            else {
 5726|      0|                nlinks = (nlink_t)-1;
 5727|      0|                nostat = (_Bool)0;
 5728|      0|            }
 5729|     10|        }
 5730|     10|        if (nlinks) {
 5731|      8|            goto _L___0;
 5732|      8|        }
 5733|      2|        else {
 5734|      2|            if (type == 3) {
 5735|     10|_L___0:
 5736|     10|                tmp___5 = dirfd(dirp);
 5737|     10|                dir_fd = tmp___5;
 5738|     10|                if (sp->fts_options & 512) {
 5739|     10|                    if (0 <= dir_fd) {
 5740|     10|                        dir_fd = dup_safer(dir_fd);
 5741|     10|                        set_cloexec_flag(dir_fd, (_Bool)1);
 5742|     10|                    }
 5743|     10|                }
 5744|     10|                if (dir_fd < 0) {
 5745|      0|                    goto _L;
 5746|      0|                }
 5747|     10|                else {
 5748|     10|                    tmp___7 =
 5749|     10|                        fts_safe_changedir(sp, cur, dir_fd, (char const *)((void *)0));
 5750|     10|                    if (tmp___7) {
 5751|      0|_L:
 5752|      0|                        if (nlinks) {
 5753|      0|                            if (type == 3) {
 5754|      0|                                tmp___6 = __errno_location();
 5755|      0|                                cur->fts_errno = *tmp___6;
 5756|      0|                            }
 5757|      0|                        }
 5758|      0|                        cur->fts_flags = (unsigned short)((int)cur->fts_flags | 1);
 5759|      0|                        descend = (_Bool)0;
 5760|      0|                        closedir(dirp);
 5761|      0|                        if (sp->fts_options & 512) {
 5762|      0|                            if (0 <= dir_fd) {
 5763|      0|                                close(dir_fd);
 5764|      0|                            }
 5765|      0|                        }
 5766|      0|                        dirp = (DIR *)((void *)0);
 5767|      0|                    }
 5768|     10|                    else {
 5769|     10|                        descend = (_Bool)1;
 5770|     10|                    }
 5771|     10|                }
 5772|     10|            }
 5773|      0|            else {
 5774|      0|                descend = (_Bool)0;
 5775|      0|            }
 5776|      2|        }
 5777|     10|        if ((int)*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
 5778|      0|            len = cur->fts_pathlen - 1UL;
 5779|      0|        }
 5780|     10|        else {
 5781|     10|            len = cur->fts_pathlen;
 5782|     10|        }
 5783|     10|        if (sp->fts_options & 4) {
 5784|      0|            cp = sp->fts_path + len;
 5785|      0|            tmp___8 = cp;
 5786|      0|            cp++;
 5787|      0|            *tmp___8 = (char)'/';
 5788|      0|        }
 5789|     10|        else {
 5790|     10|            cp = (char *)((void *)0);
 5791|     10|        }
 5792|     10|        len++;
 5793|     10|        maxlen = sp->fts_pathlen - len;
 5794|     10|        level = cur->fts_level + 1L;
 5795|     10|        doadjust = (_Bool)0;
 5796|     10|        tail = (FTSENT *)((void *)0);
 5797|     10|        head = tail;
 5798|     10|        nitems = (size_t)0;
 5799|     42|        while (1) {
 5800|       |
 5801|     42|            if (dirp) {
 5802|     42|                dp = readdir(dirp);
 5803|     42|                if (!dp) {
 5804|     10|                    goto while_break___0;
 5805|     10|                }
 5806|     42|            }
 5807|      0|            else {
 5808|      0|                goto while_break___0;
 5809|      0|            }
 5810|     32|            if (!(sp->fts_options & 32)) {
 5811|     32|                if ((int)dp->d_name[0] == 46) {
 5812|     20|                    if (!dp->d_name[1]) {
 5813|     10|                        goto __Cont;
 5814|     10|                    }
 5815|     10|                    else {
 5816|     10|                        if ((int)dp->d_name[1] == 46) {
 5817|     10|                            if (!dp->d_name[2]) {
 5818|     10|                                goto __Cont;
 5819|     10|                            }
 5820|     10|                        }
 5821|     10|                    }
 5822|     20|                }
 5823|     32|            }
 5824|     12|            tmp___9 = strlen((char const *)(dp->d_name));
 5825|     12|            p = fts_alloc(sp, (char const *)(dp->d_name), tmp___9);
 5826|     12|            if ((unsigned long)p == (unsigned long)((void *)0)) {
 5827|      0|                goto mem1;
 5828|      0|            }
 5829|     12|            tmp___14 = strlen((char const *)(dp->d_name));
 5830|     12|            if (tmp___14 >= maxlen) {
 5831|      0|                oldaddr = (void *)sp->fts_path;
 5832|      0|                tmp___12 = strlen((char const *)(dp->d_name));
 5833|      0|                tmp___13 = fts_palloc(sp, (tmp___12 + len) + 1UL);
 5834|      0|                if (!tmp___13) {
 5835|      0|mem1:
 5836|      0|                    tmp___10 = __errno_location();
 5837|      0|                    saved_errno = *tmp___10;
 5838|      0|                    free((void *)p);
 5839|      0|                    fts_lfree(head);
 5840|      0|                    closedir(dirp);
 5841|      0|                    cur->fts_info = (unsigned short)7;
 5842|      0|                    sp->fts_options |= 8192;
 5843|      0|                    tmp___11 = __errno_location();
 5844|      0|                    *tmp___11 = saved_errno;
 5845|      0|                    return ((FTSENT *)((void *)0));
 5846|      0|                }
 5847|      0|                if ((unsigned long)oldaddr != (unsigned long)sp->fts_path) {
 5848|      0|                    doadjust = (_Bool)1;
 5849|      0|                    if (sp->fts_options & 4) {
 5850|      0|                        cp = sp->fts_path + len;
 5851|      0|                    }
 5852|      0|                }
 5853|      0|                maxlen = sp->fts_pathlen - len;
 5854|      0|            }
 5855|     12|            tmp___15 = strlen((char const *)(dp->d_name));
 5856|     12|            new_len = len + tmp___15;
 5857|     12|            if (new_len < len) {
 5858|      0|                free((void *)p);
 5859|      0|                fts_lfree(head);
 5860|      0|                closedir(dirp);
 5861|      0|                cur->fts_info = (unsigned short)7;
 5862|      0|                sp->fts_options |= 8192;
 5863|      0|                tmp___16 = __errno_location();
 5864|      0|                *tmp___16 = 36;
 5865|      0|                return ((FTSENT *)((void *)0));
 5866|      0|            }
 5867|     12|            p->fts_level = level;
 5868|     12|            p->fts_parent = sp->fts_cur;
 5869|     12|            p->fts_pathlen = new_len;
 5870|     12|            p->fts_statp[0].st_ino = dp->d_ino;
 5871|     12|            if (sp->fts_options & 4) {
 5872|      0|                p->fts_accpath = p->fts_path;
 5873|      0|                memmove((void *)cp, (void const *)(p->fts_name), p->fts_namelen + 1UL);
 5874|      0|            }
 5875|     12|            else {
 5876|     12|                p->fts_accpath = p->fts_name;
 5877|     12|            }
 5878|     12|            if ((unsigned long)sp->fts_compar == (unsigned long)((void *)0)) {
 5879|     12|                goto _L___1;
 5880|     12|            }
 5881|      0|            else {
 5882|      0|                if (sp->fts_options & 1024) {
 5883|     12|_L___1:
 5884|     12|                    if (sp->fts_options & 16) {
 5885|     12|                        if (sp->fts_options & 8) {
 5886|     12|                            if ((int)dp->d_type != 0) {
 5887|     12|                                if (!((int)dp->d_type == 4)) {
 5888|      4|                                    tmp___17 = 1;
 5889|      4|                                }
 5890|      8|                                else {
 5891|      8|                                    tmp___17 = 0;
 5892|      8|                                }
 5893|     12|                            }
 5894|      0|                            else {
 5895|      0|                                tmp___17 = 0;
 5896|      0|                            }
 5897|     12|                        }
 5898|      0|                        else {
 5899|      0|                            tmp___17 = 0;
 5900|      0|                        }
 5901|     12|                    }
 5902|      0|                    else {
 5903|      0|                        tmp___17 = 0;
 5904|      0|                    }
 5905|     12|                    skip_stat = (_Bool)tmp___17;
 5906|     12|                    p->fts_info = (unsigned short)11;
 5907|     12|                    set_stat_type(p->fts_statp, (unsigned int)dp->d_type);
 5908|     12|                    fts_set_stat_required(p, (_Bool)(!skip_stat));
 5909|     12|                    if (sp->fts_options & 16) {
 5910|     12|                        if ((int)dp->d_type == 4) {
 5911|      8|                            tmp___18 = 1;
 5912|      8|                        }
 5913|      4|                        else {
 5914|      4|                            tmp___18 = 0;
 5915|      4|                        }
 5916|     12|                    }
 5917|      0|                    else {
 5918|      0|                        tmp___18 = 0;
 5919|      0|                    }
 5920|     12|                    is_dir = (_Bool)tmp___18;
 5921|     12|                }
 5922|      0|                else {
 5923|      0|                    p->fts_info = fts_stat(sp, p, (_Bool)0);
 5924|      0|                    if ((int)p->fts_info == 1) {
 5925|      0|                        tmp___19 = 1;
 5926|      0|                    }
 5927|      0|                    else {
 5928|      0|                        if ((int)p->fts_info == 2) {
 5929|      0|                            tmp___19 = 1;
 5930|      0|                        }
 5931|      0|                        else {
 5932|      0|                            if ((int)p->fts_info == 5) {
 5933|      0|                                tmp___19 = 1;
 5934|      0|                            }
 5935|      0|                            else {
 5936|      0|                                tmp___19 = 0;
 5937|      0|                            }
 5938|      0|                        }
 5939|      0|                    }
 5940|      0|                    is_dir = (_Bool)tmp___19;
 5941|      0|                }
 5942|      0|            }
 5943|     12|            if (nlinks > 0UL) {
 5944|      8|                if (is_dir) {
 5945|      8|                    nlinks -= (nlink_t)nostat;
 5946|      8|                }
 5947|      8|            }
 5948|     12|            p->fts_link = (struct _ftsent *)((void *)0);
 5949|     12|            if ((unsigned long)head == (unsigned long)((void *)0)) {
 5950|      8|                tail = p;
 5951|      8|                head = tail;
 5952|      8|            }
 5953|      4|            else {
 5954|      4|                tail->fts_link = p;
 5955|      4|                tail = p;
 5956|      4|            }
 5957|     12|            nitems++;
 5958|     32|__Cont:
 5959|     32|            ;
 5960|     32|        }
 5961|     10|while_break___0:
 5962|     10|        ;
 5963|     10|        if (dirp) {
 5964|     10|            closedir(dirp);
 5965|     10|        }
 5966|     10|        if (doadjust) {
 5967|      0|            fts_padjust(sp, head);
 5968|      0|        }
 5969|     10|        if (sp->fts_options & 4) {
 5970|      0|            if (len == sp->fts_pathlen) {
 5971|      0|                cp--;
 5972|      0|            }
 5973|      0|            else {
 5974|      0|                if (nitems == 0UL) {
 5975|      0|                    cp--;
 5976|      0|                }
 5977|      0|            }
 5978|      0|            *cp = (char)'\000';
 5979|      0|        }
 5980|     10|        if (descend) {
 5981|     10|            if (type == 1) {
 5982|      0|                goto _L___2;
 5983|      0|            }
 5984|     10|            else {
 5985|     10|                if (!nitems) {
 5986|      2|_L___2:
 5987|      2|                    if (cur->fts_level == 0L) {
 5988|      1|                        fd_ring_clear(&sp->fts_fd_ring);
 5989|      1|                        if (!(sp->fts_options & 4)) {
 5990|      1|                            if (sp->fts_options & 512) {
 5991|      1|                                if (sp->fts_options & 512) {
 5992|      1|                                    tmp___20 = -100;
 5993|      1|                                }
 5994|      0|                                else {
 5995|      0|                                    tmp___20 = sp->fts_rfd;
 5996|      0|                                }
 5997|      1|                                cwd_advance_fd(sp, tmp___20, (_Bool)1);
 5998|      1|                                tmp___23 = 0;
 5999|      1|                            }
 6000|      0|                            else {
 6001|      0|                                if (sp->fts_options & 512) {
 6002|      0|                                    tmp___21 = -100;
 6003|      0|                                }
 6004|      0|                                else {
 6005|      0|                                    tmp___21 = sp->fts_rfd;
 6006|      0|                                }
 6007|      0|                                tmp___22 = fchdir(tmp___21);
 6008|      0|                                tmp___23 = tmp___22;
 6009|      0|                            }
 6010|      1|                            if (tmp___23) {
 6011|      0|                                tmp___24 = 1;
 6012|      0|                            }
 6013|      1|                            else {
 6014|      1|                                tmp___24 = 0;
 6015|      1|                            }
 6016|      1|                        }
 6017|      0|                        else {
 6018|      0|                            tmp___24 = 0;
 6019|      0|                        }
 6020|      1|                        tmp___26 = tmp___24;
 6021|      1|                    }
 6022|      1|                    else {
 6023|      1|                        tmp___25 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
 6024|      1|                        tmp___26 = tmp___25;
 6025|      1|                    }
 6026|      2|                    if (tmp___26) {
 6027|      0|                        cur->fts_info = (unsigned short)7;
 6028|      0|                        sp->fts_options |= 8192;
 6029|      0|                        fts_lfree(head);
 6030|      0|                        return ((FTSENT *)((void *)0));
 6031|      0|                    }
 6032|      2|                }
 6033|     10|            }
 6034|     10|        }
 6035|     10|        if (!nitems) {
 6036|      2|            if (type == 3) {
 6037|      2|                cur->fts_info = (unsigned short)6;
 6038|      2|            }
 6039|      2|            fts_lfree(head);
 6040|      2|            return ((FTSENT *)((void *)0));
 6041|      2|        }
 6042|      8|        if (nitems > 10000UL) {
 6043|      0|            if (!sp->fts_compar) {
 6044|      0|                if (sp->fts_options & 512) {
 6045|      0|                    tmp___27 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
 6046|      0|                    if (tmp___27) {
 6047|      0|                        sp->fts_compar = &fts_compare_ino;
 6048|      0|                        head = fts_sort(sp, head, nitems);
 6049|      0|                        sp->fts_compar = (int (*)(struct _ftsent const **, struct _ftsent const **))((void *)0);
 6050|      0|                    }
 6051|      0|                }
 6052|      0|            }
 6053|      0|        }
 6054|      8|        if (sp->fts_compar) {
 6055|      0|            if (nitems > 1UL) {
 6056|      0|                head = fts_sort(sp, head, nitems);
 6057|      0|            }
 6058|      0|        }
 6059|      8|        return (head);
 6060|     10|    }
 6061|     10|}
 6062|       |static unsigned short fts_stat(FTS *sp, FTSENT *p, _Bool follow)
 6063|     12|{
 6064|     12|    struct stat *sbp;
 6065|     12|    int saved_errno;
 6066|     12|    int *tmp;
 6067|     12|    int *tmp___0;
 6068|     12|    int *tmp___1;
 6069|     12|    int tmp___2;
 6070|     12|    int tmp___3;
 6071|     12|    int *tmp___4;
 6072|     12|    int tmp___5;
 6073|     12|    int tmp___6;
 6074|     12|    int tmp___7;
 6075|       |
 6076|     12|    {
 6077|     12|        sbp = p->fts_statp;
 6078|     12|        if (p->fts_level == 0L) {
 6079|      4|            if (sp->fts_options & 1) {
 6080|      0|                follow = (_Bool)1;
 6081|      0|            }
 6082|      4|        }
 6083|     12|        if (sp->fts_options & 2) {
 6084|      0|            goto _L;
 6085|      0|        }
 6086|     12|        else {
 6087|     12|            if (follow) {
 6088|      0|_L:
 6089|      0|                tmp___3 = stat((char const *)p->fts_accpath, sbp);
 6090|      0|                if (tmp___3) {
 6091|      0|                    tmp = __errno_location();
 6092|      0|                    saved_errno = *tmp;
 6093|      0|                    tmp___1 = __errno_location();
 6094|      0|                    if (*tmp___1 == 2) {
 6095|      0|                        tmp___2 = lstat((char const *)p->fts_accpath, sbp);
 6096|      0|                        if (tmp___2 == 0) {
 6097|      0|                            tmp___0 = __errno_location();
 6098|      0|                            *tmp___0 = 0;
 6099|      0|                            return ((unsigned short)13);
 6100|      0|                        }
 6101|      0|                    }
 6102|      0|                    p->fts_errno = saved_errno;
 6103|      0|                    goto err;
 6104|      0|                }
 6105|      0|            }
 6106|     12|            else {
 6107|     12|                tmp___5 =
 6108|     12|                    fstatat(sp->fts_cwd_fd, (char const *)p->fts_accpath, sbp, 256);
 6109|     12|                if (tmp___5) {
 6110|      0|                    tmp___4 = __errno_location();
 6111|      0|                    p->fts_errno = *tmp___4;
 6112|      0|err:
 6113|      0|                    memset((void *)sbp, 0, sizeof(struct stat));
 6114|      0|                    return ((unsigned short)10);
 6115|      0|                }
 6116|     12|            }
 6117|     12|        }
 6118|     12|        if ((sbp->st_mode & 61440U) == 16384U) {
 6119|     10|            if (sp->fts_options & 32) {
 6120|      0|                tmp___6 = 0;
 6121|      0|            }
 6122|     10|            else {
 6123|     10|                tmp___6 = 2;
 6124|     10|            }
 6125|     10|            p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t)tmp___6;
 6126|     10|            if ((int)p->fts_name[0] == 46) {
 6127|      0|                if (!p->fts_name[1]) {
 6128|      0|                    goto _L___0;
 6129|      0|                }
 6130|      0|                else {
 6131|      0|                    if ((int)p->fts_name[1] == 46) {
 6132|      0|                        if (!p->fts_name[2]) {
 6133|      0|_L___0:
 6134|      0|                            if (p->fts_level == 0L) {
 6135|      0|                                tmp___7 = 1;
 6136|      0|                            }
 6137|      0|                            else {
 6138|      0|                                tmp___7 = 5;
 6139|      0|                            }
 6140|      0|                            return ((unsigned short)tmp___7);
 6141|      0|                        }
 6142|      0|                    }
 6143|      0|                }
 6144|      0|            }
 6145|     10|            return ((unsigned short)1);
 6146|     10|        }
 6147|      2|        if ((sbp->st_mode & 61440U) == 40960U) {
 6148|      0|            return ((unsigned short)12);
 6149|      0|        }
 6150|      2|        if ((sbp->st_mode & 61440U) == 32768U) {
 6151|      2|            return ((unsigned short)8);
 6152|      2|        }
 6153|      0|        return ((unsigned short)3);
 6154|      2|    }
 6155|      2|}
 6156|       |static int fts_compar(void const *a, void const *b)
 6157|      0|{
 6158|      0|    FTSENT const **pa;
 6159|      0|    FTSENT const **pb;
 6160|      0|    int tmp;
 6161|       |
 6162|      0|    {
 6163|      0|        pa = (FTSENT const **)a;
 6164|      0|        pb = (FTSENT const **)b;
 6165|      0|        tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
 6166|      0|        return (tmp);
 6167|      0|    }
 6168|      0|}
 6169|       |static FTSENT *fts_sort(FTS *sp, FTSENT *head, size_t nitems)
 6170|      0|{
 6171|      0|    register FTSENT **ap;
 6172|      0|    register FTSENT *p;
 6173|      0|    FTSENT *dummy = 0;
 6174|      0|    int (*compare)(void const *, void const *);
 6175|      0|    int (*tmp)(void const *, void const *);
 6176|      0|    FTSENT **a;
 6177|      0|    FTSENT **tmp___0;
 6178|       |
 6179|      0|    {
 6180|      0|        if (sizeof(&dummy) == sizeof(void *)) {
 6181|      0|            if ((long)(&dummy) == (long)((void *)(&dummy))) {
 6182|      0|                tmp = (int (*)(void const *, void const *))sp->fts_compar;
 6183|      0|            }
 6184|      0|            else {
 6185|      0|                tmp = &fts_compar;
 6186|      0|            }
 6187|      0|        }
 6188|      0|        else {
 6189|      0|            tmp = &fts_compar;
 6190|      0|        }
 6191|      0|        compare = tmp;
 6192|      0|        if (nitems > sp->fts_nitems) {
 6193|      0|            sp->fts_nitems = nitems + 40UL;
 6194|      0|            if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
 6195|      0|                free((void *)sp->fts_array);
 6196|      0|                sp->fts_array = (struct _ftsent **)((void *)0);
 6197|      0|                sp->fts_nitems = (size_t)0;
 6198|      0|                return (head);
 6199|      0|            }
 6200|      0|            else {
 6201|      0|                a = (FTSENT **)realloc((void *)sp->fts_array,
 6202|      0|                                       sp->fts_nitems * sizeof(*a));
 6203|      0|                if (!a) {
 6204|      0|                    free((void *)sp->fts_array);
 6205|      0|                    sp->fts_array = (struct _ftsent **)((void *)0);
 6206|      0|                    sp->fts_nitems = (size_t)0;
 6207|      0|                    return (head);
 6208|      0|                }
 6209|      0|            }
 6210|      0|            sp->fts_array = a;
 6211|      0|        }
 6212|      0|        ap = sp->fts_array;
 6213|      0|        p = head;
 6214|      0|        while (1) {
 6215|       |
 6216|      0|            if (!p) {
 6217|      0|                goto while_break;
 6218|      0|            }
 6219|      0|            tmp___0 = ap;
 6220|      0|            ap++;
 6221|      0|            *tmp___0 = p;
 6222|      0|            p = p->fts_link;
 6223|      0|        }
 6224|      0|while_break:
 6225|      0|        qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
 6226|      0|        ap = sp->fts_array;
 6227|      0|        head = *ap;
 6228|      0|        while (1) {
 6229|      0|            nitems--;
 6230|      0|            if (!nitems) {
 6231|      0|                goto while_break___0;
 6232|      0|            }
 6233|      0|            (*(ap + 0))->fts_link = *(ap + 1);
 6234|      0|            ap++;
 6235|      0|        }
 6236|      0|while_break___0:
 6237|      0|        (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
 6238|      0|        return (head);
 6239|      0|    }
 6240|      0|}
 6241|       |static FTSENT *fts_alloc(FTS *sp, char const *name, size_t namelen)
 6242|     20|{
 6243|     20|    register FTSENT *p;
 6244|     20|    size_t len;
 6245|       |
 6246|     20|    {
 6247|     20|        len = sizeof(FTSENT) + namelen;
 6248|     20|        p = (FTSENT *)malloc(len);
 6249|     20|        if ((unsigned long)p == (unsigned long)((void *)0)) {
 6250|      0|            return ((FTSENT *)((void *)0));
 6251|      0|        }
 6252|     20|        memmove((void *)(p->fts_name), (void const *)name, namelen);
 6253|     20|        p->fts_name[namelen] = (char)'\000';
 6254|     20|        p->fts_namelen = namelen;
 6255|     20|        p->fts_fts = sp;
 6256|     20|        p->fts_path = sp->fts_path;
 6257|     20|        p->fts_errno = 0;
 6258|     20|        p->fts_flags = (unsigned short)0;
 6259|     20|        p->fts_instr = (unsigned short)3;
 6260|     20|        p->fts_number = 0L;
 6261|     20|        p->fts_pointer = (void *)0;
 6262|     20|        return (p);
 6263|     20|    }
 6264|     20|}
 6265|       |static void fts_lfree(FTSENT *head)
 6266|      2|{
 6267|      2|    register FTSENT *p;
 6268|       |
 6269|      2|    {
 6270|      2|        while (1) {
 6271|      2|            p = head;
 6272|      2|            if (!p) {
 6273|      2|                goto while_break;
 6274|      2|            }
 6275|      0|            head = head->fts_link;
 6276|      0|            free((void *)p);
 6277|      0|        }
 6278|      2|while_break:
 6279|      2|        ;
 6280|      2|        return;
 6281|      2|    }
 6282|      2|}
 6283|       |static _Bool fts_palloc(FTS *sp, size_t more)
 6284|      2|{
 6285|      2|    char *p;
 6286|      2|    size_t new_len;
 6287|      2|    int *tmp;
 6288|       |
 6289|      2|    {
 6290|      2|        new_len = (sp->fts_pathlen + more) + 256UL;
 6291|      2|        if (new_len < sp->fts_pathlen) {
 6292|      0|            free((void *)sp->fts_path);
 6293|      0|            sp->fts_path = (char *)((void *)0);
 6294|      0|            tmp = __errno_location();
 6295|      0|            *tmp = 36;
 6296|      0|            return ((_Bool)0);
 6297|      0|        }
 6298|      2|        sp->fts_pathlen = new_len;
 6299|      2|        p = (char *)realloc((void *)sp->fts_path, sp->fts_pathlen);
 6300|      2|        if ((unsigned long)p == (unsigned long)((void *)0)) {
 6301|      0|            free((void *)sp->fts_path);
 6302|      0|            sp->fts_path = (char *)((void *)0);
 6303|      0|            return ((_Bool)0);
 6304|      0|        }
 6305|      2|        sp->fts_path = p;
 6306|      2|        return ((_Bool)1);
 6307|      2|    }
 6308|      2|}
 6309|       |static void fts_padjust(FTS *sp, FTSENT *head)
 6310|      0|{
 6311|      0|    FTSENT *p;
 6312|      0|    char *addr;
 6313|       |
 6314|      0|    {
 6315|      0|        addr = sp->fts_path;
 6316|      0|        p = sp->fts_child;
 6317|      0|        while (1) {
 6318|       |
 6319|      0|            if (!p) {
 6320|      0|                goto while_break;
 6321|      0|            }
 6322|      0|            while (1) {
 6323|       |
 6324|      0|                if ((unsigned long)p->fts_accpath != (unsigned long)(p->fts_name)) {
 6325|      0|                    p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
 6326|      0|                }
 6327|      0|                p->fts_path = addr;
 6328|      0|                goto while_break___0;
 6329|      0|            }
 6330|      0|while_break___0:
 6331|      0|            p = p->fts_link;
 6332|      0|        }
 6333|      0|while_break:
 6334|      0|        p = head;
 6335|      0|        while (1) {
 6336|       |
 6337|      0|            if (!(p->fts_level >= 0L)) {
 6338|      0|                goto while_break___1;
 6339|      0|            }
 6340|      0|            while (1) {
 6341|       |
 6342|      0|                if ((unsigned long)p->fts_accpath != (unsigned long)(p->fts_name)) {
 6343|      0|                    p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
 6344|      0|                }
 6345|      0|                p->fts_path = addr;
 6346|      0|                goto while_break___2;
 6347|      0|            }
 6348|      0|while_break___2:
 6349|      0|            ;
 6350|      0|            if (p->fts_link) {
 6351|      0|                p = p->fts_link;
 6352|      0|            }
 6353|      0|            else {
 6354|      0|                p = p->fts_parent;
 6355|      0|            }
 6356|      0|        }
 6357|      0|while_break___1:
 6358|      0|        ;
 6359|      0|        return;
 6360|      0|    }
 6361|      0|}
 6362|       |static size_t fts_maxarglen(char *const *argv)
 6363|      2|{
 6364|      2|    size_t len;
 6365|      2|    size_t max;
 6366|       |
 6367|      2|    {
 6368|      2|        max = (size_t)0;
 6369|      6|        while (1) {
 6370|       |
 6371|      6|            if (!*argv) {
 6372|      2|                goto while_break;
 6373|      2|            }
 6374|      4|            len = strlen((char const *)*argv);
 6375|      4|            if (len > max) {
 6376|      3|                max = len;
 6377|      3|            }
 6378|      4|            argv++;
 6379|      4|        }
 6380|      2|while_break:
 6381|      2|        ;
 6382|      2|        return (max + 1UL);
 6383|      2|    }
 6384|      2|}
 6385|       |static int fts_safe_changedir(FTS *sp, FTSENT *p, int fd, char const *dir)
 6386|     18|{
 6387|     18|    int ret;
 6388|     18|    _Bool is_dotdot;
 6389|     18|    int tmp;
 6390|     18|    int tmp___0;
 6391|     18|    int newfd;
 6392|     18|    int parent_fd;
 6393|     18|    _Bool tmp___1;
 6394|     18|    struct stat sb;
 6395|     18|    int tmp___2;
 6396|     18|    int *tmp___3;
 6397|     18|    int tmp___4;
 6398|     18|    int oerrno;
 6399|     18|    int *tmp___5;
 6400|     18|    int *tmp___6;
 6401|       |
 6402|     18|    {
 6403|     18|        if (dir) {
 6404|      8|            tmp = strcmp(dir, "..");
 6405|      8|            if (tmp == 0) {
 6406|      8|                tmp___0 = 1;
 6407|      8|            }
 6408|      0|            else {
 6409|      0|                tmp___0 = 0;
 6410|      0|            }
 6411|      8|        }
 6412|     10|        else {
 6413|     10|            tmp___0 = 0;
 6414|     10|        }
 6415|     18|        is_dotdot = (_Bool)tmp___0;
 6416|     18|        if (sp->fts_options & 4) {
 6417|      0|            if (sp->fts_options & 512) {
 6418|      0|                if (0 <= fd) {
 6419|      0|                    close(fd);
 6420|      0|                }
 6421|      0|            }
 6422|      0|            return (0);
 6423|      0|        }
 6424|     18|        if (fd < 0) {
 6425|      8|            if (is_dotdot) {
 6426|      8|                if (sp->fts_options & 512) {
 6427|      8|                    tmp___1 = i_ring_empty((I_ring const *)(&sp->fts_fd_ring));
 6428|      8|                    if (!tmp___1) {
 6429|      4|                        parent_fd = i_ring_pop(&sp->fts_fd_ring);
 6430|      4|                        is_dotdot = (_Bool)1;
 6431|      4|                        if (0 <= parent_fd) {
 6432|      4|                            fd = parent_fd;
 6433|      4|                            dir = (char const *)((void *)0);
 6434|      4|                        }
 6435|      4|                    }
 6436|      8|                }
 6437|      8|            }
 6438|      8|        }
 6439|     18|        newfd = fd;
 6440|     18|        if (fd < 0) {
 6441|      4|            newfd = diropen((FTS const *)sp, dir);
 6442|      4|            if (newfd < 0) {
 6443|      0|                return (-1);
 6444|      0|            }
 6445|      4|        }
 6446|     18|        if (sp->fts_options & 2) {
 6447|      0|            goto _L;
 6448|      0|        }
 6449|     18|        else {
 6450|     18|            if (dir) {
 6451|      4|                tmp___4 = strcmp(dir, "..");
 6452|      4|                if (tmp___4 == 0) {
 6453|      4|_L:
 6454|      4|                    tmp___2 = fstat(newfd, &sb);
 6455|      4|                    if (tmp___2) {
 6456|      0|                        ret = -1;
 6457|      0|                        goto bail;
 6458|      0|                    }
 6459|      4|                    if (p->fts_statp[0].st_dev != sb.st_dev) {
 6460|      0|                        tmp___3 = __errno_location();
 6461|      0|                        *tmp___3 = 2;
 6462|      0|                        ret = -1;
 6463|      0|                        goto bail;
 6464|      0|                    }
 6465|      4|                    else {
 6466|      4|                        if (p->fts_statp[0].st_ino != sb.st_ino) {
 6467|      0|                            tmp___3 = __errno_location();
 6468|      0|                            *tmp___3 = 2;
 6469|      0|                            ret = -1;
 6470|      0|                            goto bail;
 6471|      0|                        }
 6472|      4|                    }
 6473|      4|                }
 6474|      4|            }
 6475|     18|        }
 6476|     18|        if (sp->fts_options & 512) {
 6477|     18|            cwd_advance_fd(sp, newfd, (_Bool)(!is_dotdot));
 6478|     18|            return (0);
 6479|     18|        }
 6480|      0|        ret = fchdir(newfd);
 6481|      0|bail:
 6482|      0|        if (fd < 0) {
 6483|      0|            tmp___5 = __errno_location();
 6484|      0|            oerrno = *tmp___5;
 6485|      0|            close(newfd);
 6486|      0|            tmp___6 = __errno_location();
 6487|      0|            *tmp___6 = oerrno;
 6488|      0|        }
 6489|      0|        return (ret);
 6490|      0|    }
 6491|      0|}
 6492|       |extern int fseeko(FILE *__stream, __off_t __off, int __whence);
 6493|       |extern __attribute__((__nothrow__))
 6494|       |__off_t(__attribute__((__leaf__)) lseek)(int __fd, __off_t __offset,
 6495|       |        int __whence);
 6496|       |int(__attribute__((__nonnull__(1))) rpl_fseeko)(FILE *fp, off_t offset,
 6497|       |        int whence)
 6498|      0|{
 6499|      0|    off_t pos;
 6500|      0|    off_t tmp;
 6501|      0|    int tmp___0;
 6502|      0|    off_t tmp___1;
 6503|      0|    int tmp___2;
 6504|       |
 6505|      0|    {
 6506|      0|        if ((unsigned long)fp->_IO_read_end == (unsigned long)fp->_IO_read_ptr) {
 6507|      0|            if ((unsigned long)fp->_IO_write_ptr ==
 6508|      0|                    (unsigned long)fp->_IO_write_base) {
 6509|      0|                if ((unsigned long)fp->_IO_save_base == (unsigned long)((void *)0)) {
 6510|      0|                    if (whence == 2) {
 6511|      0|                        if (offset > 0L) {
 6512|      0|                            tmp = (off_t)0;
 6513|      0|                        }
 6514|      0|                        else {
 6515|      0|                            tmp = offset;
 6516|      0|                        }
 6517|      0|                    }
 6518|      0|                    else {
 6519|      0|                        tmp = offset;
 6520|      0|                    }
 6521|      0|                    tmp___0 = fileno(fp);
 6522|      0|                    tmp___1 = lseek(tmp___0, tmp, whence);
 6523|      0|                    pos = tmp___1;
 6524|      0|                    if (pos == -1L) {
 6525|      0|                        return (-1);
 6526|      0|                    }
 6527|      0|                    fp->_flags &= -17;
 6528|      0|                    if (whence == 2) {
 6529|      0|                        if (!(offset > 0L)) {
 6530|      0|                            return (0);
 6531|      0|                        }
 6532|      0|                    }
 6533|      0|                    else {
 6534|      0|                        return (0);
 6535|      0|                    }
 6536|      0|                }
 6537|      0|            }
 6538|      0|        }
 6539|      0|        tmp___2 = fseeko(fp, offset, whence);
 6540|      0|        return (tmp___2);
 6541|      0|    }
 6542|      0|}
 6543|       |char const *Version = "8.4";
 6544|       |extern
 6545|       |__attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 6546|       |                                 euidaccess)(char const *__name,
 6547|       |                                         int __type);
 6548|       |extern
 6549|       |__attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
 6550|       |                                 faccessat)(int __fd, char const *__file,
 6551|       |                                         int __type, int __flag);
 6552|       |extern
 6553|       |__attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
 6554|       |                                 unlinkat)(int __fd, char const *__name,
 6555|       |                                         int __flag);
 6556|       |__inline static int lstatat(int fd, char const *name, struct stat *st)
 6557|      0|{
 6558|      0|    int tmp;
 6559|       |
 6560|      0|    {
 6561|      0|        tmp = fstatat(fd, name, st, 256);
 6562|      0|        return (tmp);
 6563|      0|    }
 6564|      0|}
 6565|       |__inline static _Bool dot_or_dotdot(char const *file_name___3)
 6566|      2|{
 6567|      2|    char sep;
 6568|      2|    int tmp;
 6569|       |
 6570|      2|    {
 6571|      2|        if ((int const) * (file_name___3 + 0) == 46) {
 6572|      0|            sep = (char)*(file_name___3 +
 6573|      0|                          (((int const) * (file_name___3 + 1) == 46) + 1));
 6574|      0|            if (!sep) {
 6575|      0|                tmp = 1;
 6576|      0|            }
 6577|      0|            else {
 6578|      0|                if ((int)sep == 47) {
 6579|      0|                    tmp = 1;
 6580|      0|                }
 6581|      0|                else {
 6582|      0|                    tmp = 0;
 6583|      0|                }
 6584|      0|            }
 6585|      0|            return ((_Bool)tmp);
 6586|      0|        }
 6587|      2|        else {
 6588|      2|            return ((_Bool)0);
 6589|      2|        }
 6590|      2|    }
 6591|      2|}
 6592|       |__inline static struct dirent const *
 6593|       |readdir_ignoring_dot_and_dotdot(DIR *dirp)
 6594|      0|{
 6595|      0|    struct dirent const *dp;
 6596|      0|    struct dirent const *tmp;
 6597|      0|    _Bool tmp___0;
 6598|       |
 6599|      0|    {
 6600|      0|        while (1) {
 6601|      0|            tmp = (struct dirent const *)readdir(dirp);
 6602|      0|            dp = tmp;
 6603|      0|            if ((unsigned long)dp == (unsigned long)((void *)0)) {
 6604|      0|                return (dp);
 6605|      0|            }
 6606|      0|            else {
 6607|      0|                tmp___0 = dot_or_dotdot((char const *)(dp->d_name));
 6608|      0|                if (!tmp___0) {
 6609|      0|                    return (dp);
 6610|      0|                }
 6611|      0|            }
 6612|      0|        }
 6613|       |
 6614|      0|        return ((struct dirent const *)0);
 6615|      0|    }
 6616|      0|}
 6617|       |__inline static _Bool is_empty_dir(int fd_cwd, char const *dir)
 6618|      0|{
 6619|      0|    DIR *dirp;
 6620|      0|    struct dirent const *dp;
 6621|      0|    int saved_errno;
 6622|      0|    int fd;
 6623|      0|    int tmp;
 6624|      0|    int *tmp___0;
 6625|      0|    int *tmp___1;
 6626|      0|    int tmp___2;
 6627|       |
 6628|      0|    {
 6629|      0|        tmp = openat(fd_cwd, dir, 198912);
 6630|      0|        fd = tmp;
 6631|      0|        if (fd < 0) {
 6632|      0|            return ((_Bool)0);
 6633|      0|        }
 6634|      0|        dirp = fdopendir(fd);
 6635|      0|        if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 6636|      0|            close(fd);
 6637|      0|            return ((_Bool)0);
 6638|      0|        }
 6639|      0|        tmp___0 = __errno_location();
 6640|      0|        *tmp___0 = 0;
 6641|      0|        dp = readdir_ignoring_dot_and_dotdot(dirp);
 6642|      0|        tmp___1 = __errno_location();
 6643|      0|        saved_errno = *tmp___1;
 6644|      0|        closedir(dirp);
 6645|      0|        if ((unsigned long)dp != (unsigned long)((void *)0)) {
 6646|      0|            return ((_Bool)0);
 6647|      0|        }
 6648|      0|        if (saved_errno == 0) {
 6649|      0|            tmp___2 = 1;
 6650|      0|        }
 6651|      0|        else {
 6652|      0|            tmp___2 = 0;
 6653|      0|        }
 6654|      0|        return ((_Bool)tmp___2);
 6655|      0|    }
 6656|      0|}
 6657|       |enum RM_status rm(char *const *file, struct rm_options const *x);
 6658|       |static int cache_fstatat(int fd, char const *file, struct stat *st, int flag)
 6659|      0|{
 6660|      0|    int *tmp;
 6661|      0|    int tmp___0;
 6662|      0|    int *tmp___1;
 6663|       |
 6664|      0|    {
 6665|      0|        if (st->st_size == -1L) {
 6666|      0|            tmp___0 = fstatat(fd, file, st, flag);
 6667|      0|            if (tmp___0 != 0) {
 6668|      0|                st->st_size = (__off_t)-2;
 6669|      0|                tmp = __errno_location();
 6670|      0|                st->st_ino = (__ino_t)*tmp;
 6671|      0|            }
 6672|      0|        }
 6673|      0|        if (0L <= st->st_size) {
 6674|      0|            return (0);
 6675|      0|        }
 6676|      0|        tmp___1 = __errno_location();
 6677|      0|        *tmp___1 = (int)st->st_ino;
 6678|      0|        return (-1);
 6679|      0|    }
 6680|      0|}
 6681|       |__inline static struct stat *cache_stat_init(struct stat *st)
 6682|     26|{
 6683|       |
 6684|     26|    {
 6685|     26|        st->st_size = (__off_t)-1;
 6686|     26|        return (st);
 6687|     26|    }
 6688|     26|}
 6689|       |static int write_protected_non_symlink(int fd_cwd, char const *file,
 6690|       |                                       char const *full_name,
 6691|       |                                       struct stat *buf___1)
 6692|      0|{
 6693|      0|    _Bool tmp;
 6694|      0|    int tmp___0;
 6695|      0|    int tmp___1;
 6696|      0|    size_t file_name_len;
 6697|      0|    size_t tmp___2;
 6698|      0|    _Bool tmp___3;
 6699|      0|    int tmp___4;
 6700|      0|    int tmp___5;
 6701|      0|    int *tmp___6;
 6702|      0|    int *tmp___7;
 6703|       |
 6704|      0|    {
 6705|      0|        tmp = can_write_any_file();
 6706|      0|        if (tmp) {
 6707|      0|            return (0);
 6708|      0|        }
 6709|      0|        tmp___0 = cache_fstatat(fd_cwd, file, buf___1, 256);
 6710|      0|        if (tmp___0 != 0) {
 6711|      0|            return (-1);
 6712|      0|        }
 6713|      0|        if ((buf___1->st_mode & 61440U) == 40960U) {
 6714|      0|            return (0);
 6715|      0|        }
 6716|      0|        tmp___1 = faccessat(fd_cwd, file, 2, 512);
 6717|      0|        if (tmp___1 == 0) {
 6718|      0|            return (0);
 6719|      0|        }
 6720|      0|        tmp___2 = strlen(full_name);
 6721|      0|        file_name_len = tmp___2;
 6722|      0|        if (4096UL <= file_name_len) {
 6723|      0|            tmp___3 = euidaccess_stat((struct stat const *)buf___1, 2);
 6724|      0|            if (tmp___3) {
 6725|      0|                tmp___4 = 0;
 6726|      0|            }
 6727|      0|            else {
 6728|      0|                tmp___4 = 1;
 6729|      0|            }
 6730|      0|            return (tmp___4);
 6731|      0|        }
 6732|      0|        tmp___5 = euidaccess(full_name, 2);
 6733|      0|        if (tmp___5 == 0) {
 6734|      0|            return (0);
 6735|      0|        }
 6736|      0|        tmp___7 = __errno_location();
 6737|      0|        if (*tmp___7 == 13) {
 6738|      0|            tmp___6 = __errno_location();
 6739|      0|            *tmp___6 = 0;
 6740|      0|            return (1);
 6741|      0|        }
 6742|      0|        return (-1);
 6743|      0|    }
 6744|      0|}
 6745|       |static enum RM_status prompt(FTS const *fts, FTSENT const *ent, _Bool is_dir,
 6746|       |                             struct rm_options const *x,
 6747|       |                             enum Prompt_action mode, Ternary *is_empty_p)
 6748|     26|{
 6749|     26|    int fd_cwd;
 6750|     26|    char const *full_name;
 6751|     26|    char const *filename;
 6752|     26|    struct stat st;
 6753|     26|    struct stat *sbuf;
 6754|     26|    int dirent_type;
 6755|     26|    int tmp;
 6756|     26|    int write_protected;
 6757|     26|    int wp_errno;
 6758|     26|    int *tmp___0;
 6759|     26|    int *tmp___1;
 6760|     26|    int tmp___2;
 6761|     26|    char const *quoted_name;
 6762|     26|    char const *tmp___3;
 6763|     26|    char *tmp___4;
 6764|     26|    _Bool is_empty;
 6765|     26|    char *tmp___5;
 6766|     26|    char *tmp___6;
 6767|     26|    char *tmp___7;
 6768|     26|    char *tmp___8;
 6769|     26|    int *tmp___9;
 6770|     26|    int tmp___10;
 6771|     26|    char const *tmp___11;
 6772|     26|    char *tmp___12;
 6773|     26|    char *tmp___13;
 6774|     26|    char *tmp___14;
 6775|     26|    _Bool tmp___15;
 6776|       |
 6777|     26|    {
 6778|     26|        fd_cwd = (int)fts->fts_cwd_fd;
 6779|     26|        full_name = (char const *)ent->fts_path;
 6780|     26|        filename = (char const *)ent->fts_accpath;
 6781|     26|        if (is_empty_p) {
 6782|     10|            *is_empty_p = (Ternary)2;
 6783|     10|        }
 6784|     26|        sbuf = &st;
 6785|     26|        cache_stat_init(sbuf);
 6786|     26|        if (is_dir) {
 6787|     20|            tmp = 4;
 6788|     20|        }
 6789|      6|        else {
 6790|      6|            tmp = 0;
 6791|      6|        }
 6792|     26|        dirent_type = tmp;
 6793|     26|        write_protected = 0;
 6794|     26|        if (ent->fts_number) {
 6795|      0|            return ((enum RM_status)3);
 6796|      0|        }
 6797|     26|        if ((unsigned int const)x->interactive == 5U) {
 6798|     26|            return ((enum RM_status)2);
 6799|     26|        }
 6800|      0|        wp_errno = 0;
 6801|      0|        if (!x->ignore_missing_files) {
 6802|      0|            if ((unsigned int const)x->interactive == 3U) {
 6803|      0|                goto _L;
 6804|      0|            }
 6805|      0|            else {
 6806|      0|                if (x->stdin_tty) {
 6807|      0|_L:
 6808|      0|                    if (dirent_type != 10) {
 6809|      0|                        write_protected =
 6810|      0|                            write_protected_non_symlink(fd_cwd, filename, full_name, sbuf);
 6811|      0|                        tmp___0 = __errno_location();
 6812|      0|                        wp_errno = *tmp___0;
 6813|      0|                    }
 6814|      0|                }
 6815|      0|            }
 6816|      0|        }
 6817|      0|        if (write_protected) {
 6818|      0|            goto _L___2;
 6819|      0|        }
 6820|      0|        else {
 6821|      0|            if ((unsigned int const)x->interactive == 3U) {
 6822|      0|_L___2:
 6823|      0|                if (0 <= write_protected) {
 6824|      0|                    if (dirent_type == 0) {
 6825|      0|                        tmp___2 = cache_fstatat(fd_cwd, filename, sbuf, 256);
 6826|      0|                        if (tmp___2 == 0) {
 6827|      0|                            if ((sbuf->st_mode & 61440U) == 40960U) {
 6828|      0|                                dirent_type = 10;
 6829|      0|                            }
 6830|      0|                            else {
 6831|      0|                                if ((sbuf->st_mode & 61440U) == 16384U) {
 6832|      0|                                    dirent_type = 4;
 6833|      0|                                }
 6834|      0|                            }
 6835|      0|                        }
 6836|      0|                        else {
 6837|      0|                            write_protected = -1;
 6838|      0|                            tmp___1 = __errno_location();
 6839|      0|                            wp_errno = *tmp___1;
 6840|      0|                        }
 6841|      0|                    }
 6842|      0|                }
 6843|      0|                if (0 <= write_protected) {
 6844|      0|                    if (dirent_type == 10) {
 6845|      0|                        goto case_10;
 6846|      0|                    }
 6847|      0|                    if (dirent_type == 4) {
 6848|      0|                        goto case_4;
 6849|      0|                    }
 6850|      0|                    goto switch_break;
 6851|      0|case_10:
 6852|      0|                    if ((unsigned int const)x->interactive != 3U) {
 6853|      0|                        return ((enum RM_status)2);
 6854|      0|                    }
 6855|      0|                    goto switch_break;
 6856|      0|case_4:
 6857|      0|                    if (!x->recursive) {
 6858|      0|                        write_protected = -1;
 6859|      0|                        wp_errno = 21;
 6860|      0|                    }
 6861|      0|                    goto switch_break;
 6862|      0|switch_break:
 6863|      0|                    ;
 6864|      0|                }
 6865|      0|                tmp___3 = quote(full_name);
 6866|      0|                quoted_name = tmp___3;
 6867|      0|                if (write_protected < 0) {
 6868|      0|                    tmp___4 = gettext("cannot remove %s");
 6869|      0|                    error(0, wp_errno, (char const *)tmp___4, quoted_name);
 6870|      0|                    return ((enum RM_status)4);
 6871|      0|                }
 6872|      0|                if (is_empty_p) {
 6873|      0|                    is_empty = is_empty_dir(fd_cwd, filename);
 6874|      0|                    if (is_empty) {
 6875|      0|                        *is_empty_p = (Ternary)4;
 6876|      0|                    }
 6877|      0|                    else {
 6878|      0|                        *is_empty_p = (Ternary)3;
 6879|      0|                    }
 6880|      0|                }
 6881|      0|                else {
 6882|      0|                    is_empty = (_Bool)0;
 6883|      0|                }
 6884|      0|                if (dirent_type == 4) {
 6885|      0|                    if ((unsigned int)mode == 2U) {
 6886|      0|                        if (!is_empty) {
 6887|      0|                            if (write_protected) {
 6888|      0|                                tmp___5 =
 6889|      0|                                    gettext("%s: descend into write-protected directory %s? ");
 6890|      0|                                tmp___7 = tmp___5;
 6891|      0|                            }
 6892|      0|                            else {
 6893|      0|                                tmp___6 = gettext("%s: descend into directory %s? ");
 6894|      0|                                tmp___7 = tmp___6;
 6895|      0|                            }
 6896|      0|                            fprintf(stderr, (char const *)tmp___7, program_name, quoted_name);
 6897|      0|                        }
 6898|      0|                        else {
 6899|      0|                            goto _L___1;
 6900|      0|                        }
 6901|      0|                    }
 6902|      0|                    else {
 6903|      0|                        goto _L___1;
 6904|      0|                    }
 6905|      0|                }
 6906|      0|                else {
 6907|      0|_L___1:
 6908|      0|                    tmp___10 = cache_fstatat(fd_cwd, filename, sbuf, 256);
 6909|      0|                    if (tmp___10 != 0) {
 6910|      0|                        tmp___8 = gettext("cannot remove %s");
 6911|      0|                        tmp___9 = __errno_location();
 6912|      0|                        error(0, *tmp___9, (char const *)tmp___8, quoted_name);
 6913|      0|                        return ((enum RM_status)4);
 6914|      0|                    }
 6915|      0|                    tmp___11 = file_type((struct stat const *)sbuf);
 6916|      0|                    if (write_protected) {
 6917|      0|                        tmp___12 = gettext("%s: remove write-protected %s %s? ");
 6918|      0|                        tmp___14 = tmp___12;
 6919|      0|                    }
 6920|      0|                    else {
 6921|      0|                        tmp___13 = gettext("%s: remove %s %s? ");
 6922|      0|                        tmp___14 = tmp___13;
 6923|      0|                    }
 6924|      0|                    fprintf(stderr, (char const *)tmp___14, program_name, tmp___11,
 6925|      0|                            quoted_name);
 6926|      0|                }
 6927|      0|                tmp___15 = yesno();
 6928|      0|                if (!tmp___15) {
 6929|      0|                    return ((enum RM_status)3);
 6930|      0|                }
 6931|      0|            }
 6932|      0|        }
 6933|      0|        return ((enum RM_status)2);
 6934|      0|    }
 6935|      0|}
 6936|       |__inline static _Bool nonexistent_file_errno(int errnum)
 6937|      0|{
 6938|       |
 6939|      0|    {
 6940|      0|        if (errnum == 2) {
 6941|      0|            goto case_2;
 6942|      0|        }
 6943|      0|        if (errnum == 20) {
 6944|      0|            goto case_2;
 6945|      0|        }
 6946|      0|        goto switch_default;
 6947|      0|case_2:
 6948|      0|        return ((_Bool)1);
 6949|      0|switch_default:
 6950|      0|        return ((_Bool)0);
 6951|       |
 6952|      0|        return ((_Bool)0);
 6953|      0|    }
 6954|      0|}
 6955|       |__inline static _Bool ignorable_missing(struct rm_options const *x,
 6956|       |                                        int errnum)
 6957|      0|{
 6958|      0|    _Bool tmp;
 6959|      0|    int tmp___0;
 6960|       |
 6961|      0|    {
 6962|      0|        if (x->ignore_missing_files) {
 6963|      0|            tmp = nonexistent_file_errno(errnum);
 6964|      0|            if (tmp) {
 6965|      0|                tmp___0 = 1;
 6966|      0|            }
 6967|      0|            else {
 6968|      0|                tmp___0 = 0;
 6969|      0|            }
 6970|      0|        }
 6971|      0|        else {
 6972|      0|            tmp___0 = 0;
 6973|      0|        }
 6974|      0|        return ((_Bool)tmp___0);
 6975|      0|    }
 6976|      0|}
 6977|       |static void fts_skip_tree(FTS *fts, FTSENT *ent)
 6978|      0|{
 6979|       |
 6980|      0|    {
 6981|      0|        fts_set(fts, ent, 4);
 6982|      0|        ent = fts_read(fts);
 6983|      0|        return;
 6984|      0|    }
 6985|      0|}
 6986|       |static void mark_ancestor_dirs(FTSENT *ent)
 6987|      0|{
 6988|      0|    FTSENT *p;
 6989|       |
 6990|      0|    {
 6991|      0|        p = ent->fts_parent;
 6992|      0|        while (1) {
 6993|       |
 6994|      0|            if (!(0L <= p->fts_level)) {
 6995|      0|                goto while_break;
 6996|      0|            }
 6997|      0|            if (p->fts_number) {
 6998|      0|                goto while_break;
 6999|      0|            }
 7000|      0|            p->fts_number = 1L;
 7001|      0|            p = p->fts_parent;
 7002|      0|        }
 7003|      0|while_break:
 7004|      0|        ;
 7005|      0|        return;
 7006|      0|    }
 7007|      0|}
 7008|       |static enum RM_status excise(FTS *fts, FTSENT *ent, struct rm_options const *x,
 7009|       |                             _Bool is_dir)
 7010|     16|{
 7011|     16|    int flag;
 7012|     16|    int tmp;
 7013|     16|    char const *tmp___0;
 7014|     16|    char *tmp___1;
 7015|     16|    char *tmp___2;
 7016|     16|    char *tmp___3;
 7017|     16|    int tmp___4;
 7018|     16|    struct stat st;
 7019|     16|    int *tmp___5;
 7020|     16|    int tmp___6;
 7021|     16|    int *tmp___7;
 7022|     16|    int *tmp___8;
 7023|     16|    int *tmp___9;
 7024|     16|    _Bool tmp___10;
 7025|     16|    int *tmp___11;
 7026|     16|    char const *tmp___12;
 7027|     16|    char *tmp___13;
 7028|     16|    int *tmp___14;
 7029|       |
 7030|     16|    {
 7031|     16|        if (is_dir) {
 7032|     10|            tmp = 512;
 7033|     10|        }
 7034|      6|        else {
 7035|      6|            tmp = 0;
 7036|      6|        }
 7037|     16|        flag = tmp;
 7038|     16|        tmp___4 = unlinkat(fts->fts_cwd_fd, (char const *)ent->fts_accpath, flag);
 7039|     16|        if (tmp___4 == 0) {
 7040|     16|            if (x->verbose) {
 7041|      0|                tmp___0 = quote((char const *)ent->fts_path);
 7042|      0|                if (is_dir) {
 7043|      0|                    tmp___1 = gettext("removed directory: %s\n");
 7044|      0|                    tmp___3 = tmp___1;
 7045|      0|                }
 7046|      0|                else {
 7047|      0|                    tmp___2 = gettext("removed %s\n");
 7048|      0|                    tmp___3 = tmp___2;
 7049|      0|                }
 7050|      0|                printf((char const *)tmp___3, tmp___0);
 7051|      0|            }
 7052|     16|            return ((enum RM_status)2);
 7053|     16|        }
 7054|      0|        tmp___8 = __errno_location();
 7055|      0|        if (*tmp___8 == 30) {
 7056|      0|            tmp___6 = lstatat(fts->fts_cwd_fd, (char const *)ent->fts_accpath, &st);
 7057|      0|            if (tmp___6) {
 7058|      0|                tmp___7 = __errno_location();
 7059|      0|                if (!(*tmp___7 == 2)) {
 7060|      0|                    tmp___5 = __errno_location();
 7061|      0|                    *tmp___5 = 30;
 7062|      0|                }
 7063|      0|            }
 7064|      0|            else {
 7065|      0|                tmp___5 = __errno_location();
 7066|      0|                *tmp___5 = 30;
 7067|      0|            }
 7068|      0|        }
 7069|      0|        tmp___9 = __errno_location();
 7070|      0|        tmp___10 = ignorable_missing(x, *tmp___9);
 7071|      0|        if (tmp___10) {
 7072|      0|            return ((enum RM_status)2);
 7073|      0|        }
 7074|      0|        if ((int)ent->fts_info == 4) {
 7075|      0|            tmp___11 = __errno_location();
 7076|      0|            *tmp___11 = ent->fts_errno;
 7077|      0|        }
 7078|      0|        tmp___12 = quote((char const *)ent->fts_path);
 7079|      0|        tmp___13 = gettext("cannot remove %s");
 7080|      0|        tmp___14 = __errno_location();
 7081|      0|        error(0, *tmp___14, (char const *)tmp___13, tmp___12);
 7082|      0|        mark_ancestor_dirs(ent);
 7083|      0|        return ((enum RM_status)4);
 7084|      0|    }
 7085|      0|}
 7086|       |static enum RM_status rm_fts(FTS *fts, FTSENT *ent,
 7087|       |                             struct rm_options const *x)
 7088|     26|{
 7089|     26|    char const *tmp;
 7090|     26|    char *tmp___0;
 7091|     26|    _Bool tmp___1;
 7092|     26|    char const *tmp___2;
 7093|     26|    char *tmp___3;
 7094|     26|    char *tmp___4;
 7095|     26|    _Bool tmp___5;
 7096|     26|    char const *tmp___6;
 7097|     26|    char *tmp___7;
 7098|     26|    char const *tmp___8;
 7099|     26|    char const *tmp___9;
 7100|     26|    char *tmp___10;
 7101|     26|    int tmp___11;
 7102|     26|    char *tmp___12;
 7103|     26|    Ternary is_empty_directory;
 7104|     26|    enum RM_status s;
 7105|     26|    enum RM_status tmp___13;
 7106|     26|    char const *tmp___14;
 7107|     26|    char *tmp___15;
 7108|     26|    _Bool is_dir;
 7109|     26|    int tmp___16;
 7110|     26|    enum RM_status s___0;
 7111|     26|    enum RM_status tmp___17;
 7112|     26|    enum RM_status tmp___18;
 7113|     26|    char const *tmp___19;
 7114|     26|    char *tmp___20;
 7115|     26|    char const *tmp___21;
 7116|     26|    char *tmp___22;
 7117|     26|    char const *tmp___23;
 7118|     26|    char *tmp___24;
 7119|       |
 7120|     26|    {
 7121|     26|        if ((int)ent->fts_info == 1) {
 7122|     10|            goto case_1;
 7123|     10|        }
 7124|     16|        if ((int)ent->fts_info == 8) {
 7125|      2|            goto case_8;
 7126|      2|        }
 7127|     14|        if ((int)ent->fts_info == 10) {
 7128|      0|            goto case_8;
 7129|      0|        }
 7130|     14|        if ((int)ent->fts_info == 12) {
 7131|      0|            goto case_8;
 7132|      0|        }
 7133|     14|        if ((int)ent->fts_info == 13) {
 7134|      0|            goto case_8;
 7135|      0|        }
 7136|     14|        if ((int)ent->fts_info == 6) {
 7137|     10|            goto case_8;
 7138|     10|        }
 7139|      4|        if ((int)ent->fts_info == 4) {
 7140|      0|            goto case_8;
 7141|      0|        }
 7142|      4|        if ((int)ent->fts_info == 11) {
 7143|      4|            goto case_8;
 7144|      4|        }
 7145|      0|        if ((int)ent->fts_info == 3) {
 7146|      0|            goto case_8;
 7147|      0|        }
 7148|      0|        if ((int)ent->fts_info == 2) {
 7149|      0|            goto case_2;
 7150|      0|        }
 7151|      0|        if ((int)ent->fts_info == 7) {
 7152|      0|            goto case_7;
 7153|      0|        }
 7154|      0|        goto switch_default;
 7155|     10|case_1:
 7156|     10|        if (!x->recursive) {
 7157|      0|            tmp = quote((char const *)ent->fts_path);
 7158|      0|            tmp___0 = gettext("cannot remove %s");
 7159|      0|            error(0, 21, (char const *)tmp___0, tmp);
 7160|      0|            mark_ancestor_dirs(ent);
 7161|      0|            fts_skip_tree(fts, ent);
 7162|      0|            return ((enum RM_status)4);
 7163|      0|        }
 7164|     10|        if (ent->fts_level == 0L) {
 7165|      2|            tmp___1 = strip_trailing_slashes(ent->fts_path);
 7166|      2|            if (tmp___1) {
 7167|      0|                ent->fts_pathlen = strlen((char const *)ent->fts_path);
 7168|      0|            }
 7169|      2|            tmp___4 = last_component((char const *)ent->fts_accpath);
 7170|      2|            tmp___5 = dot_or_dotdot((char const *)tmp___4);
 7171|      2|            if (tmp___5) {
 7172|      0|                tmp___2 = quote((char const *)ent->fts_path);
 7173|      0|                tmp___3 = gettext("cannot remove directory: %s");
 7174|      0|                error(0, 0, (char const *)tmp___3, tmp___2);
 7175|      0|                fts_skip_tree(fts, ent);
 7176|      0|                return ((enum RM_status)4);
 7177|      0|            }
 7178|      2|            if (x->root_dev_ino) {
 7179|      2|                if (ent->fts_statp[0].st_ino == (x->root_dev_ino)->st_ino) {
 7180|      0|                    if (ent->fts_statp[0].st_dev == (x->root_dev_ino)->st_dev) {
 7181|      0|                        while (1) {
 7182|      0|                            tmp___11 = strcmp((char const *)ent->fts_path, "/");
 7183|      0|                            if (tmp___11 == 0) {
 7184|      0|                                tmp___6 = quote((char const *)ent->fts_path);
 7185|      0|                                tmp___7 =
 7186|      0|                                    gettext("it is dangerous to operate recursively on %s");
 7187|      0|                                error(0, 0, (char const *)tmp___7, tmp___6);
 7188|      0|                            }
 7189|      0|                            else {
 7190|      0|                                tmp___8 = quote_n(1, "/");
 7191|      0|                                tmp___9 = quote_n(0, (char const *)ent->fts_path);
 7192|      0|                                tmp___10 = gettext("it is dangerous to operate recursively on "
 7193|      0|                                                   "%s (same as %s)");
 7194|      0|                                error(0, 0, (char const *)tmp___10, tmp___9, tmp___8);
 7195|      0|                            }
 7196|      0|                            tmp___12 =
 7197|      0|                                gettext("use --no-preserve-root to override this failsafe");
 7198|      0|                            error(0, 0, (char const *)tmp___12);
 7199|      0|                            goto while_break;
 7200|      0|                        }
 7201|      0|while_break:
 7202|      0|                        fts_skip_tree(fts, ent);
 7203|      0|                        return ((enum RM_status)4);
 7204|      0|                    }
 7205|      0|                }
 7206|      2|            }
 7207|      2|        }
 7208|     10|        tmp___13 = prompt((FTS const *)fts, (FTSENT const *)ent, (_Bool)1, x,
 7209|     10|                          (enum Prompt_action)2, &is_empty_directory);
 7210|     10|        s = tmp___13;
 7211|     10|        if ((unsigned int)s == 2U) {
 7212|     10|            if ((unsigned int)is_empty_directory == 4U) {
 7213|      0|                s = excise(fts, ent, x, (_Bool)1);
 7214|      0|                fts_skip_tree(fts, ent);
 7215|      0|            }
 7216|     10|        }
 7217|     10|        if ((unsigned int)s != 2U) {
 7218|      0|            mark_ancestor_dirs(ent);
 7219|      0|            fts_skip_tree(fts, ent);
 7220|      0|        }
 7221|     10|        return (s);
 7222|     16|case_8:
 7223|     16|        if ((int)ent->fts_info == 6) {
 7224|     10|            if (x->one_file_system) {
 7225|      0|                if (0L < ent->fts_level) {
 7226|      0|                    if (ent->fts_statp[0].st_dev != fts->fts_dev) {
 7227|      0|                        mark_ancestor_dirs(ent);
 7228|      0|                        tmp___14 = quote((char const *)ent->fts_path);
 7229|      0|                        tmp___15 =
 7230|      0|                            gettext("skipping %s, since it\'s on a different device");
 7231|      0|                        error(0, 0, (char const *)tmp___15, tmp___14);
 7232|      0|                        return ((enum RM_status)4);
 7233|      0|                    }
 7234|      0|                }
 7235|      0|            }
 7236|     10|        }
 7237|     16|        if ((int)ent->fts_info == 6) {
 7238|     10|            tmp___16 = 1;
 7239|     10|        }
 7240|      6|        else {
 7241|      6|            if ((int)ent->fts_info == 4) {
 7242|      0|                tmp___16 = 1;
 7243|      0|            }
 7244|      6|            else {
 7245|      6|                tmp___16 = 0;
 7246|      6|            }
 7247|      6|        }
 7248|     16|        is_dir = (_Bool)tmp___16;
 7249|     16|        tmp___17 = prompt((FTS const *)fts, (FTSENT const *)ent, is_dir, x,
 7250|     16|                          (enum Prompt_action)3, (Ternary *)((void *)0));
 7251|     16|        s___0 = tmp___17;
 7252|     16|        if ((unsigned int)s___0 != 2U) {
 7253|      0|            return (s___0);
 7254|      0|        }
 7255|     16|        tmp___18 = excise(fts, ent, x, is_dir);
 7256|     16|        return (tmp___18);
 7257|      0|case_2:
 7258|      0|        while (1) {
 7259|      0|            tmp___19 = quote((char const *)ent->fts_path);
 7260|      0|            tmp___20 = gettext(
 7261|      0|                           "WARNING: Circular directory structure.\nThis almost certainly means "
 7262|      0|                           "that you have a corrupted file system.\nNOTIFY YOUR SYSTEM "
 7263|      0|                           "MANAGER.\nThe following directory is part of the cycle:\n  %s\n");
 7264|      0|            error(0, 0, (char const *)tmp___20, tmp___19);
 7265|      0|            goto while_break___0;
 7266|      0|        }
 7267|      0|while_break___0:
 7268|      0|        fts_skip_tree(fts, ent);
 7269|      0|        return ((enum RM_status)4);
 7270|      0|case_7:
 7271|      0|        tmp___21 = quote((char const *)ent->fts_path);
 7272|      0|        tmp___22 = gettext("traversal failed: %s");
 7273|      0|        error(0, ent->fts_errno, (char const *)tmp___22, tmp___21);
 7274|      0|        fts_skip_tree(fts, ent);
 7275|      0|        return ((enum RM_status)4);
 7276|      0|switch_default:
 7277|      0|        tmp___23 = quote((char const *)ent->fts_path);
 7278|      0|        tmp___24 =
 7279|      0|            gettext("unexpected failure: fts_info=%d: %s\nplease report to %s");
 7280|      0|        error(0, 0, (char const *)tmp___24, (int)ent->fts_info, tmp___23,
 7281|      0|              "bug-coreutils@gnu.org");
 7282|      0|        abort();
 7283|       |
 7284|      0|        return ((enum RM_status)0);
 7285|      0|    }
 7286|      0|}
 7287|       |enum RM_status rm(char *const *file, struct rm_options const *x)
 7288|      2|{
 7289|      2|    enum RM_status rm_status;
 7290|      2|    int bit_flags;
 7291|      2|    FTS *fts;
 7292|      2|    FTS *tmp;
 7293|      2|    FTSENT *ent;
 7294|      2|    char *tmp___0;
 7295|      2|    int *tmp___1;
 7296|      2|    int *tmp___2;
 7297|      2|    enum RM_status s;
 7298|      2|    enum RM_status tmp___3;
 7299|      2|    char *tmp___4;
 7300|      2|    int *tmp___5;
 7301|      2|    int tmp___6;
 7302|       |
 7303|      2|    {
 7304|      2|        rm_status = (enum RM_status)2;
 7305|      2|        if (*file) {
 7306|      2|            bit_flags = 536;
 7307|      2|            if (x->one_file_system) {
 7308|      0|                bit_flags |= 64;
 7309|      0|            }
 7310|      2|            tmp = xfts_open(file, bit_flags,
 7311|      2|                            (int (*)(FTSENT const **, FTSENT const **))((void *)0));
 7312|      2|            fts = tmp;
 7313|     28|            while (1) {
 7314|     28|                ent = fts_read(fts);
 7315|     28|                if ((unsigned long)ent == (unsigned long)((void *)0)) {
 7316|      2|                    tmp___2 = __errno_location();
 7317|      2|                    if (*tmp___2 != 0) {
 7318|      0|                        tmp___0 = gettext("fts_read failed");
 7319|      0|                        tmp___1 = __errno_location();
 7320|      0|                        error(0, *tmp___1, (char const *)tmp___0);
 7321|      0|                        rm_status = (enum RM_status)4;
 7322|      0|                    }
 7323|      2|                    goto while_break;
 7324|      2|                }
 7325|     26|                tmp___3 = rm_fts(fts, ent, x);
 7326|     26|                s = tmp___3;
 7327|     26|                if (!((unsigned int)s == 2U)) {
 7328|      0|                    if (!((unsigned int)s == 3U)) {
 7329|      0|                        if (!((unsigned int)s == 4U)) {
 7330|      0|                            __assert_fail(
 7331|      0|                                "((s) == RM_OK || (s) == RM_USER_DECLINED || (s) == "
 7332|      0|                                "RM_ERROR)",
 7333|      0|                                "/home/khheo/project/benchmark/coreutils-8.4/src/remove.c",
 7334|      0|                                624U, "rm");
 7335|      0|                        }
 7336|      0|                    }
 7337|      0|                }
 7338|     26|                while (1) {
 7339|       |
 7340|     26|                    if ((unsigned int)s == 4U) {
 7341|      0|                        rm_status = s;
 7342|      0|                    }
 7343|     26|                    else {
 7344|     26|                        if ((unsigned int)s == 3U) {
 7345|      0|                            if ((unsigned int)rm_status == 2U) {
 7346|      0|                                rm_status = s;
 7347|      0|                            }
 7348|      0|                        }
 7349|     26|                    }
 7350|     26|                    goto while_break___0;
 7351|     26|                }
 7352|     26|while_break___0:
 7353|     26|                ;
 7354|     26|            }
 7355|      2|while_break:
 7356|      2|            tmp___6 = fts_close(fts);
 7357|      2|            if (tmp___6 != 0) {
 7358|      0|                tmp___4 = gettext("fts_close failed");
 7359|      0|                tmp___5 = __errno_location();
 7360|      0|                error(0, *tmp___5, (char const *)tmp___4);
 7361|      0|                rm_status = (enum RM_status)4;
 7362|      0|            }
 7363|      2|        }
 7364|      2|        return (rm_status);
 7365|      2|    }
 7366|      2|}
 7367|       |extern char *optarg;
 7368|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
 7369|       |                                        isatty)(int __fd);
 7370|       |extern
 7371|       |__attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 7372|       |                                 atexit)(void (*__func)(void));
 7373|       |extern
 7374|       |__attribute__((__nothrow__)) char *(__attribute__((__leaf__))
 7375|       |                                    textdomain)(char const *__domainname);
 7376|       |extern __attribute__((__nothrow__)) char *(__attribute__((
 7377|       |            __leaf__)) bindtextdomain)(char const *__domainname, char const *__dirname);
 7378|       |__inline static void emit_ancillary_info(void)
 7379|      0|{
 7380|      0|    char *tmp;
 7381|      0|    char *tmp___0;
 7382|      0|    char *tmp___1;
 7383|      0|    char *tmp___2;
 7384|      0|    char const *lc_messages;
 7385|      0|    char const *tmp___3;
 7386|      0|    char *tmp___4;
 7387|      0|    char *tmp___5;
 7388|      0|    int tmp___6;
 7389|      0|    char *tmp___7;
 7390|      0|    char *tmp___8;
 7391|       |
 7392|      0|    {
 7393|      0|        tmp = last_component(program_name);
 7394|      0|        tmp___0 = gettext("\nReport %s bugs to %s\n");
 7395|      0|        printf((char const *)tmp___0, tmp, "bug-coreutils@gnu.org");
 7396|      0|        tmp___1 = gettext("%s home page: <http://www.gnu.org/software/%s/>\n");
 7397|      0|        printf((char const *)tmp___1, "GNU coreutils", "coreutils");
 7398|      0|        tmp___2 = gettext(
 7399|      0|                      "General help using GNU software: <http://www.gnu.org/gethelp/>\n");
 7400|      0|        fputs_unlocked((char const *)tmp___2, stdout);
 7401|      0|        tmp___3 = (char const *)setlocale(5, (char const *)((void *)0));
 7402|      0|        lc_messages = tmp___3;
 7403|      0|        if (lc_messages) {
 7404|      0|            tmp___6 = strncmp(lc_messages, "en_", (size_t)3);
 7405|      0|            if (tmp___6) {
 7406|      0|                tmp___4 = last_component(program_name);
 7407|      0|                tmp___5 = gettext("Report %s translation bugs to "
 7408|      0|                                  "<http://translationproject.org/team/>\n");
 7409|      0|                printf((char const *)tmp___5, tmp___4);
 7410|      0|            }
 7411|      0|        }
 7412|      0|        tmp___7 = last_component(program_name);
 7413|      0|        tmp___8 = gettext(
 7414|      0|                      "For complete documentation, run: info coreutils \'%s invocation\'\n");
 7415|      0|        printf((char const *)tmp___8, tmp___7);
 7416|      0|        return;
 7417|      0|    }
 7418|      0|}
 7419|       |__inline static int priv_set_remove_linkdir(void)
 7420|      2|{
 7421|       |
 7422|      2|    {
 7423|      2|        return (-1);
 7424|      2|    }
 7425|      2|}
 7426|       |static struct option const long_opts[12] = {
 7427|       |    {"directory", 0, (int *)((void *)0), 'd'},
 7428|       |    {"force", 0, (int *)((void *)0), 'f'},
 7429|       |    {"interactive", 2, (int *)((void *)0), 128},
 7430|       |    {"one-file-system", 0, (int *)((void *)0), 129},
 7431|       |    {"no-preserve-root", 0, (int *)((void *)0), 130},
 7432|       |    {"preserve-root", 0, (int *)((void *)0), 131},
 7433|       |    {"-presume-input-tty", 0, (int *)((void *)0), 132},
 7434|       |    {"recursive", 0, (int *)((void *)0), 'r'},
 7435|       |    {"verbose", 0, (int *)((void *)0), 'v'},
 7436|       |    {"help", 0, (int *)((void *)0), -130},
 7437|       |    {"version", 0, (int *)((void *)0), -131},
 7438|       |    {(char const *)((void *)0), 0, (int *)((void *)0), 0}
 7439|       |};
 7440|       |static char const *const interactive_args[7] = {
 7441|       |    "never", "no", "none", "once", "always", "yes", (char const *)((void *)0)
 7442|       |};
 7443|       |static enum interactive_type const interactive_types[6] = {
 7444|       |    (enum interactive_type const)0, (enum interactive_type const)0,
 7445|       |    (enum interactive_type const)0, (enum interactive_type const)1,
 7446|       |    (enum interactive_type const)2, (enum interactive_type const)2
 7447|       |};
 7448|       |static void diagnose_leading_hyphen(int argc, char **argv)
 7449|      0|{
 7450|      0|    int i;
 7451|      0|    char const *arg;
 7452|      0|    struct stat st;
 7453|      0|    char const *tmp;
 7454|      0|    char *tmp___0;
 7455|      0|    char *tmp___1;
 7456|      0|    int tmp___2;
 7457|       |
 7458|      0|    {
 7459|      0|        i = 1;
 7460|      0|        while (1) {
 7461|       |
 7462|      0|            if (!(i < argc)) {
 7463|      0|                goto while_break;
 7464|      0|            }
 7465|      0|            arg = (char const *)*(argv + i);
 7466|      0|            if ((int const) * (arg + 0) == 45) {
 7467|      0|                if (*(arg + 1)) {
 7468|      0|                    tmp___2 = lstat(arg, &st);
 7469|      0|                    if (tmp___2 == 0) {
 7470|      0|                        tmp = quote(arg);
 7471|      0|                        tmp___0 = quotearg_n_style(1, (enum quoting_style)1, arg);
 7472|      0|                        tmp___1 = gettext("Try `%s ./%s\' to remove the file %s.\n");
 7473|      0|                        fprintf(stderr, (char const *)tmp___1, *(argv + 0), tmp___0, tmp);
 7474|      0|                        goto while_break;
 7475|      0|                    }
 7476|      0|                }
 7477|      0|            }
 7478|      0|            i++;
 7479|      0|        }
 7480|      0|while_break:
 7481|      0|        ;
 7482|      0|        return;
 7483|      0|    }
 7484|      0|}
 7485|       |__attribute__((__noreturn__)) void usage(int status);
 7486|       |void usage(int status)
 7487|      0|{
 7488|      0|    char *tmp;
 7489|      0|    char *tmp___0;
 7490|      0|    char *tmp___1;
 7491|      0|    char *tmp___2;
 7492|      0|    char *tmp___3;
 7493|      0|    char *tmp___4;
 7494|      0|    char *tmp___5;
 7495|      0|    char *tmp___6;
 7496|      0|    char *tmp___7;
 7497|      0|    char *tmp___8;
 7498|      0|    char *tmp___9;
 7499|       |
 7500|      0|    {
 7501|      0|        if (status != 0) {
 7502|      0|            tmp = gettext("Try `%s --help\' for more information.\n");
 7503|      0|            fprintf(stderr, (char const *)tmp, program_name);
 7504|      0|        }
 7505|      0|        else {
 7506|      0|            tmp___0 = gettext("Usage: %s [OPTION]... FILE...\n");
 7507|      0|            printf((char const *)tmp___0, program_name);
 7508|      0|            tmp___1 = gettext("Remove (unlink) the FILE(s).\n\n  -f, --force         "
 7509|      0|                              "  ignore nonexistent files, never prompt\n  -i        "
 7510|      0|                              "            prompt before every removal\n");
 7511|      0|            fputs_unlocked((char const *)tmp___1, stdout);
 7512|      0|            tmp___2 = gettext(
 7513|      0|                          "  -I                    prompt once before removing more than three "
 7514|      0|                          "files, or\n                          when removing recursively.  "
 7515|      0|                          "Less intrusive than -i,\n                          while still "
 7516|      0|                          "giving protection against most mistakes\n      --interactive[=WHEN] "
 7517|      0|                          " prompt according to WHEN: never, once (-I), or\n                   "
 7518|      0|                          "       always (-i).  Without WHEN, prompt always\n");
 7519|      0|            fputs_unlocked((char const *)tmp___2, stdout);
 7520|      0|            tmp___3 =
 7521|      0|                gettext("      --one-file-system  when removing a hierarchy "
 7522|      0|                        "recursively, skip any\n                          directory "
 7523|      0|                        "that is on a file system different from\n                   "
 7524|      0|                        "       that of the corresponding command line argument\n");
 7525|      0|            fputs_unlocked((char const *)tmp___3, stdout);
 7526|      0|            tmp___4 = gettext(
 7527|      0|                          "      --no-preserve-root  do not treat `/\' specially\n      "
 7528|      0|                          "--preserve-root   do not remove `/\' (default)\n  -r, -R, "
 7529|      0|                          "--recursive   remove directories and their contents recursively\n  "
 7530|      0|                          "-v, --verbose         explain what is being done\n");
 7531|      0|            fputs_unlocked((char const *)tmp___4, stdout);
 7532|      0|            tmp___5 = gettext("      --help     display this help and exit\n");
 7533|      0|            fputs_unlocked((char const *)tmp___5, stdout);
 7534|      0|            tmp___6 =
 7535|      0|                gettext("      --version  output version information and exit\n");
 7536|      0|            fputs_unlocked((char const *)tmp___6, stdout);
 7537|      0|            tmp___7 =
 7538|      0|                gettext("\nBy default, rm does not remove directories.  Use the "
 7539|      0|                        "--recursive (-r or -R)\noption to remove each listed "
 7540|      0|                        "directory, too, along with all of its contents.\n");
 7541|      0|            fputs_unlocked((char const *)tmp___7, stdout);
 7542|      0|            tmp___8 = gettext("\nTo remove a file whose name starts with a `-\', for "
 7543|      0|                              "example `-foo\',\nuse one of these commands:\n  %s -- "
 7544|      0|                              "-foo\n\n  %s ./-foo\n");
 7545|      0|            printf((char const *)tmp___8, program_name, program_name);
 7546|      0|            tmp___9 = gettext("\nNote that if you use rm to remove a file, it is "
 7547|      0|                              "usually possible to recover\nthe contents of that "
 7548|      0|                              "file.  If you want more assurance that the contents "
 7549|      0|                              "are\ntruly unrecoverable, consider using shred.\n");
 7550|      0|            fputs_unlocked((char const *)tmp___9, stdout);
 7551|      0|            emit_ancillary_info();
 7552|      0|        }
 7553|      0|        exit(status);
 7554|      0|    }
 7555|      0|}
 7556|       |static void rm_option_init(struct rm_options *x)
 7557|      2|{
 7558|       |
 7559|      2|    {
 7560|      2|        x->ignore_missing_files = (_Bool)0;
 7561|      2|        x->interactive = (enum rm_interactive)4;
 7562|      2|        x->one_file_system = (_Bool)0;
 7563|      2|        x->recursive = (_Bool)0;
 7564|      2|        x->root_dev_ino = (struct dev_ino *)((void *)0);
 7565|      2|        x->stdin_tty = (_Bool)isatty(0);
 7566|      2|        x->verbose = (_Bool)0;
 7567|      2|        x->require_restore_cwd = (_Bool)0;
 7568|      2|        return;
 7569|      2|    }
 7570|      2|}
 7571|       |static struct dev_ino dev_ino_buf;
 7572|       |int main(int argc, char **argv)
 7573|      2|{
 7574|      2|    _Bool preserve_root;
 7575|      2|    struct rm_options x;
 7576|      2|    _Bool prompt_once;
 7577|      2|    int c;
 7578|      2|    int i;
 7579|      2|    ptrdiff_t tmp;
 7580|      2|    char *tmp___0;
 7581|      2|    char const *tmp___1;
 7582|      2|    char *tmp___2;
 7583|      2|    int *tmp___3;
 7584|      2|    size_t n_files;
 7585|      2|    char **file;
 7586|      2|    char *tmp___4;
 7587|      2|    char *tmp___5;
 7588|      2|    char *tmp___6;
 7589|      2|    _Bool tmp___7;
 7590|      2|    enum RM_status status;
 7591|      2|    enum RM_status tmp___8;
 7592|      2|    int tmp___9;
 7593|       |
 7594|      2|    {
 7595|      2|        preserve_root = (_Bool)1;
 7596|      2|        prompt_once = (_Bool)0;
 7597|      2|        set_program_name((char const *)*(argv + 0));
 7598|      2|        setlocale(6, "");
 7599|      2|        bindtextdomain("coreutils", "/usr/local/share/locale");
 7600|      2|        textdomain("coreutils");
 7601|      2|        atexit(&close_stdin);
 7602|      2|        rm_option_init(&x);
 7603|      2|        priv_set_remove_linkdir();
 7604|      6|        while (1) {
 7605|      6|            c = getopt_long(argc, (char *const *)argv, "dfirvIR", long_opts,
 7606|      6|                            (int *)((void *)0));
 7607|      6|            if (!(c != -1)) {
 7608|      2|                goto while_break;
 7609|      2|            }
 7610|      4|            if (c == 100) {
 7611|      0|                goto case_100;
 7612|      0|            }
 7613|      4|            if (c == 102) {
 7614|      2|                goto case_102;
 7615|      2|            }
 7616|      2|            if (c == 105) {
 7617|      0|                goto case_105;
 7618|      0|            }
 7619|      2|            if (c == 73) {
 7620|      0|                goto case_73;
 7621|      0|            }
 7622|      2|            if (c == 114) {
 7623|      2|                goto case_114;
 7624|      2|            }
 7625|      0|            if (c == 82) {
 7626|      0|                goto case_114;
 7627|      0|            }
 7628|      0|            if (c == 128) {
 7629|      0|                goto case_128;
 7630|      0|            }
 7631|      0|            if (c == 129) {
 7632|      0|                goto case_129;
 7633|      0|            }
 7634|      0|            if (c == 130) {
 7635|      0|                goto case_130;
 7636|      0|            }
 7637|      0|            if (c == 131) {
 7638|      0|                goto case_131;
 7639|      0|            }
 7640|      0|            if (c == 132) {
 7641|      0|                goto case_132;
 7642|      0|            }
 7643|      0|            if (c == 118) {
 7644|      0|                goto case_118;
 7645|      0|            }
 7646|      0|            if (c == -130) {
 7647|      0|                goto case_neg_130;
 7648|      0|            }
 7649|      0|            if (c == -131) {
 7650|      0|                goto case_neg_131;
 7651|      0|            }
 7652|      0|            goto switch_default;
 7653|      0|case_100:
 7654|      0|            goto switch_break;
 7655|      2|case_102:
 7656|      2|            x.interactive = (enum rm_interactive)5;
 7657|      2|            x.ignore_missing_files = (_Bool)1;
 7658|      2|            prompt_once = (_Bool)0;
 7659|      2|            goto switch_break;
 7660|      0|case_105:
 7661|      0|            x.interactive = (enum rm_interactive)3;
 7662|      0|            x.ignore_missing_files = (_Bool)0;
 7663|      0|            prompt_once = (_Bool)0;
 7664|      0|            goto switch_break;
 7665|      0|case_73:
 7666|      0|            x.interactive = (enum rm_interactive)5;
 7667|      0|            x.ignore_missing_files = (_Bool)0;
 7668|      0|            prompt_once = (_Bool)1;
 7669|      0|            goto switch_break;
 7670|      2|case_114:
 7671|      2|            x.recursive = (_Bool)1;
 7672|      2|            goto switch_break;
 7673|      0|case_128:
 7674|      0|            if (optarg) {
 7675|      0|                tmp = __xargmatch_internal("--interactive", (char const *)optarg,
 7676|      0|                                           interactive_args,
 7677|      0|                                           (char const *)(interactive_types),
 7678|      0|                                           sizeof(interactive_types[0]), argmatch_die);
 7679|      0|                i = (int)interactive_types[tmp];
 7680|      0|            }
 7681|      0|            else {
 7682|      0|                i = 2;
 7683|      0|            }
 7684|      0|            if (i == 0) {
 7685|      0|                goto case_0;
 7686|      0|            }
 7687|      0|            if (i == 1) {
 7688|      0|                goto case_1;
 7689|      0|            }
 7690|      0|            if (i == 2) {
 7691|      0|                goto case_2;
 7692|      0|            }
 7693|      0|            goto switch_break___0;
 7694|      0|case_0:
 7695|      0|            x.interactive = (enum rm_interactive)5;
 7696|      0|            prompt_once = (_Bool)0;
 7697|      0|            goto switch_break___0;
 7698|      0|case_1:
 7699|      0|            x.interactive = (enum rm_interactive)4;
 7700|      0|            x.ignore_missing_files = (_Bool)0;
 7701|      0|            prompt_once = (_Bool)1;
 7702|      0|            goto switch_break___0;
 7703|      0|case_2:
 7704|      0|            x.interactive = (enum rm_interactive)3;
 7705|      0|            x.ignore_missing_files = (_Bool)0;
 7706|      0|            prompt_once = (_Bool)0;
 7707|      0|            goto switch_break___0;
 7708|      0|switch_break___0:
 7709|      0|            ;
 7710|      0|            goto switch_break;
 7711|      0|case_129:
 7712|      0|            x.one_file_system = (_Bool)1;
 7713|      0|            goto switch_break;
 7714|      0|case_130:
 7715|      0|            preserve_root = (_Bool)0;
 7716|      0|            goto switch_break;
 7717|      0|case_131:
 7718|      0|            preserve_root = (_Bool)1;
 7719|      0|            goto switch_break;
 7720|      0|case_132:
 7721|      0|            x.stdin_tty = (_Bool)1;
 7722|      0|            goto switch_break;
 7723|      0|case_118:
 7724|      0|            x.verbose = (_Bool)1;
 7725|      0|            goto switch_break;
 7726|      0|case_neg_130:
 7727|      0|            usage(0);
 7728|      0|            goto switch_break;
 7729|      0|case_neg_131:
 7730|      0|            version_etc(stdout, "rm", "GNU coreutils", Version, "Paul Rubin",
 7731|      0|                        "David MacKenzie", "Richard M. Stallman", "Jim Meyering",
 7732|      0|                        (char *)((void *)0));
 7733|      0|            exit(0);
 7734|      0|            goto switch_break;
 7735|      0|switch_default:
 7736|      0|            diagnose_leading_hyphen(argc, argv);
 7737|      0|            usage(1);
 7738|      4|switch_break:
 7739|      4|            ;
 7740|      4|        }
 7741|      2|while_break:
 7742|      2|        ;
 7743|      2|        if (argc <= optind) {
 7744|      0|            if (x.ignore_missing_files) {
 7745|      0|                exit(0);
 7746|      0|            }
 7747|      0|            else {
 7748|      0|                tmp___0 = gettext("missing operand");
 7749|      0|                error(0, 0, (char const *)tmp___0);
 7750|      0|                usage(1);
 7751|      0|            }
 7752|      0|        }
 7753|      2|        if (x.recursive) {
 7754|      2|            if (preserve_root) {
 7755|      2|                x.root_dev_ino = get_root_dev_ino(&dev_ino_buf);
 7756|      2|                if ((unsigned long)x.root_dev_ino == (unsigned long)((void *)0)) {
 7757|      0|                    tmp___1 = quote("/");
 7758|      0|                    tmp___2 = gettext("failed to get attributes of %s");
 7759|      0|                    tmp___3 = __errno_location();
 7760|      0|                    error(1, *tmp___3, (char const *)tmp___2, tmp___1);
 7761|      0|                }
 7762|      2|            }
 7763|      2|        }
 7764|      2|        n_files = (size_t)(argc - optind);
 7765|      2|        file = argv + optind;
 7766|      2|        if (prompt_once) {
 7767|      0|            if (x.recursive) {
 7768|      0|                goto _L;
 7769|      0|            }
 7770|      0|            else {
 7771|      0|                if (3UL < n_files) {
 7772|      0|_L:
 7773|      0|                    if (x.recursive) {
 7774|      0|                        tmp___4 = gettext("%s: remove all arguments recursively? ");
 7775|      0|                        tmp___6 = tmp___4;
 7776|      0|                    }
 7777|      0|                    else {
 7778|      0|                        tmp___5 = gettext("%s: remove all arguments? ");
 7779|      0|                        tmp___6 = tmp___5;
 7780|      0|                    }
 7781|      0|                    fprintf(stderr, (char const *)tmp___6, program_name);
 7782|      0|                    tmp___7 = yesno();
 7783|      0|                    if (!tmp___7) {
 7784|      0|                        exit(0);
 7785|      0|                    }
 7786|      0|                }
 7787|      0|            }
 7788|      0|        }
 7789|      2|        tmp___8 = rm((char *const *)file, (struct rm_options const *)(&x));
 7790|      2|        status = tmp___8;
 7791|      2|        if (!((unsigned int)status == 2U)) {
 7792|      0|            if (!((unsigned int)status == 3U)) {
 7793|      0|                if (!((unsigned int)status == 4U)) {
 7794|      0|                    __assert_fail("((status) == RM_OK || (status) == RM_USER_DECLINED || "
 7795|      0|                                  "(status) == RM_ERROR)",
 7796|      0|                                  "/home/khheo/project/benchmark/coreutils-8.4/src/rm.c",
 7797|      0|                                  352U, "main");
 7798|      0|                }
 7799|      0|            }
 7800|      0|        }
 7801|      2|        if ((unsigned int)status == 4U) {
 7802|      0|            tmp___9 = 1;
 7803|      0|        }
 7804|      2|        else {
 7805|      2|            tmp___9 = 0;
 7806|      2|        }
 7807|      2|        exit(tmp___9);
 7808|      2|    }
 7809|      2|}


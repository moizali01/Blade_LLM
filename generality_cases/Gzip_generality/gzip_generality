#!/bin/bash

PROGRAM_NAME=gzip-8.16
DIR=$(pwd)
ORIGINAL_FILE=$DIR/gzip-org.c
REDUCED_FILE=$DIR/gzip-util.c.blade.c
ORIGINAL_BINARY=$DIR/original_binary
REDUCED_BINARY=$DIR/reduced_binary
CC=clang
TIMEOUT_LIMIT="-k 10 10"
LOG=$DIR/log

TOTAL_TESTS=0

TOTAL_FUNCTIONALITY=0
TOTAL_SECURITY=0
TOTAL_ROBUSTNESS=0

TOTAL_FUNCTIONALITY_PASSED=0
TOTAL_SECURITY_PASSED=0
TOTAL_ROBUSTNESS_PASSED=0

function compile() {
    cd $DIR
    $CC $REDUCED_FILE -w -o $REDUCED_BINARY >>${LOG} 2>&1 || exit 1
    $CC $ORIGINAL_FILE -w -o $ORIGINAL_BINARY >>${LOG} 2>&1 || exit 1
    return 0
}


function run_functionality() {
    ((TOTAL_TESTS++))

    echo "CASE: $TOTAL_TESTS" >>${LOG} 2>&1
    sec_flag="$1"       # Store the first argument in sec_flag
    shift                  # Shift the positional parameters to the left (removes $1)
    files=("$@") 
    if [ -n "$sec_flag" ] && [ "$sec_flag" -eq 1 ]; then
        ((TOTAL_SECURITY++))
    else
        ((TOTAL_FUNCTIONALITY++))
    fi
    rm -rf temp comparison ${compression_debloated} ${decompression_original} >/dev/null 2>&1
    mkdir -p temp >/dev/null 2>&1
    mkdir -p comparison >/dev/null 2>&1
    
    for file in "${files[@]}"; do
        cp "${file}" "temp/"
        filename=$(basename "$file")
        cp "$file" "comparison/original_$filename"
    done

    local compression_debloated="compression_debloated.txt"
    { timeout ${TIMEOUT_LIMIT} ${REDUCED_BINARY} temp/*; } &>>${compression_debloated}
    local a=$?
    if [[ $a -ne 0 ]]; then
        echo "Compression failed: ${files[@]}" >>${LOG} 2>&1
        #print the output of the debloated file
        cat $compression_debloated >>${LOG} 2>&1

        rm -rf temp comparison ${compression_debloated} ${decompression_original}  >/dev/null 2>&1
        return 1
    fi

    local debloated_compressed_files=$(ls temp)
    if find temp -type f ! -name "*.gz" | grep -q .; then
        echo "Not all files are .gz: ${files[@]}" >>${LOG} 2>&1
        rm -rf temp comparison ${compression_debloated} ${decompression_original}  >/dev/null 2>&1
        return 1

    else
        echo "All files are .gz" >>${LOG} 2>&1
    fi

    local decompression_original="decompression_original.txt"
    { timeout ${TIMEOUT_LIMIT} ${ORIGINAL_BINARY} -d temp/*; } &>>${decompression_original}
    local b=$?
    if [[ $b -ne 0 ]]; then
        echo "Decompression failed: ${files[@]}" >>${LOG} 2>&1
        cat $decompression_original >>${LOG} 2>&1
        rm -rf temp comparison ${compression_debloated} ${decompression_original}  >/dev/null 2>&1
        return 1
    fi
    
    local original_decompressed_files=$(ls temp)
    if find temp -type f -name "*.gz" | grep -q .; then
        echo "There are .gz files: ${files[@]}" >>${LOG} 2>&1
        rm -rf temp comparison ${compression_debloated} ${decompression_original}  >/dev/null 2>&1
        return 1
    else
        echo "There are no .gz files" >>${LOG} 2>&1
    fi

    for file in temp/*; do
        filename=$(basename "$file")
        cp "$file" "comparison/debloated_$filename"
    done

    for file in $files; do
        filename=$(basename "$file")

        # Determine file type (more robust than relying on extensions alone)
        filetype=$(file -b --mime-type "$file")

        if [[ $filetype =~ ^text/ ]]; then
            # Text file comparison using diff
            if diff "comparison/original_$filename" "comparison/debloated_$filename" >/dev/null; then
                echo "Decompressed file matched the original file" >/dev/null 2>&1
            else
                echo "Error: Decompressed file does not match the original file: $file"
                rm -rf temp comparison ${compression_debloated} ${decompression_original} >/dev/null 2>&1
                return 1
            fi
        else
            # Audio/Video file comparison using cmp
            if cmp -s "comparison/original_$filename" "comparison/debloated_$filename" >/dev/null; then
                echo "Decompressed file matched the original file" >/dev/null 2>&1
            else
                echo "Error: Decompressed file does not match the original file: $file"
                rm -rf temp comparison ${compression_debloated} ${decompression_original} >/dev/null 2>&1
                return 1
            fi
        fi
    done

    if [ -n "$sec_flag" ] && [ "$sec_flag" -eq 1 ]; then
        ((TOTAL_SECURITY_PASSED++))
    else
        ((TOTAL_FUNCTIONALITY_PASSED++))
    fi
    echo "Success" >>${LOG} 2>&1
    echo "" >>${LOG} 2>&1
    rm -rf temp comparison ${compression_debloated} ${decompression_original}  >/dev/null 2>&1
    return 0
}

function run_robustness() {
    ((TOTAL_TESTS++))
    ((TOTAL_ROBUSTNESS++))
    
    description=$1
    command=$2
    
    echo -e "CASE: $TOTAL_TESTS, $description" >>${LOG} 2>&1
    output_debloat=$(timeout "$TIMEOUT_LIMIT" bash -c "$command" 2>&1 | sed "s|$REDUCED_BINARY: ||") || output_debloat="TIMEOUT"
    if [[ "$output_debloat" == "TIMEOUT" ]]; then
        echo "Test failed: $description" >>${LOG} 2>&1
        return
    fi
    ((TOTAL_ROBUSTNESS_PASSED++))
    
    
}
function functionality_cases() {
    echo "starting generality run" >>${LOG} 2>&1
    echo "=========================="
    echo "Functionality Related Tests"
    
    local functionality_files="functionality_files"

    for file in $functionality_files/*; do
        echo "Running test $file"
        run_functionality 0 $file
    done
    
    # randomly pick two files from the functionality_files
    files=($(ls $functionality_files | shuf -n 2))
    files=("${files[@]/#/functionality_files/}")
    echo "Running test: Multiple files"
    run_functionality 0 ${files[@]}
    
    #randomly pick four files from the functionality_files
    files=($(ls $functionality_files | shuf -n 4))
    files=("${files[@]/#/functionality_files/}")
    echo "Running test: Multiple files"
    run_functionality 0 ${files[@]}

    #5 files
    files=($(ls $functionality_files | shuf -n 5))
    files=("${files[@]/#/functionality_files/}")
    echo "Running test: Multiple files"
    run_functionality 0 ${files[@]}

    return 0
}
function security_cases() {
    #Non Existent file
    echo "=========================="
    echo "Security Related Tests"
    echo "=========================="
    
    local security_dir="security_cases"
    
    for file in $security_dir/*; do
        echo "Running test $file"
        run_functionality 1 $file
    done
    
    # randomly pick two files from the functionality_files
    files=($(ls $security_dir | shuf -n 2))
    files=("${files[@]/#/security_cases/}")
    echo "Running test: Multiple files"
    run_functionality 0 ${files[@]}
    
    #randomly pick four files from the security_dir
    files=($(ls $security_dir | shuf -n 4))
    files=("${files[@]/#/security_cases/}")
    echo "Running test: Multiple files"
    run_functionality 0 ${files[@]}

    files=($(ls $security_dir | shuf -n 5))
    files=("${files[@]/#/security_cases/}")
    echo "Running test: Multiple files"
    run_functionality 0 ${files[@]}

}
function robustness_cases() {
    echo "=========================="
    echo "Robustness Related Tests"
    echo "=========================="
    local robustness_dir="robustness_cases"
    for file in $robustness_dir/*; do
        echo "Running test $file"
        run_robustness "Robustness test file: $file" \
        "{ timeout $TIMEOUT_LIMIT $REDUCED_BINARY $file > $DIR/temp_output.txt; }"
    done

    touch new_file.txt
    echo "Running test: Invalid Flag"
    run_robustness "Invalid Flag" \
        "{ timeout $TIMEOUT_LIMIT $REDUCED_BINARY -a new_file.txt > $DIR/temp_output.txt; }"

    echo "Running test: No arguments"
    run_robustness "No arguments " \
        "{ timeout $TIMEOUT_LIMIT $REDUCED_BINARY -a > $DIR/temp_output.txt; }" 

    echo "Running test: -R flag"
    run_robustness "Invalid Flag" \
        "{ timeout $TIMEOUT_LIMIT $REDUCED_BINARY -R new_file.txt > $DIR/temp_output.txt; }"
    
    echo "Running test: -z flag"
    run_robustness "Invalid Flag" \
        "{ timeout $TIMEOUT_LIMIT $REDUCED_BINARY -z new_file.txt > $DIR/temp_output.txt; }"
    
    echo "Running test Non Existent file"
    run_robustness "Non Existent file" \
        "{ timeout $TIMEOUT_LIMIT $REDUCED_BINARY Nonexistent.txt > $DIR/temp_output.txt; }"
    
    gzip new_file.txt
    echo "Running test: decompression flag"
    run_robustness "Invalid Flag" \
        "{ timeout $TIMEOUT_LIMIT $REDUCED_BINARY -d new_file.txt.gz > $DIR/temp_output.txt; }"

    #pass a dir
    mkdir temp_dir
    echo "Running test: Directory"
    run_robustness "Invalid Flag" \
        "{ timeout $TIMEOUT_LIMIT $REDUCED_BINARY temp_dir > $DIR/temp_output.txt; }"
    rm -rf temp_dir
    rm -rf new_file.txt new_file.txt.gz
    
}

function clean_env() {
    cd $DIR
    rm -rf  $REDUCED_BINARY $ORIGINAL_BINARY > /dev/null 2>&1
    return 0
}

function main() {
    clean_env
    rm -rf $LOG
    compile || exit 1
    
    functionality_cases
    security_cases
    robustness_cases
    
    clean_env
    
    echo "Total tests: $TOTAL_TESTS"
    echo "=========================="
    echo "Total functionality tests Passed: $TOTAL_FUNCTIONALITY_PASSED/$TOTAL_FUNCTIONALITY"
    echo "Total security tests Passed: $TOTAL_SECURITY_PASSED/$TOTAL_SECURITY"
    echo "Total robustness tests Passed: $TOTAL_ROBUSTNESS_PASSED/$TOTAL_ROBUSTNESS"
    echo "=========================="
    echo "Total tests Passed: $((TOTAL_FUNCTIONALITY_PASSED + TOTAL_SECURITY_PASSED + TOTAL_ROBUSTNESS_PASSED))/$((TOTAL_FUNCTIONALITY + TOTAL_SECURITY + TOTAL_ROBUSTNESS))"
    return 0
}

main
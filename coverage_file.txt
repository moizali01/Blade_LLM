    1|       |typedef unsigned long size_t;
    2|       |typedef long __off_t;
    3|       |typedef long __off64_t;
    4|       |struct _IO_FILE;
    5|       |struct _IO_FILE;
    6|       |struct _IO_FILE;
    7|       |typedef struct _IO_FILE FILE;
    8|       |typedef void _IO_lock_t;
    9|       |struct _IO_marker {
   10|       |  struct _IO_marker *_next;
   11|       |  struct _IO_FILE *_sbuf;
   12|       |  int _pos;
   13|       |};
   14|       |struct _IO_FILE {
   15|       |  int _flags;
   16|       |  char *_IO_read_ptr;
   17|       |  char *_IO_read_end;
   18|       |  char *_IO_read_base;
   19|       |  char *_IO_write_base;
   20|       |  char *_IO_write_ptr;
   21|       |  char *_IO_write_end;
   22|       |  char *_IO_buf_base;
   23|       |  char *_IO_buf_end;
   24|       |  char *_IO_save_base;
   25|       |  char *_IO_backup_base;
   26|       |  char *_IO_save_end;
   27|       |  struct _IO_marker *_markers;
   28|       |  struct _IO_FILE *_chain;
   29|       |  int _fileno;
   30|       |  int _flags2;
   31|       |  __off_t _old_offset;
   32|       |  unsigned short _cur_column;
   33|       |  signed char _vtable_offset;
   34|       |  char _shortbuf[1];
   35|       |  _IO_lock_t *_lock;
   36|       |  __off64_t _offset;
   37|       |  void *__pad1;
   38|       |  void *__pad2;
   39|       |  void *__pad3;
   40|       |  void *__pad4;
   41|       |  size_t __pad5;
   42|       |  int _mode;
   43|       |  char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
   44|       |};
   45|       |typedef long __time_t;
   46|       |typedef unsigned long __dev_t;
   47|       |typedef unsigned int __uid_t;
   48|       |typedef unsigned int __gid_t;
   49|       |typedef unsigned long __ino_t;
   50|       |typedef unsigned int __mode_t;
   51|       |typedef unsigned long __nlink_t;
   52|       |typedef long __blksize_t;
   53|       |typedef long __blkcnt_t;
   54|       |typedef long __syscall_slong_t;
   55|       |typedef __mode_t mode_t;
   56|       |struct timespec {
   57|       |  __time_t tv_sec;
   58|       |  __syscall_slong_t tv_nsec;
   59|       |};
   60|       |struct stat {
   61|       |  __dev_t st_dev;
   62|       |  __ino_t st_ino;
   63|       |  __nlink_t st_nlink;
   64|       |  __mode_t st_mode;
   65|       |  __uid_t st_uid;
   66|       |  __gid_t st_gid;
   67|       |  int __pad0;
   68|       |  __dev_t st_rdev;
   69|       |  __off_t st_size;
   70|       |  __blksize_t st_blksize;
   71|       |  __blkcnt_t st_blocks;
   72|       |  struct timespec st_atim;
   73|       |  struct timespec st_mtim;
   74|       |  struct timespec st_ctim;
   75|       |  __syscall_slong_t __glibc_reserved[3];
   76|       |};
   77|       |typedef __ino_t ino_t;
   78|       |typedef __dev_t dev_t;
   79|       |struct hash_table;
   80|       |struct hash_table;
   81|       |struct hash_table;
   82|       |typedef struct hash_table Hash_table;
   83|       |struct F_triple {
   84|       |  char *name;
   85|       |  ino_t st_ino;
   86|       |  dev_t st_dev;
   87|       |};
   88|       |typedef __off_t off_t;
   89|       |typedef __builtin_va_list __gnuc_va_list;
   90|       |typedef __gnuc_va_list va_list;
   91|       |typedef int wchar_t;
   92|       |union __anonunion___value_4 {
   93|       |  unsigned int __wch;
   94|       |  char __wchb[4];
   95|       |};
   96|       |struct __anonstruct___mbstate_t_3 {
   97|       |  int __count;
   98|       |  union __anonunion___value_4 __value;
   99|       |};
  100|       |typedef struct __anonstruct___mbstate_t_3 __mbstate_t;
  101|       |typedef unsigned int wint_t;
  102|       |struct hash_tuning {
  103|       |  float shrink_threshold;
  104|       |  float shrink_factor;
  105|       |  float growth_threshold;
  106|       |  float growth_factor;
  107|       |  _Bool is_n_buckets;
  108|       |};
  109|       |typedef struct hash_tuning Hash_tuning;
  110|       |typedef __mbstate_t mbstate_t;
  111|       |struct mbchar {
  112|       |  char const *ptr;
  113|       |  size_t bytes;
  114|       |  _Bool wc_valid;
  115|       |  wchar_t wc;
  116|       |  char buf[24];
  117|       |};
  118|       |struct mbuiter_multi {
  119|       |  _Bool in_shift;
  120|       |  mbstate_t state;
  121|       |  _Bool next_done;
  122|       |  struct mbchar cur;
  123|       |};
  124|       |typedef struct mbuiter_multi mbui_iterator_t;
  125|       |typedef __gid_t gid_t;
  126|       |typedef __uid_t uid_t;
  127|       |typedef unsigned long uintmax_t;
  128|       |struct dev_ino {
  129|       |  ino_t st_ino;
  130|       |  dev_t st_dev;
  131|       |};
  132|       |struct cycle_check_state {
  133|       |  struct dev_ino dev_ino;
  134|       |  uintmax_t chdir_counter;
  135|       |  int magic;
  136|       |};
  137|       |typedef long ptrdiff_t;
  138|       |struct dirent {
  139|       |  __ino_t d_ino;
  140|       |  __off_t d_off;
  141|       |  unsigned short d_reclen;
  142|       |  unsigned char d_type;
  143|       |  char d_name[256];
  144|       |};
  145|       |struct __dirstream;
  146|       |struct __dirstream;
  147|       |struct __dirstream;
  148|       |typedef struct __dirstream DIR;
  149|       |typedef long __ssize_t;
  150|       |typedef __ssize_t ssize_t;
  151|       |enum quoting_style {
  152|       |  literal_quoting_style = 0,
  153|       |  shell_quoting_style = 1,
  154|       |  shell_always_quoting_style = 2,
  155|       |  c_quoting_style = 3,
  156|       |  c_maybe_quoting_style = 4,
  157|       |  escape_quoting_style = 5,
  158|       |  locale_quoting_style = 6,
  159|       |  clocale_quoting_style = 7,
  160|       |  custom_quoting_style = 8
  161|       |};
  162|       |struct option {
  163|       |  char const *name;
  164|       |  int has_arg;
  165|       |  int *flag;
  166|       |  int val;
  167|       |};
  168|       |typedef __nlink_t nlink_t;
  169|       |struct I_ring {
  170|       |  int ir_data[4];
  171|       |  int ir_default_val;
  172|       |  unsigned int ir_front;
  173|       |  unsigned int ir_back;
  174|       |  _Bool ir_empty;
  175|       |};
  176|       |typedef struct I_ring I_ring;
  177|       |struct _ftsent;
  178|       |struct _ftsent;
  179|       |struct _ftsent;
  180|       |union __anonunion_fts_cycle_26 {
  181|       |  struct hash_table *ht;
  182|       |  struct cycle_check_state *state;
  183|       |};
  184|       |struct __anonstruct_FTS_25 {
  185|       |  struct _ftsent *fts_cur;
  186|       |  struct _ftsent *fts_child;
  187|       |  struct _ftsent **fts_array;
  188|       |  dev_t fts_dev;
  189|       |  char *fts_path;
  190|       |  int fts_rfd;
  191|       |  int fts_cwd_fd;
  192|       |  size_t fts_pathlen;
  193|       |  size_t fts_nitems;
  194|       |  int (*fts_compar)(struct _ftsent const **, struct _ftsent const **);
  195|       |  int fts_options;
  196|       |  struct hash_table *fts_leaf_optimization_works_ht;
  197|       |  union __anonunion_fts_cycle_26 fts_cycle;
  198|       |  I_ring fts_fd_ring;
  199|       |};
  200|       |typedef struct __anonstruct_FTS_25 FTS;
  201|       |struct _ftsent {
  202|       |  struct _ftsent *fts_cycle;
  203|       |  struct _ftsent *fts_parent;
  204|       |  struct _ftsent *fts_link;
  205|       |  long fts_number;
  206|       |  void *fts_pointer;
  207|       |  char *fts_accpath;
  208|       |  char *fts_path;
  209|       |  int fts_errno;
  210|       |  int fts_symfd;
  211|       |  size_t fts_pathlen;
  212|       |  FTS *fts_fts;
  213|       |  ptrdiff_t fts_level;
  214|       |  size_t fts_namelen;
  215|       |  nlink_t fts_n_dirs_remaining;
  216|       |  unsigned short fts_info;
  217|       |  unsigned short fts_flags;
  218|       |  unsigned short fts_instr;
  219|       |  struct stat fts_statp[1];
  220|       |  char fts_name[1];
  221|       |};
  222|       |typedef struct _ftsent FTSENT;
  223|       |typedef unsigned long reg_syntax_t;
  224|       |struct quoting_options;
  225|       |struct quoting_options;
  226|       |struct quoting_options;
  227|       |struct quoting_options {
  228|       |  enum quoting_style style;
  229|       |  int flags;
  230|       |  unsigned int quote_these_too[255UL / (sizeof(int) * 8UL) + 1UL];
  231|       |  char const *left_quote;
  232|       |  char const *right_quote;
  233|       |};
  234|       |struct slotvec {
  235|       |  size_t size;
  236|       |  char *val;
  237|       |};
  238|       |struct hash_entry {
  239|       |  void *data;
  240|       |  struct hash_entry *next;
  241|       |};
  242|       |struct hash_table {
  243|       |  struct hash_entry *bucket;
  244|       |  struct hash_entry const *bucket_limit;
  245|       |  size_t n_buckets;
  246|       |  size_t n_buckets_used;
  247|       |  size_t n_entries;
  248|       |  Hash_tuning const *tuning;
  249|       |  size_t (*hasher)(void const *, size_t);
  250|       |  _Bool (*comparator)(void const *, void const *);
  251|       |  void (*data_freer)(void *);
  252|       |  struct hash_entry *free_entry_list;
  253|       |};
  254|       |struct __anonstruct___fsid_t_1 {
  255|       |  int __val[2];
  256|       |};
  257|       |typedef struct __anonstruct___fsid_t_1 __fsid_t;
  258|       |typedef unsigned long __fsblkcnt_t;
  259|       |typedef unsigned long __fsfilcnt_t;
  260|       |typedef long __fsword_t;
  261|       |struct Active_dir {
  262|       |  dev_t dev;
  263|       |  ino_t ino;
  264|       |  FTSENT *fts_ent;
  265|       |};
  266|       |struct statfs {
  267|       |  __fsword_t f_type;
  268|       |  __fsword_t f_bsize;
  269|       |  __fsblkcnt_t f_blocks;
  270|       |  __fsblkcnt_t f_bfree;
  271|       |  __fsblkcnt_t f_bavail;
  272|       |  __fsfilcnt_t f_files;
  273|       |  __fsfilcnt_t f_ffree;
  274|       |  __fsid_t f_fsid;
  275|       |  __fsword_t f_namelen;
  276|       |  __fsword_t f_frsize;
  277|       |  __fsword_t f_flags;
  278|       |  __fsword_t f_spare[4];
  279|       |};
  280|       |struct LCO_ent {
  281|       |  dev_t st_dev;
  282|       |  _Bool opt_ok;
  283|       |};
  284|       |enum rm_interactive { RMI_ALWAYS = 3,
  285|       |                      RMI_SOMETIMES = 4,
  286|       |                      RMI_NEVER = 5 };
  287|       |struct rm_options {
  288|       |  _Bool ignore_missing_files;
  289|       |  enum rm_interactive interactive;
  290|       |  _Bool one_file_system;
  291|       |  _Bool recursive;
  292|       |  struct dev_ino *root_dev_ino;
  293|       |  _Bool stdin_tty;
  294|       |  _Bool verbose;
  295|       |  _Bool require_restore_cwd;
  296|       |};
  297|       |enum RM_status {
  298|       |  RM_OK = 2,
  299|       |  RM_USER_DECLINED = 3,
  300|       |  RM_ERROR = 4,
  301|       |  RM_NONEMPTY_DIR = 5
  302|       |};
  303|       |enum Ternary { T_UNKNOWN = 2,
  304|       |               T_NO = 3,
  305|       |               T_YES = 4 };
  306|       |typedef enum Ternary Ternary;
  307|       |enum Prompt_action { PA_DESCEND_INTO_DIR = 2,
  308|       |                     PA_REMOVE_DIR = 3 };
  309|       |enum interactive_type {
  310|       |  interactive_never = 0,
  311|       |  interactive_once = 1,
  312|       |  interactive_always = 2
  313|       |};
  314|       |size_t freadahead(FILE *fp);
  315|      1|size_t freadahead(FILE *fp) {
  316|      1|  long tmp;
  317|       |
  318|      1|  {
  319|      1|    if ((unsigned long)fp->_IO_write_ptr > (unsigned long)fp->_IO_write_base) {
  320|      0|      return ((size_t)0);
  321|      0|    }
  322|      1|    if (fp->_flags & 256) {
  323|      0|      tmp = fp->_IO_save_end - fp->_IO_save_base;
  324|      1|    } else {
  325|      1|      tmp = 0L;
  326|      1|    }
  327|      1|    return ((size_t)((fp->_IO_read_end - fp->_IO_read_ptr) + tmp));
  328|      1|  }
  329|      1|}
  330|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  331|       |                                        tolower)(int __c);
  332|       |extern __attribute__((__nothrow__))
  333|       |size_t(__attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s)
  334|       |    __attribute__((__pure__));
  335|       |extern int fclose(FILE *__stream);
  336|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  337|       |                                        fileno)(FILE *__stream);
  338|       |extern __attribute__((__nothrow__)) int *(
  339|       |    __attribute__((__leaf__)) __errno_location)(void)__attribute__((__const__));
  340|       |extern int close(int __fd);
  341|       |int dup_safer(int fd);
  342|       |extern __attribute__((__nothrow__)) int(
  343|       |    __attribute__((__nonnull__(1, 2), __leaf__))
  344|       |    strcmp)(char const *__s1, char const *__s2) __attribute__((__pure__));
  345|       |extern __attribute__((__nothrow__)) int(
  346|       |    __attribute__((__nonnull__(1, 2), __leaf__))
  347|       |    strncmp)(char const *__s1, char const *__s2, size_t __n)
  348|       |    __attribute__((__pure__));
  349|       |__attribute__((__noreturn__)) void xalloc_die(void);
  350|       |extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
  351|       |                                           malloc)(size_t __size)
  352|       |    __attribute__((__malloc__));
  353|       |size_t base_len(char const *name);
  354|       |char *last_component(char const *name);
  355|       |char const *file_type(struct stat const *st);
  356|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
  357|       |                                           gettext)(char const *__msgid)
  358|       |    __attribute__((__format_arg__(1)));
  359|      0|char const *file_type(struct stat const *st) {
  360|      0|  char *tmp;
  361|      0|  char *tmp___0;
  362|      0|  char *tmp___1;
  363|      0|  char const *tmp___2;
  364|      0|  char const *tmp___3;
  365|      0|  char const *tmp___4;
  366|      0|  char const *tmp___5;
  367|      0|  char const *tmp___6;
  368|      0|  char const *tmp___7;
  369|      0|  char const *tmp___8;
  370|      0|  char const *tmp___9;
  371|      0|  char const *tmp___10;
  372|      0|  char const *tmp___12;
  373|       |
  374|      0|  {
  375|      0|    if ((st->st_mode & 61440U) == 32768U) {
  376|      0|      if (st->st_size == 0L) {
  377|      0|        tmp = gettext("regular empty file");
  378|      0|        tmp___1 = tmp;
  379|      0|      } else {
  380|      0|        tmp___0 = gettext("regular file");
  381|      0|        tmp___1 = tmp___0;
  382|      0|      }
  383|      0|      return ((char const *)tmp___1);
  384|      0|    }
  385|      0|    if ((st->st_mode & 61440U) == 16384U) {
  386|      0|      tmp___2 = (char const *)gettext("directory");
  387|      0|      return (tmp___2);
  388|      0|    }
  389|      0|    if ((st->st_mode & 61440U) == 24576U) {
  390|      0|      tmp___3 = (char const *)gettext("block special file");
  391|      0|      return (tmp___3);
  392|      0|    }
  393|      0|    if ((st->st_mode & 61440U) == 8192U) {
  394|      0|      tmp___4 = (char const *)gettext("character special file");
  395|      0|      return (tmp___4);
  396|      0|    }
  397|      0|    if ((st->st_mode & 61440U) == 4096U) {
  398|      0|      tmp___5 = (char const *)gettext("fifo");
  399|      0|      return (tmp___5);
  400|      0|    }
  401|      0|    if ((st->st_mode & 61440U) == 40960U) {
  402|      0|      tmp___6 = (char const *)gettext("symbolic link");
  403|      0|      return (tmp___6);
  404|      0|    }
  405|      0|    if ((st->st_mode & 61440U) == 49152U) {
  406|      0|      tmp___7 = (char const *)gettext("socket");
  407|      0|      return (tmp___7);
  408|      0|    }
  409|      0|    if (st->st_mode - st->st_mode) {
  410|      0|      tmp___8 = (char const *)gettext("message queue");
  411|      0|      return (tmp___8);
  412|      0|    }
  413|      0|    if (st->st_mode - st->st_mode) {
  414|      0|      tmp___9 = (char const *)gettext("semaphore");
  415|      0|      return (tmp___9);
  416|      0|    }
  417|      0|    if (st->st_mode - st->st_mode) {
  418|      0|      tmp___10 = (char const *)gettext("shared memory object");
  419|      0|      return (tmp___10);
  420|      0|    }
  421|      0|    tmp___12 = (char const *)gettext("weird file");
  422|      0|    return (tmp___12);
  423|      0|  }
  424|      0|}
  425|       |void *hash_lookup(Hash_table const *table___0, void const *entry);
  426|       |void *(__attribute__((__warn_unused_result__))
  427|       |       hash_insert)(Hash_table *table___0, void const *entry);
  428|       |void triple_free(void *x);
  429|       |void *xmalloc(size_t n) __attribute__((__malloc__));
  430|       |extern int fflush(FILE *__stream);
  431|       |int rpl_fflush(FILE *stream);
  432|       |int(__attribute__((__nonnull__(1))) rpl_fseeko)(FILE *fp, off_t offset,
  433|       |                                                int whence);
  434|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  435|       |                                        __freading)(FILE *__fp);
  436|      0|__inline static void clear_ungetc_buffer_preserving_position(FILE *fp) {
  437|       |
  438|      0|  {
  439|      0|    if (fp->_flags & 256) {
  440|      0|      rpl_fseeko(fp, (off_t)0, 1);
  441|      0|    }
  442|      0|    return;
  443|      0|  }
  444|      0|}
  445|      0|int rpl_fflush(FILE *stream) {
  446|      0|  int tmp;
  447|      0|  int tmp___0;
  448|      0|  int tmp___1;
  449|       |
  450|      0|  {
  451|      0|    if ((unsigned long)stream == (unsigned long)((void *)0)) {
  452|      0|      tmp = fflush(stream);
  453|      0|      return (tmp);
  454|      0|    } else {
  455|      0|      tmp___0 = __freading(stream);
  456|      0|      if (!(tmp___0 != 0)) {
  457|      0|        tmp = fflush(stream);
  458|      0|        return (tmp);
  459|      0|      }
  460|      0|    }
  461|      0|    clear_ungetc_buffer_preserving_position(stream);
  462|      0|    tmp___1 = fflush(stream);
  463|      0|    return (tmp___1);
  464|      0|  }
  465|      0|}
  466|       |int fd_safer(int fd);
  467|      0|int fd_safer(int fd) {
  468|      0|  int f;
  469|      0|  int tmp;
  470|      0|  int e;
  471|      0|  int *tmp___0;
  472|      0|  int *tmp___1;
  473|       |
  474|      0|  {
  475|      0|    if (0 <= fd) {
  476|      0|      if (fd <= 2) {
  477|      0|        tmp = dup_safer(fd);
  478|      0|        f = tmp;
  479|      0|        tmp___0 = __errno_location();
  480|      0|        e = *tmp___0;
  481|      0|        close(fd);
  482|      0|        tmp___1 = __errno_location();
  483|      0|        *tmp___1 = e;
  484|      0|        fd = f;
  485|      0|      }
  486|      0|    }
  487|      0|    return (fd);
  488|      0|  }
  489|      0|}
  490|       |extern int(__attribute__((__nonnull__(1))) open)(char const *__file,
  491|       |                                                 int __oflag, ...);
  492|       |extern int fcntl(int __fd, int __cmd, ...);
  493|       |int rpl_fcntl(int fd, int action, ...);
  494|       |static int have_dupfd_cloexec = 0;
  495|      0|int rpl_fcntl(int fd, int action, ...) {
  496|      0|  va_list arg;
  497|      0|  int result;
  498|      0|  int target;
  499|      0|  int tmp;
  500|      0|  int *tmp___0;
  501|      0|  int flags;
  502|      0|  int tmp___1;
  503|      0|  int saved_errno;
  504|      0|  int *tmp___2;
  505|      0|  int *tmp___3;
  506|      0|  int tmp___4;
  507|      0|  void *p;
  508|      0|  void *tmp___5;
  509|       |
  510|      0|  {
  511|      0|    result = -1;
  512|      0|    __builtin_va_start(arg, action);
  513|      0|    if (action == 1030) {
  514|      0|      goto case_1030;
  515|      0|    }
  516|      0|    goto switch_default;
  517|      0|  case_1030:
  518|      0|    tmp = __builtin_va_arg(arg, int);
  519|      0|    target = tmp;
  520|      0|    if (0 <= have_dupfd_cloexec) {
  521|      0|      result = fcntl(fd, action, target);
  522|      0|      if (0 <= result) {
  523|      0|        have_dupfd_cloexec = 1;
  524|      0|      } else {
  525|      0|        tmp___0 = __errno_location();
  526|      0|        if (*tmp___0 != 22) {
  527|      0|          have_dupfd_cloexec = 1;
  528|      0|        } else {
  529|      0|          result = rpl_fcntl(fd, 0, target);
  530|      0|          if (result < 0) {
  531|      0|            goto switch_break;
  532|      0|          }
  533|      0|          have_dupfd_cloexec = -1;
  534|      0|        }
  535|      0|      }
  536|      0|    } else {
  537|      0|      result = rpl_fcntl(fd, 0, target);
  538|      0|    }
  539|      0|    if (0 <= result) {
  540|      0|      if (have_dupfd_cloexec == -1) {
  541|      0|        tmp___1 = fcntl(result, 1);
  542|      0|        flags = tmp___1;
  543|      0|        if (flags < 0) {
  544|      0|          goto _L;
  545|      0|        } else {
  546|      0|          tmp___4 = fcntl(result, 2, flags | 1);
  547|      0|          if (tmp___4 == -1) {
  548|      0|          _L:
  549|      0|            tmp___2 = __errno_location();
  550|      0|            saved_errno = *tmp___2;
  551|      0|            close(result);
  552|      0|            tmp___3 = __errno_location();
  553|      0|            *tmp___3 = saved_errno;
  554|      0|            result = -1;
  555|      0|          }
  556|      0|        }
  557|      0|      }
  558|      0|    }
  559|      0|    goto switch_break;
  560|      0|  switch_default:
  561|      0|    tmp___5 = __builtin_va_arg(arg, void *);
  562|      0|    p = tmp___5;
  563|      0|    result = fcntl(fd, action, p);
  564|      0|    goto switch_break;
  565|      0|  switch_break:
  566|      0|    __builtin_va_end(arg);
  567|      0|    return (result);
  568|      0|  }
  569|      0|}
  570|       |int volatile exit_failure;
  571|       |int volatile exit_failure = (int volatile)1;
  572|       |extern __attribute__((__nothrow__)) unsigned short const **(
  573|       |    __attribute__((__leaf__)) __ctype_b_loc)(void)__attribute__((__const__));
  574|       |extern struct _IO_FILE *stdin;
  575|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  576|       |                                        ferror_unlocked)(FILE *__stream);
  577|       |extern __attribute__((__nothrow__))
  578|       |size_t(__attribute__((__leaf__)) __ctype_get_mb_cur_max)(void);
  579|       |extern __attribute__((__nothrow__)) void(__attribute__((__leaf__))
  580|       |                                         free)(void *__ptr);
  581|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__))
  582|       |                                                       abort)(void);
  583|       |extern
  584|       |    __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1),
  585|       |                                                       __leaf__))
  586|       |                                        memset)(void *__s, int __c, size_t __n);
  587|       |extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1),
  588|       |                                                          __leaf__))
  589|       |                                           strrchr)(char const *__s, int __c)
  590|       |    __attribute__((__pure__));
  591|       |int(__attribute__((__nonnull__(1, 2))) mbscasecmp)(char const *s1,
  592|       |                                                   char const *s2);
  593|       |extern __attribute__((__nothrow__))
  594|       |wint_t(__attribute__((__leaf__)) towlower)(wint_t __wc);
  595|       |size_t hash_string(char const *string, size_t n_buckets);
  596|       |Hash_table *(__attribute__((__warn_unused_result__))
  597|       |             hash_initialize)(size_t candidate, Hash_tuning const *tuning,
  598|       |                              size_t (*hasher)(void const *, size_t),
  599|       |                              _Bool (*comparator)(void const *, void const *),
  600|       |                              void (*data_freer)(void *));
  601|       |void hash_free(Hash_table *table___0);
  602|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((
  603|       |    __leaf__)) __assert_fail)(char const *__assertion, char const *__file,
  604|       |                              unsigned int __line, char const *__function);
  605|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  606|       |                                        mbsinit)(mbstate_t const *__ps)
  607|       |    __attribute__((__pure__));
  608|       |extern __attribute__((__nothrow__))
  609|       |size_t(__attribute__((__leaf__))
  610|       |       mbrtowc)(wchar_t *__restrict __pwc, char const *__restrict __s,
  611|       |                size_t __n, mbstate_t *__restrict __p);
  612|       |unsigned int const is_basic_table[8];
  613|      0|__inline static _Bool is_basic(char c) {
  614|       |
  615|      0|  {
  616|      0|    return ((_Bool)((is_basic_table[(int)((unsigned char)c) >> 5] >>
  617|      0|                     ((int)((unsigned char)c) & 31)) &
  618|      0|                    1U));
  619|      0|  }
  620|      0|}
  621|       |size_t strnlen1(char const *string, size_t maxlen);
  622|      0|__inline static void mbuiter_multi_next(struct mbuiter_multi *iter) {
  623|      0|  int tmp;
  624|      0|  size_t tmp___0;
  625|      0|  size_t tmp___1;
  626|      0|  int tmp___2;
  627|      0|  _Bool tmp___3;
  628|       |
  629|      0|  {
  630|      0|    if (iter->next_done) {
  631|      0|      return;
  632|      0|    }
  633|      0|    if (iter->in_shift) {
  634|      0|      goto with_shift;
  635|      0|    }
  636|      0|    tmp___3 = is_basic((char)*(iter->cur.ptr));
  637|      0|    if (tmp___3) {
  638|      0|      iter->cur.bytes = (size_t)1;
  639|      0|      iter->cur.wc = (wchar_t) * (iter->cur.ptr);
  640|      0|      iter->cur.wc_valid = (_Bool)1;
  641|      0|    } else {
  642|      0|      tmp = mbsinit((mbstate_t const *)(&iter->state));
  643|      0|      if (!tmp) {
  644|      0|        __assert_fail(
  645|      0|            "mbsinit (&iter->state)",
  646|      0|            "/home/khheo/project/benchmark/coreutils-8.4/lib/mbuiter.h", 142U,
  647|      0|            "mbuiter_multi_next");
  648|      0|      }
  649|      0|      iter->in_shift = (_Bool)1;
  650|      0|    with_shift:
  651|      0|      tmp___0 = __ctype_get_mb_cur_max();
  652|      0|      tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
  653|      0|      iter->cur.bytes =
  654|      0|          mbrtowc(&iter->cur.wc, iter->cur.ptr, tmp___1, &iter->state);
  655|      0|      if (iter->cur.bytes == 0xffffffffffffffffUL) {
  656|      0|        iter->cur.bytes = (size_t)1;
  657|      0|        iter->cur.wc_valid = (_Bool)0;
  658|      0|      } else {
  659|      0|        if (iter->cur.bytes == 0xfffffffffffffffeUL) {
  660|      0|          iter->cur.bytes = strlen(iter->cur.ptr);
  661|      0|          iter->cur.wc_valid = (_Bool)0;
  662|      0|        } else {
  663|      0|          if (iter->cur.bytes == 0UL) {
  664|      0|            iter->cur.bytes = (size_t)1;
  665|      0|            if (!((int const) * (iter->cur.ptr) == 0)) {
  666|      0|              __assert_fail(
  667|      0|                  "*iter->cur.ptr == \'\\0\'",
  668|      0|                  "/home/khheo/project/benchmark/coreutils-8.4/lib/mbuiter.h",
  669|      0|                  170U, "mbuiter_multi_next");
  670|      0|            }
  671|      0|            if (!(iter->cur.wc == 0)) {
  672|      0|              __assert_fail(
  673|      0|                  "iter->cur.wc == 0",
  674|      0|                  "/home/khheo/project/benchmark/coreutils-8.4/lib/mbuiter.h",
  675|      0|                  171U, "mbuiter_multi_next");
  676|      0|            }
  677|      0|          }
  678|      0|          iter->cur.wc_valid = (_Bool)1;
  679|      0|          tmp___2 = mbsinit((mbstate_t const *)(&iter->state));
  680|      0|          if (tmp___2) {
  681|      0|            iter->in_shift = (_Bool)0;
  682|      0|          }
  683|      0|        }
  684|      0|      }
  685|      0|    }
  686|      0|    iter->next_done = (_Bool)1;
  687|      0|    return;
  688|      0|  }
  689|      0|}
  690|       |void *xrealloc(void *p, size_t n);
  691|       |_Bool euidaccess_stat(struct stat const *st, int mode);
  692|       |extern __attribute__((__nothrow__))
  693|       |__uid_t(__attribute__((__leaf__)) geteuid)(void);
  694|       |extern __attribute__((__nothrow__))
  695|       |__gid_t(__attribute__((__leaf__)) getegid)(void);
  696|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
  697|       |                                        group_member)(__gid_t __gid);
  698|      0|_Bool euidaccess_stat(struct stat const *st, int mode) {
  699|      0|  uid_t euid;
  700|      0|  unsigned int granted;
  701|      0|  int tmp___2;
  702|      0|  int tmp___3;
  703|      0|  int tmp___4;
  704|      0|  int tmp___5;
  705|      0|  int tmp___6;
  706|      0|  int tmp___7;
  707|      0|  int tmp___8;
  708|      0|  int tmp___9;
  709|      0|  int tmp___10;
  710|      0|  gid_t egid;
  711|      0|  gid_t tmp___11;
  712|      0|  int tmp___12;
  713|       |
  714|      0|  {
  715|      0|    mode &= 7;
  716|      0|    if (mode == 0) {
  717|      0|      return ((_Bool)1);
  718|      0|    }
  719|      0|    euid = geteuid();
  720|      0|    if (euid == 0U) {
  721|      0|      if ((mode & 1) == 0) {
  722|      0|        return ((_Bool)1);
  723|      0|      } else {
  724|      0|        if (st->st_mode &
  725|      0|            (unsigned int const)((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
  726|      0|          return ((_Bool)1);
  727|      0|        }
  728|      0|      }
  729|      0|    }
  730|      0|    if (256 == 4 << 6) {
  731|      0|      if (128 == 2 << 6) {
  732|      0|        if (64 == 1 << 6) {
  733|      0|          if (256 >> 3 == 4 << 3) {
  734|      0|            if (128 >> 3 == 2 << 3) {
  735|      0|              if (64 >> 3 == 1 << 3) {
  736|      0|                if ((256 >> 3) >> 3 == 4) {
  737|      0|                  if ((128 >> 3) >> 3 == 2) {
  738|      0|                    if ((64 >> 3) >> 3 == 1) {
  739|      0|                      granted = (unsigned int)st->st_mode;
  740|      0|                    } else {
  741|      0|                      goto _L___6;
  742|      0|                    }
  743|      0|                  } else {
  744|      0|                    goto _L___6;
  745|      0|                  }
  746|      0|                } else {
  747|      0|                  goto _L___6;
  748|      0|                }
  749|      0|              } else {
  750|      0|                goto _L___6;
  751|      0|              }
  752|      0|            } else {
  753|      0|              goto _L___6;
  754|      0|            }
  755|      0|          } else {
  756|      0|            goto _L___6;
  757|      0|          }
  758|      0|        } else {
  759|      0|          goto _L___6;
  760|      0|        }
  761|      0|      } else {
  762|      0|        goto _L___6;
  763|      0|      }
  764|      0|    } else {
  765|      0|    _L___6:
  766|      0|      if (st->st_mode & 256U) {
  767|      0|        tmp___2 = 4 << 6;
  768|      0|      } else {
  769|      0|        tmp___2 = 0;
  770|      0|      }
  771|      0|      if (st->st_mode & 128U) {
  772|      0|        tmp___3 = 2 << 6;
  773|      0|      } else {
  774|      0|        tmp___3 = 0;
  775|      0|      }
  776|      0|      if (st->st_mode & 64U) {
  777|      0|        tmp___4 = 1 << 6;
  778|      0|      } else {
  779|      0|        tmp___4 = 0;
  780|      0|      }
  781|      0|      if (st->st_mode & (unsigned int const)(256 >> 3)) {
  782|      0|        tmp___5 = 4 << 3;
  783|      0|      } else {
  784|      0|        tmp___5 = 0;
  785|      0|      }
  786|      0|      if (st->st_mode & (unsigned int const)(128 >> 3)) {
  787|      0|        tmp___6 = 2 << 3;
  788|      0|      } else {
  789|      0|        tmp___6 = 0;
  790|      0|      }
  791|      0|      if (st->st_mode & (unsigned int const)(64 >> 3)) {
  792|      0|        tmp___7 = 1 << 3;
  793|      0|      } else {
  794|      0|        tmp___7 = 0;
  795|      0|      }
  796|      0|      if (st->st_mode & (unsigned int const)((256 >> 3) >> 3)) {
  797|      0|        tmp___8 = 4;
  798|      0|      } else {
  799|      0|        tmp___8 = 0;
  800|      0|      }
  801|      0|      if (st->st_mode & (unsigned int const)((128 >> 3) >> 3)) {
  802|      0|        tmp___9 = 2;
  803|      0|      } else {
  804|      0|        tmp___9 = 0;
  805|      0|      }
  806|      0|      if (st->st_mode & (unsigned int const)((64 >> 3) >> 3)) {
  807|      0|        tmp___10 = 1;
  808|      0|      } else {
  809|      0|        tmp___10 = 0;
  810|      0|      }
  811|      0|      granted = (unsigned int)((((((((tmp___2 + tmp___3) + tmp___4) + tmp___5) +
  812|      0|                                   tmp___6) +
  813|      0|                                  tmp___7) +
  814|      0|                                 tmp___8) +
  815|      0|                                tmp___9) +
  816|      0|                               tmp___10);
  817|      0|    }
  818|      0|    if (euid == (uid_t)st->st_uid) {
  819|      0|      granted >>= 6;
  820|      0|    } else {
  821|      0|      tmp___11 = getegid();
  822|      0|      egid = tmp___11;
  823|      0|      if (egid == (gid_t)st->st_gid) {
  824|      0|        granted >>= 3;
  825|      0|      } else {
  826|      0|        tmp___12 = group_member((__gid_t)st->st_gid);
  827|      0|        if (tmp___12) {
  828|      0|          granted >>= 3;
  829|      0|        }
  830|      0|      }
  831|      0|    }
  832|      0|    if (((unsigned int)mode & ~granted) == 0U) {
  833|      0|      return ((_Bool)1);
  834|      0|    }
  835|      0|    return ((_Bool)0);
  836|      0|  }
  837|      0|}
  838|      0|int dup_safer(int fd) {
  839|      0|  int tmp;
  840|       |
  841|      0|  {
  842|      0|    tmp = rpl_fcntl(fd, 0, 3);
  843|      0|    return (tmp);
  844|      0|  }
  845|      0|}
  846|       |extern __attribute__((__nothrow__)) int(
  847|       |    __attribute__((__nonnull__(1, 2), __leaf__))
  848|       |    stat)(char const *__restrict __file, struct stat *__restrict __buf);
  849|       |extern
  850|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
  851|       |                                     fstat)(int __fd, struct stat *__buf);
  852|       |char const diacrit_base[256];
  853|       |char const diacrit_diac[256];
  854|       |char const diacrit_base[256] = {
  855|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  856|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  857|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  858|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  859|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  860|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  861|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  862|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  863|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  864|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  865|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  866|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  867|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  868|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  869|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  870|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  871|       |    (char const)0, (char const)'A', (char const)'B', (char const)'C',
  872|       |    (char const)'D', (char const)'E', (char const)'F', (char const)'G',
  873|       |    (char const)'H', (char const)'I', (char const)'J', (char const)'K',
  874|       |    (char const)'L', (char const)'M', (char const)'N', (char const)'O',
  875|       |    (char const)'P', (char const)'Q', (char const)'R', (char const)'S',
  876|       |    (char const)'T', (char const)'U', (char const)'V', (char const)'W',
  877|       |    (char const)'X', (char const)'Y', (char const)'Z', (char const)0,
  878|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  879|       |    (char const)0, (char const)'a', (char const)'b', (char const)'c',
  880|       |    (char const)'d', (char const)'e', (char const)'f', (char const)'g',
  881|       |    (char const)'h', (char const)'i', (char const)'j', (char const)'k',
  882|       |    (char const)'l', (char const)'m', (char const)'n', (char const)'o',
  883|       |    (char const)'p', (char const)'q', (char const)'r', (char const)'s',
  884|       |    (char const)'t', (char const)'u', (char const)'v', (char const)'w',
  885|       |    (char const)'x', (char const)'y', (char const)'z', (char const)0,
  886|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  887|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  888|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  889|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  890|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  891|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  892|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  893|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  894|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  895|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  896|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  897|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  898|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  899|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  900|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  901|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  902|       |    (char const)0, (char const)0, (char const)0, (char const)0,
  903|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'A',
  904|       |    (char const)'A', (char const)'A', (char const)'A', (char const)'C',
  905|       |    (char const)'E', (char const)'E', (char const)'E', (char const)'E',
  906|       |    (char const)'I', (char const)'I', (char const)'I', (char const)'I',
  907|       |    (char const)0, (char const)'N', (char const)'O', (char const)'O',
  908|       |    (char const)'O', (char const)'O', (char const)'O', (char const)0,
  909|       |    (char const)'O', (char const)'U', (char const)'U', (char const)'U',
  910|       |    (char const)'U', (char const)'Y', (char const)0, (char const)0,
  911|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'a',
  912|       |    (char const)'a', (char const)'a', (char const)'a', (char const)'c',
  913|       |    (char const)'e', (char const)'e', (char const)'e', (char const)'e',
  914|       |    (char const)'i', (char const)'i', (char const)'i', (char const)'i',
  915|       |    (char const)0, (char const)'n', (char const)'o', (char const)'o',
  916|       |    (char const)'o', (char const)'o', (char const)'o', (char const)0,
  917|       |    (char const)'o', (char const)'u', (char const)'u', (char const)'u',
  918|       |    (char const)'u', (char const)'y', (char const)0, (char const)'y'};
  919|       |char const diacrit_diac[256] = {
  920|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  921|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  922|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  923|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  924|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  925|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  926|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  927|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  928|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  929|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  930|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  931|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  932|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  933|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  934|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  935|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  936|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  937|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  938|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)4,
  939|       |    (char const)0, (char const)3, (char const)0, (char const)0, (char const)0,
  940|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  941|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  942|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  943|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  944|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  945|       |    (char const)0, (char const)6, (char const)0, (char const)0, (char const)0,
  946|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  947|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  948|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  949|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  950|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  951|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  952|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  953|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  954|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  955|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  956|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  957|       |    (char const)0, (char const)0, (char const)0, (char const)0, (char const)0,
  958|       |    (char const)0, (char const)0, (char const)3, (char const)2, (char const)4,
  959|       |    (char const)6, (char const)5, (char const)8, (char const)1, (char const)7,
  960|       |    (char const)3, (char const)2, (char const)4, (char const)5, (char const)3,
  961|       |    (char const)2, (char const)4, (char const)5, (char const)0, (char const)6,
  962|       |    (char const)3, (char const)2, (char const)4, (char const)6, (char const)5,
  963|       |    (char const)0, (char const)9, (char const)3, (char const)2, (char const)4,
  964|       |    (char const)5, (char const)2, (char const)0, (char const)0, (char const)3,
  965|       |    (char const)2, (char const)4, (char const)6, (char const)5, (char const)8,
  966|       |    (char const)1, (char const)7, (char const)3, (char const)2, (char const)4,
  967|       |    (char const)5, (char const)3, (char const)2, (char const)4, (char const)5,
  968|       |    (char const)0, (char const)6, (char const)3, (char const)2, (char const)4,
  969|       |    (char const)6, (char const)5, (char const)0, (char const)9, (char const)3,
  970|       |    (char const)2, (char const)4, (char const)5, (char const)2, (char const)0,
  971|       |    (char const)0};
  972|       |void cycle_check_init(struct cycle_check_state *state);
  973|       |_Bool cycle_check(struct cycle_check_state *state, struct stat const *sb);
  974|      0|__inline static _Bool is_zero_or_power_of_two(uintmax_t i) {
  975|       |
  976|      0|  { return ((_Bool)((i & (i - 1UL)) == 0UL)); }
  977|      0|}
  978|      2|void cycle_check_init(struct cycle_check_state *state) {
  979|       |
  980|      2|  {
  981|      2|    state->chdir_counter = (uintmax_t)0;
  982|      2|    state->magic = 9827862;
  983|      2|    return;
  984|      2|  }
  985|      2|}
  986|      0|_Bool cycle_check(struct cycle_check_state *state, struct stat const *sb) {
  987|      0|  _Bool tmp;
  988|       |
  989|      0|  {
  990|      0|    if (!(state->magic == 9827862)) {
  991|      0|      __assert_fail(
  992|      0|          "state->magic == 9827862",
  993|      0|          "/home/khheo/project/benchmark/coreutils-8.4/lib/cycle-check.c", 60U,
  994|      0|          "cycle_check");
  995|      0|    }
  996|      0|    if (state->chdir_counter) {
  997|      0|      if (sb->st_ino == (__ino_t const)state->dev_ino.st_ino) {
  998|      0|        if (sb->st_dev == (__dev_t const)state->dev_ino.st_dev) {
  999|      0|          return ((_Bool)1);
 1000|      0|        }
 1001|      0|      }
 1002|      0|    }
 1003|      0|    (state->chdir_counter)++;
 1004|      0|    tmp = is_zero_or_power_of_two(state->chdir_counter);
 1005|      0|    if (tmp) {
 1006|      0|      if (state->chdir_counter == 0UL) {
 1007|      0|        return ((_Bool)1);
 1008|      0|      }
 1009|      0|      state->dev_ino.st_dev = (dev_t)sb->st_dev;
 1010|      0|      state->dev_ino.st_ino = (ino_t)sb->st_ino;
 1011|      0|    }
 1012|      0|    return ((_Bool)0);
 1013|      0|  }
 1014|      0|}
 1015|       |extern void error(int __status, int __errnum, char const *__format, ...);
 1016|       |char const *quote(char const *name);
 1017|       |void close_stdout(void);
 1018|       |extern struct _IO_FILE *stdout;
 1019|       |extern struct _IO_FILE *stderr;
 1020|       |extern __attribute__((__noreturn__)) void _exit(int __status);
 1021|       |int close_stream(FILE *stream);
 1022|       |char *quotearg_colon(char const *arg);
 1023|       |static char const *file_name;
 1024|       |static _Bool ignore_EPIPE;
 1025|      1|void close_stdout(void) {
 1026|      1|  char const *write_error;
 1027|      1|  char const *tmp;
 1028|      1|  char *tmp___0;
 1029|      1|  int *tmp___1;
 1030|      1|  int *tmp___2;
 1031|      1|  int tmp___3;
 1032|      1|  int *tmp___4;
 1033|      1|  int tmp___5;
 1034|       |
 1035|      1|  {
 1036|      1|    tmp___3 = close_stream(stdout);
 1037|      1|    if (tmp___3 != 0) {
 1038|      0|      if (ignore_EPIPE) {
 1039|      0|        tmp___4 = __errno_location();
 1040|      0|        if (!(*tmp___4 == 32)) {
 1041|      0|          goto _L;
 1042|      0|        }
 1043|      0|      } else {
 1044|      0|      _L:
 1045|      0|        tmp = (char const *)gettext("write error");
 1046|      0|        write_error = tmp;
 1047|      0|        if (file_name) {
 1048|      0|          tmp___0 = quotearg_colon(file_name);
 1049|      0|          tmp___1 = __errno_location();
 1050|      0|          error(0, *tmp___1, "%s: %s", tmp___0, write_error);
 1051|      0|        } else {
 1052|      0|          tmp___2 = __errno_location();
 1053|      0|          error(0, *tmp___2, "%s", write_error);
 1054|      0|        }
 1055|      0|        _exit((int)exit_failure);
 1056|      0|      }
 1057|      0|    }
 1058|      1|    tmp___5 = close_stream(stderr);
 1059|      1|    if (tmp___5 != 0) {
 1060|      0|      _exit((int)exit_failure);
 1061|      0|    }
 1062|      1|    return;
 1063|      1|  }
 1064|      1|}
 1065|       |void close_stdin(void);
 1066|       |static char const *file_name___0;
 1067|      1|void close_stdin(void) {
 1068|      1|  _Bool fail;
 1069|      1|  int tmp;
 1070|      1|  int tmp___0;
 1071|      1|  size_t tmp___1;
 1072|      1|  int tmp___2;
 1073|      1|  char const *close_error;
 1074|      1|  char const *tmp___3;
 1075|      1|  char *tmp___4;
 1076|      1|  int *tmp___5;
 1077|      1|  int *tmp___6;
 1078|       |
 1079|      1|  {
 1080|      1|    fail = (_Bool)0;
 1081|      1|    tmp___1 = freadahead(stdin);
 1082|      1|    if (tmp___1 > 0UL) {
 1083|      0|      tmp = rpl_fseeko(stdin, (off_t)0, 1);
 1084|      0|      if (tmp == 0) {
 1085|      0|        tmp___0 = rpl_fflush(stdin);
 1086|      0|        if (tmp___0 != 0) {
 1087|      0|          fail = (_Bool)1;
 1088|      0|        }
 1089|      0|      }
 1090|      0|    }
 1091|      1|    tmp___2 = close_stream(stdin);
 1092|      1|    if (tmp___2 != 0) {
 1093|      0|      fail = (_Bool)1;
 1094|      0|    }
 1095|      1|    if (fail) {
 1096|      0|      tmp___3 = (char const *)gettext("error closing file");
 1097|      0|      close_error = tmp___3;
 1098|      0|      if (file_name___0) {
 1099|      0|        tmp___4 = quotearg_colon(file_name___0);
 1100|      0|        tmp___5 = __errno_location();
 1101|      0|        error(0, *tmp___5, "%s: %s", tmp___4, close_error);
 1102|      0|      } else {
 1103|      0|        tmp___6 = __errno_location();
 1104|      0|        error(0, *tmp___6, "%s", close_error);
 1105|      0|      }
 1106|      0|    }
 1107|      1|    close_stdout();
 1108|      1|    if (fail) {
 1109|      0|      _exit((int)exit_failure);
 1110|      0|    }
 1111|      1|    return;
 1112|      1|  }
 1113|      1|}
 1114|       |extern __attribute__((__nothrow__))
 1115|       |size_t(__attribute__((__leaf__)) __fpending)(FILE *__fp);
 1116|      3|int close_stream(FILE *stream) {
 1117|      3|  _Bool some_pending;
 1118|      3|  size_t tmp;
 1119|      3|  _Bool prev_fail;
 1120|      3|  int tmp___0;
 1121|      3|  _Bool fclose_fail;
 1122|      3|  int tmp___1;
 1123|      3|  int *tmp___2;
 1124|      3|  int *tmp___3;
 1125|       |
 1126|      3|  {
 1127|      3|    tmp = __fpending(stream);
 1128|      3|    some_pending = (_Bool)(tmp != 0UL);
 1129|      3|    tmp___0 = ferror_unlocked(stream);
 1130|      3|    prev_fail = (_Bool)(tmp___0 != 0);
 1131|      3|    tmp___1 = fclose(stream);
 1132|      3|    fclose_fail = (_Bool)(tmp___1 != 0);
 1133|      3|    if (prev_fail) {
 1134|      0|      goto _L___0;
 1135|      3|    } else {
 1136|      3|      if (fclose_fail) {
 1137|      0|        if (some_pending) {
 1138|      0|          goto _L___0;
 1139|      0|        } else {
 1140|      0|          tmp___3 = __errno_location();
 1141|      0|          if (*tmp___3 != 9) {
 1142|      0|          _L___0:
 1143|      0|            if (!fclose_fail) {
 1144|      0|              tmp___2 = __errno_location();
 1145|      0|              *tmp___2 = 0;
 1146|      0|            }
 1147|      0|            return (-1);
 1148|      0|          }
 1149|      0|        }
 1150|      0|      }
 1151|      3|    }
 1152|      3|    return (0);
 1153|      3|  }
 1154|      3|}
 1155|       |int set_cloexec_flag(int desc, _Bool value);
 1156|      0|int set_cloexec_flag(int desc, _Bool value) {
 1157|      0|  int flags;
 1158|      0|  int tmp;
 1159|      0|  int newflags;
 1160|      0|  int tmp___0;
 1161|      0|  int tmp___1;
 1162|       |
 1163|      0|  {
 1164|      0|    tmp = rpl_fcntl(desc, 1, 0);
 1165|      0|    flags = tmp;
 1166|      0|    if (0 <= flags) {
 1167|      0|      if (value) {
 1168|      0|        tmp___0 = flags | 1;
 1169|      0|      } else {
 1170|      0|        tmp___0 = flags & -2;
 1171|      0|      }
 1172|      0|      newflags = tmp___0;
 1173|      0|      if (flags == newflags) {
 1174|      0|        return (0);
 1175|      0|      } else {
 1176|      0|        tmp___1 = rpl_fcntl(desc, 2, newflags);
 1177|      0|        if (tmp___1 != -1) {
 1178|      0|          return (0);
 1179|      0|        }
 1180|      0|      }
 1181|      0|    }
 1182|      0|    return (-1);
 1183|      0|  }
 1184|      0|}
 1185|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
 1186|       |                                        fchdir)(int __fd);
 1187|       |extern int(__attribute__((__nonnull__(2))) openat)(int __fd, char const *__file,
 1188|       |                                                   int __oflag, ...);
 1189|       |extern __attribute__((__nothrow__)) void *(
 1190|       |    __attribute__((__nonnull__(1), __leaf__))
 1191|       |    memchr)(void const *__s, int __c, size_t __n) __attribute__((__pure__));
 1192|       |extern __attribute__((__nothrow__)) void *(
 1193|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 1194|       |    memmove)(void *__dest, void const *__src, size_t __n);
 1195|       |extern __attribute__((__nothrow__)) int(
 1196|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 1197|       |    lstat)(char const *__restrict __file, struct stat *__restrict __buf);
 1198|       |size_t triple_hash(void const *x, size_t table_size);
 1199|       |_Bool triple_compare_ino_str(void const *x, void const *y);
 1200|      0|char *last_component(char const *name) {
 1201|      0|  char const *base;
 1202|      0|  char const *p;
 1203|      0|  _Bool saw_slash;
 1204|       |
 1205|      0|  {
 1206|      0|    base = name + 0;
 1207|      0|    saw_slash = (_Bool)0;
 1208|      0|    while (1) {
 1209|       |
 1210|      0|      if (!((int const) * base == 47)) {
 1211|      0|        goto while_break;
 1212|      0|      }
 1213|      0|      base++;
 1214|      0|    }
 1215|      0|  while_break:
 1216|      0|    p = base;
 1217|      0|    while (1) {
 1218|       |
 1219|      0|      if (!*p) {
 1220|      0|        goto while_break___0;
 1221|      0|      }
 1222|      0|      if ((int const) * p == 47) {
 1223|      0|        saw_slash = (_Bool)1;
 1224|      0|      } else {
 1225|      0|        if (saw_slash) {
 1226|      0|          base = p;
 1227|      0|          saw_slash = (_Bool)0;
 1228|      0|        }
 1229|      0|      }
 1230|      0|      p++;
 1231|      0|    }
 1232|      0|  while_break___0:;
 1233|      0|    return ((char *)base);
 1234|      0|  }
 1235|      0|}
 1236|      0|size_t base_len(char const *name) {
 1237|      0|  size_t len;
 1238|      0|  size_t prefix_len;
 1239|       |
 1240|      0|  {
 1241|      0|    prefix_len = (size_t)0;
 1242|      0|    len = strlen(name);
 1243|      0|    while (1) {
 1244|       |
 1245|      0|      if (1UL < len) {
 1246|      0|        if (!((int const) * (name + (len - 1UL)) == 47)) {
 1247|      0|          goto while_break;
 1248|      0|        }
 1249|      0|      } else {
 1250|      0|        goto while_break;
 1251|      0|      }
 1252|      0|      goto __Cont;
 1253|      0|    __Cont:
 1254|      0|      len--;
 1255|      0|    }
 1256|      0|  while_break:;
 1257|      0|    return (len);
 1258|      0|  }
 1259|      0|}
 1260|       |char const *simple_backup_suffix;
 1261|       |void (*argmatch_die)(void);
 1262|       |ptrdiff_t __xargmatch_internal(char const *context, char const *arg,
 1263|       |                               char const *const *arglist, char const *vallist,
 1264|       |                               size_t valsize, void (*exit_fn)(void));
 1265|       |extern __attribute__((__nothrow__)) int(
 1266|       |    __attribute__((__nonnull__(1, 2), __leaf__))
 1267|       |    memcmp)(void const *__s1, void const *__s2, size_t __n)
 1268|       |    __attribute__((__pure__));
 1269|       |extern int(__attribute__((__nonnull__(1))) closedir)(DIR *__dirp);
 1270|       |extern struct dirent *(__attribute__((__nonnull__(1))) readdir)(DIR *__dirp);
 1271|       |DIR *opendir_safer(char const *name);
 1272|       |char const *simple_backup_suffix = "~";
 1273|       |ptrdiff_t argmatch(char const *arg, char const *const *arglist,
 1274|       |                   char const *vallist, size_t valsize);
 1275|       |void argmatch_invalid(char const *context, char const *value,
 1276|       |                      ptrdiff_t problem);
 1277|       |void argmatch_valid(char const *const *arglist, char const *vallist,
 1278|       |                    size_t valsize);
 1279|       |extern int fprintf(FILE *__restrict __stream, char const *__restrict __format,
 1280|       |                   ...);
 1281|       |extern int putc_unlocked(int __c, FILE *__stream);
 1282|       |char *quotearg_n_style(int n, enum quoting_style s, char const *arg);
 1283|       |char const *quote_n(int n, char const *name);
 1284|       |__attribute__((__noreturn__)) void usage(int status);
 1285|      0|static void __argmatch_die(void) {
 1286|       |
 1287|      0|  {
 1288|      0|    usage(1);
 1289|      0|    return;
 1290|      0|  }
 1291|      0|}
 1292|       |void (*argmatch_die)(void) = &__argmatch_die;
 1293|       |ptrdiff_t argmatch(char const *arg, char const *const *arglist,
 1294|      0|                   char const *vallist, size_t valsize) {
 1295|      0|  size_t i;
 1296|      0|  size_t arglen;
 1297|      0|  ptrdiff_t matchind;
 1298|      0|  _Bool ambiguous;
 1299|      0|  int tmp;
 1300|      0|  size_t tmp___0;
 1301|      0|  int tmp___1;
 1302|       |
 1303|      0|  {
 1304|      0|    matchind = (ptrdiff_t)-1;
 1305|      0|    ambiguous = (_Bool)0;
 1306|      0|    arglen = strlen(arg);
 1307|      0|    i = (size_t)0;
 1308|      0|    while (1) {
 1309|       |
 1310|      0|      if (!*(arglist + i)) {
 1311|      0|        goto while_break;
 1312|      0|      }
 1313|      0|      tmp___1 = strncmp((char const *)*(arglist + i), arg, arglen);
 1314|      0|      if (!tmp___1) {
 1315|      0|        tmp___0 = strlen((char const *)*(arglist + i));
 1316|      0|        if (tmp___0 == arglen) {
 1317|      0|          return ((ptrdiff_t)i);
 1318|      0|        } else {
 1319|      0|          if (matchind == -1L) {
 1320|      0|            matchind = (ptrdiff_t)i;
 1321|      0|          } else {
 1322|      0|            if ((unsigned long)vallist == (unsigned long)((void *)0)) {
 1323|      0|              ambiguous = (_Bool)1;
 1324|      0|            } else {
 1325|      0|              tmp = memcmp((void const *)(vallist + valsize * (size_t)matchind),
 1326|      0|                           (void const *)(vallist + valsize * i), valsize);
 1327|      0|              if (tmp) {
 1328|      0|                ambiguous = (_Bool)1;
 1329|      0|              }
 1330|      0|            }
 1331|      0|          }
 1332|      0|        }
 1333|      0|      }
 1334|      0|      i++;
 1335|      0|    }
 1336|      0|  while_break:;
 1337|      0|    if (ambiguous) {
 1338|      0|      return ((ptrdiff_t)-2);
 1339|      0|    } else {
 1340|      0|      return (matchind);
 1341|      0|    }
 1342|      0|  }
 1343|      0|}
 1344|       |void argmatch_invalid(char const *context, char const *value,
 1345|      0|                      ptrdiff_t problem) {
 1346|      0|  char const *format;
 1347|      0|  char *tmp;
 1348|      0|  char *tmp___0;
 1349|      0|  char *tmp___1;
 1350|      0|  char const *tmp___2;
 1351|      0|  char *tmp___3;
 1352|       |
 1353|      0|  {
 1354|      0|    if (problem == -1L) {
 1355|      0|      tmp = gettext("invalid argument %s for %s");
 1356|      0|      tmp___1 = tmp;
 1357|      0|    } else {
 1358|      0|      tmp___0 = gettext("ambiguous argument %s for %s");
 1359|      0|      tmp___1 = tmp___0;
 1360|      0|    }
 1361|      0|    format = (char const *)tmp___1;
 1362|      0|    tmp___2 = quote_n(1, context);
 1363|      0|    tmp___3 = quotearg_n_style(0, (enum quoting_style)6, value);
 1364|      0|    error(0, 0, format, tmp___3, tmp___2);
 1365|      0|    return;
 1366|      0|  }
 1367|      0|}
 1368|       |void argmatch_valid(char const *const *arglist, char const *vallist,
 1369|      0|                    size_t valsize) {
 1370|      0|  size_t i;
 1371|      0|  char const *last_val;
 1372|      0|  char *tmp;
 1373|      0|  int tmp___0;
 1374|       |
 1375|      0|  {
 1376|      0|    last_val = (char const *)((void *)0);
 1377|      0|    tmp = gettext("Valid arguments are:");
 1378|      0|    fprintf(stderr, (char const *)tmp);
 1379|      0|    i = (size_t)0;
 1380|      0|    while (1) {
 1381|       |
 1382|      0|      if (!*(arglist + i)) {
 1383|      0|        goto while_break;
 1384|      0|      }
 1385|      0|      if (i == 0UL) {
 1386|      0|        fprintf(stderr, "\n  - `%s\'", *(arglist + i));
 1387|      0|        last_val = vallist + valsize * i;
 1388|      0|      } else {
 1389|      0|        tmp___0 = memcmp((void const *)last_val,
 1390|      0|                         (void const *)(vallist + valsize * i), valsize);
 1391|      0|        if (tmp___0) {
 1392|      0|          fprintf(stderr, "\n  - `%s\'", *(arglist + i));
 1393|      0|          last_val = vallist + valsize * i;
 1394|      0|        } else {
 1395|      0|          fprintf(stderr, ", `%s\'", *(arglist + i));
 1396|      0|        }
 1397|      0|      }
 1398|      0|      i++;
 1399|      0|    }
 1400|      0|  while_break:
 1401|      0|    putc_unlocked('\n', stderr);
 1402|      0|    return;
 1403|      0|  }
 1404|      0|}
 1405|       |ptrdiff_t __xargmatch_internal(char const *context, char const *arg,
 1406|       |                               char const *const *arglist, char const *vallist,
 1407|      0|                               size_t valsize, void (*exit_fn)(void)) {
 1408|      0|  ptrdiff_t res;
 1409|      0|  ptrdiff_t tmp;
 1410|       |
 1411|      0|  {
 1412|      0|    tmp = argmatch(arg, arglist, vallist, valsize);
 1413|      0|    res = tmp;
 1414|      0|    if (res >= 0L) {
 1415|      0|      return (res);
 1416|      0|    }
 1417|      0|    argmatch_invalid(context, arg, res);
 1418|      0|    argmatch_valid(arglist, vallist, valsize);
 1419|      0|    (*exit_fn)();
 1420|      0|    return ((ptrdiff_t)-1);
 1421|      0|  }
 1422|      0|}
 1423|       |extern
 1424|       |    __attribute__((__nothrow__)) void *(__attribute__((__warn_unused_result__,
 1425|       |                                                       __leaf__))
 1426|       |                                        realloc)(void *__ptr, size_t __size);
 1427|       |_Bool yesno(void);
 1428|       |extern
 1429|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 1430|       |                                     rpmatch)(char const *__response);
 1431|       |extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n,
 1432|       |                         FILE *__restrict __stream);
 1433|      0|_Bool yesno(void) {
 1434|      0|  _Bool yes;
 1435|      0|  char *response;
 1436|      0|  size_t response_size;
 1437|      0|  ssize_t response_len;
 1438|      0|  ssize_t tmp;
 1439|      0|  int tmp___0;
 1440|       |
 1441|      0|  {
 1442|      0|    response = (char *)((void *)0);
 1443|      0|    response_size = (size_t)0;
 1444|      0|    tmp = getline(&response, &response_size, stdin);
 1445|      0|    response_len = tmp;
 1446|      0|    if (response_len <= 0L) {
 1447|      0|      yes = (_Bool)0;
 1448|      0|    } else {
 1449|      0|      *(response + (response_len - 1L)) = (char)'\000';
 1450|      0|      tmp___0 = rpmatch((char const *)response);
 1451|      0|      yes = (_Bool)(0 < tmp___0);
 1452|      0|    }
 1453|      0|    free((void *)response);
 1454|      0|    return (yes);
 1455|      0|  }
 1456|      0|}
 1457|       |__inline static void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__));
 1458|       |__inline static void *xnmalloc(size_t n, size_t s) __attribute__((__malloc__));
 1459|      0|__inline static void *xnmalloc(size_t n, size_t s) {
 1460|      0|  int tmp;
 1461|      0|  void *tmp___0;
 1462|      0|
 1463|      0|  {
 1464|      0|    if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 1465|      0|      tmp = -1;
 1466|      0|    } else {
 1467|      0|      tmp = -2;
 1468|      0|    }
 1469|      0|    if ((size_t)tmp / s < n) {
 1470|      0|      xalloc_die();
 1471|      0|    }
 1472|      0|    tmp___0 = xmalloc(n * s);
 1473|      0|    return (tmp___0);
 1474|      0|  }
 1475|      0|}
 1476|       |extern
 1477|       |    __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
 1478|       |                                        calloc)(size_t __nmemb, size_t __size)
 1479|       |        __attribute__((__malloc__));
 1480|       |void *xmalloc(size_t n) __attribute__((__malloc__));
 1481|      0|void *xmalloc(size_t n) {
 1482|      0|  void *p;
 1483|      0|  void *tmp;
 1484|       |
 1485|      0|  {
 1486|      0|    tmp = malloc(n);
 1487|      0|    p = tmp;
 1488|      0|    if (!p) {
 1489|      0|      if (n != 0UL) {
 1490|      0|        xalloc_die();
 1491|      0|      }
 1492|      0|    }
 1493|      0|    return (p);
 1494|      0|  }
 1495|      0|}
 1496|      0|void *xrealloc(void *p, size_t n) {
 1497|       |
 1498|      0|  {
 1499|      0|    p = realloc(p, n);
 1500|      0|    if (!p) {
 1501|      0|      if (n != 0UL) {
 1502|      0|        xalloc_die();
 1503|      0|      }
 1504|      0|    }
 1505|      0|    return (p);
 1506|      0|  }
 1507|      0|}
 1508|       |__attribute__((__nothrow__))
 1509|       |FTS *(__attribute__((__warn_unused_result__, __leaf__))
 1510|       |      fts_open)(char *const *argv, int options,
 1511|       |                int (*compar)(FTSENT const **, FTSENT const **));
 1512|       |FTS *xfts_open(char *const *argv, int options,
 1513|       |               int (*compar)(FTSENT const **, FTSENT const **));
 1514|       |FTS *xfts_open(char *const *argv, int options,
 1515|      1|               int (*compar)(FTSENT const **, FTSENT const **)) {
 1516|      1|  FTS *fts;
 1517|      1|  FTS *tmp;
 1518|      1|  int *tmp___0;
 1519|       |
 1520|      1|  {
 1521|      1|    tmp = fts_open(argv, options | 512, compar);
 1522|      1|    fts = tmp;
 1523|      1|    if ((unsigned long)fts == (unsigned long)((void *)0)) {
 1524|      0|      tmp___0 = __errno_location();
 1525|      0|      if (!(*tmp___0 != 22)) {
 1526|      0|        __assert_fail("(*__errno_location ()) != 22",
 1527|      0|                      "/home/khheo/project/benchmark/coreutils-8.4/lib/xfts.c",
 1528|      0|                      41U, "xfts_open");
 1529|      0|      }
 1530|      0|      xalloc_die();
 1531|      0|    }
 1532|      1|    return (fts);
 1533|      1|  }
 1534|      1|}
 1535|       |__attribute__((__noreturn__)) void xalloc_die(void);
 1536|      0|void xalloc_die(void) {
 1537|      0|  char *tmp;
 1538|       |
 1539|      0|  {
 1540|      0|    tmp = gettext("memory exhausted");
 1541|      0|    error((int)exit_failure, 0, "%s", tmp);
 1542|      0|    abort();
 1543|      0|  }
 1544|      0|}
 1545|       |_Bool can_write_any_file(void);
 1546|       |static _Bool initialized;
 1547|       |static _Bool can_write;
 1548|      1|_Bool can_write_any_file(void) {
 1549|      1|  _Bool can;
 1550|      1|  __uid_t tmp;
 1551|       |
 1552|      1|  {
 1553|      1|    if (!initialized) {
 1554|      1|      can = (_Bool)0;
 1555|      1|      tmp = geteuid();
 1556|      1|      can = (_Bool)(tmp == 0U);
 1557|      1|      can_write = can;
 1558|      1|      initialized = (_Bool)1;
 1559|      1|    }
 1560|      1|    return (can_write);
 1561|      1|  }
 1562|      1|}
 1563|       |extern int printf(char const *__restrict __format, ...);
 1564|       |extern int fputs_unlocked(char const *__restrict __s,
 1565|       |                          FILE *__restrict __stream);
 1566|       |char const version_etc_copyright[47];
 1567|       |void version_etc_arn(FILE *stream, char const *command_name,
 1568|       |                     char const *package, char const *version,
 1569|       |                     char const *const *authors, size_t n_authors);
 1570|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 1571|       |                    char const *version, va_list authors);
 1572|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1573|       |                 char const *version, ...) __attribute__((__sentinel__));
 1574|       |void version_etc_arn(FILE *stream, char const *command_name,
 1575|       |                     char const *package, char const *version,
 1576|      0|                     char const *const *authors, size_t n_authors) {
 1577|      0|  char *tmp;
 1578|      0|  char *tmp___0;
 1579|      0|  char *tmp___1;
 1580|      0|  char *tmp___2;
 1581|      0|  char *tmp___3;
 1582|      0|  char *tmp___4;
 1583|      0|  char *tmp___5;
 1584|      0|  char *tmp___6;
 1585|      0|  char *tmp___7;
 1586|      0|  char *tmp___8;
 1587|      0|  char *tmp___9;
 1588|      0|  char *tmp___10;
 1589|       |
 1590|      0|  {
 1591|      0|    if (command_name) {
 1592|      0|      fprintf(stream, "%s (%s) %s\n", command_name, package, version);
 1593|      0|    } else {
 1594|      0|      fprintf(stream, "%s %s\n", package, version);
 1595|      0|    }
 1596|      0|    tmp = gettext("(C)");
 1597|      0|    fprintf(stream, version_etc_copyright, tmp, 2010);
 1598|      0|    tmp___0 =
 1599|      0|        gettext("\nLicense GPLv3+: GNU GPL version 3 or later "
 1600|      0|                "<http://gnu.org/licenses/gpl.html>.\nThis is free software: "
 1601|      0|                "you are free to change and redistribute it.\nThere is NO "
 1602|      0|                "WARRANTY, to the extent permitted by law.\n\n");
 1603|      0|    fputs_unlocked((char const *)tmp___0, stream);
 1604|      0|    if (n_authors == 0UL) {
 1605|      0|      goto case_0;
 1606|      0|    }
 1607|      0|    if (n_authors == 1UL) {
 1608|      0|      goto case_1;
 1609|      0|    }
 1610|      0|    if (n_authors == 2UL) {
 1611|      0|      goto case_2;
 1612|      0|    }
 1613|      0|    if (n_authors == 3UL) {
 1614|      0|      goto case_3;
 1615|      0|    }
 1616|      0|    if (n_authors == 4UL) {
 1617|      0|      goto case_4;
 1618|      0|    }
 1619|      0|    if (n_authors == 5UL) {
 1620|      0|      goto case_5;
 1621|      0|    }
 1622|      0|    if (n_authors == 6UL) {
 1623|      0|      goto case_6;
 1624|      0|    }
 1625|      0|    if (n_authors == 7UL) {
 1626|      0|      goto case_7;
 1627|      0|    }
 1628|      0|    if (n_authors == 8UL) {
 1629|      0|      goto case_8;
 1630|      0|    }
 1631|      0|    if (n_authors == 9UL) {
 1632|      0|      goto case_9;
 1633|      0|    }
 1634|      0|    goto switch_default;
 1635|      0|  case_0:
 1636|      0|    abort();
 1637|      0|  case_1:
 1638|      0|    tmp___1 = gettext("Written by %s.\n");
 1639|      0|    fprintf(stream, (char const *)tmp___1, *(authors + 0));
 1640|      0|    goto switch_break;
 1641|      0|  case_2:
 1642|      0|    tmp___2 = gettext("Written by %s and %s.\n");
 1643|      0|    fprintf(stream, (char const *)tmp___2, *(authors + 0), *(authors + 1));
 1644|      0|    goto switch_break;
 1645|      0|  case_3:
 1646|      0|    tmp___3 = gettext("Written by %s, %s, and %s.\n");
 1647|      0|    fprintf(stream, (char const *)tmp___3, *(authors + 0), *(authors + 1),
 1648|      0|            *(authors + 2));
 1649|      0|    goto switch_break;
 1650|      0|  case_4:
 1651|      0|    tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
 1652|      0|    fprintf(stream, (char const *)tmp___4, *(authors + 0), *(authors + 1),
 1653|      0|            *(authors + 2), *(authors + 3));
 1654|      0|    goto switch_break;
 1655|      0|  case_5:
 1656|      0|    tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
 1657|      0|    fprintf(stream, (char const *)tmp___5, *(authors + 0), *(authors + 1),
 1658|      0|            *(authors + 2), *(authors + 3), *(authors + 4));
 1659|      0|    goto switch_break;
 1660|      0|  case_6:
 1661|      0|    tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
 1662|      0|    fprintf(stream, (char const *)tmp___6, *(authors + 0), *(authors + 1),
 1663|      0|            *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5));
 1664|      0|    goto switch_break;
 1665|      0|  case_7:
 1666|      0|    tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
 1667|      0|    fprintf(stream, (char const *)tmp___7, *(authors + 0), *(authors + 1),
 1668|      0|            *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1669|      0|            *(authors + 6));
 1670|      0|    goto switch_break;
 1671|      0|  case_8:
 1672|      0|    tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
 1673|      0|    fprintf(stream, (char const *)tmp___8, *(authors + 0), *(authors + 1),
 1674|      0|            *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1675|      0|            *(authors + 6), *(authors + 7));
 1676|      0|    goto switch_break;
 1677|      0|  case_9:
 1678|      0|    tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
 1679|      0|    fprintf(stream, (char const *)tmp___9, *(authors + 0), *(authors + 1),
 1680|      0|            *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1681|      0|            *(authors + 6), *(authors + 7), *(authors + 8));
 1682|      0|    goto switch_break;
 1683|      0|  switch_default:
 1684|      0|    tmp___10 = gettext(
 1685|      0|        "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
 1686|      0|    fprintf(stream, (char const *)tmp___10, *(authors + 0), *(authors + 1),
 1687|      0|            *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
 1688|      0|            *(authors + 6), *(authors + 7), *(authors + 8));
 1689|      0|    goto switch_break;
 1690|      0|  switch_break:;
 1691|      0|    return;
 1692|      0|  }
 1693|      0|}
 1694|       |void version_etc_va(FILE *stream, char const *command_name, char const *package,
 1695|      0|                    char const *version, va_list authors) {
 1696|      0|  size_t n_authors;
 1697|      0|  char const *authtab[10];
 1698|      0|  char const *tmp;
 1699|       |
 1700|      0|  {
 1701|      0|    n_authors = (size_t)0;
 1702|      0|    while (1) {
 1703|       |
 1704|      0|      if (n_authors < 10UL) {
 1705|      0|        tmp = __builtin_va_arg(authors, char const *);
 1706|      0|        authtab[n_authors] = tmp;
 1707|      0|        if (!((unsigned long)tmp != (unsigned long)((void *)0))) {
 1708|      0|          goto while_break;
 1709|      0|        }
 1710|      0|      } else {
 1711|      0|        goto while_break;
 1712|      0|      }
 1713|      0|      n_authors++;
 1714|      0|    }
 1715|      0|  while_break:
 1716|      0|    version_etc_arn(stream, command_name, package, version,
 1717|      0|                    (char const *const *)(authtab), n_authors);
 1718|      0|    return;
 1719|      0|  }
 1720|      0|}
 1721|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1722|       |                 char const *version, ...) __attribute__((__sentinel__));
 1723|       |void version_etc(FILE *stream, char const *command_name, char const *package,
 1724|      0|                 char const *version, ...) {
 1725|      0|  va_list authors;
 1726|       |
 1727|      0|  {
 1728|      0|    __builtin_va_start(authors, version);
 1729|      0|    version_etc_va(stream, command_name, package, version, authors);
 1730|      0|    __builtin_va_end(authors);
 1731|      0|    return;
 1732|      0|  }
 1733|      0|}
 1734|       |char const version_etc_copyright[47] = {
 1735|       |    (char const)'C', (char const)'o', (char const)'p', (char const)'y',
 1736|       |    (char const)'r', (char const)'i', (char const)'g', (char const)'h',
 1737|       |    (char const)'t', (char const)' ', (char const)'%', (char const)'s',
 1738|       |    (char const)' ', (char const)'%', (char const)'d', (char const)' ',
 1739|       |    (char const)'F', (char const)'r', (char const)'e', (char const)'e',
 1740|       |    (char const)' ', (char const)'S', (char const)'o', (char const)'f',
 1741|       |    (char const)'t', (char const)'w', (char const)'a', (char const)'r',
 1742|       |    (char const)'e', (char const)' ', (char const)'F', (char const)'o',
 1743|       |    (char const)'u', (char const)'n', (char const)'d', (char const)'a',
 1744|       |    (char const)'t', (char const)'i', (char const)'o', (char const)'n',
 1745|       |    (char const)',', (char const)' ', (char const)'I', (char const)'n',
 1746|       |    (char const)'c', (char const)'.', (char const)'\000'};
 1747|       |#pragma weak pthread_key_create
 1748|       |#pragma weak pthread_getspecific
 1749|       |#pragma weak pthread_setspecific
 1750|       |#pragma weak pthread_key_delete
 1751|       |#pragma weak pthread_self
 1752|       |#pragma weak pthread_cancel
 1753|      0|size_t strnlen1(char const *string, size_t maxlen) {
 1754|      0|  char const *end;
 1755|      0|  char const *tmp;
 1756|       |
 1757|      0|  {
 1758|      0|    tmp = (char const *)memchr((void const *)string, '\000', maxlen);
 1759|      0|    end = tmp;
 1760|      0|    if ((unsigned long)end != (unsigned long)((void *)0)) {
 1761|      0|      return ((size_t)((end - string) + 1L));
 1762|      0|    } else {
 1763|      0|      return (maxlen);
 1764|      0|    }
 1765|      0|  }
 1766|      0|}
 1767|       |_Bool strip_trailing_slashes(char *file);
 1768|      0|_Bool strip_trailing_slashes(char *file) {
 1769|      0|  char *base;
 1770|      0|  char *tmp;
 1771|      0|  char *base_lim;
 1772|      0|  _Bool had_slash;
 1773|      0|  size_t tmp___0;
 1774|       |
 1775|      0|  {
 1776|      0|    tmp = last_component((char const *)file);
 1777|      0|    base = tmp;
 1778|      0|    if (!*base) {
 1779|      0|      base = file;
 1780|      0|    }
 1781|      0|    tmp___0 = base_len((char const *)base);
 1782|      0|    base_lim = base + tmp___0;
 1783|      0|    had_slash = (_Bool)((int)*base_lim != 0);
 1784|      0|    *base_lim = (char)'\000';
 1785|      0|    return (had_slash);
 1786|      0|  }
 1787|      0|}
 1788|       |int open_safer(char const *file, int flags, ...);
 1789|       |extern DIR *fdopendir(int __fd);
 1790|       |struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i);
 1791|      0|struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i) {
 1792|      0|  struct stat statbuf;
 1793|      0|  int tmp;
 1794|       |
 1795|      0|  {
 1796|      0|    tmp = lstat("/", &statbuf);
 1797|      0|    if (tmp) {
 1798|      0|      return ((struct dev_ino *)((void *)0));
 1799|      0|    }
 1800|      0|    root_d_i->st_ino = statbuf.st_ino;
 1801|      0|    root_d_i->st_dev = statbuf.st_dev;
 1802|      0|    return (root_d_i);
 1803|      0|  }
 1804|      0|}
 1805|       |reg_syntax_t rpl_re_syntax_options;
 1806|       |char const *const quoting_style_args[9];
 1807|       |enum quoting_style const quoting_style_vals[8];
 1808|       |int set_char_quoting(struct quoting_options *o, char c, int i);
 1809|       |char *quotearg_char(char const *arg, char ch);
 1810|       |char *quotearg_char_mem(char const *arg, size_t argsize, char ch);
 1811|       |__inline static char *xcharalloc(size_t n) __attribute__((__malloc__));
 1812|       |__inline static char *xcharalloc(size_t n) __attribute__((__malloc__));
 1813|      0|__inline static char *xcharalloc(size_t n) {
 1814|      0|  void *tmp;
 1815|      0|  void *tmp___0;
 1816|      0|  void *tmp___1;
 1817|       |
 1818|      0|  {
 1819|      0|    if (sizeof(char) == 1UL) {
 1820|      0|      tmp = xmalloc(n);
 1821|      0|      tmp___1 = tmp;
 1822|      0|    } else {
 1823|      0|      tmp___0 = xnmalloc(n, sizeof(char));
 1824|      0|      tmp___1 = tmp___0;
 1825|      0|    }
 1826|      0|    return ((char *)tmp___1);
 1827|      0|  }
 1828|      0|}
 1829|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
 1830|       |                                        iswprint)(wint_t __wc);
 1831|       |char const *const quoting_style_args[9] = {
 1832|       |    "literal", "shell", "shell-always", "c", "c-maybe", "escape",
 1833|       |    "locale", "clocale", (char const *)0};
 1834|       |enum quoting_style const quoting_style_vals[8] = {
 1835|       |    (enum quoting_style const)0, (enum quoting_style const)1,
 1836|       |    (enum quoting_style const)2, (enum quoting_style const)3,
 1837|       |    (enum quoting_style const)4, (enum quoting_style const)5,
 1838|       |    (enum quoting_style const)6, (enum quoting_style const)7};
 1839|       |static struct quoting_options default_quoting_options;
 1840|      0|int set_char_quoting(struct quoting_options *o, char c, int i) {
 1841|      0|  unsigned char uc;
 1842|      0|  unsigned int *p;
 1843|      0|  struct quoting_options *tmp;
 1844|      0|  int shift;
 1845|      0|  int r;
 1846|       |
 1847|      0|  {
 1848|      0|    uc = (unsigned char)c;
 1849|      0|    if (o) {
 1850|      0|      tmp = o;
 1851|      0|    } else {
 1852|      0|      tmp = &default_quoting_options;
 1853|      0|    }
 1854|      0|    p = tmp->quote_these_too + (unsigned long)uc / (sizeof(int) * 8UL);
 1855|      0|    shift = (int)((unsigned long)uc % (sizeof(int) * 8UL));
 1856|      0|    r = (int)((*p >> shift) & 1U);
 1857|      0|    *p ^= (unsigned int)(((i & 1) ^ r) << shift);
 1858|      0|    return (r);
 1859|      0|  }
 1860|      0|}
 1861|       |static struct quoting_options
 1862|      0|quoting_options_from_style(enum quoting_style style) {
 1863|      0|  struct quoting_options o;
 1864|       |
 1865|      0|  {
 1866|      0|    o.style = style;
 1867|      0|    o.flags = 0;
 1868|      0|    memset((void *)(o.quote_these_too), 0, sizeof(o.quote_these_too));
 1869|      0|    return (o);
 1870|      0|  }
 1871|      0|}
 1872|      0|static char const *gettext_quote(char const *msgid, enum quoting_style s) {
 1873|      0|  char const *translation;
 1874|      0|  char const *tmp;
 1875|       |
 1876|      0|  {
 1877|      0|    tmp = (char const *)gettext(msgid);
 1878|      0|    translation = tmp;
 1879|      0|    if ((unsigned long)translation == (unsigned long)msgid) {
 1880|      0|      if ((unsigned int)s == 7U) {
 1881|      0|        translation = "\"";
 1882|      0|      }
 1883|      0|    }
 1884|      0|    return (translation);
 1885|      0|  }
 1886|      0|}
 1887|       |static size_t
 1888|       |quotearg_buffer_restyled(char *buffer, size_t buffersize, char const *arg,
 1889|       |                         size_t argsize, enum quoting_style quoting_style,
 1890|       |                         int flags, unsigned int const *quote_these_too,
 1891|      0|                         char const *left_quote, char const *right_quote) {
 1892|      0|  size_t i;
 1893|      0|  size_t len;
 1894|      0|  char const *quote_string;
 1895|      0|  size_t quote_string_len;
 1896|      0|  _Bool backslash_escapes;
 1897|      0|  _Bool unibyte_locale;
 1898|      0|  size_t tmp;
 1899|      0|  _Bool elide_outer_quotes;
 1900|      0|  unsigned char c;
 1901|      0|  unsigned char esc;
 1902|      0|  _Bool is_right_quote;
 1903|      0|  int tmp___0;
 1904|      0|  int tmp___1;
 1905|      0|  size_t m;
 1906|      0|  _Bool printable;
 1907|      0|  unsigned short const **tmp___2;
 1908|      0|  mbstate_t mbstate;
 1909|      0|  wchar_t w;
 1910|      0|  size_t bytes;
 1911|      0|  size_t tmp___3;
 1912|      0|  size_t j;
 1913|      0|  int tmp___4;
 1914|      0|  int tmp___5;
 1915|      0|  size_t ilim;
 1916|      0|  int tmp___6;
 1917|      0|  size_t tmp___7;
 1918|       |
 1919|      0|  {
 1920|      0|    len = (size_t)0;
 1921|      0|    quote_string = (char const *)0;
 1922|      0|    quote_string_len = (size_t)0;
 1923|      0|    backslash_escapes = (_Bool)0;
 1924|      0|    tmp = __ctype_get_mb_cur_max();
 1925|      0|    unibyte_locale = (_Bool)(tmp == 1UL);
 1926|      0|    elide_outer_quotes = (_Bool)((flags & 2) != 0);
 1927|      0|    if ((unsigned int)quoting_style == 4U) {
 1928|      0|      goto case_4;
 1929|      0|    }
 1930|      0|    if ((unsigned int)quoting_style == 3U) {
 1931|      0|      goto case_3;
 1932|      0|    }
 1933|      0|    if ((unsigned int)quoting_style == 5U) {
 1934|      0|      goto case_5;
 1935|      0|    }
 1936|      0|    if ((unsigned int)quoting_style == 6U) {
 1937|      0|      goto case_6;
 1938|      0|    }
 1939|      0|    if ((unsigned int)quoting_style == 7U) {
 1940|      0|      goto case_6;
 1941|      0|    }
 1942|      0|    if ((unsigned int)quoting_style == 8U) {
 1943|      0|      goto case_6;
 1944|      0|    }
 1945|      0|    if ((unsigned int)quoting_style == 1U) {
 1946|      0|      goto case_1;
 1947|      0|    }
 1948|      0|    if ((unsigned int)quoting_style == 2U) {
 1949|      0|      goto case_2;
 1950|      0|    }
 1951|      0|    if ((unsigned int)quoting_style == 0U) {
 1952|      0|      goto case_0;
 1953|      0|    }
 1954|      0|    goto switch_default;
 1955|      0|  case_4:
 1956|      0|    quoting_style = (enum quoting_style)3;
 1957|      0|    elide_outer_quotes = (_Bool)1;
 1958|      0|  case_3:
 1959|      0|    if (!elide_outer_quotes) {
 1960|      0|      while (1) {
 1961|       |
 1962|      0|        if (len < buffersize) {
 1963|      0|          *(buffer + len) = (char)'\"';
 1964|      0|        }
 1965|      0|        len++;
 1966|      0|        goto while_break;
 1967|      0|      }
 1968|      0|    while_break:;
 1969|      0|    }
 1970|      0|    backslash_escapes = (_Bool)1;
 1971|      0|    quote_string = "\"";
 1972|      0|    quote_string_len = (size_t)1;
 1973|      0|    goto switch_break;
 1974|      0|  case_5:
 1975|      0|    backslash_escapes = (_Bool)1;
 1976|      0|    elide_outer_quotes = (_Bool)0;
 1977|      0|    goto switch_break;
 1978|      0|  case_6:
 1979|      0|    if ((unsigned int)quoting_style != 8U) {
 1980|      0|      left_quote = gettext_quote("`", quoting_style);
 1981|      0|      right_quote = gettext_quote("\'", quoting_style);
 1982|      0|    }
 1983|      0|    if (!elide_outer_quotes) {
 1984|      0|      quote_string = left_quote;
 1985|      0|      while (1) {
 1986|       |
 1987|      0|        if (!*quote_string) {
 1988|      0|          goto while_break___0;
 1989|      0|        }
 1990|      0|        while (1) {
 1991|       |
 1992|      0|          if (len < buffersize) {
 1993|      0|            *(buffer + len) = (char)*quote_string;
 1994|      0|          }
 1995|      0|          len++;
 1996|      0|          goto while_break___1;
 1997|      0|        }
 1998|      0|      while_break___1:
 1999|      0|        quote_string++;
 2000|      0|      }
 2001|      0|    while_break___0:;
 2002|      0|    }
 2003|      0|    backslash_escapes = (_Bool)1;
 2004|      0|    quote_string = right_quote;
 2005|      0|    quote_string_len = strlen(quote_string);
 2006|      0|    goto switch_break;
 2007|      0|  case_1:
 2008|      0|    quoting_style = (enum quoting_style)2;
 2009|      0|    elide_outer_quotes = (_Bool)1;
 2010|      0|  case_2:
 2011|      0|    if (!elide_outer_quotes) {
 2012|      0|      while (1) {
 2013|       |
 2014|      0|        if (len < buffersize) {
 2015|      0|          *(buffer + len) = (char)'\'';
 2016|      0|        }
 2017|      0|        len++;
 2018|      0|        goto while_break___2;
 2019|      0|      }
 2020|      0|    while_break___2:;
 2021|      0|    }
 2022|      0|    quote_string = "\'";
 2023|      0|    quote_string_len = (size_t)1;
 2024|      0|    goto switch_break;
 2025|      0|  case_0:
 2026|      0|    elide_outer_quotes = (_Bool)0;
 2027|      0|    goto switch_break;
 2028|      0|  switch_default:
 2029|      0|    abort();
 2030|      0|  switch_break:
 2031|      0|    i = (size_t)0;
 2032|      0|    while (1) {
 2033|       |
 2034|      0|      if (argsize == 0xffffffffffffffffUL) {
 2035|      0|        tmp___6 = (int const) * (arg + i) == 0;
 2036|      0|      } else {
 2037|      0|        tmp___6 = i == argsize;
 2038|      0|      }
 2039|      0|      if (tmp___6) {
 2040|      0|        goto while_break___3;
 2041|      0|      }
 2042|      0|      is_right_quote = (_Bool)0;
 2043|      0|      if (backslash_escapes) {
 2044|      0|        if (quote_string_len) {
 2045|      0|          if (i + quote_string_len <= argsize) {
 2046|      0|            tmp___0 = memcmp((void const *)(arg + i),
 2047|      0|                             (void const *)quote_string, quote_string_len);
 2048|      0|            if (tmp___0 == 0) {
 2049|      0|              if (elide_outer_quotes) {
 2050|      0|                goto force_outer_quoting_style;
 2051|      0|              }
 2052|      0|              is_right_quote = (_Bool)1;
 2053|      0|            }
 2054|      0|          }
 2055|      0|        }
 2056|      0|      }
 2057|      0|      c = (unsigned char)*(arg + i);
 2058|      0|      if ((int)c == 0) {
 2059|      0|        goto case_0___0;
 2060|      0|      }
 2061|      0|      if ((int)c == 63) {
 2062|      0|        goto case_63;
 2063|      0|      }
 2064|      0|      if ((int)c == 7) {
 2065|      0|        goto case_7___0;
 2066|      0|      }
 2067|      0|      if ((int)c == 8) {
 2068|      0|        goto case_8___0;
 2069|      0|      }
 2070|      0|      if ((int)c == 12) {
 2071|      0|        goto case_12;
 2072|      0|      }
 2073|      0|      if ((int)c == 10) {
 2074|      0|        goto case_10;
 2075|      0|      }
 2076|      0|      if ((int)c == 13) {
 2077|      0|        goto case_13;
 2078|      0|      }
 2079|      0|      if ((int)c == 9) {
 2080|      0|        goto case_9;
 2081|      0|      }
 2082|      0|      if ((int)c == 11) {
 2083|      0|        goto case_11;
 2084|      0|      }
 2085|      0|      if ((int)c == 92) {
 2086|      0|        goto case_92;
 2087|      0|      }
 2088|      0|      if ((int)c == 123) {
 2089|      0|        goto case_123;
 2090|      0|      }
 2091|      0|      if ((int)c == 125) {
 2092|      0|        goto case_123;
 2093|      0|      }
 2094|      0|      if ((int)c == 35) {
 2095|      0|        goto case_35;
 2096|      0|      }
 2097|      0|      if ((int)c == 126) {
 2098|      0|        goto case_35;
 2099|      0|      }
 2100|      0|      if ((int)c == 32) {
 2101|      0|        goto case_32;
 2102|      0|      }
 2103|      0|      if ((int)c == 33) {
 2104|      0|        goto case_32;
 2105|      0|      }
 2106|      0|      if ((int)c == 34) {
 2107|      0|        goto case_32;
 2108|      0|      }
 2109|      0|      if ((int)c == 36) {
 2110|      0|        goto case_32;
 2111|      0|      }
 2112|      0|      if ((int)c == 38) {
 2113|      0|        goto case_32;
 2114|      0|      }
 2115|      0|      if ((int)c == 40) {
 2116|      0|        goto case_32;
 2117|      0|      }
 2118|      0|      if ((int)c == 41) {
 2119|      0|        goto case_32;
 2120|      0|      }
 2121|      0|      if ((int)c == 42) {
 2122|      0|        goto case_32;
 2123|      0|      }
 2124|      0|      if ((int)c == 59) {
 2125|      0|        goto case_32;
 2126|      0|      }
 2127|      0|      if ((int)c == 60) {
 2128|      0|        goto case_32;
 2129|      0|      }
 2130|      0|      if ((int)c == 61) {
 2131|      0|        goto case_32;
 2132|      0|      }
 2133|      0|      if ((int)c == 62) {
 2134|      0|        goto case_32;
 2135|      0|      }
 2136|      0|      if ((int)c == 91) {
 2137|      0|        goto case_32;
 2138|      0|      }
 2139|      0|      if ((int)c == 94) {
 2140|      0|        goto case_32;
 2141|      0|      }
 2142|      0|      if ((int)c == 96) {
 2143|      0|        goto case_32;
 2144|      0|      }
 2145|      0|      if ((int)c == 124) {
 2146|      0|        goto case_32;
 2147|      0|      }
 2148|      0|      if ((int)c == 39) {
 2149|      0|        goto case_39___0;
 2150|      0|      }
 2151|      0|      if ((int)c == 37) {
 2152|      0|        goto case_37;
 2153|      0|      }
 2154|      0|      if ((int)c == 43) {
 2155|      0|        goto case_37;
 2156|      0|      }
 2157|      0|      if ((int)c == 44) {
 2158|      0|        goto case_37;
 2159|      0|      }
 2160|      0|      if ((int)c == 45) {
 2161|      0|        goto case_37;
 2162|      0|      }
 2163|      0|      if ((int)c == 46) {
 2164|      0|        goto case_37;
 2165|      0|      }
 2166|      0|      if ((int)c == 47) {
 2167|      0|        goto case_37;
 2168|      0|      }
 2169|      0|      if ((int)c == 48) {
 2170|      0|        goto case_37;
 2171|      0|      }
 2172|      0|      if ((int)c == 49) {
 2173|      0|        goto case_37;
 2174|      0|      }
 2175|      0|      if ((int)c == 50) {
 2176|      0|        goto case_37;
 2177|      0|      }
 2178|      0|      if ((int)c == 51) {
 2179|      0|        goto case_37;
 2180|      0|      }
 2181|      0|      if ((int)c == 52) {
 2182|      0|        goto case_37;
 2183|      0|      }
 2184|      0|      if ((int)c == 53) {
 2185|      0|        goto case_37;
 2186|      0|      }
 2187|      0|      if ((int)c == 54) {
 2188|      0|        goto case_37;
 2189|      0|      }
 2190|      0|      if ((int)c == 55) {
 2191|      0|        goto case_37;
 2192|      0|      }
 2193|      0|      if ((int)c == 56) {
 2194|      0|        goto case_37;
 2195|      0|      }
 2196|      0|      if ((int)c == 57) {
 2197|      0|        goto case_37;
 2198|      0|      }
 2199|      0|      if ((int)c == 58) {
 2200|      0|        goto case_37;
 2201|      0|      }
 2202|      0|      if ((int)c == 65) {
 2203|      0|        goto case_37;
 2204|      0|      }
 2205|      0|      if ((int)c == 66) {
 2206|      0|        goto case_37;
 2207|      0|      }
 2208|      0|      if ((int)c == 67) {
 2209|      0|        goto case_37;
 2210|      0|      }
 2211|      0|      if ((int)c == 68) {
 2212|      0|        goto case_37;
 2213|      0|      }
 2214|      0|      if ((int)c == 69) {
 2215|      0|        goto case_37;
 2216|      0|      }
 2217|      0|      if ((int)c == 70) {
 2218|      0|        goto case_37;
 2219|      0|      }
 2220|      0|      if ((int)c == 71) {
 2221|      0|        goto case_37;
 2222|      0|      }
 2223|      0|      if ((int)c == 72) {
 2224|      0|        goto case_37;
 2225|      0|      }
 2226|      0|      if ((int)c == 73) {
 2227|      0|        goto case_37;
 2228|      0|      }
 2229|      0|      if ((int)c == 74) {
 2230|      0|        goto case_37;
 2231|      0|      }
 2232|      0|      if ((int)c == 75) {
 2233|      0|        goto case_37;
 2234|      0|      }
 2235|      0|      if ((int)c == 76) {
 2236|      0|        goto case_37;
 2237|      0|      }
 2238|      0|      if ((int)c == 77) {
 2239|      0|        goto case_37;
 2240|      0|      }
 2241|      0|      if ((int)c == 78) {
 2242|      0|        goto case_37;
 2243|      0|      }
 2244|      0|      if ((int)c == 79) {
 2245|      0|        goto case_37;
 2246|      0|      }
 2247|      0|      if ((int)c == 80) {
 2248|      0|        goto case_37;
 2249|      0|      }
 2250|      0|      if ((int)c == 81) {
 2251|      0|        goto case_37;
 2252|      0|      }
 2253|      0|      if ((int)c == 82) {
 2254|      0|        goto case_37;
 2255|      0|      }
 2256|      0|      if ((int)c == 83) {
 2257|      0|        goto case_37;
 2258|      0|      }
 2259|      0|      if ((int)c == 84) {
 2260|      0|        goto case_37;
 2261|      0|      }
 2262|      0|      if ((int)c == 85) {
 2263|      0|        goto case_37;
 2264|      0|      }
 2265|      0|      if ((int)c == 86) {
 2266|      0|        goto case_37;
 2267|      0|      }
 2268|      0|      if ((int)c == 87) {
 2269|      0|        goto case_37;
 2270|      0|      }
 2271|      0|      if ((int)c == 88) {
 2272|      0|        goto case_37;
 2273|      0|      }
 2274|      0|      if ((int)c == 89) {
 2275|      0|        goto case_37;
 2276|      0|      }
 2277|      0|      if ((int)c == 90) {
 2278|      0|        goto case_37;
 2279|      0|      }
 2280|      0|      if ((int)c == 93) {
 2281|      0|        goto case_37;
 2282|      0|      }
 2283|      0|      if ((int)c == 95) {
 2284|      0|        goto case_37;
 2285|      0|      }
 2286|      0|      if ((int)c == 97) {
 2287|      0|        goto case_37;
 2288|      0|      }
 2289|      0|      if ((int)c == 98) {
 2290|      0|        goto case_37;
 2291|      0|      }
 2292|      0|      if ((int)c == 99) {
 2293|      0|        goto case_37;
 2294|      0|      }
 2295|      0|      if ((int)c == 100) {
 2296|      0|        goto case_37;
 2297|      0|      }
 2298|      0|      if ((int)c == 101) {
 2299|      0|        goto case_37;
 2300|      0|      }
 2301|      0|      if ((int)c == 102) {
 2302|      0|        goto case_37;
 2303|      0|      }
 2304|      0|      if ((int)c == 103) {
 2305|      0|        goto case_37;
 2306|      0|      }
 2307|      0|      if ((int)c == 104) {
 2308|      0|        goto case_37;
 2309|      0|      }
 2310|      0|      if ((int)c == 105) {
 2311|      0|        goto case_37;
 2312|      0|      }
 2313|      0|      if ((int)c == 106) {
 2314|      0|        goto case_37;
 2315|      0|      }
 2316|      0|      if ((int)c == 107) {
 2317|      0|        goto case_37;
 2318|      0|      }
 2319|      0|      if ((int)c == 108) {
 2320|      0|        goto case_37;
 2321|      0|      }
 2322|      0|      if ((int)c == 109) {
 2323|      0|        goto case_37;
 2324|      0|      }
 2325|      0|      if ((int)c == 110) {
 2326|      0|        goto case_37;
 2327|      0|      }
 2328|      0|      if ((int)c == 111) {
 2329|      0|        goto case_37;
 2330|      0|      }
 2331|      0|      if ((int)c == 112) {
 2332|      0|        goto case_37;
 2333|      0|      }
 2334|      0|      if ((int)c == 113) {
 2335|      0|        goto case_37;
 2336|      0|      }
 2337|      0|      if ((int)c == 114) {
 2338|      0|        goto case_37;
 2339|      0|      }
 2340|      0|      if ((int)c == 115) {
 2341|      0|        goto case_37;
 2342|      0|      }
 2343|      0|      if ((int)c == 116) {
 2344|      0|        goto case_37;
 2345|      0|      }
 2346|      0|      if ((int)c == 117) {
 2347|      0|        goto case_37;
 2348|      0|      }
 2349|      0|      if ((int)c == 118) {
 2350|      0|        goto case_37;
 2351|      0|      }
 2352|      0|      if ((int)c == 119) {
 2353|      0|        goto case_37;
 2354|      0|      }
 2355|      0|      if ((int)c == 120) {
 2356|      0|        goto case_37;
 2357|      0|      }
 2358|      0|      if ((int)c == 121) {
 2359|      0|        goto case_37;
 2360|      0|      }
 2361|      0|      if ((int)c == 122) {
 2362|      0|        goto case_37;
 2363|      0|      }
 2364|      0|      goto switch_default___2;
 2365|      0|    case_0___0:
 2366|      0|      if (backslash_escapes) {
 2367|      0|        if (elide_outer_quotes) {
 2368|      0|          goto force_outer_quoting_style;
 2369|      0|        }
 2370|      0|        while (1) {
 2371|       |
 2372|      0|          if (len < buffersize) {
 2373|      0|            *(buffer + len) = (char)'\\';
 2374|      0|          }
 2375|      0|          len++;
 2376|      0|          goto while_break___4;
 2377|      0|        }
 2378|      0|      while_break___4:;
 2379|      0|        if (i + 1UL < argsize) {
 2380|      0|          if (48 <= (int)*(arg + (i + 1UL))) {
 2381|      0|            if ((int const) * (arg + (i + 1UL)) <= 57) {
 2382|      0|              while (1) {
 2383|       |
 2384|      0|                if (len < buffersize) {
 2385|      0|                  *(buffer + len) = (char)'0';
 2386|      0|                }
 2387|      0|                len++;
 2388|      0|                goto while_break___5;
 2389|      0|              }
 2390|      0|            while_break___5:;
 2391|      0|              while (1) {
 2392|       |
 2393|      0|                if (len < buffersize) {
 2394|      0|                  *(buffer + len) = (char)'0';
 2395|      0|                }
 2396|      0|                len++;
 2397|      0|                goto while_break___6;
 2398|      0|              }
 2399|      0|            while_break___6:;
 2400|      0|            }
 2401|      0|          }
 2402|      0|        }
 2403|      0|        c = (unsigned char)'0';
 2404|      0|      } else {
 2405|      0|        if (flags & 1) {
 2406|      0|          goto __Cont;
 2407|      0|        }
 2408|      0|      }
 2409|      0|      goto switch_break___0;
 2410|      0|    case_63:
 2411|      0|      if ((unsigned int)quoting_style == 2U) {
 2412|      0|        goto case_2___0;
 2413|      0|      }
 2414|      0|      if ((unsigned int)quoting_style == 3U) {
 2415|      0|        goto case_3___0;
 2416|      0|      }
 2417|      0|      goto switch_default___1;
 2418|      0|    case_2___0:
 2419|      0|      if (elide_outer_quotes) {
 2420|      0|        goto force_outer_quoting_style;
 2421|      0|      }
 2422|      0|      goto switch_break___1;
 2423|      0|    case_3___0:
 2424|      0|      if (flags & 4) {
 2425|      0|        if (i + 2UL < argsize) {
 2426|      0|          if ((int const) * (arg + (i + 1UL)) == 63) {
 2427|      0|            if ((int const) * (arg + (i + 2UL)) == 33) {
 2428|      0|              goto case_33;
 2429|      0|            }
 2430|      0|            if ((int const) * (arg + (i + 2UL)) == 39) {
 2431|      0|              goto case_33;
 2432|      0|            }
 2433|      0|            if ((int const) * (arg + (i + 2UL)) == 40) {
 2434|      0|              goto case_33;
 2435|      0|            }
 2436|      0|            if ((int const) * (arg + (i + 2UL)) == 41) {
 2437|      0|              goto case_33;
 2438|      0|            }
 2439|      0|            if ((int const) * (arg + (i + 2UL)) == 45) {
 2440|      0|              goto case_33;
 2441|      0|            }
 2442|      0|            if ((int const) * (arg + (i + 2UL)) == 47) {
 2443|      0|              goto case_33;
 2444|      0|            }
 2445|      0|            if ((int const) * (arg + (i + 2UL)) == 60) {
 2446|      0|              goto case_33;
 2447|      0|            }
 2448|      0|            if ((int const) * (arg + (i + 2UL)) == 61) {
 2449|      0|              goto case_33;
 2450|      0|            }
 2451|      0|            if ((int const) * (arg + (i + 2UL)) == 62) {
 2452|      0|              goto case_33;
 2453|      0|            }
 2454|      0|            goto switch_default___0;
 2455|      0|          case_33:
 2456|      0|            if (elide_outer_quotes) {
 2457|      0|              goto force_outer_quoting_style;
 2458|      0|            }
 2459|      0|            c = (unsigned char)*(arg + (i + 2UL));
 2460|      0|            i += 2UL;
 2461|      0|            while (1) {
 2462|       |
 2463|      0|              if (len < buffersize) {
 2464|      0|                *(buffer + len) = (char)'?';
 2465|      0|              }
 2466|      0|              len++;
 2467|      0|              goto while_break___7;
 2468|      0|            }
 2469|      0|          while_break___7:;
 2470|      0|            while (1) {
 2471|       |
 2472|      0|              if (len < buffersize) {
 2473|      0|                *(buffer + len) = (char)'\"';
 2474|      0|              }
 2475|      0|              len++;
 2476|      0|              goto while_break___8;
 2477|      0|            }
 2478|      0|          while_break___8:;
 2479|      0|            while (1) {
 2480|       |
 2481|      0|              if (len < buffersize) {
 2482|      0|                *(buffer + len) = (char)'\"';
 2483|      0|              }
 2484|      0|              len++;
 2485|      0|              goto while_break___9;
 2486|      0|            }
 2487|      0|          while_break___9:;
 2488|      0|            while (1) {
 2489|       |
 2490|      0|              if (len < buffersize) {
 2491|      0|                *(buffer + len) = (char)'?';
 2492|      0|              }
 2493|      0|              len++;
 2494|      0|              goto while_break___10;
 2495|      0|            }
 2496|      0|          while_break___10:;
 2497|      0|            goto switch_break___2;
 2498|      0|          switch_default___0:
 2499|      0|            goto switch_break___2;
 2500|      0|          switch_break___2:;
 2501|      0|          }
 2502|      0|        }
 2503|      0|      }
 2504|      0|      goto switch_break___1;
 2505|      0|    switch_default___1:
 2506|      0|      goto switch_break___1;
 2507|      0|    switch_break___1:;
 2508|      0|      goto switch_break___0;
 2509|      0|    case_7___0:
 2510|      0|      esc = (unsigned char)'a';
 2511|      0|      goto c_escape;
 2512|      0|    case_8___0:
 2513|      0|      esc = (unsigned char)'b';
 2514|      0|      goto c_escape;
 2515|      0|    case_12:
 2516|      0|      esc = (unsigned char)'f';
 2517|      0|      goto c_escape;
 2518|      0|    case_10:
 2519|      0|      esc = (unsigned char)'n';
 2520|      0|      goto c_and_shell_escape;
 2521|      0|    case_13:
 2522|      0|      esc = (unsigned char)'r';
 2523|      0|      goto c_and_shell_escape;
 2524|      0|    case_9:
 2525|      0|      esc = (unsigned char)'t';
 2526|      0|      goto c_and_shell_escape;
 2527|      0|    case_11:
 2528|      0|      esc = (unsigned char)'v';
 2529|      0|      goto c_escape;
 2530|      0|    case_92:
 2531|      0|      esc = c;
 2532|      0|      if (backslash_escapes) {
 2533|      0|        if (elide_outer_quotes) {
 2534|      0|          if (quote_string_len) {
 2535|      0|            goto store_c;
 2536|      0|          }
 2537|      0|        }
 2538|      0|      }
 2539|      0|    c_and_shell_escape:
 2540|      0|      if ((unsigned int)quoting_style == 2U) {
 2541|      0|        if (elide_outer_quotes) {
 2542|      0|          goto force_outer_quoting_style;
 2543|      0|        }
 2544|      0|      }
 2545|      0|    c_escape:
 2546|      0|      if (backslash_escapes) {
 2547|      0|        c = esc;
 2548|      0|        goto store_escape;
 2549|      0|      }
 2550|      0|      goto switch_break___0;
 2551|      0|    case_123:
 2552|      0|      if (argsize == 0xffffffffffffffffUL) {
 2553|      0|        tmp___1 = (int const) * (arg + 1) == 0;
 2554|      0|      } else {
 2555|      0|        tmp___1 = argsize == 1UL;
 2556|      0|      }
 2557|      0|      if (!tmp___1) {
 2558|      0|        goto switch_break___0;
 2559|      0|      }
 2560|      0|    case_35:
 2561|      0|      if (i != 0UL) {
 2562|      0|        goto switch_break___0;
 2563|      0|      }
 2564|      0|    case_32:
 2565|      0|      if ((unsigned int)quoting_style == 2U) {
 2566|      0|        if (elide_outer_quotes) {
 2567|      0|          goto force_outer_quoting_style;
 2568|      0|        }
 2569|      0|      }
 2570|      0|      goto switch_break___0;
 2571|      0|    case_39___0:
 2572|      0|      if ((unsigned int)quoting_style == 2U) {
 2573|      0|        if (elide_outer_quotes) {
 2574|      0|          goto force_outer_quoting_style;
 2575|      0|        }
 2576|      0|        while (1) {
 2577|       |
 2578|      0|          if (len < buffersize) {
 2579|      0|            *(buffer + len) = (char)'\'';
 2580|      0|          }
 2581|      0|          len++;
 2582|      0|          goto while_break___11;
 2583|      0|        }
 2584|      0|      while_break___11:;
 2585|      0|        while (1) {
 2586|       |
 2587|      0|          if (len < buffersize) {
 2588|      0|            *(buffer + len) = (char)'\\';
 2589|      0|          }
 2590|      0|          len++;
 2591|      0|          goto while_break___12;
 2592|      0|        }
 2593|      0|      while_break___12:;
 2594|      0|        while (1) {
 2595|       |
 2596|      0|          if (len < buffersize) {
 2597|      0|            *(buffer + len) = (char)'\'';
 2598|      0|          }
 2599|      0|          len++;
 2600|      0|          goto while_break___13;
 2601|      0|        }
 2602|      0|      while_break___13:;
 2603|      0|      }
 2604|      0|      goto switch_break___0;
 2605|      0|    case_37:
 2606|      0|      goto switch_break___0;
 2607|      0|    switch_default___2:
 2608|      0|      if (unibyte_locale) {
 2609|      0|        m = (size_t)1;
 2610|      0|        tmp___2 = __ctype_b_loc();
 2611|      0|        printable = (_Bool)(((int const) * (*tmp___2 + (int)c) & 16384) != 0);
 2612|      0|      } else {
 2613|      0|        memset((void *)(&mbstate), 0, sizeof(mbstate));
 2614|      0|        m = (size_t)0;
 2615|      0|        printable = (_Bool)1;
 2616|      0|        if (argsize == 0xffffffffffffffffUL) {
 2617|      0|          argsize = strlen(arg);
 2618|      0|        }
 2619|      0|        while (1) {
 2620|      0|          tmp___3 = mbrtowc(&w, arg + (i + m), argsize - (i + m), &mbstate);
 2621|      0|          bytes = tmp___3;
 2622|      0|          if (bytes == 0UL) {
 2623|      0|            goto while_break___14;
 2624|      0|          } else {
 2625|      0|            if (bytes == 0xffffffffffffffffUL) {
 2626|      0|              printable = (_Bool)0;
 2627|      0|              goto while_break___14;
 2628|      0|            } else {
 2629|      0|              if (bytes == 0xfffffffffffffffeUL) {
 2630|      0|                printable = (_Bool)0;
 2631|      0|                while (1) {
 2632|       |
 2633|      0|                  if (i + m < argsize) {
 2634|      0|                    if (!*(arg + (i + m))) {
 2635|      0|                      goto while_break___15;
 2636|      0|                    }
 2637|      0|                  } else {
 2638|      0|                    goto while_break___15;
 2639|      0|                  }
 2640|      0|                  m++;
 2641|      0|                }
 2642|      0|              while_break___15:;
 2643|      0|                goto while_break___14;
 2644|      0|              } else {
 2645|      0|                if (elide_outer_quotes) {
 2646|      0|                  if ((unsigned int)quoting_style == 2U) {
 2647|      0|                    j = (size_t)1;
 2648|      0|                    while (1) {
 2649|       |
 2650|      0|                      if (!(j < bytes)) {
 2651|      0|                        goto while_break___16;
 2652|      0|                      }
 2653|      0|                      if ((int const) * (arg + ((i + m) + j)) == 91) {
 2654|      0|                        goto case_91___0;
 2655|      0|                      }
 2656|      0|                      if ((int const) * (arg + ((i + m) + j)) == 92) {
 2657|      0|                        goto case_91___0;
 2658|      0|                      }
 2659|      0|                      if ((int const) * (arg + ((i + m) + j)) == 94) {
 2660|      0|                        goto case_91___0;
 2661|      0|                      }
 2662|      0|                      if ((int const) * (arg + ((i + m) + j)) == 96) {
 2663|      0|                        goto case_91___0;
 2664|      0|                      }
 2665|      0|                      if ((int const) * (arg + ((i + m) + j)) == 124) {
 2666|      0|                        goto case_91___0;
 2667|      0|                      }
 2668|      0|                      goto switch_default___3;
 2669|      0|                    case_91___0:
 2670|      0|                      goto force_outer_quoting_style;
 2671|      0|                    switch_default___3:
 2672|      0|                      goto switch_break___3;
 2673|      0|                    switch_break___3:
 2674|      0|                      j++;
 2675|      0|                    }
 2676|      0|                  while_break___16:;
 2677|      0|                  }
 2678|      0|                }
 2679|      0|                tmp___4 = iswprint((wint_t)w);
 2680|      0|                if (!tmp___4) {
 2681|      0|                  printable = (_Bool)0;
 2682|      0|                }
 2683|      0|                m += bytes;
 2684|      0|              }
 2685|      0|            }
 2686|      0|          }
 2687|      0|          tmp___5 = mbsinit((mbstate_t const *)(&mbstate));
 2688|      0|          if (tmp___5) {
 2689|      0|            goto while_break___14;
 2690|      0|          }
 2691|      0|        }
 2692|      0|      while_break___14:;
 2693|      0|      }
 2694|      0|      if (1UL < m) {
 2695|      0|        goto _L___0;
 2696|      0|      } else {
 2697|      0|        if (backslash_escapes) {
 2698|      0|          if (!printable) {
 2699|      0|          _L___0:
 2700|      0|            ilim = i + m;
 2701|      0|            while (1) {
 2702|       |
 2703|      0|              if (backslash_escapes) {
 2704|      0|                if (!printable) {
 2705|      0|                  if (elide_outer_quotes) {
 2706|      0|                    goto force_outer_quoting_style;
 2707|      0|                  }
 2708|      0|                  while (1) {
 2709|       |
 2710|      0|                    if (len < buffersize) {
 2711|      0|                      *(buffer + len) = (char)'\\';
 2712|      0|                    }
 2713|      0|                    len++;
 2714|      0|                    goto while_break___18;
 2715|      0|                  }
 2716|      0|                while_break___18:;
 2717|      0|                  while (1) {
 2718|       |
 2719|      0|                    if (len < buffersize) {
 2720|      0|                      *(buffer + len) = (char)(48 + ((int)c >> 6));
 2721|      0|                    }
 2722|      0|                    len++;
 2723|      0|                    goto while_break___19;
 2724|      0|                  }
 2725|      0|                while_break___19:;
 2726|      0|                  while (1) {
 2727|       |
 2728|      0|                    if (len < buffersize) {
 2729|      0|                      *(buffer + len) = (char)(48 + (((int)c >> 3) & 7));
 2730|      0|                    }
 2731|      0|                    len++;
 2732|      0|                    goto while_break___20;
 2733|      0|                  }
 2734|      0|                while_break___20:
 2735|      0|                  c = (unsigned char)(48 + ((int)c & 7));
 2736|      0|                } else {
 2737|      0|                  goto _L;
 2738|      0|                }
 2739|      0|              } else {
 2740|      0|              _L:
 2741|      0|                if (is_right_quote) {
 2742|      0|                  while (1) {
 2743|       |
 2744|      0|                    if (len < buffersize) {
 2745|      0|                      *(buffer + len) = (char)'\\';
 2746|      0|                    }
 2747|      0|                    len++;
 2748|      0|                    goto while_break___21;
 2749|      0|                  }
 2750|      0|                while_break___21:
 2751|      0|                  is_right_quote = (_Bool)0;
 2752|      0|                }
 2753|      0|              }
 2754|      0|              if (ilim <= i + 1UL) {
 2755|      0|                goto while_break___17;
 2756|      0|              }
 2757|      0|              while (1) {
 2758|       |
 2759|      0|                if (len < buffersize) {
 2760|      0|                  *(buffer + len) = (char)c;
 2761|      0|                }
 2762|      0|                len++;
 2763|      0|                goto while_break___22;
 2764|      0|              }
 2765|      0|            while_break___22:
 2766|      0|              i++;
 2767|      0|              c = (unsigned char)*(arg + i);
 2768|      0|            }
 2769|      0|          while_break___17:;
 2770|      0|            goto store_c;
 2771|      0|          }
 2772|      0|        }
 2773|      0|      }
 2774|      0|    switch_break___0:;
 2775|      0|      if (backslash_escapes) {
 2776|      0|        goto _L___3;
 2777|      0|      } else {
 2778|      0|        if (elide_outer_quotes) {
 2779|      0|        _L___3:
 2780|      0|          if (quote_these_too) {
 2781|      0|            if (!(*(quote_these_too + (unsigned long)c / (sizeof(int) * 8UL)) &
 2782|      0|                  (unsigned int const)(1 << (unsigned long)c %
 2783|      0|                                                (sizeof(int) * 8UL)))) {
 2784|      0|              goto _L___2;
 2785|      0|            }
 2786|      0|          } else {
 2787|      0|            goto _L___2;
 2788|      0|          }
 2789|      0|        } else {
 2790|      0|        _L___2:
 2791|      0|          if (!is_right_quote) {
 2792|      0|            goto store_c;
 2793|      0|          }
 2794|      0|        }
 2795|      0|      }
 2796|      0|    store_escape:
 2797|      0|      if (elide_outer_quotes) {
 2798|      0|        goto force_outer_quoting_style;
 2799|      0|      }
 2800|      0|      while (1) {
 2801|       |
 2802|      0|        if (len < buffersize) {
 2803|      0|          *(buffer + len) = (char)'\\';
 2804|      0|        }
 2805|      0|        len++;
 2806|      0|        goto while_break___23;
 2807|      0|      }
 2808|      0|    while_break___23:;
 2809|      0|    store_c:
 2810|      0|      while (1) {
 2811|       |
 2812|      0|        if (len < buffersize) {
 2813|      0|          *(buffer + len) = (char)c;
 2814|      0|        }
 2815|      0|        len++;
 2816|      0|        goto while_break___24;
 2817|      0|      }
 2818|      0|    while_break___24:;
 2819|      0|    __Cont:
 2820|      0|      i++;
 2821|      0|    }
 2822|      0|  while_break___3:;
 2823|      0|    if (len == 0UL) {
 2824|      0|      if ((unsigned int)quoting_style == 2U) {
 2825|      0|        if (elide_outer_quotes) {
 2826|      0|          goto force_outer_quoting_style;
 2827|      0|        }
 2828|      0|      }
 2829|      0|    }
 2830|      0|    if (quote_string) {
 2831|      0|      if (!elide_outer_quotes) {
 2832|      0|        while (1) {
 2833|       |
 2834|      0|          if (!*quote_string) {
 2835|      0|            goto while_break___25;
 2836|      0|          }
 2837|      0|          while (1) {
 2838|       |
 2839|      0|            if (len < buffersize) {
 2840|      0|              *(buffer + len) = (char)*quote_string;
 2841|      0|            }
 2842|      0|            len++;
 2843|      0|            goto while_break___26;
 2844|      0|          }
 2845|      0|        while_break___26:
 2846|      0|          quote_string++;
 2847|      0|        }
 2848|      0|      while_break___25:;
 2849|      0|      }
 2850|      0|    }
 2851|      0|    if (len < buffersize) {
 2852|      0|      *(buffer + len) = (char)'\000';
 2853|      0|    }
 2854|      0|    return (len);
 2855|      0|  force_outer_quoting_style:
 2856|      0|    tmp___7 = quotearg_buffer_restyled(
 2857|      0|        buffer, buffersize, arg, argsize, quoting_style, flags & -3,
 2858|      0|        (unsigned int const *)((void *)0), left_quote, right_quote);
 2859|      0|    return (tmp___7);
 2860|      0|  }
 2861|      0|}
 2862|       |static char slot0[256];
 2863|       |static unsigned int nslots = 1U;
 2864|       |static struct slotvec slotvec0 = {sizeof(slot0), slot0};
 2865|       |static struct slotvec *slotvec = &slotvec0;
 2866|       |static char *quotearg_n_options(int n, char const *arg, size_t argsize,
 2867|      0|                                struct quoting_options const *options) {
 2868|      0|  int e;
 2869|      0|  int *tmp;
 2870|      0|  unsigned int n0;
 2871|      0|  struct slotvec *sv;
 2872|      0|  size_t n1;
 2873|      0|  _Bool preallocated;
 2874|      0|  int tmp___0;
 2875|      0|  struct slotvec *tmp___1;
 2876|      0|  size_t size;
 2877|      0|  char *val;
 2878|      0|  int flags;
 2879|      0|  size_t qsize;
 2880|      0|  size_t tmp___2;
 2881|      0|  int *tmp___3;
 2882|       |
 2883|      0|  {
 2884|      0|    tmp = __errno_location();
 2885|      0|    e = *tmp;
 2886|      0|    n0 = (unsigned int)n;
 2887|      0|    sv = slotvec;
 2888|      0|    if (n < 0) {
 2889|      0|      abort();
 2890|      0|    }
 2891|      0|    if (nslots <= n0) {
 2892|      0|      n1 = (size_t)(n0 + 1U);
 2893|      0|      preallocated = (_Bool)((unsigned long)sv == (unsigned long)(&slotvec0));
 2894|      0|      if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 2895|      0|        tmp___0 = -1;
 2896|      0|      } else {
 2897|      0|        tmp___0 = -2;
 2898|      0|      }
 2899|      0|      if ((size_t)tmp___0 / sizeof(*sv) < n1) {
 2900|      0|        xalloc_die();
 2901|      0|      }
 2902|      0|      if (preallocated) {
 2903|      0|        tmp___1 = (struct slotvec *)((void *)0);
 2904|      0|      } else {
 2905|      0|        tmp___1 = sv;
 2906|      0|      }
 2907|      0|      sv = (struct slotvec *)xrealloc((void *)tmp___1, n1 * sizeof(*sv));
 2908|      0|      slotvec = sv;
 2909|      0|      if (preallocated) {
 2910|      0|        *sv = slotvec0;
 2911|      0|      }
 2912|      0|      memset((void *)(sv + nslots), 0, (n1 - (size_t)nslots) * sizeof(*sv));
 2913|      0|      nslots = (unsigned int)n1;
 2914|      0|    }
 2915|      0|    size = (sv + n)->size;
 2916|      0|    val = (sv + n)->val;
 2917|      0|    flags = (int)(options->flags | 1);
 2918|      0|    tmp___2 = quotearg_buffer_restyled(
 2919|      0|        val, size, arg, argsize, (enum quoting_style)options->style, flags,
 2920|      0|        (unsigned int const *)(options->quote_these_too),
 2921|      0|        (char const *)options->left_quote, (char const *)options->right_quote);
 2922|      0|    qsize = tmp___2;
 2923|      0|    if (size <= qsize) {
 2924|      0|      size = qsize + 1UL;
 2925|      0|      (sv + n)->size = size;
 2926|      0|      if ((unsigned long)val != (unsigned long)(slot0)) {
 2927|      0|        free((void *)val);
 2928|      0|      }
 2929|      0|      val = xcharalloc(size);
 2930|      0|      (sv + n)->val = val;
 2931|      0|      quotearg_buffer_restyled(val, size, arg, argsize,
 2932|      0|                               (enum quoting_style)options->style, flags,
 2933|      0|                               (unsigned int const *)(options->quote_these_too),
 2934|      0|                               (char const *)options->left_quote,
 2935|      0|                               (char const *)options->right_quote);
 2936|      0|    }
 2937|      0|    tmp___3 = __errno_location();
 2938|      0|    *tmp___3 = e;
 2939|      0|    return (val);
 2940|      0|  }
 2941|      0|}
 2942|      0|char *quotearg_n_style(int n, enum quoting_style s, char const *arg) {
 2943|      0|  struct quoting_options o;
 2944|      0|  struct quoting_options tmp;
 2945|      0|  char *tmp___0;
 2946|       |
 2947|      0|  {
 2948|      0|    tmp = quoting_options_from_style(s);
 2949|      0|    o = tmp;
 2950|      0|    tmp___0 = quotearg_n_options(n, arg, (size_t)-1,
 2951|      0|                                 (struct quoting_options const *)(&o));
 2952|      0|    return (tmp___0);
 2953|      0|  }
 2954|      0|}
 2955|      0|char *quotearg_char_mem(char const *arg, size_t argsize, char ch) {
 2956|      0|  struct quoting_options options;
 2957|      0|  char *tmp;
 2958|       |
 2959|      0|  {
 2960|      0|    options = default_quoting_options;
 2961|      0|    set_char_quoting(&options, ch, 1);
 2962|      0|    tmp = quotearg_n_options(0, arg, argsize,
 2963|      0|                             (struct quoting_options const *)(&options));
 2964|      0|    return (tmp);
 2965|      0|  }
 2966|      0|}
 2967|      0|char *quotearg_char(char const *arg, char ch) {
 2968|      0|  char *tmp;
 2969|       |
 2970|      0|  {
 2971|      0|    tmp = quotearg_char_mem(arg, (size_t)-1, ch);
 2972|      0|    return (tmp);
 2973|      0|  }
 2974|      0|}
 2975|      0|char *quotearg_colon(char const *arg) {
 2976|      0|  char *tmp;
 2977|       |
 2978|      0|  {
 2979|      0|    tmp = quotearg_char(arg, (char)':');
 2980|      0|    return (tmp);
 2981|      0|  }
 2982|      0|}
 2983|      0|char const *quote_n(int n, char const *name) {
 2984|      0|  char const *tmp;
 2985|       |
 2986|      0|  {
 2987|      0|    tmp = (char const *)quotearg_n_style(n, (enum quoting_style)6, name);
 2988|      0|    return (tmp);
 2989|      0|  }
 2990|      0|}
 2991|      0|char const *quote(char const *name) {
 2992|      0|  char const *tmp;
 2993|       |
 2994|      0|  {
 2995|      0|    tmp = quote_n(0, name);
 2996|      0|    return (tmp);
 2997|      0|  }
 2998|      0|}
 2999|       |char const *program_name;
 3000|       |void set_program_name(char const *argv0);
 3001|       |extern char *program_invocation_name;
 3002|       |extern char *program_invocation_short_name;
 3003|       |extern int fputs(char const *__restrict __s, FILE *__restrict __stream);
 3004|       |char const *program_name = (char const *)((void *)0);
 3005|      1|void set_program_name(char const *argv0) {
 3006|      1|  char const *slash;
 3007|      1|  char const *base;
 3008|      1|  int tmp;
 3009|      1|  int tmp___0;
 3010|       |
 3011|      1|  {
 3012|      1|    if ((unsigned long)argv0 == (unsigned long)((void *)0)) {
 3013|      0|      fputs("A NULL argv[0] was passed through an exec system call.\n", stderr);
 3014|      0|      abort();
 3015|      0|    }
 3016|      1|    slash = (char const *)strrchr(argv0, '/');
 3017|      1|    if ((unsigned long)slash != (unsigned long)((void *)0)) {
 3018|      1|      base = slash + 1;
 3019|      1|    } else {
 3020|      0|      base = argv0;
 3021|      0|    }
 3022|      1|    if (base - argv0 >= 7L) {
 3023|      0|      tmp___0 = strncmp(base - 7, "/.libs/", (size_t)7);
 3024|      0|      if (tmp___0 == 0) {
 3025|      0|        argv0 = base;
 3026|      0|        tmp = strncmp(base, "lt-", (size_t)3);
 3027|      0|        if (tmp == 0) {
 3028|      0|          argv0 = base + 3;
 3029|      0|          program_invocation_short_name = (char *)argv0;
 3030|      0|        }
 3031|      0|      }
 3032|      0|    }
 3033|      1|    program_name = argv0;
 3034|      1|    program_invocation_name = (char *)argv0;
 3035|      1|    return;
 3036|      1|  }
 3037|      1|}
 3038|       |extern DIR *(__attribute__((__nonnull__(1))) opendir)(char const *__name);
 3039|       |extern
 3040|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 3041|       |                                     dirfd)(DIR *__dirp);
 3042|      0|DIR *opendir_safer(char const *name) {
 3043|      0|  DIR *dp;
 3044|      0|  DIR *tmp;
 3045|      0|  int fd;
 3046|      0|  int tmp___0;
 3047|      0|  DIR *newdp;
 3048|      0|  int e;
 3049|      0|  int f;
 3050|      0|  int tmp___1;
 3051|      0|  int *tmp___2;
 3052|      0|  int *tmp___3;
 3053|       |
 3054|      0|  {
 3055|      0|    tmp = opendir(name);
 3056|      0|    dp = tmp;
 3057|      0|    if (dp) {
 3058|      0|      tmp___0 = dirfd(dp);
 3059|      0|      fd = tmp___0;
 3060|      0|      if (0 <= fd) {
 3061|      0|        if (fd <= 2) {
 3062|      0|          tmp___1 = dup_safer(fd);
 3063|      0|          f = tmp___1;
 3064|      0|          newdp = fdopendir(f);
 3065|      0|          tmp___2 = __errno_location();
 3066|      0|          e = *tmp___2;
 3067|      0|          if (!newdp) {
 3068|      0|            close(f);
 3069|      0|          }
 3070|      0|          closedir(dp);
 3071|      0|          tmp___3 = __errno_location();
 3072|      0|          *tmp___3 = e;
 3073|      0|          dp = newdp;
 3074|      0|        }
 3075|      0|      }
 3076|      0|    }
 3077|      0|    return (dp);
 3078|      0|  }
 3079|      0|}
 3080|       |int openat_safer(int fd, char const *file, int flags, ...);
 3081|      0|int openat_safer(int fd, char const *file, int flags, ...) {
 3082|      0|  mode_t mode;
 3083|      0|  va_list ap;
 3084|      0|  int tmp;
 3085|      0|  int tmp___0;
 3086|       |
 3087|      0|  {
 3088|      0|    mode = (mode_t)0;
 3089|      0|    if (flags & 64) {
 3090|      0|      __builtin_va_start(ap, flags);
 3091|      0|      mode = __builtin_va_arg(ap, mode_t);
 3092|      0|      __builtin_va_end(ap);
 3093|      0|    }
 3094|      0|    tmp = openat(fd, file, flags, mode);
 3095|      0|    tmp___0 = fd_safer(tmp);
 3096|      0|    return (tmp___0);
 3097|      0|  }
 3098|      0|}
 3099|      0|int open_safer(char const *file, int flags, ...) {
 3100|      0|  mode_t mode;
 3101|      0|  va_list ap;
 3102|      0|  int tmp;
 3103|      0|  int tmp___0;
 3104|       |
 3105|      0|  {
 3106|      0|    mode = (mode_t)0;
 3107|      0|    if (flags & 64) {
 3108|      0|      __builtin_va_start(ap, flags);
 3109|      0|      mode = __builtin_va_arg(ap, mode_t);
 3110|      0|      __builtin_va_end(ap);
 3111|      0|    }
 3112|      0|    tmp = open(file, flags, mode);
 3113|      0|    tmp___0 = fd_safer(tmp);
 3114|      0|    return (tmp___0);
 3115|      0|  }
 3116|      0|}
 3117|       |int(__attribute__((__nonnull__(1, 2))) mbscasecmp)(char const *s1,
 3118|      0|                                                   char const *s2) {
 3119|      0|  mbui_iterator_t iter1;
 3120|      0|  mbui_iterator_t iter2;
 3121|      0|  int cmp;
 3122|      0|  wint_t tmp;
 3123|      0|  wint_t tmp___0;
 3124|      0|  int tmp___1;
 3125|      0|  int tmp___2;
 3126|      0|  int tmp___4;
 3127|      0|  int tmp___5;
 3128|      0|  int tmp___7;
 3129|      0|  int tmp___8;
 3130|      0|  int tmp___9;
 3131|      0|  int tmp___10;
 3132|      0|  int tmp___11;
 3133|      0|  int tmp___12;
 3134|      0|  int tmp___13;
 3135|      0|  int tmp___14;
 3136|      0|  int tmp___15;
 3137|      0|  int tmp___16;
 3138|      0|  unsigned char const *p1;
 3139|      0|  unsigned char const *p2;
 3140|      0|  unsigned char c1;
 3141|      0|  unsigned char c2;
 3142|      0|  int tmp___18;
 3143|      0|  unsigned short const **tmp___19;
 3144|      0|  int tmp___21;
 3145|      0|  unsigned short const **tmp___22;
 3146|      0|  size_t tmp___25;
 3147|       |
 3148|      0|  {
 3149|      0|    if ((unsigned long)s1 == (unsigned long)s2) {
 3150|      0|      return (0);
 3151|      0|    }
 3152|      0|    tmp___25 = __ctype_get_mb_cur_max();
 3153|      0|    if (tmp___25 > 1UL) {
 3154|      0|      iter1.cur.ptr = s1;
 3155|      0|      iter1.in_shift = (_Bool)0;
 3156|      0|      memset((void *)(&iter1.state), '\000', sizeof(mbstate_t));
 3157|      0|      iter1.next_done = (_Bool)0;
 3158|      0|      iter2.cur.ptr = s2;
 3159|      0|      iter2.in_shift = (_Bool)0;
 3160|      0|      memset((void *)(&iter2.state), '\000', sizeof(mbstate_t));
 3161|      0|      iter2.next_done = (_Bool)0;
 3162|      0|      while (1) {
 3163|      0|        mbuiter_multi_next(&iter1);
 3164|      0|        if (iter1.cur.wc_valid) {
 3165|      0|          if (iter1.cur.wc == 0) {
 3166|      0|            tmp___13 = 0;
 3167|      0|          } else {
 3168|      0|            tmp___13 = 1;
 3169|      0|          }
 3170|      0|        } else {
 3171|      0|          tmp___13 = 1;
 3172|      0|        }
 3173|      0|        if (tmp___13) {
 3174|      0|          mbuiter_multi_next(&iter2);
 3175|      0|          if (iter2.cur.wc_valid) {
 3176|      0|            if (iter2.cur.wc == 0) {
 3177|      0|              tmp___14 = 0;
 3178|      0|            } else {
 3179|      0|              tmp___14 = 1;
 3180|      0|            }
 3181|      0|          } else {
 3182|      0|            tmp___14 = 1;
 3183|      0|          }
 3184|      0|          if (!tmp___14) {
 3185|      0|            goto while_break;
 3186|      0|          }
 3187|      0|        } else {
 3188|      0|          goto while_break;
 3189|      0|        }
 3190|      0|        if (iter1.cur.wc_valid) {
 3191|      0|          if (iter2.cur.wc_valid) {
 3192|      0|            tmp = towlower((wint_t)iter1.cur.wc);
 3193|      0|            tmp___0 = towlower((wint_t)iter2.cur.wc);
 3194|      0|            tmp___1 = (int)tmp - (int)tmp___0;
 3195|      0|          } else {
 3196|      0|            tmp___1 = -1;
 3197|      0|          }
 3198|      0|          tmp___12 = tmp___1;
 3199|      0|        } else {
 3200|      0|          if (iter2.cur.wc_valid) {
 3201|      0|            tmp___11 = 1;
 3202|      0|          } else {
 3203|      0|            if (iter1.cur.bytes == iter2.cur.bytes) {
 3204|      0|              tmp___2 = memcmp((void const *)iter1.cur.ptr,
 3205|      0|                               (void const *)iter2.cur.ptr, iter1.cur.bytes);
 3206|      0|              tmp___10 = tmp___2;
 3207|      0|            } else {
 3208|      0|              if (iter1.cur.bytes < iter2.cur.bytes) {
 3209|      0|                tmp___5 = memcmp((void const *)iter1.cur.ptr,
 3210|      0|                                 (void const *)iter2.cur.ptr, iter1.cur.bytes);
 3211|      0|                if (tmp___5 > 0) {
 3212|      0|                  tmp___4 = 1;
 3213|      0|                } else {
 3214|      0|                  tmp___4 = -1;
 3215|      0|                }
 3216|      0|                tmp___9 = tmp___4;
 3217|      0|              } else {
 3218|      0|                tmp___8 = memcmp((void const *)iter1.cur.ptr,
 3219|      0|                                 (void const *)iter2.cur.ptr, iter2.cur.bytes);
 3220|      0|                if (tmp___8 >= 0) {
 3221|      0|                  tmp___7 = 1;
 3222|      0|                } else {
 3223|      0|                  tmp___7 = -1;
 3224|      0|                }
 3225|      0|                tmp___9 = tmp___7;
 3226|      0|              }
 3227|      0|              tmp___10 = tmp___9;
 3228|      0|            }
 3229|      0|            tmp___11 = tmp___10;
 3230|      0|          }
 3231|      0|          tmp___12 = tmp___11;
 3232|      0|        }
 3233|      0|        cmp = tmp___12;
 3234|      0|        if (cmp != 0) {
 3235|      0|          return (cmp);
 3236|      0|        }
 3237|      0|        iter1.cur.ptr += iter1.cur.bytes;
 3238|      0|        iter1.next_done = (_Bool)0;
 3239|      0|        iter2.cur.ptr += iter2.cur.bytes;
 3240|      0|        iter2.next_done = (_Bool)0;
 3241|      0|      }
 3242|      0|    while_break:
 3243|      0|      mbuiter_multi_next(&iter1);
 3244|      0|      if (iter1.cur.wc_valid) {
 3245|      0|        if (iter1.cur.wc == 0) {
 3246|      0|          tmp___15 = 0;
 3247|      0|        } else {
 3248|      0|          tmp___15 = 1;
 3249|      0|        }
 3250|      0|      } else {
 3251|      0|        tmp___15 = 1;
 3252|      0|      }
 3253|      0|      if (tmp___15) {
 3254|      0|        return (1);
 3255|      0|      }
 3256|      0|      mbuiter_multi_next(&iter2);
 3257|      0|      if (iter2.cur.wc_valid) {
 3258|      0|        if (iter2.cur.wc == 0) {
 3259|      0|          tmp___16 = 0;
 3260|      0|        } else {
 3261|      0|          tmp___16 = 1;
 3262|      0|        }
 3263|      0|      } else {
 3264|      0|        tmp___16 = 1;
 3265|      0|      }
 3266|      0|      if (tmp___16) {
 3267|      0|        return (-1);
 3268|      0|      }
 3269|      0|      return (0);
 3270|      0|    } else {
 3271|      0|      p1 = (unsigned char const *)s1;
 3272|      0|      p2 = (unsigned char const *)s2;
 3273|      0|      while (1) {
 3274|      0|        tmp___19 = __ctype_b_loc();
 3275|      0|        if ((int const) * (*tmp___19 + (int)*p1) & 256) {
 3276|      0|          tmp___18 = tolower((int)*p1);
 3277|      0|          c1 = (unsigned char)tmp___18;
 3278|      0|        } else {
 3279|      0|          c1 = (unsigned char)*p1;
 3280|      0|        }
 3281|      0|        tmp___22 = __ctype_b_loc();
 3282|      0|        if ((int const) * (*tmp___22 + (int)*p2) & 256) {
 3283|      0|          tmp___21 = tolower((int)*p2);
 3284|      0|          c2 = (unsigned char)tmp___21;
 3285|      0|        } else {
 3286|      0|          c2 = (unsigned char)*p2;
 3287|      0|        }
 3288|      0|        if ((int)c1 == 0) {
 3289|      0|          goto while_break___0;
 3290|      0|        }
 3291|      0|        p1++;
 3292|      0|        p2++;
 3293|      0|        if (!((int)c1 == (int)c2)) {
 3294|      0|          goto while_break___0;
 3295|      0|        }
 3296|      0|      }
 3297|      0|    while_break___0:;
 3298|      0|      return ((int)c1 - (int)c2);
 3299|      0|    }
 3300|      0|  }
 3301|      0|}
 3302|       |unsigned int const is_basic_table[8] = {
 3303|       |    (unsigned int const)6656, (unsigned int const)4294967279U,
 3304|       |    (unsigned int const)4294967294U, (unsigned int const)2147483646};
 3305|       |extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__))
 3306|       |                                                       exit)(int __status);
 3307|       |extern int optind;
 3308|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__)) getopt_long)(
 3309|       |    int ___argc, char *const *___argv, char const *__shortopts,
 3310|       |    struct option const *__longopts, int *__longind);
 3311|       |#pragma weak pthread_mutex_init
 3312|       |#pragma weak pthread_mutex_lock
 3313|       |#pragma weak pthread_mutex_unlock
 3314|       |#pragma weak pthread_mutex_destroy
 3315|       |#pragma weak pthread_rwlock_init
 3316|       |#pragma weak pthread_rwlock_rdlock
 3317|       |#pragma weak pthread_rwlock_wrlock
 3318|       |#pragma weak pthread_rwlock_unlock
 3319|       |#pragma weak pthread_rwlock_destroy
 3320|       |#pragma weak pthread_once
 3321|       |#pragma weak pthread_cond_init
 3322|       |#pragma weak pthread_cond_wait
 3323|       |#pragma weak pthread_cond_signal
 3324|       |#pragma weak pthread_cond_broadcast
 3325|       |#pragma weak pthread_cond_destroy
 3326|       |#pragma weak pthread_mutexattr_init
 3327|       |#pragma weak pthread_mutexattr_settype
 3328|       |#pragma weak pthread_mutexattr_destroy
 3329|       |#pragma weak pthread_self
 3330|       |#pragma weak pthread_cancel
 3331|       |void i_ring_init(I_ring *ir, int default_val);
 3332|       |int i_ring_push(I_ring *ir, int val);
 3333|       |int i_ring_pop(I_ring *ir);
 3334|       |_Bool i_ring_empty(I_ring const *ir);
 3335|      1|void i_ring_init(I_ring *ir, int default_val) {
 3336|      1|  int i;
 3337|       |
 3338|      1|  {
 3339|      1|    ir->ir_empty = (_Bool)1;
 3340|      1|    ir->ir_front = 0U;
 3341|      1|    ir->ir_back = 0U;
 3342|      1|    i = 0;
 3343|      5|    while (1) {
 3344|       |
 3345|      5|      if (!(i < 4)) {
 3346|      1|        goto while_break;
 3347|      1|      }
 3348|      4|      ir->ir_data[i] = default_val;
 3349|      4|      i++;
 3350|      4|    }
 3351|      1|  while_break:
 3352|      1|    ir->ir_default_val = default_val;
 3353|      1|    return;
 3354|      1|  }
 3355|      1|}
 3356|      4|_Bool i_ring_empty(I_ring const *ir) {
 3357|       |
 3358|      4|  { return ((_Bool)ir->ir_empty); }
 3359|      4|}
 3360|      1|int i_ring_push(I_ring *ir, int val) {
 3361|      1|  unsigned int dest_idx;
 3362|      1|  int old_val;
 3363|       |
 3364|      1|  {
 3365|      1|    dest_idx = (ir->ir_front + (unsigned int)(!ir->ir_empty)) % 4U;
 3366|      1|    old_val = ir->ir_data[dest_idx];
 3367|      1|    ir->ir_data[dest_idx] = val;
 3368|      1|    ir->ir_front = dest_idx;
 3369|      1|    if (dest_idx == ir->ir_back) {
 3370|      1|      ir->ir_back = (ir->ir_back + (unsigned int)(!ir->ir_empty)) % 4U;
 3371|      1|    }
 3372|      1|    ir->ir_empty = (_Bool)0;
 3373|      1|    return (old_val);
 3374|      1|  }
 3375|      1|}
 3376|      1|int i_ring_pop(I_ring *ir) {
 3377|      1|  int top_val;
 3378|      1|  _Bool tmp;
 3379|       |
 3380|      1|  {
 3381|      1|    tmp = i_ring_empty((I_ring const *)ir);
 3382|      1|    if (tmp) {
 3383|      0|      abort();
 3384|      0|    }
 3385|      1|    top_val = ir->ir_data[ir->ir_front];
 3386|      1|    ir->ir_data[ir->ir_front] = ir->ir_default_val;
 3387|      1|    if (ir->ir_front == ir->ir_back) {
 3388|      1|      ir->ir_empty = (_Bool)1;
 3389|      1|    } else {
 3390|      0|      ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
 3391|      0|    }
 3392|      1|    return (top_val);
 3393|      1|  }
 3394|      1|}
 3395|       |_Bool(__attribute__((__warn_unused_result__))
 3396|       |      hash_rehash)(Hash_table *table___0, size_t candidate);
 3397|       |void *hash_delete(Hash_table *table___0, void const *entry);
 3398|      0|__inline static size_t rotr_sz(size_t x, int n) {
 3399|       |
 3400|      0|  {
 3401|      0|    return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long)n))) &
 3402|      0|            0xffffffffffffffffUL);
 3403|      0|  }
 3404|      0|}
 3405|       |static struct hash_tuning const default_tuning = {
 3406|       |    (float)0.0, (float)1.0, (float)0.8, (float)1.414, (_Bool)0};
 3407|      0|void *hash_lookup(Hash_table const *table___0, void const *entry) {
 3408|      0|  struct hash_entry const *bucket;
 3409|      0|  size_t tmp;
 3410|      0|  struct hash_entry const *cursor;
 3411|      0|  _Bool tmp___0;
 3412|       |
 3413|      0|  {
 3414|      0|    tmp = (*(table___0->hasher))(entry, (size_t)table___0->n_buckets);
 3415|      0|    bucket = (struct hash_entry const *)(table___0->bucket + tmp);
 3416|      0|    if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3417|      0|      abort();
 3418|      0|    }
 3419|      0|    if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
 3420|      0|      return ((void *)0);
 3421|      0|    }
 3422|      0|    cursor = bucket;
 3423|      0|    while (1) {
 3424|       |
 3425|      0|      if (!cursor) {
 3426|      0|        goto while_break;
 3427|      0|      }
 3428|      0|      if ((unsigned long)entry == (unsigned long)cursor->data) {
 3429|      0|        return ((void *)cursor->data);
 3430|      0|      } else {
 3431|      0|        tmp___0 = (*(table___0->comparator))(entry, (void const *)cursor->data);
 3432|      0|        if (tmp___0) {
 3433|      0|          return ((void *)cursor->data);
 3434|      0|        }
 3435|      0|      }
 3436|      0|      cursor = (struct hash_entry const *)cursor->next;
 3437|      0|    }
 3438|      0|  while_break:;
 3439|      0|    return ((void *)0);
 3440|      0|  }
 3441|      0|}
 3442|      0|size_t hash_string(char const *string, size_t n_buckets) {
 3443|      0|  size_t value;
 3444|      0|  unsigned char ch;
 3445|       |
 3446|      0|  {
 3447|      0|    value = (size_t)0;
 3448|      0|    while (1) {
 3449|      0|      ch = (unsigned char)*string;
 3450|      0|      if (!ch) {
 3451|      0|        goto while_break;
 3452|      0|      }
 3453|      0|      value = (value * 31UL + (size_t)ch) % n_buckets;
 3454|      0|      string++;
 3455|      0|    }
 3456|      0|  while_break:;
 3457|      0|    return (value);
 3458|      0|  }
 3459|      0|}
 3460|      0|static _Bool is_prime(size_t candidate) {
 3461|      0|  size_t divisor;
 3462|      0|  size_t square;
 3463|      0|  int tmp;
 3464|       |
 3465|      0|  {
 3466|      0|    divisor = (size_t)3;
 3467|      0|    square = divisor * divisor;
 3468|      0|    while (1) {
 3469|       |
 3470|      0|      if (square < candidate) {
 3471|      0|        if (!(candidate % divisor)) {
 3472|      0|          goto while_break;
 3473|      0|        }
 3474|      0|      } else {
 3475|      0|        goto while_break;
 3476|      0|      }
 3477|      0|      divisor++;
 3478|      0|      square += 4UL * divisor;
 3479|      0|      divisor++;
 3480|      0|    }
 3481|      0|  while_break:;
 3482|      0|    if (candidate % divisor) {
 3483|      0|      tmp = 1;
 3484|      0|    } else {
 3485|      0|      tmp = 0;
 3486|      0|    }
 3487|      0|    return ((_Bool)tmp);
 3488|      0|  }
 3489|      0|}
 3490|      0|static size_t next_prime(size_t candidate) {
 3491|      0|  _Bool tmp;
 3492|       |
 3493|      0|  {
 3494|      0|    if (candidate < 10UL) {
 3495|      0|      candidate = (size_t)10;
 3496|      0|    }
 3497|      0|    candidate |= 1UL;
 3498|      0|    while (1) {
 3499|       |
 3500|      0|      if (0xffffffffffffffffUL != candidate) {
 3501|      0|        tmp = is_prime(candidate);
 3502|      0|        if (tmp) {
 3503|      0|          goto while_break;
 3504|      0|        }
 3505|      0|      } else {
 3506|      0|        goto while_break;
 3507|      0|      }
 3508|      0|      candidate += 2UL;
 3509|      0|    }
 3510|      0|  while_break:;
 3511|      0|    return (candidate);
 3512|      0|  }
 3513|      0|}
 3514|      0|static size_t raw_hasher(void const *data, size_t n) {
 3515|      0|  size_t val;
 3516|      0|  size_t tmp;
 3517|       |
 3518|      0|  {
 3519|      0|    tmp = rotr_sz((size_t)data, 3);
 3520|      0|    val = tmp;
 3521|      0|    return (val % n);
 3522|      0|  }
 3523|      0|}
 3524|      0|static _Bool raw_comparator(void const *a, void const *b) {
 3525|       |
 3526|      0|  { return ((_Bool)((unsigned long)a == (unsigned long)b)); }
 3527|      0|}
 3528|      0|static _Bool check_tuning(Hash_table *table___0) {
 3529|      0|  Hash_tuning const *tuning;
 3530|      0|  float epsilon;
 3531|       |
 3532|      0|  {
 3533|      0|    tuning = table___0->tuning;
 3534|      0|    if ((unsigned long)tuning == (unsigned long)(&default_tuning)) {
 3535|      0|      return ((_Bool)1);
 3536|      0|    }
 3537|      0|    epsilon = 0.1f;
 3538|      0|    if (epsilon < (float)tuning->growth_threshold) {
 3539|      0|      if (tuning->growth_threshold < (float const)((float)1 - epsilon)) {
 3540|      0|        if ((float)1 + epsilon < (float)tuning->growth_factor) {
 3541|      0|          if ((float const)0 <= tuning->shrink_threshold) {
 3542|      0|            if (tuning->shrink_threshold + (float const)epsilon <
 3543|      0|                tuning->shrink_factor) {
 3544|      0|              if (tuning->shrink_factor <= (float const)1) {
 3545|      0|                if (tuning->shrink_threshold + (float const)epsilon <
 3546|      0|                    tuning->growth_threshold) {
 3547|      0|                  return ((_Bool)1);
 3548|      0|                }
 3549|      0|              }
 3550|      0|            }
 3551|      0|          }
 3552|      0|        }
 3553|      0|      }
 3554|      0|    }
 3555|      0|    table___0->tuning = &default_tuning;
 3556|      0|    return ((_Bool)0);
 3557|      0|  }
 3558|      0|}
 3559|      0|static size_t compute_bucket_size(size_t candidate, Hash_tuning const *tuning) {
 3560|      0|  float new_candidate;
 3561|      0|  int tmp;
 3562|       |
 3563|      0|  {
 3564|      0|    if (!tuning->is_n_buckets) {
 3565|      0|      new_candidate =
 3566|      0|          (float)((float const)candidate / tuning->growth_threshold);
 3567|      0|      if ((float)0xffffffffffffffffUL <= new_candidate) {
 3568|      0|        return ((size_t)0);
 3569|      0|      }
 3570|      0|      candidate = (size_t)new_candidate;
 3571|      0|    }
 3572|      0|    candidate = next_prime(candidate);
 3573|      0|    if (sizeof(ptrdiff_t) <= sizeof(size_t)) {
 3574|      0|      tmp = -1;
 3575|      0|    } else {
 3576|      0|      tmp = -2;
 3577|      0|    }
 3578|      0|    if ((size_t)tmp / sizeof(struct hash_entry *) < candidate) {
 3579|      0|      return ((size_t)0);
 3580|      0|    }
 3581|      0|    return (candidate);
 3582|      0|  }
 3583|      0|}
 3584|       |Hash_table *(__attribute__((__warn_unused_result__))
 3585|       |             hash_initialize)(size_t candidate, Hash_tuning const *tuning,
 3586|       |                              size_t (*hasher)(void const *, size_t),
 3587|       |                              _Bool (*comparator)(void const *, void const *),
 3588|      0|                              void (*data_freer)(void *)) {
 3589|      0|  Hash_table *table___0;
 3590|      0|  _Bool tmp;
 3591|       |
 3592|      0|  {
 3593|      0|    if ((unsigned long)hasher == (unsigned long)((void *)0)) {
 3594|      0|      hasher = &raw_hasher;
 3595|      0|    }
 3596|      0|    if ((unsigned long)comparator == (unsigned long)((void *)0)) {
 3597|      0|      comparator = &raw_comparator;
 3598|      0|    }
 3599|      0|    table___0 = (Hash_table *)malloc(sizeof(*table___0));
 3600|      0|    if ((unsigned long)table___0 == (unsigned long)((void *)0)) {
 3601|      0|      return ((Hash_table *)((void *)0));
 3602|      0|    }
 3603|      0|    if (!tuning) {
 3604|      0|      tuning = &default_tuning;
 3605|      0|    }
 3606|      0|    table___0->tuning = tuning;
 3607|      0|    tmp = check_tuning(table___0);
 3608|      0|    if (!tmp) {
 3609|      0|      goto fail;
 3610|      0|    }
 3611|      0|    table___0->n_buckets = compute_bucket_size(candidate, tuning);
 3612|      0|    if (!table___0->n_buckets) {
 3613|      0|      goto fail;
 3614|      0|    }
 3615|      0|    table___0->bucket = (struct hash_entry *)calloc(
 3616|      0|        table___0->n_buckets, sizeof(*(table___0->bucket)));
 3617|      0|    if ((unsigned long)table___0->bucket == (unsigned long)((void *)0)) {
 3618|      0|      goto fail;
 3619|      0|    }
 3620|      0|    table___0->bucket_limit =
 3621|      0|        (struct hash_entry const *)(table___0->bucket + table___0->n_buckets);
 3622|      0|    table___0->n_buckets_used = (size_t)0;
 3623|      0|    table___0->n_entries = (size_t)0;
 3624|      0|    table___0->hasher = hasher;
 3625|      0|    table___0->comparator = comparator;
 3626|      0|    table___0->data_freer = data_freer;
 3627|      0|    table___0->free_entry_list = (struct hash_entry *)((void *)0);
 3628|      0|    return (table___0);
 3629|      0|  fail:
 3630|      0|    free((void *)table___0);
 3631|      0|    return ((Hash_table *)((void *)0));
 3632|      0|  }
 3633|      0|}
 3634|      0|void hash_free(Hash_table *table___0) {
 3635|      0|  struct hash_entry *bucket;
 3636|      0|  struct hash_entry *cursor;
 3637|      0|  struct hash_entry *next;
 3638|       |
 3639|      0|  {
 3640|      0|    if (table___0->data_freer) {
 3641|      0|      if (table___0->n_entries) {
 3642|      0|        bucket = table___0->bucket;
 3643|      0|        while (1) {
 3644|       |
 3645|      0|          if (!((unsigned long)bucket <
 3646|      0|                (unsigned long)table___0->bucket_limit)) {
 3647|      0|            goto while_break;
 3648|      0|          }
 3649|      0|          if (bucket->data) {
 3650|      0|            cursor = bucket;
 3651|      0|            while (1) {
 3652|       |
 3653|      0|              if (!cursor) {
 3654|      0|                goto while_break___0;
 3655|      0|              }
 3656|      0|              (*(table___0->data_freer))(cursor->data);
 3657|      0|              cursor = cursor->next;
 3658|      0|            }
 3659|      0|          while_break___0:;
 3660|      0|          }
 3661|      0|          bucket++;
 3662|      0|        }
 3663|      0|      while_break:;
 3664|      0|      }
 3665|      0|    }
 3666|      0|    bucket = table___0->bucket;
 3667|      0|    while (1) {
 3668|       |
 3669|      0|      if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3670|      0|        goto while_break___1;
 3671|      0|      }
 3672|      0|      cursor = bucket->next;
 3673|      0|      while (1) {
 3674|       |
 3675|      0|        if (!cursor) {
 3676|      0|          goto while_break___2;
 3677|      0|        }
 3678|      0|        next = cursor->next;
 3679|      0|        free((void *)cursor);
 3680|      0|        cursor = next;
 3681|      0|      }
 3682|      0|    while_break___2:
 3683|      0|      bucket++;
 3684|      0|    }
 3685|      0|  while_break___1:
 3686|      0|    cursor = table___0->free_entry_list;
 3687|      0|    while (1) {
 3688|       |
 3689|      0|      if (!cursor) {
 3690|      0|        goto while_break___3;
 3691|      0|      }
 3692|      0|      next = cursor->next;
 3693|      0|      free((void *)cursor);
 3694|      0|      cursor = next;
 3695|      0|    }
 3696|      0|  while_break___3:
 3697|      0|    free((void *)table___0->bucket);
 3698|      0|    free((void *)table___0);
 3699|      0|    return;
 3700|      0|  }
 3701|      0|}
 3702|      0|static struct hash_entry *allocate_entry(Hash_table *table___0) {
 3703|      0|  struct hash_entry *new;
 3704|       |
 3705|      0|  {
 3706|      0|    if (table___0->free_entry_list) {
 3707|      0|      new = table___0->free_entry_list;
 3708|      0|      table___0->free_entry_list = new->next;
 3709|      0|    } else {
 3710|      0|      new = (struct hash_entry *)malloc(sizeof(*new));
 3711|      0|    }
 3712|      0|    return (new);
 3713|      0|  }
 3714|      0|}
 3715|      0|static void free_entry(Hash_table *table___0, struct hash_entry *entry) {
 3716|       |
 3717|      0|  {
 3718|      0|    entry->data = (void *)0;
 3719|      0|    entry->next = table___0->free_entry_list;
 3720|      0|    table___0->free_entry_list = entry;
 3721|      0|    return;
 3722|      0|  }
 3723|      0|}
 3724|       |static void *hash_find_entry(Hash_table *table___0, void const *entry,
 3725|      0|                             struct hash_entry **bucket_head, _Bool delete) {
 3726|      0|  struct hash_entry *bucket;
 3727|      0|  size_t tmp;
 3728|      0|  struct hash_entry *cursor;
 3729|      0|  void *data;
 3730|      0|  struct hash_entry *next;
 3731|      0|  _Bool tmp___0;
 3732|      0|  void *data___0;
 3733|      0|  struct hash_entry *next___0;
 3734|      0|  _Bool tmp___1;
 3735|       |
 3736|      0|  {
 3737|      0|    tmp = (*(table___0->hasher))(entry, table___0->n_buckets);
 3738|      0|    bucket = table___0->bucket + tmp;
 3739|      0|    if (!((unsigned long)bucket < (unsigned long)table___0->bucket_limit)) {
 3740|      0|      abort();
 3741|      0|    }
 3742|      0|    *bucket_head = bucket;
 3743|      0|    if ((unsigned long)bucket->data == (unsigned long)((void *)0)) {
 3744|      0|      return ((void *)0);
 3745|      0|    }
 3746|      0|    if ((unsigned long)entry == (unsigned long)bucket->data) {
 3747|      0|      goto _L;
 3748|      0|    } else {
 3749|      0|      tmp___0 = (*(table___0->comparator))(entry, (void const *)bucket->data);
 3750|      0|      if (tmp___0) {
 3751|      0|      _L:
 3752|      0|        data = bucket->data;
 3753|      0|        if (delete) {
 3754|      0|          if (bucket->next) {
 3755|      0|            next = bucket->next;
 3756|      0|            *bucket = *next;
 3757|      0|            free_entry(table___0, next);
 3758|      0|          } else {
 3759|      0|            bucket->data = (void *)0;
 3760|      0|          }
 3761|      0|        }
 3762|      0|        return (data);
 3763|      0|      }
 3764|      0|    }
 3765|      0|    cursor = bucket;
 3766|      0|    while (1) {
 3767|       |
 3768|      0|      if (!cursor->next) {
 3769|      0|        goto while_break;
 3770|      0|      }
 3771|      0|      if ((unsigned long)entry == (unsigned long)(cursor->next)->data) {
 3772|      0|        goto _L___0;
 3773|      0|      } else {
 3774|      0|        tmp___1 = (*(table___0->comparator))(
 3775|      0|            entry, (void const *)(cursor->next)->data);
 3776|      0|        if (tmp___1) {
 3777|      0|        _L___0:
 3778|      0|          data___0 = (cursor->next)->data;
 3779|      0|          if (delete) {
 3780|      0|            next___0 = cursor->next;
 3781|      0|            cursor->next = next___0->next;
 3782|      0|            free_entry(table___0, next___0);
 3783|      0|          }
 3784|      0|          return (data___0);
 3785|      0|        }
 3786|      0|      }
 3787|      0|      cursor = cursor->next;
 3788|      0|    }
 3789|      0|  while_break:;
 3790|      0|    return ((void *)0);
 3791|      0|  }
 3792|      0|}
 3793|      0|static _Bool transfer_entries(Hash_table *dst, Hash_table *src, _Bool safe) {
 3794|      0|  struct hash_entry *bucket;
 3795|      0|  struct hash_entry *cursor;
 3796|      0|  struct hash_entry *next;
 3797|      0|  void *data;
 3798|      0|  struct hash_entry *new_bucket;
 3799|      0|  size_t tmp;
 3800|      0|  size_t tmp___0;
 3801|      0|  struct hash_entry *new_entry;
 3802|      0|  struct hash_entry *tmp___1;
 3803|       |
 3804|      0|  {
 3805|      0|    bucket = src->bucket;
 3806|      0|    while (1) {
 3807|       |
 3808|      0|      if (!((unsigned long)bucket < (unsigned long)src->bucket_limit)) {
 3809|      0|        goto while_break;
 3810|      0|      }
 3811|      0|      if (bucket->data) {
 3812|      0|        cursor = bucket->next;
 3813|      0|        while (1) {
 3814|       |
 3815|      0|          if (!cursor) {
 3816|      0|            goto while_break___0;
 3817|      0|          }
 3818|      0|          data = cursor->data;
 3819|      0|          tmp = (*(dst->hasher))((void const *)data, dst->n_buckets);
 3820|      0|          new_bucket = dst->bucket + tmp;
 3821|      0|          if (!((unsigned long)new_bucket < (unsigned long)dst->bucket_limit)) {
 3822|      0|            abort();
 3823|      0|          }
 3824|      0|          next = cursor->next;
 3825|      0|          if (new_bucket->data) {
 3826|      0|            cursor->next = new_bucket->next;
 3827|      0|            new_bucket->next = cursor;
 3828|      0|          } else {
 3829|      0|            new_bucket->data = data;
 3830|      0|            (dst->n_buckets_used)++;
 3831|      0|            free_entry(dst, cursor);
 3832|      0|          }
 3833|      0|          cursor = next;
 3834|      0|        }
 3835|      0|      while_break___0:
 3836|      0|        data = bucket->data;
 3837|      0|        bucket->next = (struct hash_entry *)((void *)0);
 3838|      0|        if (safe) {
 3839|      0|          goto __Cont;
 3840|      0|        }
 3841|      0|        tmp___0 = (*(dst->hasher))((void const *)data, dst->n_buckets);
 3842|      0|        new_bucket = dst->bucket + tmp___0;
 3843|      0|        if (!((unsigned long)new_bucket < (unsigned long)dst->bucket_limit)) {
 3844|      0|          abort();
 3845|      0|        }
 3846|      0|        if (new_bucket->data) {
 3847|      0|          tmp___1 = allocate_entry(dst);
 3848|      0|          new_entry = tmp___1;
 3849|      0|          if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 3850|      0|            return ((_Bool)0);
 3851|      0|          }
 3852|      0|          new_entry->data = data;
 3853|      0|          new_entry->next = new_bucket->next;
 3854|      0|          new_bucket->next = new_entry;
 3855|      0|        } else {
 3856|      0|          new_bucket->data = data;
 3857|      0|          (dst->n_buckets_used)++;
 3858|      0|        }
 3859|      0|        bucket->data = (void *)0;
 3860|      0|        (src->n_buckets_used)--;
 3861|      0|      }
 3862|      0|    __Cont:
 3863|      0|      bucket++;
 3864|      0|    }
 3865|      0|  while_break:;
 3866|      0|    return ((_Bool)1);
 3867|      0|  }
 3868|      0|}
 3869|       |_Bool(__attribute__((__warn_unused_result__))
 3870|      0|      hash_rehash)(Hash_table *table___0, size_t candidate) {
 3871|      0|  Hash_table storage;
 3872|      0|  Hash_table *new_table;
 3873|      0|  size_t new_size;
 3874|      0|  size_t tmp;
 3875|      0|  _Bool tmp___0;
 3876|      0|  _Bool tmp___1;
 3877|      0|  _Bool tmp___2;
 3878|       |
 3879|      0|  {
 3880|      0|    tmp = compute_bucket_size(candidate, table___0->tuning);
 3881|      0|    new_size = tmp;
 3882|      0|    if (!new_size) {
 3883|      0|      return ((_Bool)0);
 3884|      0|    }
 3885|      0|    if (new_size == table___0->n_buckets) {
 3886|      0|      return ((_Bool)1);
 3887|      0|    }
 3888|      0|    new_table = &storage;
 3889|      0|    new_table->bucket =
 3890|      0|        (struct hash_entry *)calloc(new_size, sizeof(*(new_table->bucket)));
 3891|      0|    if ((unsigned long)new_table->bucket == (unsigned long)((void *)0)) {
 3892|      0|      return ((_Bool)0);
 3893|      0|    }
 3894|      0|    new_table->n_buckets = new_size;
 3895|      0|    new_table->bucket_limit =
 3896|      0|        (struct hash_entry const *)(new_table->bucket + new_size);
 3897|      0|    new_table->n_buckets_used = (size_t)0;
 3898|      0|    new_table->n_entries = (size_t)0;
 3899|      0|    new_table->tuning = table___0->tuning;
 3900|      0|    new_table->hasher = table___0->hasher;
 3901|      0|    new_table->comparator = table___0->comparator;
 3902|      0|    new_table->data_freer = table___0->data_freer;
 3903|      0|    new_table->free_entry_list = table___0->free_entry_list;
 3904|      0|    tmp___0 = transfer_entries(new_table, table___0, (_Bool)0);
 3905|      0|    if (tmp___0) {
 3906|      0|      free((void *)table___0->bucket);
 3907|      0|      table___0->bucket = new_table->bucket;
 3908|      0|      table___0->bucket_limit = new_table->bucket_limit;
 3909|      0|      table___0->n_buckets = new_table->n_buckets;
 3910|      0|      table___0->n_buckets_used = new_table->n_buckets_used;
 3911|      0|      table___0->free_entry_list = new_table->free_entry_list;
 3912|      0|      return ((_Bool)1);
 3913|      0|    }
 3914|      0|    table___0->free_entry_list = new_table->free_entry_list;
 3915|      0|    tmp___1 = transfer_entries(table___0, new_table, (_Bool)1);
 3916|      0|    if (tmp___1) {
 3917|      0|      tmp___2 = transfer_entries(table___0, new_table, (_Bool)0);
 3918|      0|      if (!tmp___2) {
 3919|      0|        abort();
 3920|      0|      }
 3921|      0|    } else {
 3922|      0|      abort();
 3923|      0|    }
 3924|      0|    free((void *)new_table->bucket);
 3925|      0|    return ((_Bool)0);
 3926|      0|  }
 3927|      0|}
 3928|       |void *(__attribute__((__warn_unused_result__))
 3929|      0|       hash_insert)(Hash_table *table___0, void const *entry) {
 3930|      0|  void *data;
 3931|      0|  struct hash_entry *bucket;
 3932|      0|  Hash_tuning const *tuning;
 3933|      0|  float candidate;
 3934|      0|  float tmp;
 3935|      0|  _Bool tmp___0;
 3936|      0|  void *tmp___1;
 3937|      0|  struct hash_entry *new_entry;
 3938|      0|  struct hash_entry *tmp___2;
 3939|       |
 3940|      0|  {
 3941|      0|    if (!entry) {
 3942|      0|      abort();
 3943|      0|    }
 3944|      0|    data = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 3945|      0|    if ((unsigned long)data != (unsigned long)((void *)0)) {
 3946|      0|      return (data);
 3947|      0|    }
 3948|      0|    if ((float const)table___0->n_buckets_used >
 3949|      0|        (table___0->tuning)->growth_threshold *
 3950|      0|            (float const)table___0->n_buckets) {
 3951|      0|      check_tuning(table___0);
 3952|      0|      if ((float const)table___0->n_buckets_used >
 3953|      0|          (table___0->tuning)->growth_threshold *
 3954|      0|              (float const)table___0->n_buckets) {
 3955|      0|        tuning = table___0->tuning;
 3956|      0|        if (tuning->is_n_buckets) {
 3957|      0|          tmp = (float)((float const)table___0->n_buckets *
 3958|      0|                        tuning->growth_factor);
 3959|      0|        } else {
 3960|      0|          tmp = (float)(((float const)table___0->n_buckets *
 3961|      0|                         tuning->growth_factor) *
 3962|      0|                        tuning->growth_threshold);
 3963|      0|        }
 3964|      0|        candidate = tmp;
 3965|      0|        if ((float)0xffffffffffffffffUL <= candidate) {
 3966|      0|          return ((void *)0);
 3967|      0|        }
 3968|      0|        tmp___0 = hash_rehash(table___0, (size_t)candidate);
 3969|      0|        if (!tmp___0) {
 3970|      0|          return ((void *)0);
 3971|      0|        }
 3972|      0|        tmp___1 = hash_find_entry(table___0, entry, &bucket, (_Bool)0);
 3973|      0|        if ((unsigned long)tmp___1 != (unsigned long)((void *)0)) {
 3974|      0|          abort();
 3975|      0|        }
 3976|      0|      }
 3977|      0|    }
 3978|      0|    if (bucket->data) {
 3979|      0|      tmp___2 = allocate_entry(table___0);
 3980|      0|      new_entry = tmp___2;
 3981|      0|      if ((unsigned long)new_entry == (unsigned long)((void *)0)) {
 3982|      0|        return ((void *)0);
 3983|      0|      }
 3984|      0|      new_entry->data = (void *)entry;
 3985|      0|      new_entry->next = bucket->next;
 3986|      0|      bucket->next = new_entry;
 3987|      0|      (table___0->n_entries)++;
 3988|      0|      return ((void *)entry);
 3989|      0|    }
 3990|      0|    bucket->data = (void *)entry;
 3991|      0|    (table___0->n_entries)++;
 3992|      0|    (table___0->n_buckets_used)++;
 3993|      0|    return ((void *)entry);
 3994|      0|  }
 3995|      0|}
 3996|      0|void *hash_delete(Hash_table *table___0, void const *entry) {
 3997|      0|  void *data;
 3998|      0|  struct hash_entry *bucket;
 3999|      0|  Hash_tuning const *tuning;
 4000|      0|  size_t candidate;
 4001|      0|  float tmp;
 4002|      0|  struct hash_entry *cursor;
 4003|      0|  struct hash_entry *next;
 4004|      0|  _Bool tmp___0;
 4005|       |
 4006|      0|  {
 4007|      0|    data = hash_find_entry(table___0, entry, &bucket, (_Bool)1);
 4008|      0|    if (!data) {
 4009|      0|      return ((void *)0);
 4010|      0|    }
 4011|      0|    (table___0->n_entries)--;
 4012|      0|    if (!bucket->data) {
 4013|      0|      (table___0->n_buckets_used)--;
 4014|      0|      if ((float const)table___0->n_buckets_used <
 4015|      0|          (table___0->tuning)->shrink_threshold *
 4016|      0|              (float const)table___0->n_buckets) {
 4017|      0|        check_tuning(table___0);
 4018|      0|        if ((float const)table___0->n_buckets_used <
 4019|      0|            (table___0->tuning)->shrink_threshold *
 4020|      0|                (float const)table___0->n_buckets) {
 4021|      0|          tuning = table___0->tuning;
 4022|      0|          if (tuning->is_n_buckets) {
 4023|      0|            tmp = (float)((float const)table___0->n_buckets *
 4024|      0|                          tuning->shrink_factor);
 4025|      0|          } else {
 4026|      0|            tmp = (float)(((float const)table___0->n_buckets *
 4027|      0|                           tuning->shrink_factor) *
 4028|      0|                          tuning->growth_threshold);
 4029|      0|          }
 4030|      0|          candidate = (size_t)tmp;
 4031|      0|          tmp___0 = hash_rehash(table___0, candidate);
 4032|      0|          if (!tmp___0) {
 4033|      0|            cursor = table___0->free_entry_list;
 4034|      0|            while (1) {
 4035|       |
 4036|      0|              if (!cursor) {
 4037|      0|                goto while_break;
 4038|      0|              }
 4039|      0|              next = cursor->next;
 4040|      0|              free((void *)cursor);
 4041|      0|              cursor = next;
 4042|      0|            }
 4043|      0|          while_break:
 4044|      0|            table___0->free_entry_list = (struct hash_entry *)((void *)0);
 4045|      0|          }
 4046|      0|        }
 4047|      0|      }
 4048|      0|    }
 4049|      0|    return (data);
 4050|      0|  }
 4051|      0|}
 4052|       |size_t hash_pjw(void const *x, size_t tablesize);
 4053|      0|size_t triple_hash(void const *x, size_t table_size) {
 4054|      0|  struct F_triple const *p;
 4055|      0|  size_t tmp;
 4056|      0|  size_t tmp___0;
 4057|       |
 4058|      0|  {
 4059|      0|    p = (struct F_triple const *)x;
 4060|      0|    tmp___0 = hash_pjw((void const *)p->name, table_size);
 4061|      0|    tmp = tmp___0;
 4062|      0|    return ((tmp ^ (unsigned long)p->st_ino) % table_size);
 4063|      0|  }
 4064|      0|}
 4065|      0|_Bool triple_compare_ino_str(void const *x, void const *y) {
 4066|      0|  struct F_triple const *a;
 4067|      0|  struct F_triple const *b;
 4068|      0|  int tmp___0;
 4069|      0|  int tmp___1;
 4070|       |
 4071|      0|  {
 4072|      0|    a = (struct F_triple const *)x;
 4073|      0|    b = (struct F_triple const *)y;
 4074|      0|    if (a->st_ino == b->st_ino) {
 4075|      0|      if (a->st_dev == b->st_dev) {
 4076|      0|        tmp___1 = strcmp((char const *)a->name, (char const *)b->name);
 4077|      0|        if (tmp___1 == 0) {
 4078|      0|          tmp___0 = 1;
 4079|      0|        } else {
 4080|      0|          tmp___0 = 0;
 4081|      0|        }
 4082|      0|      } else {
 4083|      0|        tmp___0 = 0;
 4084|      0|      }
 4085|      0|    } else {
 4086|      0|      tmp___0 = 0;
 4087|      0|    }
 4088|      0|    return ((_Bool)tmp___0);
 4089|      0|  }
 4090|      0|}
 4091|      0|void triple_free(void *x) {
 4092|      0|  struct F_triple *a;
 4093|       |
 4094|      0|  {
 4095|      0|    a = (struct F_triple *)x;
 4096|      0|    free((void *)a->name);
 4097|      0|    free((void *)a);
 4098|      0|    return;
 4099|      0|  }
 4100|      0|}
 4101|      0|size_t hash_pjw(void const *x, size_t tablesize) {
 4102|      0|  char const *s;
 4103|      0|  size_t h;
 4104|       |
 4105|      0|  {
 4106|      0|    h = (size_t)0;
 4107|      0|    s = (char const *)x;
 4108|      0|    while (1) {
 4109|       |
 4110|      0|      if (!*s) {
 4111|      0|        goto while_break;
 4112|      0|      }
 4113|      0|      h = (unsigned long)*s + ((h << 9) | (h >> (sizeof(size_t) * 8UL - 9UL)));
 4114|      0|      s++;
 4115|      0|    }
 4116|      0|  while_break:;
 4117|      0|    return (h % tablesize);
 4118|      0|  }
 4119|      0|}
 4120|       |extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
 4121|       |                                           setlocale)(int __category,
 4122|       |                                                      char const *__locale);
 4123|       |extern __attribute__((__nothrow__)) int(
 4124|       |    __attribute__((__nonnull__(2, 3), __leaf__))
 4125|       |    fstatat)(int __fd, char const *__restrict __file,
 4126|       |             struct stat *__restrict __buf, int __flag);
 4127|       |__attribute__((__nothrow__)) int(__attribute__((__warn_unused_result__,
 4128|       |                                                __leaf__)) fts_close)(FTS *sp);
 4129|       |__attribute__((__nothrow__))
 4130|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp);
 4131|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__))
 4132|       |                                 fts_set)(FTS *sp __attribute__((__unused__)),
 4133|       |                                          FTSENT *p, int instr);
 4134|       |extern void(__attribute__((__nonnull__(1, 4)))
 4135|       |            qsort)(void *__base, size_t __nmemb, size_t __size,
 4136|       |                   int (*__compar)(void const *, void const *));
 4137|       |static FTSENT *fts_alloc(FTS *sp, char const *name, size_t namelen);
 4138|       |static FTSENT *fts_build(FTS *sp, int type);
 4139|       |static void fts_lfree(FTSENT *head);
 4140|       |static void fts_load(FTS *sp, FTSENT *p);
 4141|       |static size_t fts_maxarglen(char *const *argv);
 4142|       |static void fts_padjust(FTS *sp, FTSENT *head);
 4143|       |static _Bool fts_palloc(FTS *sp, size_t more);
 4144|       |static FTSENT *fts_sort(FTS *sp, FTSENT *head, size_t nitems);
 4145|       |static unsigned short fts_stat(FTS *sp, FTSENT *p, _Bool follow);
 4146|       |static int fts_safe_changedir(FTS *sp, FTSENT *p, int fd, char const *dir);
 4147|      0|static _Bool AD_compare(void const *x, void const *y) {
 4148|      0|  struct Active_dir const *ax;
 4149|      0|  struct Active_dir const *ay;
 4150|      0|  int tmp;
 4151|       |
 4152|      0|  {
 4153|      0|    ax = (struct Active_dir const *)x;
 4154|      0|    ay = (struct Active_dir const *)y;
 4155|      0|    if (ax->ino == ay->ino) {
 4156|      0|      if (ax->dev == ay->dev) {
 4157|      0|        tmp = 1;
 4158|      0|      } else {
 4159|      0|        tmp = 0;
 4160|      0|      }
 4161|      0|    } else {
 4162|      0|      tmp = 0;
 4163|      0|    }
 4164|      0|    return ((_Bool)tmp);
 4165|      0|  }
 4166|      0|}
 4167|      0|static size_t AD_hash(void const *x, size_t table_size) {
 4168|      0|  struct Active_dir const *ax;
 4169|       |
 4170|      0|  {
 4171|      0|    ax = (struct Active_dir const *)x;
 4172|      0|    return ((uintmax_t)ax->ino % table_size);
 4173|      0|  }
 4174|      0|}
 4175|      2|static _Bool setup_dir(FTS *fts) {
 4176|       |
 4177|      2|  {
 4178|      2|    if (fts->fts_options & 258) {
 4179|      0|      fts->fts_cycle.ht =
 4180|      0|          hash_initialize((size_t)31, (Hash_tuning const *)((void *)0),
 4181|      0|                          &AD_hash, &AD_compare, (void (*)(void *))(&free));
 4182|      0|      if (!fts->fts_cycle.ht) {
 4183|      0|        return ((_Bool)0);
 4184|      0|      }
 4185|      2|    } else {
 4186|      2|      fts->fts_cycle.state =
 4187|      2|          (struct cycle_check_state *)malloc(sizeof(*(fts->fts_cycle.state)));
 4188|      2|      if (!fts->fts_cycle.state) {
 4189|      0|        return ((_Bool)0);
 4190|      0|      }
 4191|      2|      cycle_check_init(fts->fts_cycle.state);
 4192|      2|    }
 4193|      2|    return ((_Bool)1);
 4194|      2|  }
 4195|      2|}
 4196|      0|static _Bool enter_dir(FTS *fts, FTSENT *ent) {
 4197|      0|  struct stat const *st;
 4198|      0|  struct Active_dir *ad;
 4199|      0|  struct Active_dir *tmp;
 4200|      0|  struct Active_dir *ad_from_table;
 4201|      0|  _Bool tmp___0;
 4202|       |
 4203|      0|  {
 4204|      0|    if (fts->fts_options & 258) {
 4205|      0|      st = (struct stat const *)(ent->fts_statp);
 4206|      0|      tmp = (struct Active_dir *)malloc(sizeof(*ad));
 4207|      0|      ad = tmp;
 4208|      0|      if (!ad) {
 4209|      0|        return ((_Bool)0);
 4210|      0|      }
 4211|      0|      ad->dev = (dev_t)st->st_dev;
 4212|      0|      ad->ino = (ino_t)st->st_ino;
 4213|      0|      ad->fts_ent = ent;
 4214|      0|      ad_from_table =
 4215|      0|          (struct Active_dir *)hash_insert(fts->fts_cycle.ht, (void const *)ad);
 4216|      0|      if ((unsigned long)ad_from_table != (unsigned long)ad) {
 4217|      0|        free((void *)ad);
 4218|      0|        if (!ad_from_table) {
 4219|      0|          return ((_Bool)0);
 4220|      0|        }
 4221|      0|        ent->fts_cycle = ad_from_table->fts_ent;
 4222|      0|        ent->fts_info = (unsigned short)2;
 4223|      0|      }
 4224|      0|    } else {
 4225|      0|      tmp___0 = cycle_check(fts->fts_cycle.state,
 4226|      0|                            (struct stat const *)(ent->fts_statp));
 4227|      0|      if (tmp___0) {
 4228|      0|        ent->fts_cycle = ent;
 4229|      0|        ent->fts_info = (unsigned short)2;
 4230|      0|      }
 4231|      0|    }
 4232|      0|    return ((_Bool)1);
 4233|      0|  }
 4234|      0|}
 4235|      0|static void leave_dir(FTS *fts, FTSENT *ent) {
 4236|      0|  struct stat const *st;
 4237|      0|  struct Active_dir obj;
 4238|      0|  void *found;
 4239|      0|  FTSENT *parent;
 4240|       |
 4241|      0|  {
 4242|      0|    st = (struct stat const *)(ent->fts_statp);
 4243|      0|    if (fts->fts_options & 258) {
 4244|      0|      obj.dev = (dev_t)st->st_dev;
 4245|      0|      obj.ino = (ino_t)st->st_ino;
 4246|      0|      found = hash_delete(fts->fts_cycle.ht, (void const *)(&obj));
 4247|      0|      if (!found) {
 4248|      0|        abort();
 4249|      0|      }
 4250|      0|      free(found);
 4251|      0|    } else {
 4252|      0|      parent = ent->fts_parent;
 4253|      0|      if ((unsigned long)parent != (unsigned long)((void *)0)) {
 4254|      0|        if (0L <= parent->fts_level) {
 4255|      0|          while (1) {
 4256|       |
 4257|      0|            if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
 4258|      0|              abort();
 4259|      0|            }
 4260|      0|            if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t)st->st_ino) {
 4261|      0|              if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t)st->st_dev) {
 4262|      0|                (fts->fts_cycle.state)->dev_ino.st_dev =
 4263|      0|                    parent->fts_statp[0].st_dev;
 4264|      0|                (fts->fts_cycle.state)->dev_ino.st_ino =
 4265|      0|                    parent->fts_statp[0].st_ino;
 4266|      0|              }
 4267|      0|            }
 4268|      0|            goto while_break;
 4269|      0|          }
 4270|      0|        while_break:;
 4271|      0|        }
 4272|      0|      }
 4273|      0|    }
 4274|      0|    return;
 4275|      0|  }
 4276|      0|}
 4277|      2|static void free_dir(FTS *sp) {
 4278|       |
 4279|      2|  {
 4280|      2|    if (sp->fts_options & 258) {
 4281|      0|      if (sp->fts_cycle.ht) {
 4282|      0|        hash_free(sp->fts_cycle.ht);
 4283|      0|      }
 4284|      2|    } else {
 4285|      2|      free((void *)sp->fts_cycle.state);
 4286|      2|    }
 4287|      2|    return;
 4288|      2|  }
 4289|      2|}
 4290|      2|static void fd_ring_clear(I_ring *fd_ring) {
 4291|      2|  int fd;
 4292|      2|  int tmp;
 4293|      2|  _Bool tmp___0;
 4294|       |
 4295|      2|  {
 4296|      3|    while (1) {
 4297|      3|      tmp___0 = i_ring_empty((I_ring const *)fd_ring);
 4298|      3|      if (tmp___0) {
 4299|      2|        goto while_break;
 4300|      2|      }
 4301|      1|      tmp = i_ring_pop(fd_ring);
 4302|      1|      fd = tmp;
 4303|      1|      if (0 <= fd) {
 4304|      0|        close(fd);
 4305|      0|      }
 4306|      1|    }
 4307|      2|  while_break:;
 4308|      2|    return;
 4309|      2|  }
 4310|      2|}
 4311|      0|static void fts_set_stat_required(FTSENT *p, _Bool required) {
 4312|       |
 4313|      0|  {
 4314|      0|    while (1) {
 4315|       |
 4316|      0|      if (!((int)p->fts_info == 11)) {
 4317|      0|        abort();
 4318|      0|      }
 4319|      0|      goto while_break;
 4320|      0|    }
 4321|      0|  while_break:;
 4322|      0|    if (required) {
 4323|      0|      p->fts_statp[0].st_size = (__off_t)2;
 4324|      0|    } else {
 4325|      0|      p->fts_statp[0].st_size = (__off_t)1;
 4326|      0|    }
 4327|      0|    return;
 4328|      0|  }
 4329|      0|}
 4330|      0|__inline static DIR *opendirat(int fd, char const *dir) {
 4331|      0|  int new_fd;
 4332|      0|  int tmp;
 4333|      0|  DIR *dirp;
 4334|      0|  int saved_errno;
 4335|      0|  int *tmp___0;
 4336|      0|  int *tmp___1;
 4337|       |
 4338|      0|  {
 4339|      0|    tmp = openat_safer(fd, dir, 67840);
 4340|      0|    new_fd = tmp;
 4341|      0|    if (new_fd < 0) {
 4342|      0|      return ((DIR *)((void *)0));
 4343|      0|    }
 4344|      0|    set_cloexec_flag(new_fd, (_Bool)1);
 4345|      0|    dirp = fdopendir(new_fd);
 4346|      0|    if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 4347|      0|      tmp___0 = __errno_location();
 4348|      0|      saved_errno = *tmp___0;
 4349|      0|      close(new_fd);
 4350|      0|      tmp___1 = __errno_location();
 4351|      0|      *tmp___1 = saved_errno;
 4352|      0|    }
 4353|      0|    return (dirp);
 4354|      0|  }
 4355|      0|}
 4356|      1|static void cwd_advance_fd(FTS *sp, int fd, _Bool chdir_down_one) {
 4357|      1|  int old;
 4358|      1|  int prev_fd_in_slot;
 4359|      1|  int tmp;
 4360|       |
 4361|      1|  {
 4362|      1|    old = sp->fts_cwd_fd;
 4363|      1|    while (1) {
 4364|       |
 4365|      1|      if (!(old != fd)) {
 4366|      1|        if (!(old == -100)) {
 4367|      0|          abort();
 4368|      0|        }
 4369|      1|      }
 4370|      1|      goto while_break;
 4371|      1|    }
 4372|      1|  while_break:;
 4373|      1|    if (chdir_down_one) {
 4374|      1|      tmp = i_ring_push(&sp->fts_fd_ring, old);
 4375|      1|      prev_fd_in_slot = tmp;
 4376|      1|      if (0 <= prev_fd_in_slot) {
 4377|      0|        close(prev_fd_in_slot);
 4378|      0|      }
 4379|      1|    } else {
 4380|      0|      if (!(sp->fts_options & 4)) {
 4381|      0|        if (0 <= old) {
 4382|      0|          close(old);
 4383|      0|        }
 4384|      0|      }
 4385|      0|    }
 4386|      1|    sp->fts_cwd_fd = fd;
 4387|      1|    return;
 4388|      1|  }
 4389|      1|}
 4390|      0|__inline static int diropen(FTS const *sp, char const *dir) {
 4391|      0|  int open_flags;
 4392|      0|  int tmp;
 4393|      0|  int fd;
 4394|      0|  int tmp___0;
 4395|      0|  int tmp___1;
 4396|      0|  int tmp___2;
 4397|       |
 4398|      0|  {
 4399|      0|    if (sp->fts_options & 16) {
 4400|      0|      tmp = 131072;
 4401|      0|    } else {
 4402|      0|      tmp = 0;
 4403|      0|    }
 4404|      0|    open_flags = 67840 | tmp;
 4405|      0|    if (sp->fts_options & 512) {
 4406|      0|      tmp___0 = openat_safer((int)sp->fts_cwd_fd, dir, open_flags);
 4407|      0|      tmp___2 = tmp___0;
 4408|      0|    } else {
 4409|      0|      tmp___1 = open_safer(dir, open_flags);
 4410|      0|      tmp___2 = tmp___1;
 4411|      0|    }
 4412|      0|    fd = tmp___2;
 4413|      0|    if (0 <= fd) {
 4414|      0|      set_cloexec_flag(fd, (_Bool)1);
 4415|      0|    }
 4416|      0|    return (fd);
 4417|      0|  }
 4418|      0|}
 4419|       |__attribute__((__nothrow__))
 4420|       |FTS *(__attribute__((__warn_unused_result__, __leaf__))
 4421|       |      fts_open)(char *const *argv, int options,
 4422|       |                int (*compar)(FTSENT const **, FTSENT const **));
 4423|       |FTS *(__attribute__((__warn_unused_result__, __leaf__))
 4424|       |      fts_open)(char *const *argv, int options,
 4425|      1|                int (*compar)(FTSENT const **, FTSENT const **)) {
 4426|      1|  register FTS *sp;
 4427|      1|  register FTSENT *p;
 4428|      1|  register FTSENT *root;
 4429|      1|  register size_t nitems;
 4430|      1|  FTSENT *parent;
 4431|      1|  FTSENT *tmp;
 4432|      1|  _Bool defer_stat;
 4433|      1|  int *tmp___0;
 4434|      1|  int *tmp___1;
 4435|      1|  int *tmp___2;
 4436|      1|  size_t maxarglen;
 4437|      1|  size_t tmp___4;
 4438|      1|  size_t tmp___5;
 4439|      1|  _Bool tmp___6;
 4440|      1|  int tmp___7;
 4441|      1|  size_t len;
 4442|      1|  size_t tmp___8;
 4443|      1|  struct _ftsent *tmp___9;
 4444|      1|  _Bool tmp___10;
 4445|      1|  int tmp___11;
 4446|       |
 4447|      1|  {
 4448|      1|    parent = (FTSENT *)((void *)0);
 4449|      1|    tmp = (FTSENT *)((void *)0);
 4450|      1|    if (options & -2048) {
 4451|      0|      tmp___0 = __errno_location();
 4452|      0|      *tmp___0 = 22;
 4453|      0|      return ((FTS *)((void *)0));
 4454|      0|    }
 4455|      1|    if (options & 4) {
 4456|      0|      if (options & 512) {
 4457|      0|        tmp___1 = __errno_location();
 4458|      0|        *tmp___1 = 22;
 4459|      0|        return ((FTS *)((void *)0));
 4460|      0|      }
 4461|      0|    }
 4462|      1|    if (!(options & 18)) {
 4463|      0|      tmp___2 = __errno_location();
 4464|      0|      *tmp___2 = 22;
 4465|      0|      return ((FTS *)((void *)0));
 4466|      0|    }
 4467|      1|    sp = (FTS *)malloc(sizeof(FTS));
 4468|      1|    if ((unsigned long)sp == (unsigned long)((void *)0)) {
 4469|      0|      return ((FTS *)((void *)0));
 4470|      0|    }
 4471|      1|    memset((void *)sp, 0, sizeof(FTS));
 4472|      1|    sp->fts_compar = compar;
 4473|      1|    sp->fts_options = options;
 4474|      1|    if (sp->fts_options & 2) {
 4475|      0|      sp->fts_options |= 4;
 4476|      0|      sp->fts_options &= -513;
 4477|      0|    }
 4478|      1|    sp->fts_cwd_fd = -100;
 4479|      1|    tmp___4 = fts_maxarglen(argv);
 4480|      1|    maxarglen = tmp___4;
 4481|      1|    if (maxarglen > 4096UL) {
 4482|      0|      tmp___5 = maxarglen;
 4483|      1|    } else {
 4484|      1|      tmp___5 = (size_t)4096;
 4485|      1|    }
 4486|      1|    tmp___6 = fts_palloc(sp, tmp___5);
 4487|      1|    if (!tmp___6) {
 4488|      0|      goto mem1;
 4489|      0|    }
 4490|      1|    if ((unsigned long)*argv != (unsigned long)((void *)0)) {
 4491|      1|      parent = fts_alloc(sp, "", (size_t)0);
 4492|      1|      if ((unsigned long)parent == (unsigned long)((void *)0)) {
 4493|      0|        goto mem2;
 4494|      0|      }
 4495|      1|      parent->fts_level = (ptrdiff_t)-1;
 4496|      1|    }
 4497|      1|    if ((unsigned long)compar == (unsigned long)((void *)0)) {
 4498|      1|      tmp___7 = 1;
 4499|      1|    } else {
 4500|      0|      if (sp->fts_options & 1024) {
 4501|      0|        tmp___7 = 1;
 4502|      0|      } else {
 4503|      0|        tmp___7 = 0;
 4504|      0|      }
 4505|      0|    }
 4506|      1|    defer_stat = (_Bool)tmp___7;
 4507|      1|    root = (FTSENT *)((void *)0);
 4508|      1|    nitems = (size_t)0;
 4509|      2|    while (1) {
 4510|       |
 4511|      2|      if (!((unsigned long)*argv != (unsigned long)((void *)0))) {
 4512|      1|        goto while_break;
 4513|      1|      }
 4514|      1|      tmp___8 = strlen((char const *)*argv);
 4515|      1|      len = tmp___8;
 4516|      1|      p = fts_alloc(sp, (char const *)*argv, len);
 4517|      1|      if ((unsigned long)p == (unsigned long)((void *)0)) {
 4518|      0|        goto mem3;
 4519|      0|      }
 4520|      1|      p->fts_level = (ptrdiff_t)0;
 4521|      1|      p->fts_parent = parent;
 4522|      1|      p->fts_accpath = p->fts_name;
 4523|      1|      if (defer_stat) {
 4524|      1|        if ((unsigned long)root != (unsigned long)((void *)0)) {
 4525|      0|          p->fts_info = (unsigned short)11;
 4526|      0|          fts_set_stat_required(p, (_Bool)1);
 4527|      1|        } else {
 4528|      1|          p->fts_info = fts_stat(sp, p, (_Bool)0);
 4529|      1|        }
 4530|      1|      } else {
 4531|      0|        p->fts_info = fts_stat(sp, p, (_Bool)0);
 4532|      0|      }
 4533|      1|      if (compar) {
 4534|      0|        p->fts_link = root;
 4535|      0|        root = p;
 4536|      1|      } else {
 4537|      1|        p->fts_link = (struct _ftsent *)((void *)0);
 4538|      1|        if ((unsigned long)root == (unsigned long)((void *)0)) {
 4539|      1|          root = p;
 4540|      1|          tmp = root;
 4541|      1|        } else {
 4542|      0|          tmp->fts_link = p;
 4543|      0|          tmp = p;
 4544|      0|        }
 4545|      1|      }
 4546|      1|      argv++;
 4547|      1|      nitems++;
 4548|      1|    }
 4549|      1|  while_break:;
 4550|      1|    if (compar) {
 4551|      0|      if (nitems > 1UL) {
 4552|      0|        root = fts_sort(sp, root, nitems);
 4553|      0|      }
 4554|      0|    }
 4555|      1|    tmp___9 = fts_alloc(sp, "", (size_t)0);
 4556|      1|    sp->fts_cur = tmp___9;
 4557|      1|    if ((unsigned long)tmp___9 == (unsigned long)((void *)0)) {
 4558|      0|      goto mem3;
 4559|      0|    }
 4560|      1|    (sp->fts_cur)->fts_link = root;
 4561|      1|    (sp->fts_cur)->fts_info = (unsigned short)9;
 4562|      1|    tmp___10 = setup_dir(sp);
 4563|      1|    if (!tmp___10) {
 4564|      0|      goto mem3;
 4565|      0|    }
 4566|      1|    if (!(sp->fts_options & 4)) {
 4567|      1|      if (!(sp->fts_options & 512)) {
 4568|      0|        tmp___11 = diropen((FTS const *)sp, ".");
 4569|      0|        sp->fts_rfd = tmp___11;
 4570|      0|        if (tmp___11 < 0) {
 4571|      0|          sp->fts_options |= 4;
 4572|      0|        }
 4573|      0|      }
 4574|      1|    }
 4575|      1|    i_ring_init(&sp->fts_fd_ring, -1);
 4576|      1|    return (sp);
 4577|      0|  mem3:
 4578|      0|    fts_lfree(root);
 4579|      0|    free((void *)parent);
 4580|      0|  mem2:
 4581|      0|    free((void *)sp->fts_path);
 4582|      0|  mem1:
 4583|      0|    free((void *)sp);
 4584|      0|    return ((FTS *)((void *)0));
 4585|      0|  }
 4586|      0|}
 4587|      1|static void fts_load(FTS *sp, FTSENT *p) {
 4588|      1|  register size_t len;
 4589|      1|  register char *cp;
 4590|      1|  size_t tmp;
 4591|      1|  char *tmp___0;
 4592|       |
 4593|      1|  {
 4594|      1|    tmp = p->fts_namelen;
 4595|      1|    p->fts_pathlen = tmp;
 4596|      1|    len = tmp;
 4597|      1|    memmove((void *)sp->fts_path, (void const *)(p->fts_name), len + 1UL);
 4598|      1|    cp = strrchr((char const *)(p->fts_name), '/');
 4599|      1|    if (cp) {
 4600|      1|      if ((unsigned long)cp != (unsigned long)(p->fts_name)) {
 4601|      1|        cp++;
 4602|      1|        len = strlen((char const *)cp);
 4603|      1|        memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
 4604|      1|        p->fts_namelen = len;
 4605|      1|      } else {
 4606|      0|        if (*(cp + 1)) {
 4607|      0|          cp++;
 4608|      0|          len = strlen((char const *)cp);
 4609|      0|          memmove((void *)(p->fts_name), (void const *)cp, len + 1UL);
 4610|      0|          p->fts_namelen = len;
 4611|      0|        }
 4612|      0|      }
 4613|      1|    }
 4614|      1|    tmp___0 = sp->fts_path;
 4615|      1|    p->fts_path = tmp___0;
 4616|      1|    p->fts_accpath = tmp___0;
 4617|      1|    return;
 4618|      1|  }
 4619|      1|}
 4620|       |__attribute__((__nothrow__)) int(__attribute__((__warn_unused_result__,
 4621|       |                                                __leaf__)) fts_close)(FTS *sp);
 4622|      1|int(__attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp) {
 4623|      1|  register FTSENT *freep;
 4624|      1|  register FTSENT *p;
 4625|      1|  int saved_errno;
 4626|      1|  int *tmp;
 4627|      1|  int tmp___0;
 4628|      1|  int *tmp___1;
 4629|      1|  int tmp___2;
 4630|      1|  int *tmp___3;
 4631|      1|  int tmp___4;
 4632|      1|  int *tmp___5;
 4633|       |
 4634|      1|  {
 4635|      1|    saved_errno = 0;
 4636|      1|    if (sp->fts_cur) {
 4637|      0|      p = sp->fts_cur;
 4638|      0|      while (1) {
 4639|       |
 4640|      0|        if (!(p->fts_level >= 0L)) {
 4641|      0|          goto while_break;
 4642|      0|        }
 4643|      0|        freep = p;
 4644|      0|        if ((unsigned long)p->fts_link != (unsigned long)((void *)0)) {
 4645|      0|          p = p->fts_link;
 4646|      0|        } else {
 4647|      0|          p = p->fts_parent;
 4648|      0|        }
 4649|      0|        free((void *)freep);
 4650|      0|      }
 4651|      0|    while_break:
 4652|      0|      free((void *)p);
 4653|      0|    }
 4654|      1|    if (sp->fts_child) {
 4655|      0|      fts_lfree(sp->fts_child);
 4656|      0|    }
 4657|      1|    free((void *)sp->fts_array);
 4658|      1|    free((void *)sp->fts_path);
 4659|      1|    if (sp->fts_options & 512) {
 4660|      1|      if (0 <= sp->fts_cwd_fd) {
 4661|      0|        tmp___0 = close(sp->fts_cwd_fd);
 4662|      0|        if (tmp___0) {
 4663|      0|          tmp = __errno_location();
 4664|      0|          saved_errno = *tmp;
 4665|      0|        }
 4666|      0|      }
 4667|      1|    } else {
 4668|      0|      if (!(sp->fts_options & 4)) {
 4669|      0|        tmp___2 = fchdir(sp->fts_rfd);
 4670|      0|        if (tmp___2) {
 4671|      0|          tmp___1 = __errno_location();
 4672|      0|          saved_errno = *tmp___1;
 4673|      0|        }
 4674|      0|        tmp___4 = close(sp->fts_rfd);
 4675|      0|        if (tmp___4) {
 4676|      0|          if (saved_errno == 0) {
 4677|      0|            tmp___3 = __errno_location();
 4678|      0|            saved_errno = *tmp___3;
 4679|      0|          }
 4680|      0|        }
 4681|      0|      }
 4682|      0|    }
 4683|      1|    fd_ring_clear(&sp->fts_fd_ring);
 4684|      1|    if (sp->fts_leaf_optimization_works_ht) {
 4685|      0|      hash_free(sp->fts_leaf_optimization_works_ht);
 4686|      0|    }
 4687|      1|    free_dir(sp);
 4688|      1|    free((void *)sp);
 4689|      1|    if (saved_errno) {
 4690|      0|      tmp___5 = __errno_location();
 4691|      0|      *tmp___5 = saved_errno;
 4692|      0|      return (-1);
 4693|      0|    }
 4694|      1|    return (0);
 4695|      1|  }
 4696|      1|}
 4697|       |extern
 4698|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
 4699|       |                                     fstatfs)(int __fildes,
 4700|       |                                              struct statfs *__buf);
 4701|      0|static _Bool dirent_inode_sort_may_be_useful(int dir_fd) {
 4702|      0|  struct statfs fs_buf;
 4703|      0|  int tmp;
 4704|       |
 4705|      0|  {
 4706|      0|    tmp = fstatfs(dir_fd, &fs_buf);
 4707|      0|    if (tmp != 0) {
 4708|      0|      return ((_Bool)1);
 4709|      0|    }
 4710|      0|    if (fs_buf.f_type == 16914836L) {
 4711|      0|      goto case_16914836;
 4712|      0|    }
 4713|      0|    if (fs_buf.f_type == 26985L) {
 4714|      0|      goto case_16914836;
 4715|      0|    }
 4716|      0|    goto switch_default;
 4717|      0|  case_16914836:
 4718|      0|    return ((_Bool)0);
 4719|      0|  switch_default:
 4720|      0|    return ((_Bool)1);
 4721|       |
 4722|      0|    return ((_Bool)0);
 4723|      0|  }
 4724|      0|}
 4725|      0|static _Bool leaf_optimization_applies(int dir_fd) {
 4726|      0|  struct statfs fs_buf;
 4727|      0|  int tmp;
 4728|       |
 4729|      0|  {
 4730|      0|    tmp = fstatfs(dir_fd, &fs_buf);
 4731|      0|    if (tmp != 0) {
 4732|      0|      return ((_Bool)0);
 4733|      0|    }
 4734|      0|    if (fs_buf.f_type == 1382369651L) {
 4735|      0|      goto case_1382369651;
 4736|      0|    }
 4737|      0|    goto switch_default;
 4738|      0|  case_1382369651:
 4739|      0|    return ((_Bool)1);
 4740|      0|  switch_default:
 4741|      0|    return ((_Bool)0);
 4742|       |
 4743|      0|    return ((_Bool)0);
 4744|      0|  }
 4745|      0|}
 4746|      0|static size_t LCO_hash(void const *x, size_t table_size) {
 4747|      0|  struct LCO_ent const *ax;
 4748|       |
 4749|      0|  {
 4750|      0|    ax = (struct LCO_ent const *)x;
 4751|      0|    return ((uintmax_t)ax->st_dev % table_size);
 4752|      0|  }
 4753|      0|}
 4754|      0|static _Bool LCO_compare(void const *x, void const *y) {
 4755|      0|  struct LCO_ent const *ax;
 4756|      0|  struct LCO_ent const *ay;
 4757|       |
 4758|      0|  {
 4759|      0|    ax = (struct LCO_ent const *)x;
 4760|      0|    ay = (struct LCO_ent const *)y;
 4761|      0|    return ((_Bool)(ax->st_dev == ay->st_dev));
 4762|      0|  }
 4763|      0|}
 4764|      0|static _Bool link_count_optimize_ok(FTSENT const *p) {
 4765|      0|  FTS *sp;
 4766|      0|  Hash_table *h;
 4767|      0|  struct LCO_ent tmp;
 4768|      0|  struct LCO_ent *ent;
 4769|      0|  _Bool opt_ok;
 4770|      0|  struct LCO_ent *t2;
 4771|      0|  struct hash_table *tmp___0;
 4772|       |
 4773|      0|  {
 4774|      0|    sp = (FTS *)p->fts_fts;
 4775|      0|    h = sp->fts_leaf_optimization_works_ht;
 4776|      0|    if (!(sp->fts_options & 512)) {
 4777|      0|      return ((_Bool)0);
 4778|      0|    }
 4779|      0|    if ((unsigned long)h == (unsigned long)((void *)0)) {
 4780|      0|      tmp___0 =
 4781|      0|          hash_initialize((size_t)13, (Hash_tuning const *)((void *)0),
 4782|      0|                          &LCO_hash, &LCO_compare, (void (*)(void *))(&free));
 4783|      0|      sp->fts_leaf_optimization_works_ht = tmp___0;
 4784|      0|      h = tmp___0;
 4785|      0|      if ((unsigned long)h == (unsigned long)((void *)0)) {
 4786|      0|        return ((_Bool)0);
 4787|      0|      }
 4788|      0|    }
 4789|      0|    tmp.st_dev = (dev_t)p->fts_statp[0].st_dev;
 4790|      0|    ent = (struct LCO_ent *)hash_lookup((Hash_table const *)h,
 4791|      0|                                        (void const *)(&tmp));
 4792|      0|    if (ent) {
 4793|      0|      return (ent->opt_ok);
 4794|      0|    }
 4795|      0|    t2 = (struct LCO_ent *)malloc(sizeof(*t2));
 4796|      0|    if ((unsigned long)t2 == (unsigned long)((void *)0)) {
 4797|      0|      return ((_Bool)0);
 4798|      0|    }
 4799|      0|    opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
 4800|      0|    t2->opt_ok = opt_ok;
 4801|      0|    t2->st_dev = (dev_t)p->fts_statp[0].st_dev;
 4802|      0|    ent = (struct LCO_ent *)hash_insert(h, (void const *)t2);
 4803|      0|    if ((unsigned long)ent == (unsigned long)((void *)0)) {
 4804|      0|      free((void *)t2);
 4805|      0|      return ((_Bool)0);
 4806|      0|    }
 4807|      0|    while (1) {
 4808|       |
 4809|      0|      if (!((unsigned long)ent == (unsigned long)t2)) {
 4810|      0|        abort();
 4811|      0|      }
 4812|      0|      goto while_break;
 4813|      0|    }
 4814|      0|  while_break:;
 4815|      0|    return (opt_ok);
 4816|      0|  }
 4817|      0|}
 4818|       |__attribute__((__nothrow__))
 4819|       |FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp);
 4820|      2|FTSENT *(__attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp) {
 4821|      2|  register FTSENT *p;
 4822|      2|  register FTSENT *tmp;
 4823|      2|  register unsigned short instr;
 4824|      2|  register char *t;
 4825|      2|  int *tmp___0;
 4826|      2|  int tmp___1;
 4827|      2|  int *tmp___2;
 4828|      2|  int tmp___3;
 4829|      2|  struct _ftsent *tmp___4;
 4830|      2|  int tmp___5;
 4831|      2|  int tmp___6;
 4832|      2|  int tmp___7;
 4833|      2|  int tmp___8;
 4834|      2|  int tmp___9;
 4835|      2|  int *tmp___10;
 4836|      2|  int tmp___11;
 4837|      2|  size_t tmp___12;
 4838|      2|  char *tmp___13;
 4839|      2|  FTSENT *parent;
 4840|      2|  _Bool tmp___14;
 4841|      2|  int *tmp___15;
 4842|      2|  _Bool tmp___16;
 4843|      2|  int *tmp___17;
 4844|      2|  struct _ftsent *tmp___18;
 4845|      2|  int *tmp___19;
 4846|      2|  int tmp___20;
 4847|      2|  int tmp___21;
 4848|      2|  int tmp___22;
 4849|      2|  int tmp___23;
 4850|      2|  int tmp___24;
 4851|      2|  int saved_errno;
 4852|      2|  int *tmp___25;
 4853|      2|  int *tmp___26;
 4854|      2|  int *tmp___27;
 4855|      2|  int tmp___28;
 4856|      2|  int tmp___29;
 4857|      2|  int *tmp___30;
 4858|      2|  int tmp___31;
 4859|      2|  FTSENT *tmp___32;
 4860|       |
 4861|      2|  {
 4862|      2|    if ((unsigned long)sp->fts_cur == (unsigned long)((void *)0)) {
 4863|      0|      return ((FTSENT *)((void *)0));
 4864|      2|    } else {
 4865|      2|      if (sp->fts_options & 8192) {
 4866|      0|        return ((FTSENT *)((void *)0));
 4867|      0|      }
 4868|      2|    }
 4869|      2|    p = sp->fts_cur;
 4870|      2|    instr = p->fts_instr;
 4871|      2|    p->fts_instr = (unsigned short)3;
 4872|      2|    if ((int)instr == 1) {
 4873|      0|      p->fts_info = fts_stat(sp, p, (_Bool)0);
 4874|      0|      return (p);
 4875|      0|    }
 4876|      2|    if ((int)instr == 2) {
 4877|      0|      if ((int)p->fts_info == 12) {
 4878|      0|        goto _L;
 4879|      0|      } else {
 4880|      0|        if ((int)p->fts_info == 13) {
 4881|      0|        _L:
 4882|      0|          p->fts_info = fts_stat(sp, p, (_Bool)1);
 4883|      0|          if ((int)p->fts_info == 1) {
 4884|      0|            if (!(sp->fts_options & 4)) {
 4885|      0|              tmp___1 = diropen((FTS const *)sp, ".");
 4886|      0|              p->fts_symfd = tmp___1;
 4887|      0|              if (tmp___1 < 0) {
 4888|      0|                tmp___0 = __errno_location();
 4889|      0|                p->fts_errno = *tmp___0;
 4890|      0|                p->fts_info = (unsigned short)7;
 4891|      0|              } else {
 4892|      0|                p->fts_flags = (unsigned short)((int)p->fts_flags | 2);
 4893|      0|              }
 4894|      0|            }
 4895|      0|          }
 4896|      0|          goto check_for_dir;
 4897|      0|        }
 4898|      0|      }
 4899|      0|    }
 4900|      2|    if ((int)p->fts_info == 1) {
 4901|      0|      if ((int)instr == 4) {
 4902|      0|        goto _L___0;
 4903|      0|      } else {
 4904|      0|        if (sp->fts_options & 64) {
 4905|      0|          if (p->fts_statp[0].st_dev != sp->fts_dev) {
 4906|      0|          _L___0:
 4907|      0|            if ((int)p->fts_flags & 2) {
 4908|      0|              close(p->fts_symfd);
 4909|      0|            }
 4910|      0|            if (sp->fts_child) {
 4911|      0|              fts_lfree(sp->fts_child);
 4912|      0|              sp->fts_child = (struct _ftsent *)((void *)0);
 4913|      0|            }
 4914|      0|            p->fts_info = (unsigned short)6;
 4915|      0|            while (1) {
 4916|      0|              leave_dir(sp, p);
 4917|      0|              goto while_break;
 4918|      0|            }
 4919|      0|          while_break:;
 4920|      0|            return (p);
 4921|      0|          }
 4922|      0|        }
 4923|      0|      }
 4924|      0|      if ((unsigned long)sp->fts_child != (unsigned long)((void *)0)) {
 4925|      0|        if (sp->fts_options & 4096) {
 4926|      0|          sp->fts_options &= -4097;
 4927|      0|          fts_lfree(sp->fts_child);
 4928|      0|          sp->fts_child = (struct _ftsent *)((void *)0);
 4929|      0|        }
 4930|      0|      }
 4931|      0|      if ((unsigned long)sp->fts_child != (unsigned long)((void *)0)) {
 4932|      0|        tmp___3 = fts_safe_changedir(sp, p, -1, (char const *)p->fts_accpath);
 4933|      0|        if (tmp___3) {
 4934|      0|          tmp___2 = __errno_location();
 4935|      0|          p->fts_errno = *tmp___2;
 4936|      0|          p->fts_flags = (unsigned short)((int)p->fts_flags | 1);
 4937|      0|          p = sp->fts_child;
 4938|      0|          while (1) {
 4939|       |
 4940|      0|            if (!((unsigned long)p != (unsigned long)((void *)0))) {
 4941|      0|              goto while_break___0;
 4942|      0|            }
 4943|      0|            p->fts_accpath = (p->fts_parent)->fts_accpath;
 4944|      0|            p = p->fts_link;
 4945|      0|          }
 4946|      0|        while_break___0:;
 4947|      0|        }
 4948|      0|      } else {
 4949|      0|        tmp___4 = fts_build(sp, 3);
 4950|      0|        sp->fts_child = tmp___4;
 4951|      0|        if ((unsigned long)tmp___4 == (unsigned long)((void *)0)) {
 4952|      0|          if (sp->fts_options & 8192) {
 4953|      0|            return ((FTSENT *)((void *)0));
 4954|      0|          }
 4955|      0|          if (p->fts_errno) {
 4956|      0|            if ((int)p->fts_info != 4) {
 4957|      0|              p->fts_info = (unsigned short)7;
 4958|      0|            }
 4959|      0|          }
 4960|      0|          while (1) {
 4961|      0|            leave_dir(sp, p);
 4962|      0|            goto while_break___1;
 4963|      0|          }
 4964|      0|        while_break___1:;
 4965|      0|          return (p);
 4966|      0|        }
 4967|      0|      }
 4968|      0|      p = sp->fts_child;
 4969|      0|      sp->fts_child = (struct _ftsent *)((void *)0);
 4970|      0|      goto name;
 4971|      0|    }
 4972|      2|  next:
 4973|      2|    tmp = p;
 4974|      2|    p = p->fts_link;
 4975|      2|    if ((unsigned long)p != (unsigned long)((void *)0)) {
 4976|      1|      sp->fts_cur = p;
 4977|      1|      free((void *)tmp);
 4978|      1|      if (p->fts_level == 0L) {
 4979|      1|        fd_ring_clear(&sp->fts_fd_ring);
 4980|      1|        if (!(sp->fts_options & 4)) {
 4981|      1|          if (sp->fts_options & 512) {
 4982|      1|            if (sp->fts_options & 512) {
 4983|      1|              tmp___5 = -100;
 4984|      1|            } else {
 4985|      0|              tmp___5 = sp->fts_rfd;
 4986|      0|            }
 4987|      1|            cwd_advance_fd(sp, tmp___5, (_Bool)1);
 4988|      1|            tmp___8 = 0;
 4989|      1|          } else {
 4990|      0|            if (sp->fts_options & 512) {
 4991|      0|              tmp___6 = -100;
 4992|      0|            } else {
 4993|      0|              tmp___6 = sp->fts_rfd;
 4994|      0|            }
 4995|      0|            tmp___7 = fchdir(tmp___6);
 4996|      0|            tmp___8 = tmp___7;
 4997|      0|          }
 4998|      1|          if (tmp___8) {
 4999|      0|            tmp___9 = 1;
 5000|      1|          } else {
 5001|      1|            tmp___9 = 0;
 5002|      1|          }
 5003|      1|        } else {
 5004|      0|          tmp___9 = 0;
 5005|      0|        }
 5006|      1|        if (tmp___9) {
 5007|      0|          sp->fts_options |= 8192;
 5008|      0|          return ((FTSENT *)((void *)0));
 5009|      0|        }
 5010|      1|        free_dir(sp);
 5011|      1|        fts_load(sp, p);
 5012|      1|        setup_dir(sp);
 5013|      1|        goto check_for_dir;
 5014|      1|      }
 5015|      0|      if ((int)p->fts_instr == 4) {
 5016|      0|        goto next;
 5017|      0|      }
 5018|      0|      if ((int)p->fts_instr == 2) {
 5019|      0|        p->fts_info = fts_stat(sp, p, (_Bool)1);
 5020|      0|        if ((int)p->fts_info == 1) {
 5021|      0|          if (!(sp->fts_options & 4)) {
 5022|      0|            tmp___11 = diropen((FTS const *)sp, ".");
 5023|      0|            p->fts_symfd = tmp___11;
 5024|      0|            if (tmp___11 < 0) {
 5025|      0|              tmp___10 = __errno_location();
 5026|      0|              p->fts_errno = *tmp___10;
 5027|      0|              p->fts_info = (unsigned short)7;
 5028|      0|            } else {
 5029|      0|              p->fts_flags = (unsigned short)((int)p->fts_flags | 2);
 5030|      0|            }
 5031|      0|          }
 5032|      0|        }
 5033|      0|        p->fts_instr = (unsigned short)3;
 5034|      0|      }
 5035|      0|    name:
 5036|      0|      if ((int)*((p->fts_parent)->fts_path +
 5037|      0|                 ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
 5038|      0|        tmp___12 = (p->fts_parent)->fts_pathlen - 1UL;
 5039|      0|      } else {
 5040|      0|        tmp___12 = (p->fts_parent)->fts_pathlen;
 5041|      0|      }
 5042|      0|      t = sp->fts_path + tmp___12;
 5043|      0|      tmp___13 = t;
 5044|      0|      t++;
 5045|      0|      *tmp___13 = (char)'/';
 5046|      0|      memmove((void *)t, (void const *)(p->fts_name), p->fts_namelen + 1UL);
 5047|      1|    check_for_dir:
 5048|      1|      sp->fts_cur = p;
 5049|      1|      if ((int)p->fts_info == 11) {
 5050|      0|        if (p->fts_statp[0].st_size == 2L) {
 5051|      0|          parent = p->fts_parent;
 5052|      0|          if (0L < p->fts_level) {
 5053|      0|            if (parent->fts_n_dirs_remaining == 0UL) {
 5054|      0|              if (sp->fts_options & 8) {
 5055|      0|                if (sp->fts_options & 16) {
 5056|      0|                  tmp___14 = link_count_optimize_ok((FTSENT const *)parent);
 5057|      0|                  if (!tmp___14) {
 5058|      0|                    goto _L___4;
 5059|      0|                  }
 5060|      0|                } else {
 5061|      0|                  goto _L___4;
 5062|      0|                }
 5063|      0|              } else {
 5064|      0|                goto _L___4;
 5065|      0|              }
 5066|      0|            } else {
 5067|      0|              goto _L___4;
 5068|      0|            }
 5069|      0|          } else {
 5070|      0|          _L___4:
 5071|      0|            p->fts_info = fts_stat(sp, p, (_Bool)0);
 5072|      0|            if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
 5073|      0|              if (p->fts_level != 0L) {
 5074|      0|                if (parent->fts_n_dirs_remaining) {
 5075|      0|                  (parent->fts_n_dirs_remaining)--;
 5076|      0|                }
 5077|      0|              }
 5078|      0|            }
 5079|      0|          }
 5080|      0|        } else {
 5081|      0|          while (1) {
 5082|       |
 5083|      0|            if (!(p->fts_statp[0].st_size == 1L)) {
 5084|      0|              abort();
 5085|      0|            }
 5086|      0|            goto while_break___2;
 5087|      0|          }
 5088|      0|        while_break___2:;
 5089|      0|        }
 5090|      0|      }
 5091|      1|      if ((int)p->fts_info == 1) {
 5092|      0|        if (p->fts_level == 0L) {
 5093|      0|          sp->fts_dev = p->fts_statp[0].st_dev;
 5094|      0|        }
 5095|      0|        tmp___16 = enter_dir(sp, p);
 5096|      0|        if (!tmp___16) {
 5097|      0|          tmp___15 = __errno_location();
 5098|      0|          *tmp___15 = 12;
 5099|      0|          return ((FTSENT *)((void *)0));
 5100|      0|        }
 5101|      0|      }
 5102|      1|      return (p);
 5103|      1|    }
 5104|      1|    p = tmp->fts_parent;
 5105|      1|    sp->fts_cur = p;
 5106|      1|    free((void *)tmp);
 5107|      1|    if (p->fts_level == -1L) {
 5108|      1|      free((void *)p);
 5109|      1|      tmp___17 = __errno_location();
 5110|      1|      *tmp___17 = 0;
 5111|      1|      tmp___18 = (struct _ftsent *)((void *)0);
 5112|      1|      sp->fts_cur = tmp___18;
 5113|      1|      return (tmp___18);
 5114|      1|    }
 5115|      0|    while (1) {
 5116|       |
 5117|      0|      if (!((int)p->fts_info != 11)) {
 5118|      0|        abort();
 5119|      0|      }
 5120|      0|      goto while_break___3;
 5121|      0|    }
 5122|      0|  while_break___3:
 5123|      0|    *(sp->fts_path + p->fts_pathlen) = (char)'\000';
 5124|      0|    if (p->fts_level == 0L) {
 5125|      0|      fd_ring_clear(&sp->fts_fd_ring);
 5126|      0|      if (!(sp->fts_options & 4)) {
 5127|      0|        if (sp->fts_options & 512) {
 5128|      0|          if (sp->fts_options & 512) {
 5129|      0|            tmp___20 = -100;
 5130|      0|          } else {
 5131|      0|            tmp___20 = sp->fts_rfd;
 5132|      0|          }
 5133|      0|          cwd_advance_fd(sp, tmp___20, (_Bool)1);
 5134|      0|          tmp___23 = 0;
 5135|      0|        } else {
 5136|      0|          if (sp->fts_options & 512) {
 5137|      0|            tmp___21 = -100;
 5138|      0|          } else {
 5139|      0|            tmp___21 = sp->fts_rfd;
 5140|      0|          }
 5141|      0|          tmp___22 = fchdir(tmp___21);
 5142|      0|          tmp___23 = tmp___22;
 5143|      0|        }
 5144|      0|        if (tmp___23) {
 5145|      0|          tmp___24 = 1;
 5146|      0|        } else {
 5147|      0|          tmp___24 = 0;
 5148|      0|        }
 5149|      0|      } else {
 5150|      0|        tmp___24 = 0;
 5151|      0|      }
 5152|      0|      if (tmp___24) {
 5153|      0|        tmp___19 = __errno_location();
 5154|      0|        p->fts_errno = *tmp___19;
 5155|      0|        sp->fts_options |= 8192;
 5156|      0|      }
 5157|      0|    } else {
 5158|      0|      if ((int)p->fts_flags & 2) {
 5159|      0|        if (!(sp->fts_options & 4)) {
 5160|      0|          if (sp->fts_options & 512) {
 5161|      0|            cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
 5162|      0|            tmp___29 = 0;
 5163|      0|          } else {
 5164|      0|            tmp___28 = fchdir(p->fts_symfd);
 5165|      0|            tmp___29 = tmp___28;
 5166|      0|          }
 5167|      0|          if (tmp___29) {
 5168|      0|            tmp___25 = __errno_location();
 5169|      0|            saved_errno = *tmp___25;
 5170|      0|            close(p->fts_symfd);
 5171|      0|            tmp___26 = __errno_location();
 5172|      0|            *tmp___26 = saved_errno;
 5173|      0|            tmp___27 = __errno_location();
 5174|      0|            p->fts_errno = *tmp___27;
 5175|      0|            sp->fts_options |= 8192;
 5176|      0|          }
 5177|      0|        }
 5178|      0|        close(p->fts_symfd);
 5179|      0|      } else {
 5180|      0|        if (!((int)p->fts_flags & 1)) {
 5181|      0|          tmp___31 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
 5182|      0|          if (tmp___31) {
 5183|      0|            tmp___30 = __errno_location();
 5184|      0|            p->fts_errno = *tmp___30;
 5185|      0|            sp->fts_options |= 8192;
 5186|      0|          }
 5187|      0|        }
 5188|      0|      }
 5189|      0|    }
 5190|      0|    if (p->fts_errno) {
 5191|      0|      p->fts_info = (unsigned short)7;
 5192|      0|    } else {
 5193|      0|      p->fts_info = (unsigned short)6;
 5194|      0|    }
 5195|      0|    if (p->fts_errno == 0) {
 5196|      0|      while (1) {
 5197|      0|        leave_dir(sp, p);
 5198|      0|        goto while_break___4;
 5199|      0|      }
 5200|      0|    while_break___4:;
 5201|      0|    }
 5202|      0|    if (sp->fts_options & 8192) {
 5203|      0|      tmp___32 = (FTSENT *)((void *)0);
 5204|      0|    } else {
 5205|      0|      tmp___32 = p;
 5206|      0|    }
 5207|      0|    return (tmp___32);
 5208|      0|  }
 5209|      0|}
 5210|       |__attribute__((__nothrow__)) int(__attribute__((__leaf__))
 5211|       |                                 fts_set)(FTS *sp __attribute__((__unused__)),
 5212|       |                                          FTSENT *p, int instr);
 5213|       |int(__attribute__((__leaf__)) fts_set)(FTS *sp __attribute__((__unused__)),
 5214|      0|                                       FTSENT *p, int instr) {
 5215|      0|  int *tmp;
 5216|       |
 5217|      0|  {
 5218|      0|    if (instr != 0) {
 5219|      0|      if (instr != 1) {
 5220|      0|        if (instr != 2) {
 5221|      0|          if (instr != 3) {
 5222|      0|            if (instr != 4) {
 5223|      0|              tmp = __errno_location();
 5224|      0|              *tmp = 22;
 5225|      0|              return (1);
 5226|      0|            }
 5227|      0|          }
 5228|      0|        }
 5229|      0|      }
 5230|      0|    }
 5231|      0|    p->fts_instr = (unsigned short)instr;
 5232|      0|    return (0);
 5233|      0|  }
 5234|      0|}
 5235|      0|static int fts_compare_ino(struct _ftsent const **a, struct _ftsent const **b) {
 5236|      0|  int tmp;
 5237|      0|  int tmp___0;
 5238|       |
 5239|      0|  {
 5240|      0|    if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
 5241|      0|      tmp___0 = -1;
 5242|      0|    } else {
 5243|      0|      if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
 5244|      0|        tmp = 1;
 5245|      0|      } else {
 5246|      0|        tmp = 0;
 5247|      0|      }
 5248|      0|      tmp___0 = tmp;
 5249|      0|    }
 5250|      0|    return (tmp___0);
 5251|      0|  }
 5252|      0|}
 5253|      0|static void set_stat_type(struct stat *st, unsigned int dtype) {
 5254|      0|  mode_t type;
 5255|       |
 5256|      0|  {
 5257|      0|    if (dtype == 6U) {
 5258|      0|      goto case_6;
 5259|      0|    }
 5260|      0|    if (dtype == 2U) {
 5261|      0|      goto case_2;
 5262|      0|    }
 5263|      0|    if (dtype == 4U) {
 5264|      0|      goto case_4;
 5265|      0|    }
 5266|      0|    if (dtype == 1U) {
 5267|      0|      goto case_1;
 5268|      0|    }
 5269|      0|    if (dtype == 10U) {
 5270|      0|      goto case_10;
 5271|      0|    }
 5272|      0|    if (dtype == 8U) {
 5273|      0|      goto case_8;
 5274|      0|    }
 5275|      0|    if (dtype == 12U) {
 5276|      0|      goto case_12;
 5277|      0|    }
 5278|      0|    goto switch_default;
 5279|      0|  case_6:
 5280|      0|    type = (mode_t)24576;
 5281|      0|    goto switch_break;
 5282|      0|  case_2:
 5283|      0|    type = (mode_t)8192;
 5284|      0|    goto switch_break;
 5285|      0|  case_4:
 5286|      0|    type = (mode_t)16384;
 5287|      0|    goto switch_break;
 5288|      0|  case_1:
 5289|      0|    type = (mode_t)4096;
 5290|      0|    goto switch_break;
 5291|      0|  case_10:
 5292|      0|    type = (mode_t)40960;
 5293|      0|    goto switch_break;
 5294|      0|  case_8:
 5295|      0|    type = (mode_t)32768;
 5296|      0|    goto switch_break;
 5297|      0|  case_12:
 5298|      0|    type = (mode_t)49152;
 5299|      0|    goto switch_break;
 5300|      0|  switch_default:
 5301|      0|    type = (mode_t)0;
 5302|      0|  switch_break:
 5303|      0|    st->st_mode = type;
 5304|      0|    return;
 5305|      0|  }
 5306|      0|}
 5307|      0|static FTSENT *fts_build(FTS *sp, int type) {
 5308|      0|  register struct dirent *dp;
 5309|      0|  register FTSENT *p;
 5310|      0|  register FTSENT *head;
 5311|      0|  register size_t nitems;
 5312|      0|  FTSENT *cur;
 5313|      0|  FTSENT *tail;
 5314|      0|  DIR *dirp;
 5315|      0|  void *oldaddr;
 5316|      0|  int saved_errno;
 5317|      0|  _Bool descend;
 5318|      0|  _Bool doadjust;
 5319|      0|  ptrdiff_t level;
 5320|      0|  nlink_t nlinks;
 5321|      0|  _Bool nostat;
 5322|      0|  size_t len;
 5323|      0|  size_t maxlen;
 5324|      0|  size_t new_len;
 5325|      0|  char *cp;
 5326|      0|  int *tmp;
 5327|      0|  DIR *tmp___0;
 5328|      0|  DIR *tmp___1;
 5329|      0|  int *tmp___2;
 5330|      0|  _Bool tmp___3;
 5331|      0|  int tmp___4;
 5332|      0|  int dir_fd;
 5333|      0|  int tmp___5;
 5334|      0|  int *tmp___6;
 5335|      0|  int tmp___7;
 5336|      0|  char *tmp___8;
 5337|      0|  _Bool is_dir;
 5338|      0|  size_t tmp___9;
 5339|      0|  int *tmp___10;
 5340|      0|  int *tmp___11;
 5341|      0|  size_t tmp___12;
 5342|      0|  _Bool tmp___13;
 5343|      0|  size_t tmp___14;
 5344|      0|  size_t tmp___15;
 5345|      0|  int *tmp___16;
 5346|      0|  _Bool skip_stat;
 5347|      0|  int tmp___17;
 5348|      0|  int tmp___18;
 5349|      0|  int tmp___19;
 5350|      0|  int tmp___20;
 5351|      0|  int tmp___21;
 5352|      0|  int tmp___22;
 5353|      0|  int tmp___23;
 5354|      0|  int tmp___24;
 5355|      0|  int tmp___25;
 5356|      0|  int tmp___26;
 5357|      0|  _Bool tmp___27;
 5358|       |
 5359|      0|  {
 5360|      0|    cur = sp->fts_cur;
 5361|      0|    if (!(sp->fts_options & 4)) {
 5362|      0|      if (sp->fts_options & 512) {
 5363|      0|        tmp___0 = opendirat(sp->fts_cwd_fd, (char const *)cur->fts_accpath);
 5364|      0|        dirp = tmp___0;
 5365|      0|      } else {
 5366|      0|        tmp___1 = opendir_safer((char const *)cur->fts_accpath);
 5367|      0|        dirp = tmp___1;
 5368|      0|      }
 5369|      0|    } else {
 5370|      0|      tmp___1 = opendir_safer((char const *)cur->fts_accpath);
 5371|      0|      dirp = tmp___1;
 5372|      0|    }
 5373|      0|    if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 5374|      0|      if (type == 3) {
 5375|      0|        cur->fts_info = (unsigned short)4;
 5376|      0|        tmp = __errno_location();
 5377|      0|        cur->fts_errno = *tmp;
 5378|      0|      }
 5379|      0|      return ((FTSENT *)((void *)0));
 5380|      0|    }
 5381|      0|    if ((int)cur->fts_info == 11) {
 5382|      0|      cur->fts_info = fts_stat(sp, cur, (_Bool)0);
 5383|      0|    } else {
 5384|      0|      if (sp->fts_options & 256) {
 5385|      0|        while (1) {
 5386|      0|          leave_dir(sp, cur);
 5387|      0|          goto while_break;
 5388|      0|        }
 5389|      0|      while_break:
 5390|      0|        fts_stat(sp, cur, (_Bool)0);
 5391|      0|        tmp___3 = enter_dir(sp, cur);
 5392|      0|        if (!tmp___3) {
 5393|      0|          tmp___2 = __errno_location();
 5394|      0|          *tmp___2 = 12;
 5395|      0|          return ((FTSENT *)((void *)0));
 5396|      0|        }
 5397|      0|      }
 5398|      0|    }
 5399|      0|    if (type == 2) {
 5400|      0|      nlinks = (nlink_t)0;
 5401|      0|      nostat = (_Bool)0;
 5402|      0|    } else {
 5403|      0|      if (sp->fts_options & 8) {
 5404|      0|        if (sp->fts_options & 16) {
 5405|      0|          if (sp->fts_options & 32) {
 5406|      0|            tmp___4 = 0;
 5407|      0|          } else {
 5408|      0|            tmp___4 = 2;
 5409|      0|          }
 5410|      0|          nlinks = cur->fts_statp[0].st_nlink - (__nlink_t)tmp___4;
 5411|      0|          nostat = (_Bool)1;
 5412|      0|        } else {
 5413|      0|          nlinks = (nlink_t)-1;
 5414|      0|          nostat = (_Bool)0;
 5415|      0|        }
 5416|      0|      } else {
 5417|      0|        nlinks = (nlink_t)-1;
 5418|      0|        nostat = (_Bool)0;
 5419|      0|      }
 5420|      0|    }
 5421|      0|    if (nlinks) {
 5422|      0|      goto _L___0;
 5423|      0|    } else {
 5424|      0|      if (type == 3) {
 5425|      0|      _L___0:
 5426|      0|        tmp___5 = dirfd(dirp);
 5427|      0|        dir_fd = tmp___5;
 5428|      0|        if (sp->fts_options & 512) {
 5429|      0|          if (0 <= dir_fd) {
 5430|      0|            dir_fd = dup_safer(dir_fd);
 5431|      0|            set_cloexec_flag(dir_fd, (_Bool)1);
 5432|      0|          }
 5433|      0|        }
 5434|      0|        if (dir_fd < 0) {
 5435|      0|          goto _L;
 5436|      0|        } else {
 5437|      0|          tmp___7 =
 5438|      0|              fts_safe_changedir(sp, cur, dir_fd, (char const *)((void *)0));
 5439|      0|          if (tmp___7) {
 5440|      0|          _L:
 5441|      0|            if (nlinks) {
 5442|      0|              if (type == 3) {
 5443|      0|                tmp___6 = __errno_location();
 5444|      0|                cur->fts_errno = *tmp___6;
 5445|      0|              }
 5446|      0|            }
 5447|      0|            cur->fts_flags = (unsigned short)((int)cur->fts_flags | 1);
 5448|      0|            descend = (_Bool)0;
 5449|      0|            closedir(dirp);
 5450|      0|            if (sp->fts_options & 512) {
 5451|      0|              if (0 <= dir_fd) {
 5452|      0|                close(dir_fd);
 5453|      0|              }
 5454|      0|            }
 5455|      0|            dirp = (DIR *)((void *)0);
 5456|      0|          } else {
 5457|      0|            descend = (_Bool)1;
 5458|      0|          }
 5459|      0|        }
 5460|      0|      } else {
 5461|      0|        descend = (_Bool)0;
 5462|      0|      }
 5463|      0|    }
 5464|      0|    if ((int)*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
 5465|      0|      len = cur->fts_pathlen - 1UL;
 5466|      0|    } else {
 5467|      0|      len = cur->fts_pathlen;
 5468|      0|    }
 5469|      0|    if (sp->fts_options & 4) {
 5470|      0|      cp = sp->fts_path + len;
 5471|      0|      tmp___8 = cp;
 5472|      0|      cp++;
 5473|      0|      *tmp___8 = (char)'/';
 5474|      0|    } else {
 5475|      0|      cp = (char *)((void *)0);
 5476|      0|    }
 5477|      0|    len++;
 5478|      0|    maxlen = sp->fts_pathlen - len;
 5479|      0|    level = cur->fts_level + 1L;
 5480|      0|    doadjust = (_Bool)0;
 5481|      0|    tail = (FTSENT *)((void *)0);
 5482|      0|    head = tail;
 5483|      0|    nitems = (size_t)0;
 5484|      0|    while (1) {
 5485|       |
 5486|      0|      if (dirp) {
 5487|      0|        dp = readdir(dirp);
 5488|      0|        if (!dp) {
 5489|      0|          goto while_break___0;
 5490|      0|        }
 5491|      0|      } else {
 5492|      0|        goto while_break___0;
 5493|      0|      }
 5494|      0|      if (!(sp->fts_options & 32)) {
 5495|      0|        if ((int)dp->d_name[0] == 46) {
 5496|      0|          if (!dp->d_name[1]) {
 5497|      0|            goto __Cont;
 5498|      0|          } else {
 5499|      0|            if ((int)dp->d_name[1] == 46) {
 5500|      0|              if (!dp->d_name[2]) {
 5501|      0|                goto __Cont;
 5502|      0|              }
 5503|      0|            }
 5504|      0|          }
 5505|      0|        }
 5506|      0|      }
 5507|      0|      tmp___9 = strlen((char const *)(dp->d_name));
 5508|      0|      p = fts_alloc(sp, (char const *)(dp->d_name), tmp___9);
 5509|      0|      if ((unsigned long)p == (unsigned long)((void *)0)) {
 5510|      0|        goto mem1;
 5511|      0|      }
 5512|      0|      tmp___14 = strlen((char const *)(dp->d_name));
 5513|      0|      if (tmp___14 >= maxlen) {
 5514|      0|        oldaddr = (void *)sp->fts_path;
 5515|      0|        tmp___12 = strlen((char const *)(dp->d_name));
 5516|      0|        tmp___13 = fts_palloc(sp, (tmp___12 + len) + 1UL);
 5517|      0|        if (!tmp___13) {
 5518|      0|        mem1:
 5519|      0|          tmp___10 = __errno_location();
 5520|      0|          saved_errno = *tmp___10;
 5521|      0|          free((void *)p);
 5522|      0|          fts_lfree(head);
 5523|      0|          closedir(dirp);
 5524|      0|          cur->fts_info = (unsigned short)7;
 5525|      0|          sp->fts_options |= 8192;
 5526|      0|          tmp___11 = __errno_location();
 5527|      0|          *tmp___11 = saved_errno;
 5528|      0|          return ((FTSENT *)((void *)0));
 5529|      0|        }
 5530|      0|        if ((unsigned long)oldaddr != (unsigned long)sp->fts_path) {
 5531|      0|          doadjust = (_Bool)1;
 5532|      0|          if (sp->fts_options & 4) {
 5533|      0|            cp = sp->fts_path + len;
 5534|      0|          }
 5535|      0|        }
 5536|      0|        maxlen = sp->fts_pathlen - len;
 5537|      0|      }
 5538|      0|      tmp___15 = strlen((char const *)(dp->d_name));
 5539|      0|      new_len = len + tmp___15;
 5540|      0|      if (new_len < len) {
 5541|      0|        free((void *)p);
 5542|      0|        fts_lfree(head);
 5543|      0|        closedir(dirp);
 5544|      0|        cur->fts_info = (unsigned short)7;
 5545|      0|        sp->fts_options |= 8192;
 5546|      0|        tmp___16 = __errno_location();
 5547|      0|        *tmp___16 = 36;
 5548|      0|        return ((FTSENT *)((void *)0));
 5549|      0|      }
 5550|      0|      p->fts_level = level;
 5551|      0|      p->fts_parent = sp->fts_cur;
 5552|      0|      p->fts_pathlen = new_len;
 5553|      0|      p->fts_statp[0].st_ino = dp->d_ino;
 5554|      0|      if (sp->fts_options & 4) {
 5555|      0|        p->fts_accpath = p->fts_path;
 5556|      0|        memmove((void *)cp, (void const *)(p->fts_name), p->fts_namelen + 1UL);
 5557|      0|      } else {
 5558|      0|        p->fts_accpath = p->fts_name;
 5559|      0|      }
 5560|      0|      if ((unsigned long)sp->fts_compar == (unsigned long)((void *)0)) {
 5561|      0|        goto _L___1;
 5562|      0|      } else {
 5563|      0|        if (sp->fts_options & 1024) {
 5564|      0|        _L___1:
 5565|      0|          if (sp->fts_options & 16) {
 5566|      0|            if (sp->fts_options & 8) {
 5567|      0|              if ((int)dp->d_type != 0) {
 5568|      0|                if (!((int)dp->d_type == 4)) {
 5569|      0|                  tmp___17 = 1;
 5570|      0|                } else {
 5571|      0|                  tmp___17 = 0;
 5572|      0|                }
 5573|      0|              } else {
 5574|      0|                tmp___17 = 0;
 5575|      0|              }
 5576|      0|            } else {
 5577|      0|              tmp___17 = 0;
 5578|      0|            }
 5579|      0|          } else {
 5580|      0|            tmp___17 = 0;
 5581|      0|          }
 5582|      0|          skip_stat = (_Bool)tmp___17;
 5583|      0|          p->fts_info = (unsigned short)11;
 5584|      0|          set_stat_type(p->fts_statp, (unsigned int)dp->d_type);
 5585|      0|          fts_set_stat_required(p, (_Bool)(!skip_stat));
 5586|      0|          if (sp->fts_options & 16) {
 5587|      0|            if ((int)dp->d_type == 4) {
 5588|      0|              tmp___18 = 1;
 5589|      0|            } else {
 5590|      0|              tmp___18 = 0;
 5591|      0|            }
 5592|      0|          } else {
 5593|      0|            tmp___18 = 0;
 5594|      0|          }
 5595|      0|          is_dir = (_Bool)tmp___18;
 5596|      0|        } else {
 5597|      0|          p->fts_info = fts_stat(sp, p, (_Bool)0);
 5598|      0|          if ((int)p->fts_info == 1) {
 5599|      0|            tmp___19 = 1;
 5600|      0|          } else {
 5601|      0|            if ((int)p->fts_info == 2) {
 5602|      0|              tmp___19 = 1;
 5603|      0|            } else {
 5604|      0|              if ((int)p->fts_info == 5) {
 5605|      0|                tmp___19 = 1;
 5606|      0|              } else {
 5607|      0|                tmp___19 = 0;
 5608|      0|              }
 5609|      0|            }
 5610|      0|          }
 5611|      0|          is_dir = (_Bool)tmp___19;
 5612|      0|        }
 5613|      0|      }
 5614|      0|      if (nlinks > 0UL) {
 5615|      0|        if (is_dir) {
 5616|      0|          nlinks -= (nlink_t)nostat;
 5617|      0|        }
 5618|      0|      }
 5619|      0|      p->fts_link = (struct _ftsent *)((void *)0);
 5620|      0|      if ((unsigned long)head == (unsigned long)((void *)0)) {
 5621|      0|        tail = p;
 5622|      0|        head = tail;
 5623|      0|      } else {
 5624|      0|        tail->fts_link = p;
 5625|      0|        tail = p;
 5626|      0|      }
 5627|      0|      nitems++;
 5628|      0|    __Cont:;
 5629|      0|    }
 5630|      0|  while_break___0:;
 5631|      0|    if (dirp) {
 5632|      0|      closedir(dirp);
 5633|      0|    }
 5634|      0|    if (doadjust) {
 5635|      0|      fts_padjust(sp, head);
 5636|      0|    }
 5637|      0|    if (sp->fts_options & 4) {
 5638|      0|      if (len == sp->fts_pathlen) {
 5639|      0|        cp--;
 5640|      0|      } else {
 5641|      0|        if (nitems == 0UL) {
 5642|      0|          cp--;
 5643|      0|        }
 5644|      0|      }
 5645|      0|      *cp = (char)'\000';
 5646|      0|    }
 5647|      0|    if (descend) {
 5648|      0|      if (type == 1) {
 5649|      0|        goto _L___2;
 5650|      0|      } else {
 5651|      0|        if (!nitems) {
 5652|      0|        _L___2:
 5653|      0|          if (cur->fts_level == 0L) {
 5654|      0|            fd_ring_clear(&sp->fts_fd_ring);
 5655|      0|            if (!(sp->fts_options & 4)) {
 5656|      0|              if (sp->fts_options & 512) {
 5657|      0|                if (sp->fts_options & 512) {
 5658|      0|                  tmp___20 = -100;
 5659|      0|                } else {
 5660|      0|                  tmp___20 = sp->fts_rfd;
 5661|      0|                }
 5662|      0|                cwd_advance_fd(sp, tmp___20, (_Bool)1);
 5663|      0|                tmp___23 = 0;
 5664|      0|              } else {
 5665|      0|                if (sp->fts_options & 512) {
 5666|      0|                  tmp___21 = -100;
 5667|      0|                } else {
 5668|      0|                  tmp___21 = sp->fts_rfd;
 5669|      0|                }
 5670|      0|                tmp___22 = fchdir(tmp___21);
 5671|      0|                tmp___23 = tmp___22;
 5672|      0|              }
 5673|      0|              if (tmp___23) {
 5674|      0|                tmp___24 = 1;
 5675|      0|              } else {
 5676|      0|                tmp___24 = 0;
 5677|      0|              }
 5678|      0|            } else {
 5679|      0|              tmp___24 = 0;
 5680|      0|            }
 5681|      0|            tmp___26 = tmp___24;
 5682|      0|          } else {
 5683|      0|            tmp___25 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
 5684|      0|            tmp___26 = tmp___25;
 5685|      0|          }
 5686|      0|          if (tmp___26) {
 5687|      0|            cur->fts_info = (unsigned short)7;
 5688|      0|            sp->fts_options |= 8192;
 5689|      0|            fts_lfree(head);
 5690|      0|            return ((FTSENT *)((void *)0));
 5691|      0|          }
 5692|      0|        }
 5693|      0|      }
 5694|      0|    }
 5695|      0|    if (!nitems) {
 5696|      0|      if (type == 3) {
 5697|      0|        cur->fts_info = (unsigned short)6;
 5698|      0|      }
 5699|      0|      fts_lfree(head);
 5700|      0|      return ((FTSENT *)((void *)0));
 5701|      0|    }
 5702|      0|    if (nitems > 10000UL) {
 5703|      0|      if (!sp->fts_compar) {
 5704|      0|        if (sp->fts_options & 512) {
 5705|      0|          tmp___27 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
 5706|      0|          if (tmp___27) {
 5707|      0|            sp->fts_compar = &fts_compare_ino;
 5708|      0|            head = fts_sort(sp, head, nitems);
 5709|      0|            sp->fts_compar = (int (*)(struct _ftsent const **, struct _ftsent const **))((void *)0);
 5710|      0|          }
 5711|      0|        }
 5712|      0|      }
 5713|      0|    }
 5714|      0|    if (sp->fts_compar) {
 5715|      0|      if (nitems > 1UL) {
 5716|      0|        head = fts_sort(sp, head, nitems);
 5717|      0|      }
 5718|      0|    }
 5719|      0|    return (head);
 5720|      0|  }
 5721|      0|}
 5722|      1|static unsigned short fts_stat(FTS *sp, FTSENT *p, _Bool follow) {
 5723|      1|  struct stat *sbp;
 5724|      1|  int saved_errno;
 5725|      1|  int *tmp;
 5726|      1|  int *tmp___0;
 5727|      1|  int *tmp___1;
 5728|      1|  int tmp___2;
 5729|      1|  int tmp___3;
 5730|      1|  int *tmp___4;
 5731|      1|  int tmp___5;
 5732|      1|  int tmp___6;
 5733|      1|  int tmp___7;
 5734|       |
 5735|      1|  {
 5736|      1|    sbp = p->fts_statp;
 5737|      1|    if (p->fts_level == 0L) {
 5738|      1|      if (sp->fts_options & 1) {
 5739|      0|        follow = (_Bool)1;
 5740|      0|      }
 5741|      1|    }
 5742|      1|    if (sp->fts_options & 2) {
 5743|      0|      goto _L;
 5744|      1|    } else {
 5745|      1|      if (follow) {
 5746|      0|      _L:
 5747|      0|        tmp___3 = stat((char const *)p->fts_accpath, sbp);
 5748|      0|        if (tmp___3) {
 5749|      0|          tmp = __errno_location();
 5750|      0|          saved_errno = *tmp;
 5751|      0|          tmp___1 = __errno_location();
 5752|      0|          if (*tmp___1 == 2) {
 5753|      0|            tmp___2 = lstat((char const *)p->fts_accpath, sbp);
 5754|      0|            if (tmp___2 == 0) {
 5755|      0|              tmp___0 = __errno_location();
 5756|      0|              *tmp___0 = 0;
 5757|      0|              return ((unsigned short)13);
 5758|      0|            }
 5759|      0|          }
 5760|      0|          p->fts_errno = saved_errno;
 5761|      0|          goto err;
 5762|      0|        }
 5763|      1|      } else {
 5764|      1|        tmp___5 =
 5765|      1|            fstatat(sp->fts_cwd_fd, (char const *)p->fts_accpath, sbp, 256);
 5766|      1|        if (tmp___5) {
 5767|      0|          tmp___4 = __errno_location();
 5768|      0|          p->fts_errno = *tmp___4;
 5769|      0|        err:
 5770|      0|          memset((void *)sbp, 0, sizeof(struct stat));
 5771|      0|          return ((unsigned short)10);
 5772|      0|        }
 5773|      1|      }
 5774|      1|    }
 5775|      1|    if ((sbp->st_mode & 61440U) == 16384U) {
 5776|      0|      if (sp->fts_options & 32) {
 5777|      0|        tmp___6 = 0;
 5778|      0|      } else {
 5779|      0|        tmp___6 = 2;
 5780|      0|      }
 5781|      0|      p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t)tmp___6;
 5782|      0|      if ((int)p->fts_name[0] == 46) {
 5783|      0|        if (!p->fts_name[1]) {
 5784|      0|          goto _L___0;
 5785|      0|        } else {
 5786|      0|          if ((int)p->fts_name[1] == 46) {
 5787|      0|            if (!p->fts_name[2]) {
 5788|      0|            _L___0:
 5789|      0|              if (p->fts_level == 0L) {
 5790|      0|                tmp___7 = 1;
 5791|      0|              } else {
 5792|      0|                tmp___7 = 5;
 5793|      0|              }
 5794|      0|              return ((unsigned short)tmp___7);
 5795|      0|            }
 5796|      0|          }
 5797|      0|        }
 5798|      0|      }
 5799|      0|      return ((unsigned short)1);
 5800|      0|    }
 5801|      1|    if ((sbp->st_mode & 61440U) == 40960U) {
 5802|      0|      return ((unsigned short)12);
 5803|      0|    }
 5804|      1|    if ((sbp->st_mode & 61440U) == 32768U) {
 5805|      1|      return ((unsigned short)8);
 5806|      1|    }
 5807|      0|    return ((unsigned short)3);
 5808|      1|  }
 5809|      1|}
 5810|      0|static int fts_compar(void const *a, void const *b) {
 5811|      0|  FTSENT const **pa;
 5812|      0|  FTSENT const **pb;
 5813|      0|  int tmp;
 5814|       |
 5815|      0|  {
 5816|      0|    pa = (FTSENT const **)a;
 5817|      0|    pb = (FTSENT const **)b;
 5818|      0|    tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
 5819|      0|    return (tmp);
 5820|      0|  }
 5821|      0|}
 5822|      0|static FTSENT *fts_sort(FTS *sp, FTSENT *head, size_t nitems) {
 5823|      0|  register FTSENT **ap;
 5824|      0|  register FTSENT *p;
 5825|      0|  FTSENT *dummy = 0;
 5826|      0|  int (*compare)(void const *, void const *);
 5827|      0|  int (*tmp)(void const *, void const *);
 5828|      0|  FTSENT **a;
 5829|      0|  FTSENT **tmp___0;
 5830|       |
 5831|      0|  {
 5832|      0|    if (sizeof(&dummy) == sizeof(void *)) {
 5833|      0|      if ((long)(&dummy) == (long)((void *)(&dummy))) {
 5834|      0|        tmp = (int (*)(void const *, void const *))sp->fts_compar;
 5835|      0|      } else {
 5836|      0|        tmp = &fts_compar;
 5837|      0|      }
 5838|      0|    } else {
 5839|      0|      tmp = &fts_compar;
 5840|      0|    }
 5841|      0|    compare = tmp;
 5842|      0|    if (nitems > sp->fts_nitems) {
 5843|      0|      sp->fts_nitems = nitems + 40UL;
 5844|      0|      if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
 5845|      0|        free((void *)sp->fts_array);
 5846|      0|        sp->fts_array = (struct _ftsent **)((void *)0);
 5847|      0|        sp->fts_nitems = (size_t)0;
 5848|      0|        return (head);
 5849|      0|      } else {
 5850|      0|        a = (FTSENT **)realloc((void *)sp->fts_array,
 5851|      0|                               sp->fts_nitems * sizeof(*a));
 5852|      0|        if (!a) {
 5853|      0|          free((void *)sp->fts_array);
 5854|      0|          sp->fts_array = (struct _ftsent **)((void *)0);
 5855|      0|          sp->fts_nitems = (size_t)0;
 5856|      0|          return (head);
 5857|      0|        }
 5858|      0|      }
 5859|      0|      sp->fts_array = a;
 5860|      0|    }
 5861|      0|    ap = sp->fts_array;
 5862|      0|    p = head;
 5863|      0|    while (1) {
 5864|       |
 5865|      0|      if (!p) {
 5866|      0|        goto while_break;
 5867|      0|      }
 5868|      0|      tmp___0 = ap;
 5869|      0|      ap++;
 5870|      0|      *tmp___0 = p;
 5871|      0|      p = p->fts_link;
 5872|      0|    }
 5873|      0|  while_break:
 5874|      0|    qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
 5875|      0|    ap = sp->fts_array;
 5876|      0|    head = *ap;
 5877|      0|    while (1) {
 5878|      0|      nitems--;
 5879|      0|      if (!nitems) {
 5880|      0|        goto while_break___0;
 5881|      0|      }
 5882|      0|      (*(ap + 0))->fts_link = *(ap + 1);
 5883|      0|      ap++;
 5884|      0|    }
 5885|      0|  while_break___0:
 5886|      0|    (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
 5887|      0|    return (head);
 5888|      0|  }
 5889|      0|}
 5890|      3|static FTSENT *fts_alloc(FTS *sp, char const *name, size_t namelen) {
 5891|      3|  register FTSENT *p;
 5892|      3|  size_t len;
 5893|       |
 5894|      3|  {
 5895|      3|    len = sizeof(FTSENT) + namelen;
 5896|      3|    p = (FTSENT *)malloc(len);
 5897|      3|    if ((unsigned long)p == (unsigned long)((void *)0)) {
 5898|      0|      return ((FTSENT *)((void *)0));
 5899|      0|    }
 5900|      3|    memmove((void *)(p->fts_name), (void const *)name, namelen);
 5901|      3|    p->fts_name[namelen] = (char)'\000';
 5902|      3|    p->fts_namelen = namelen;
 5903|      3|    p->fts_fts = sp;
 5904|      3|    p->fts_path = sp->fts_path;
 5905|      3|    p->fts_errno = 0;
 5906|      3|    p->fts_flags = (unsigned short)0;
 5907|      3|    p->fts_instr = (unsigned short)3;
 5908|      3|    p->fts_number = 0L;
 5909|      3|    p->fts_pointer = (void *)0;
 5910|      3|    return (p);
 5911|      3|  }
 5912|      3|}
 5913|      0|static void fts_lfree(FTSENT *head) {
 5914|      0|  register FTSENT *p;
 5915|       |
 5916|      0|  {
 5917|      0|    while (1) {
 5918|      0|      p = head;
 5919|      0|      if (!p) {
 5920|      0|        goto while_break;
 5921|      0|      }
 5922|      0|      head = head->fts_link;
 5923|      0|      free((void *)p);
 5924|      0|    }
 5925|      0|  while_break:;
 5926|      0|    return;
 5927|      0|  }
 5928|      0|}
 5929|      1|static _Bool fts_palloc(FTS *sp, size_t more) {
 5930|      1|  char *p;
 5931|      1|  size_t new_len;
 5932|      1|  int *tmp;
 5933|       |
 5934|      1|  {
 5935|      1|    new_len = (sp->fts_pathlen + more) + 256UL;
 5936|      1|    if (new_len < sp->fts_pathlen) {
 5937|      0|      free((void *)sp->fts_path);
 5938|      0|      sp->fts_path = (char *)((void *)0);
 5939|      0|      tmp = __errno_location();
 5940|      0|      *tmp = 36;
 5941|      0|      return ((_Bool)0);
 5942|      0|    }
 5943|      1|    sp->fts_pathlen = new_len;
 5944|      1|    p = (char *)realloc((void *)sp->fts_path, sp->fts_pathlen);
 5945|      1|    if ((unsigned long)p == (unsigned long)((void *)0)) {
 5946|      0|      free((void *)sp->fts_path);
 5947|      0|      sp->fts_path = (char *)((void *)0);
 5948|      0|      return ((_Bool)0);
 5949|      0|    }
 5950|      1|    sp->fts_path = p;
 5951|      1|    return ((_Bool)1);
 5952|      1|  }
 5953|      1|}
 5954|      0|static void fts_padjust(FTS *sp, FTSENT *head) {
 5955|      0|  FTSENT *p;
 5956|      0|  char *addr;
 5957|       |
 5958|      0|  {
 5959|      0|    addr = sp->fts_path;
 5960|      0|    p = sp->fts_child;
 5961|      0|    while (1) {
 5962|       |
 5963|      0|      if (!p) {
 5964|      0|        goto while_break;
 5965|      0|      }
 5966|      0|      while (1) {
 5967|       |
 5968|      0|        if ((unsigned long)p->fts_accpath != (unsigned long)(p->fts_name)) {
 5969|      0|          p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
 5970|      0|        }
 5971|      0|        p->fts_path = addr;
 5972|      0|        goto while_break___0;
 5973|      0|      }
 5974|      0|    while_break___0:
 5975|      0|      p = p->fts_link;
 5976|      0|    }
 5977|      0|  while_break:
 5978|      0|    p = head;
 5979|      0|    while (1) {
 5980|       |
 5981|      0|      if (!(p->fts_level >= 0L)) {
 5982|      0|        goto while_break___1;
 5983|      0|      }
 5984|      0|      while (1) {
 5985|       |
 5986|      0|        if ((unsigned long)p->fts_accpath != (unsigned long)(p->fts_name)) {
 5987|      0|          p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
 5988|      0|        }
 5989|      0|        p->fts_path = addr;
 5990|      0|        goto while_break___2;
 5991|      0|      }
 5992|      0|    while_break___2:;
 5993|      0|      if (p->fts_link) {
 5994|      0|        p = p->fts_link;
 5995|      0|      } else {
 5996|      0|        p = p->fts_parent;
 5997|      0|      }
 5998|      0|    }
 5999|      0|  while_break___1:;
 6000|      0|    return;
 6001|      0|  }
 6002|      0|}
 6003|      1|static size_t fts_maxarglen(char *const *argv) {
 6004|      1|  size_t len;
 6005|      1|  size_t max;
 6006|       |
 6007|      1|  {
 6008|      1|    max = (size_t)0;
 6009|      2|    while (1) {
 6010|       |
 6011|      2|      if (!*argv) {
 6012|      1|        goto while_break;
 6013|      1|      }
 6014|      1|      len = strlen((char const *)*argv);
 6015|      1|      if (len > max) {
 6016|      1|        max = len;
 6017|      1|      }
 6018|      1|      argv++;
 6019|      1|    }
 6020|      1|  while_break:;
 6021|      1|    return (max + 1UL);
 6022|      1|  }
 6023|      1|}
 6024|      0|static int fts_safe_changedir(FTS *sp, FTSENT *p, int fd, char const *dir) {
 6025|      0|  int ret;
 6026|      0|  _Bool is_dotdot;
 6027|      0|  int tmp;
 6028|      0|  int tmp___0;
 6029|      0|  int newfd;
 6030|      0|  int parent_fd;
 6031|      0|  _Bool tmp___1;
 6032|      0|  struct stat sb;
 6033|      0|  int tmp___2;
 6034|      0|  int *tmp___3;
 6035|      0|  int tmp___4;
 6036|      0|  int oerrno;
 6037|      0|  int *tmp___5;
 6038|      0|  int *tmp___6;
 6039|       |
 6040|      0|  {
 6041|      0|    if (dir) {
 6042|      0|      tmp = strcmp(dir, "..");
 6043|      0|      if (tmp == 0) {
 6044|      0|        tmp___0 = 1;
 6045|      0|      } else {
 6046|      0|        tmp___0 = 0;
 6047|      0|      }
 6048|      0|    } else {
 6049|      0|      tmp___0 = 0;
 6050|      0|    }
 6051|      0|    is_dotdot = (_Bool)tmp___0;
 6052|      0|    if (sp->fts_options & 4) {
 6053|      0|      if (sp->fts_options & 512) {
 6054|      0|        if (0 <= fd) {
 6055|      0|          close(fd);
 6056|      0|        }
 6057|      0|      }
 6058|      0|      return (0);
 6059|      0|    }
 6060|      0|    if (fd < 0) {
 6061|      0|      if (is_dotdot) {
 6062|      0|        if (sp->fts_options & 512) {
 6063|      0|          tmp___1 = i_ring_empty((I_ring const *)(&sp->fts_fd_ring));
 6064|      0|          if (!tmp___1) {
 6065|      0|            parent_fd = i_ring_pop(&sp->fts_fd_ring);
 6066|      0|            is_dotdot = (_Bool)1;
 6067|      0|            if (0 <= parent_fd) {
 6068|      0|              fd = parent_fd;
 6069|      0|              dir = (char const *)((void *)0);
 6070|      0|            }
 6071|      0|          }
 6072|      0|        }
 6073|      0|      }
 6074|      0|    }
 6075|      0|    newfd = fd;
 6076|      0|    if (fd < 0) {
 6077|      0|      newfd = diropen((FTS const *)sp, dir);
 6078|      0|      if (newfd < 0) {
 6079|      0|        return (-1);
 6080|      0|      }
 6081|      0|    }
 6082|      0|    if (sp->fts_options & 2) {
 6083|      0|      goto _L;
 6084|      0|    } else {
 6085|      0|      if (dir) {
 6086|      0|        tmp___4 = strcmp(dir, "..");
 6087|      0|        if (tmp___4 == 0) {
 6088|      0|        _L:
 6089|      0|          tmp___2 = fstat(newfd, &sb);
 6090|      0|          if (tmp___2) {
 6091|      0|            ret = -1;
 6092|      0|            goto bail;
 6093|      0|          }
 6094|      0|          if (p->fts_statp[0].st_dev != sb.st_dev) {
 6095|      0|            tmp___3 = __errno_location();
 6096|      0|            *tmp___3 = 2;
 6097|      0|            ret = -1;
 6098|      0|            goto bail;
 6099|      0|          } else {
 6100|      0|            if (p->fts_statp[0].st_ino != sb.st_ino) {
 6101|      0|              tmp___3 = __errno_location();
 6102|      0|              *tmp___3 = 2;
 6103|      0|              ret = -1;
 6104|      0|              goto bail;
 6105|      0|            }
 6106|      0|          }
 6107|      0|        }
 6108|      0|      }
 6109|      0|    }
 6110|      0|    if (sp->fts_options & 512) {
 6111|      0|      cwd_advance_fd(sp, newfd, (_Bool)(!is_dotdot));
 6112|      0|      return (0);
 6113|      0|    }
 6114|      0|    ret = fchdir(newfd);
 6115|      0|  bail:
 6116|      0|    if (fd < 0) {
 6117|      0|      tmp___5 = __errno_location();
 6118|      0|      oerrno = *tmp___5;
 6119|      0|      close(newfd);
 6120|      0|      tmp___6 = __errno_location();
 6121|      0|      *tmp___6 = oerrno;
 6122|      0|    }
 6123|      0|    return (ret);
 6124|      0|  }
 6125|      0|}
 6126|       |extern int fseeko(FILE *__stream, __off_t __off, int __whence);
 6127|       |extern __attribute__((__nothrow__))
 6128|       |__off_t(__attribute__((__leaf__)) lseek)(int __fd, __off_t __offset,
 6129|       |                                         int __whence);
 6130|       |int(__attribute__((__nonnull__(1))) rpl_fseeko)(FILE *fp, off_t offset,
 6131|      0|                                                int whence) {
 6132|      0|  off_t pos;
 6133|      0|  off_t tmp;
 6134|      0|  int tmp___0;
 6135|      0|  off_t tmp___1;
 6136|      0|  int tmp___2;
 6137|       |
 6138|      0|  {
 6139|      0|    if ((unsigned long)fp->_IO_read_end == (unsigned long)fp->_IO_read_ptr) {
 6140|      0|      if ((unsigned long)fp->_IO_write_ptr ==
 6141|      0|          (unsigned long)fp->_IO_write_base) {
 6142|      0|        if ((unsigned long)fp->_IO_save_base == (unsigned long)((void *)0)) {
 6143|      0|          if (whence == 2) {
 6144|      0|            if (offset > 0L) {
 6145|      0|              tmp = (off_t)0;
 6146|      0|            } else {
 6147|      0|              tmp = offset;
 6148|      0|            }
 6149|      0|          } else {
 6150|      0|            tmp = offset;
 6151|      0|          }
 6152|      0|          tmp___0 = fileno(fp);
 6153|      0|          tmp___1 = lseek(tmp___0, tmp, whence);
 6154|      0|          pos = tmp___1;
 6155|      0|          if (pos == -1L) {
 6156|      0|            return (-1);
 6157|      0|          }
 6158|      0|          fp->_flags &= -17;
 6159|      0|          if (whence == 2) {
 6160|      0|            if (!(offset > 0L)) {
 6161|      0|              return (0);
 6162|      0|            }
 6163|      0|          } else {
 6164|      0|            return (0);
 6165|      0|          }
 6166|      0|        }
 6167|      0|      }
 6168|      0|    }
 6169|      0|    tmp___2 = fseeko(fp, offset, whence);
 6170|      0|    return (tmp___2);
 6171|      0|  }
 6172|      0|}
 6173|       |#pragma weak pthread_key_create
 6174|       |#pragma weak pthread_getspecific
 6175|       |#pragma weak pthread_setspecific
 6176|       |#pragma weak pthread_key_delete
 6177|       |#pragma weak pthread_self
 6178|       |#pragma weak pthread_cancel
 6179|       |#pragma weak pthread_mutex_init
 6180|       |#pragma weak pthread_mutex_lock
 6181|       |#pragma weak pthread_mutex_unlock
 6182|       |#pragma weak pthread_mutex_destroy
 6183|       |#pragma weak pthread_rwlock_init
 6184|       |#pragma weak pthread_rwlock_rdlock
 6185|       |#pragma weak pthread_rwlock_wrlock
 6186|       |#pragma weak pthread_rwlock_unlock
 6187|       |#pragma weak pthread_rwlock_destroy
 6188|       |#pragma weak pthread_once
 6189|       |#pragma weak pthread_cond_init
 6190|       |#pragma weak pthread_cond_wait
 6191|       |#pragma weak pthread_cond_signal
 6192|       |#pragma weak pthread_cond_broadcast
 6193|       |#pragma weak pthread_cond_destroy
 6194|       |#pragma weak pthread_mutexattr_init
 6195|       |#pragma weak pthread_mutexattr_settype
 6196|       |#pragma weak pthread_mutexattr_destroy
 6197|       |#pragma weak pthread_self
 6198|       |#pragma weak pthread_cancel
 6199|       |char const *Version = "8.4";
 6200|       |extern
 6201|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 6202|       |                                     euidaccess)(char const *__name,
 6203|       |                                                 int __type);
 6204|       |extern
 6205|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
 6206|       |                                     faccessat)(int __fd, char const *__file,
 6207|       |                                                int __type, int __flag);
 6208|       |extern
 6209|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
 6210|       |                                     unlinkat)(int __fd, char const *__name,
 6211|       |                                               int __flag);
 6212|      0|__inline static int lstatat(int fd, char const *name, struct stat *st) {
 6213|      0|  int tmp;
 6214|       |
 6215|      0|  {
 6216|      0|    tmp = fstatat(fd, name, st, 256);
 6217|      0|    return (tmp);
 6218|      0|  }
 6219|      0|}
 6220|      0|__inline static _Bool dot_or_dotdot(char const *file_name___3) {
 6221|      0|  char sep;
 6222|      0|  int tmp;
 6223|       |
 6224|      0|  {
 6225|      0|    if ((int const) * (file_name___3 + 0) == 46) {
 6226|      0|      sep = (char)*(file_name___3 +
 6227|      0|                    (((int const) * (file_name___3 + 1) == 46) + 1));
 6228|      0|      if (!sep) {
 6229|      0|        tmp = 1;
 6230|      0|      } else {
 6231|      0|        if ((int)sep == 47) {
 6232|      0|          tmp = 1;
 6233|      0|        } else {
 6234|      0|          tmp = 0;
 6235|      0|        }
 6236|      0|      }
 6237|      0|      return ((_Bool)tmp);
 6238|      0|    } else {
 6239|      0|      return ((_Bool)0);
 6240|      0|    }
 6241|      0|  }
 6242|      0|}
 6243|       |__inline static struct dirent const *
 6244|      0|readdir_ignoring_dot_and_dotdot(DIR *dirp) {
 6245|      0|  struct dirent const *dp;
 6246|      0|  struct dirent const *tmp;
 6247|      0|  _Bool tmp___0;
 6248|       |
 6249|      0|  {
 6250|      0|    while (1) {
 6251|      0|      tmp = (struct dirent const *)readdir(dirp);
 6252|      0|      dp = tmp;
 6253|      0|      if ((unsigned long)dp == (unsigned long)((void *)0)) {
 6254|      0|        return (dp);
 6255|      0|      } else {
 6256|      0|        tmp___0 = dot_or_dotdot((char const *)(dp->d_name));
 6257|      0|        if (!tmp___0) {
 6258|      0|          return (dp);
 6259|      0|        }
 6260|      0|      }
 6261|      0|    }
 6262|       |
 6263|      0|    return ((struct dirent const *)0);
 6264|      0|  }
 6265|      0|}
 6266|      0|__inline static _Bool is_empty_dir(int fd_cwd, char const *dir) {
 6267|      0|  DIR *dirp;
 6268|      0|  struct dirent const *dp;
 6269|      0|  int saved_errno;
 6270|      0|  int fd;
 6271|      0|  int tmp;
 6272|      0|  int *tmp___0;
 6273|      0|  int *tmp___1;
 6274|      0|  int tmp___2;
 6275|       |
 6276|      0|  {
 6277|      0|    tmp = openat(fd_cwd, dir, 198912);
 6278|      0|    fd = tmp;
 6279|      0|    if (fd < 0) {
 6280|      0|      return ((_Bool)0);
 6281|      0|    }
 6282|      0|    dirp = fdopendir(fd);
 6283|      0|    if ((unsigned long)dirp == (unsigned long)((void *)0)) {
 6284|      0|      close(fd);
 6285|      0|      return ((_Bool)0);
 6286|      0|    }
 6287|      0|    tmp___0 = __errno_location();
 6288|      0|    *tmp___0 = 0;
 6289|      0|    dp = readdir_ignoring_dot_and_dotdot(dirp);
 6290|      0|    tmp___1 = __errno_location();
 6291|      0|    saved_errno = *tmp___1;
 6292|      0|    closedir(dirp);
 6293|      0|    if ((unsigned long)dp != (unsigned long)((void *)0)) {
 6294|      0|      return ((_Bool)0);
 6295|      0|    }
 6296|      0|    if (saved_errno == 0) {
 6297|      0|      tmp___2 = 1;
 6298|      0|    } else {
 6299|      0|      tmp___2 = 0;
 6300|      0|    }
 6301|      0|    return ((_Bool)tmp___2);
 6302|      0|  }
 6303|      0|}
 6304|       |enum RM_status rm(char *const *file, struct rm_options const *x);
 6305|      1|static int cache_fstatat(int fd, char const *file, struct stat *st, int flag) {
 6306|      1|  int *tmp;
 6307|      1|  int tmp___0;
 6308|      1|  int *tmp___1;
 6309|       |
 6310|      1|  {
 6311|      1|    if (st->st_size == -1L) {
 6312|      1|      tmp___0 = fstatat(fd, file, st, flag);
 6313|      1|      if (tmp___0 != 0) {
 6314|      0|        st->st_size = (__off_t)-2;
 6315|      0|        tmp = __errno_location();
 6316|      0|        st->st_ino = (__ino_t)*tmp;
 6317|      0|      }
 6318|      1|    }
 6319|      1|    if (0L <= st->st_size) {
 6320|      1|      return (0);
 6321|      1|    }
 6322|      0|    tmp___1 = __errno_location();
 6323|      0|    *tmp___1 = (int)st->st_ino;
 6324|      0|    return (-1);
 6325|      1|  }
 6326|      1|}
 6327|      1|__inline static struct stat *cache_stat_init(struct stat *st) {
 6328|       |
 6329|      1|  {
 6330|      1|    st->st_size = (__off_t)-1;
 6331|      1|    return (st);
 6332|      1|  }
 6333|      1|}
 6334|       |static int write_protected_non_symlink(int fd_cwd, char const *file,
 6335|       |                                       char const *full_name,
 6336|      1|                                       struct stat *buf___1) {
 6337|      1|  _Bool tmp;
 6338|      1|  int tmp___0;
 6339|      1|  int tmp___1;
 6340|      1|  size_t file_name_len;
 6341|      1|  size_t tmp___2;
 6342|      1|  _Bool tmp___3;
 6343|      1|  int tmp___4;
 6344|      1|  int tmp___5;
 6345|      1|  int *tmp___6;
 6346|      1|  int *tmp___7;
 6347|       |
 6348|      1|  {
 6349|      1|    tmp = can_write_any_file();
 6350|      1|    if (tmp) {
 6351|      0|      return (0);
 6352|      0|    }
 6353|      1|    tmp___0 = cache_fstatat(fd_cwd, file, buf___1, 256);
 6354|      1|    if (tmp___0 != 0) {
 6355|      0|      return (-1);
 6356|      0|    }
 6357|      1|    if ((buf___1->st_mode & 61440U) == 40960U) {
 6358|      0|      return (0);
 6359|      0|    }
 6360|      1|    tmp___1 = faccessat(fd_cwd, file, 2, 512);
 6361|      1|    if (tmp___1 == 0) {
 6362|      1|      return (0);
 6363|      1|    }
 6364|      0|    tmp___2 = strlen(full_name);
 6365|      0|    file_name_len = tmp___2;
 6366|      0|    if (4096UL <= file_name_len) {
 6367|      0|      tmp___3 = euidaccess_stat((struct stat const *)buf___1, 2);
 6368|      0|      if (tmp___3) {
 6369|      0|        tmp___4 = 0;
 6370|      0|      } else {
 6371|      0|        tmp___4 = 1;
 6372|      0|      }
 6373|      0|      return (tmp___4);
 6374|      0|    }
 6375|      0|    tmp___5 = euidaccess(full_name, 2);
 6376|      0|    if (tmp___5 == 0) {
 6377|      0|      return (0);
 6378|      0|    }
 6379|      0|    tmp___7 = __errno_location();
 6380|      0|    if (*tmp___7 == 13) {
 6381|      0|      tmp___6 = __errno_location();
 6382|      0|      *tmp___6 = 0;
 6383|      0|      return (1);
 6384|      0|    }
 6385|      0|    return (-1);
 6386|      0|  }
 6387|      0|}
 6388|       |static enum RM_status prompt(FTS const *fts, FTSENT const *ent, _Bool is_dir,
 6389|       |                             struct rm_options const *x,
 6390|      1|                             enum Prompt_action mode, Ternary *is_empty_p) {
 6391|      1|  int fd_cwd;
 6392|      1|  char const *full_name;
 6393|      1|  char const *filename;
 6394|      1|  struct stat st;
 6395|      1|  struct stat *sbuf;
 6396|      1|  int dirent_type;
 6397|      1|  int tmp;
 6398|      1|  int write_protected;
 6399|      1|  int wp_errno;
 6400|      1|  int *tmp___0;
 6401|      1|  int *tmp___1;
 6402|      1|  int tmp___2;
 6403|      1|  char const *quoted_name;
 6404|      1|  char const *tmp___3;
 6405|      1|  char *tmp___4;
 6406|      1|  _Bool is_empty;
 6407|      1|  char *tmp___5;
 6408|      1|  char *tmp___6;
 6409|      1|  char *tmp___7;
 6410|      1|  char *tmp___8;
 6411|      1|  int *tmp___9;
 6412|      1|  int tmp___10;
 6413|      1|  char const *tmp___11;
 6414|      1|  char *tmp___12;
 6415|      1|  char *tmp___13;
 6416|      1|  char *tmp___14;
 6417|      1|  _Bool tmp___15;
 6418|       |
 6419|      1|  {
 6420|      1|    fd_cwd = (int)fts->fts_cwd_fd;
 6421|      1|    full_name = (char const *)ent->fts_path;
 6422|      1|    filename = (char const *)ent->fts_accpath;
 6423|      1|    if (is_empty_p) {
 6424|      0|      *is_empty_p = (Ternary)2;
 6425|      0|    }
 6426|      1|    sbuf = &st;
 6427|      1|    cache_stat_init(sbuf);
 6428|      1|    if (is_dir) {
 6429|      0|      tmp = 4;
 6430|      1|    } else {
 6431|      1|      tmp = 0;
 6432|      1|    }
 6433|      1|    dirent_type = tmp;
 6434|      1|    write_protected = 0;
 6435|      1|    if (ent->fts_number) {
 6436|      0|      return ((enum RM_status)3);
 6437|      0|    }
 6438|      1|    if ((unsigned int const)x->interactive == 5U) {
 6439|      0|      return ((enum RM_status)2);
 6440|      0|    }
 6441|      1|    wp_errno = 0;
 6442|      1|    if (!x->ignore_missing_files) {
 6443|      1|      if ((unsigned int const)x->interactive == 3U) {
 6444|      0|        goto _L;
 6445|      1|      } else {
 6446|      1|        if (x->stdin_tty) {
 6447|      1|        _L:
 6448|      1|          if (dirent_type != 10) {
 6449|      1|            write_protected =
 6450|      1|                write_protected_non_symlink(fd_cwd, filename, full_name, sbuf);
 6451|      1|            tmp___0 = __errno_location();
 6452|      1|            wp_errno = *tmp___0;
 6453|      1|          }
 6454|      1|        }
 6455|      1|      }
 6456|      1|    }
 6457|      1|    if (write_protected) {
 6458|      0|      goto _L___2;
 6459|      1|    } else {
 6460|      1|      if ((unsigned int const)x->interactive == 3U) {
 6461|      0|      _L___2:
 6462|      0|        if (0 <= write_protected) {
 6463|      0|          if (dirent_type == 0) {
 6464|      0|            tmp___2 = cache_fstatat(fd_cwd, filename, sbuf, 256);
 6465|      0|            if (tmp___2 == 0) {
 6466|      0|              if ((sbuf->st_mode & 61440U) == 40960U) {
 6467|      0|                dirent_type = 10;
 6468|      0|              } else {
 6469|      0|                if ((sbuf->st_mode & 61440U) == 16384U) {
 6470|      0|                  dirent_type = 4;
 6471|      0|                }
 6472|      0|              }
 6473|      0|            } else {
 6474|      0|              write_protected = -1;
 6475|      0|              tmp___1 = __errno_location();
 6476|      0|              wp_errno = *tmp___1;
 6477|      0|            }
 6478|      0|          }
 6479|      0|        }
 6480|      0|        if (0 <= write_protected) {
 6481|      0|          if (dirent_type == 10) {
 6482|      0|            goto case_10;
 6483|      0|          }
 6484|      0|          if (dirent_type == 4) {
 6485|      0|            goto case_4;
 6486|      0|          }
 6487|      0|          goto switch_break;
 6488|      0|        case_10:
 6489|      0|          if ((unsigned int const)x->interactive != 3U) {
 6490|      0|            return ((enum RM_status)2);
 6491|      0|          }
 6492|      0|          goto switch_break;
 6493|      0|        case_4:
 6494|      0|          if (!x->recursive) {
 6495|      0|            write_protected = -1;
 6496|      0|            wp_errno = 21;
 6497|      0|          }
 6498|      0|          goto switch_break;
 6499|      0|        switch_break:;
 6500|      0|        }
 6501|      0|        tmp___3 = quote(full_name);
 6502|      0|        quoted_name = tmp___3;
 6503|      0|        if (write_protected < 0) {
 6504|      0|          tmp___4 = gettext("cannot remove %s");
 6505|      0|          error(0, wp_errno, (char const *)tmp___4, quoted_name);
 6506|      0|          return ((enum RM_status)4);
 6507|      0|        }
 6508|      0|        if (is_empty_p) {
 6509|      0|          is_empty = is_empty_dir(fd_cwd, filename);
 6510|      0|          if (is_empty) {
 6511|      0|            *is_empty_p = (Ternary)4;
 6512|      0|          } else {
 6513|      0|            *is_empty_p = (Ternary)3;
 6514|      0|          }
 6515|      0|        } else {
 6516|      0|          is_empty = (_Bool)0;
 6517|      0|        }
 6518|      0|        if (dirent_type == 4) {
 6519|      0|          if ((unsigned int)mode == 2U) {
 6520|      0|            if (!is_empty) {
 6521|      0|              if (write_protected) {
 6522|      0|                tmp___5 =
 6523|      0|                    gettext("%s: descend into write-protected directory %s? ");
 6524|      0|                tmp___7 = tmp___5;
 6525|      0|              } else {
 6526|      0|                tmp___6 = gettext("%s: descend into directory %s? ");
 6527|      0|                tmp___7 = tmp___6;
 6528|      0|              }
 6529|      0|              fprintf(stderr, (char const *)tmp___7, program_name, quoted_name);
 6530|      0|            } else {
 6531|      0|              goto _L___1;
 6532|      0|            }
 6533|      0|          } else {
 6534|      0|            goto _L___1;
 6535|      0|          }
 6536|      0|        } else {
 6537|      0|        _L___1:
 6538|      0|          tmp___10 = cache_fstatat(fd_cwd, filename, sbuf, 256);
 6539|      0|          if (tmp___10 != 0) {
 6540|      0|            tmp___8 = gettext("cannot remove %s");
 6541|      0|            tmp___9 = __errno_location();
 6542|      0|            error(0, *tmp___9, (char const *)tmp___8, quoted_name);
 6543|      0|            return ((enum RM_status)4);
 6544|      0|          }
 6545|      0|          tmp___11 = file_type((struct stat const *)sbuf);
 6546|      0|          if (write_protected) {
 6547|      0|            tmp___12 = gettext("%s: remove write-protected %s %s? ");
 6548|      0|            tmp___14 = tmp___12;
 6549|      0|          } else {
 6550|      0|            tmp___13 = gettext("%s: remove %s %s? ");
 6551|      0|            tmp___14 = tmp___13;
 6552|      0|          }
 6553|      0|          fprintf(stderr, (char const *)tmp___14, program_name, tmp___11,
 6554|      0|                  quoted_name);
 6555|      0|        }
 6556|      0|        tmp___15 = yesno();
 6557|      0|        if (!tmp___15) {
 6558|      0|          return ((enum RM_status)3);
 6559|      0|        }
 6560|      0|      }
 6561|      1|    }
 6562|      1|    return ((enum RM_status)2);
 6563|      1|  }
 6564|      1|}
 6565|      0|__inline static _Bool nonexistent_file_errno(int errnum) {
 6566|       |
 6567|      0|  {
 6568|      0|    if (errnum == 2) {
 6569|      0|      goto case_2;
 6570|      0|    }
 6571|      0|    if (errnum == 20) {
 6572|      0|      goto case_2;
 6573|      0|    }
 6574|      0|    goto switch_default;
 6575|      0|  case_2:
 6576|      0|    return ((_Bool)1);
 6577|      0|  switch_default:
 6578|      0|    return ((_Bool)0);
 6579|       |
 6580|      0|    return ((_Bool)0);
 6581|      0|  }
 6582|      0|}
 6583|       |__inline static _Bool ignorable_missing(struct rm_options const *x,
 6584|      0|                                        int errnum) {
 6585|      0|  _Bool tmp;
 6586|      0|  int tmp___0;
 6587|       |
 6588|      0|  {
 6589|      0|    if (x->ignore_missing_files) {
 6590|      0|      tmp = nonexistent_file_errno(errnum);
 6591|      0|      if (tmp) {
 6592|      0|        tmp___0 = 1;
 6593|      0|      } else {
 6594|      0|        tmp___0 = 0;
 6595|      0|      }
 6596|      0|    } else {
 6597|      0|      tmp___0 = 0;
 6598|      0|    }
 6599|      0|    return ((_Bool)tmp___0);
 6600|      0|  }
 6601|      0|}
 6602|      0|static void fts_skip_tree(FTS *fts, FTSENT *ent) {
 6603|       |
 6604|      0|  {
 6605|      0|    fts_set(fts, ent, 4);
 6606|      0|    ent = fts_read(fts);
 6607|      0|    return;
 6608|      0|  }
 6609|      0|}
 6610|      0|static void mark_ancestor_dirs(FTSENT *ent) {
 6611|      0|  FTSENT *p;
 6612|       |
 6613|      0|  {
 6614|      0|    p = ent->fts_parent;
 6615|      0|    while (1) {
 6616|       |
 6617|      0|      if (!(0L <= p->fts_level)) {
 6618|      0|        goto while_break;
 6619|      0|      }
 6620|      0|      if (p->fts_number) {
 6621|      0|        goto while_break;
 6622|      0|      }
 6623|      0|      p->fts_number = 1L;
 6624|      0|      p = p->fts_parent;
 6625|      0|    }
 6626|      0|  while_break:;
 6627|      0|    return;
 6628|      0|  }
 6629|      0|}
 6630|       |static enum RM_status excise(FTS *fts, FTSENT *ent, struct rm_options const *x,
 6631|      1|                             _Bool is_dir) {
 6632|      1|  int flag;
 6633|      1|  int tmp;
 6634|      1|  char const *tmp___0;
 6635|      1|  char *tmp___1;
 6636|      1|  char *tmp___2;
 6637|      1|  char *tmp___3;
 6638|      1|  int tmp___4;
 6639|      1|  struct stat st;
 6640|      1|  int *tmp___5;
 6641|      1|  int tmp___6;
 6642|      1|  int *tmp___7;
 6643|      1|  int *tmp___8;
 6644|      1|  int *tmp___9;
 6645|      1|  _Bool tmp___10;
 6646|      1|  int *tmp___11;
 6647|      1|  char const *tmp___12;
 6648|      1|  char *tmp___13;
 6649|      1|  int *tmp___14;
 6650|       |
 6651|      1|  {
 6652|      1|    if (is_dir) {
 6653|      0|      tmp = 512;
 6654|      1|    } else {
 6655|      1|      tmp = 0;
 6656|      1|    }
 6657|      1|    flag = tmp;
 6658|      1|    tmp___4 = unlinkat(fts->fts_cwd_fd, (char const *)ent->fts_accpath, flag);
 6659|      1|    if (tmp___4 == 0) {
 6660|      1|      if (x->verbose) {
 6661|      0|        tmp___0 = quote((char const *)ent->fts_path);
 6662|      0|        if (is_dir) {
 6663|      0|          tmp___1 = gettext("removed directory: %s\n");
 6664|      0|          tmp___3 = tmp___1;
 6665|      0|        } else {
 6666|      0|          tmp___2 = gettext("removed %s\n");
 6667|      0|          tmp___3 = tmp___2;
 6668|      0|        }
 6669|      0|        printf((char const *)tmp___3, tmp___0);
 6670|      0|      }
 6671|      1|      return ((enum RM_status)2);
 6672|      1|    }
 6673|      0|    tmp___8 = __errno_location();
 6674|      0|    if (*tmp___8 == 30) {
 6675|      0|      tmp___6 = lstatat(fts->fts_cwd_fd, (char const *)ent->fts_accpath, &st);
 6676|      0|      if (tmp___6) {
 6677|      0|        tmp___7 = __errno_location();
 6678|      0|        if (!(*tmp___7 == 2)) {
 6679|      0|          tmp___5 = __errno_location();
 6680|      0|          *tmp___5 = 30;
 6681|      0|        }
 6682|      0|      } else {
 6683|      0|        tmp___5 = __errno_location();
 6684|      0|        *tmp___5 = 30;
 6685|      0|      }
 6686|      0|    }
 6687|      0|    tmp___9 = __errno_location();
 6688|      0|    tmp___10 = ignorable_missing(x, *tmp___9);
 6689|      0|    if (tmp___10) {
 6690|      0|      return ((enum RM_status)2);
 6691|      0|    }
 6692|      0|    if ((int)ent->fts_info == 4) {
 6693|      0|      tmp___11 = __errno_location();
 6694|      0|      *tmp___11 = ent->fts_errno;
 6695|      0|    }
 6696|      0|    tmp___12 = quote((char const *)ent->fts_path);
 6697|      0|    tmp___13 = gettext("cannot remove %s");
 6698|      0|    tmp___14 = __errno_location();
 6699|      0|    error(0, *tmp___14, (char const *)tmp___13, tmp___12);
 6700|      0|    mark_ancestor_dirs(ent);
 6701|      0|    return ((enum RM_status)4);
 6702|      0|  }
 6703|      0|}
 6704|       |static enum RM_status rm_fts(FTS *fts, FTSENT *ent,
 6705|      1|                             struct rm_options const *x) {
 6706|      1|  char const *tmp;
 6707|      1|  char *tmp___0;
 6708|      1|  _Bool tmp___1;
 6709|      1|  char const *tmp___2;
 6710|      1|  char *tmp___3;
 6711|      1|  char *tmp___4;
 6712|      1|  _Bool tmp___5;
 6713|      1|  char const *tmp___6;
 6714|      1|  char *tmp___7;
 6715|      1|  char const *tmp___8;
 6716|      1|  char const *tmp___9;
 6717|      1|  char *tmp___10;
 6718|      1|  int tmp___11;
 6719|      1|  char *tmp___12;
 6720|      1|  Ternary is_empty_directory;
 6721|      1|  enum RM_status s;
 6722|      1|  enum RM_status tmp___13;
 6723|      1|  char const *tmp___14;
 6724|      1|  char *tmp___15;
 6725|      1|  _Bool is_dir;
 6726|      1|  int tmp___16;
 6727|      1|  enum RM_status s___0;
 6728|      1|  enum RM_status tmp___17;
 6729|      1|  enum RM_status tmp___18;
 6730|      1|  char const *tmp___19;
 6731|      1|  char *tmp___20;
 6732|      1|  char const *tmp___21;
 6733|      1|  char *tmp___22;
 6734|      1|  char const *tmp___23;
 6735|      1|  char *tmp___24;
 6736|       |
 6737|      1|  {
 6738|      1|    if ((int)ent->fts_info == 1) {
 6739|      0|      goto case_1;
 6740|      0|    }
 6741|      1|    if ((int)ent->fts_info == 8) {
 6742|      1|      goto case_8;
 6743|      1|    }
 6744|      0|    if ((int)ent->fts_info == 10) {
 6745|      0|      goto case_8;
 6746|      0|    }
 6747|      0|    if ((int)ent->fts_info == 12) {
 6748|      0|      goto case_8;
 6749|      0|    }
 6750|      0|    if ((int)ent->fts_info == 13) {
 6751|      0|      goto case_8;
 6752|      0|    }
 6753|      0|    if ((int)ent->fts_info == 6) {
 6754|      0|      goto case_8;
 6755|      0|    }
 6756|      0|    if ((int)ent->fts_info == 4) {
 6757|      0|      goto case_8;
 6758|      0|    }
 6759|      0|    if ((int)ent->fts_info == 11) {
 6760|      0|      goto case_8;
 6761|      0|    }
 6762|      0|    if ((int)ent->fts_info == 3) {
 6763|      0|      goto case_8;
 6764|      0|    }
 6765|      0|    if ((int)ent->fts_info == 2) {
 6766|      0|      goto case_2;
 6767|      0|    }
 6768|      0|    if ((int)ent->fts_info == 7) {
 6769|      0|      goto case_7;
 6770|      0|    }
 6771|      0|    goto switch_default;
 6772|      0|  case_1:
 6773|      0|    if (!x->recursive) {
 6774|      0|      tmp = quote((char const *)ent->fts_path);
 6775|      0|      tmp___0 = gettext("cannot remove %s");
 6776|      0|      error(0, 21, (char const *)tmp___0, tmp);
 6777|      0|      mark_ancestor_dirs(ent);
 6778|      0|      fts_skip_tree(fts, ent);
 6779|      0|      return ((enum RM_status)4);
 6780|      0|    }
 6781|      0|    if (ent->fts_level == 0L) {
 6782|      0|      tmp___1 = strip_trailing_slashes(ent->fts_path);
 6783|      0|      if (tmp___1) {
 6784|      0|        ent->fts_pathlen = strlen((char const *)ent->fts_path);
 6785|      0|      }
 6786|      0|      tmp___4 = last_component((char const *)ent->fts_accpath);
 6787|      0|      tmp___5 = dot_or_dotdot((char const *)tmp___4);
 6788|      0|      if (tmp___5) {
 6789|      0|        tmp___2 = quote((char const *)ent->fts_path);
 6790|      0|        tmp___3 = gettext("cannot remove directory: %s");
 6791|      0|        error(0, 0, (char const *)tmp___3, tmp___2);
 6792|      0|        fts_skip_tree(fts, ent);
 6793|      0|        return ((enum RM_status)4);
 6794|      0|      }
 6795|      0|      if (x->root_dev_ino) {
 6796|      0|        if (ent->fts_statp[0].st_ino == (x->root_dev_ino)->st_ino) {
 6797|      0|          if (ent->fts_statp[0].st_dev == (x->root_dev_ino)->st_dev) {
 6798|      0|            while (1) {
 6799|      0|              tmp___11 = strcmp((char const *)ent->fts_path, "/");
 6800|      0|              if (tmp___11 == 0) {
 6801|      0|                tmp___6 = quote((char const *)ent->fts_path);
 6802|      0|                tmp___7 =
 6803|      0|                    gettext("it is dangerous to operate recursively on %s");
 6804|      0|                error(0, 0, (char const *)tmp___7, tmp___6);
 6805|      0|              } else {
 6806|      0|                tmp___8 = quote_n(1, "/");
 6807|      0|                tmp___9 = quote_n(0, (char const *)ent->fts_path);
 6808|      0|                tmp___10 = gettext("it is dangerous to operate recursively on "
 6809|      0|                                   "%s (same as %s)");
 6810|      0|                error(0, 0, (char const *)tmp___10, tmp___9, tmp___8);
 6811|      0|              }
 6812|      0|              tmp___12 =
 6813|      0|                  gettext("use --no-preserve-root to override this failsafe");
 6814|      0|              error(0, 0, (char const *)tmp___12);
 6815|      0|              goto while_break;
 6816|      0|            }
 6817|      0|          while_break:
 6818|      0|            fts_skip_tree(fts, ent);
 6819|      0|            return ((enum RM_status)4);
 6820|      0|          }
 6821|      0|        }
 6822|      0|      }
 6823|      0|    }
 6824|      0|    tmp___13 = prompt((FTS const *)fts, (FTSENT const *)ent, (_Bool)1, x,
 6825|      0|                      (enum Prompt_action)2, &is_empty_directory);
 6826|      0|    s = tmp___13;
 6827|      0|    if ((unsigned int)s == 2U) {
 6828|      0|      if ((unsigned int)is_empty_directory == 4U) {
 6829|      0|        s = excise(fts, ent, x, (_Bool)1);
 6830|      0|        fts_skip_tree(fts, ent);
 6831|      0|      }
 6832|      0|    }
 6833|      0|    if ((unsigned int)s != 2U) {
 6834|      0|      mark_ancestor_dirs(ent);
 6835|      0|      fts_skip_tree(fts, ent);
 6836|      0|    }
 6837|      0|    return (s);
 6838|      1|  case_8:
 6839|      1|    if ((int)ent->fts_info == 6) {
 6840|      0|      if (x->one_file_system) {
 6841|      0|        if (0L < ent->fts_level) {
 6842|      0|          if (ent->fts_statp[0].st_dev != fts->fts_dev) {
 6843|      0|            mark_ancestor_dirs(ent);
 6844|      0|            tmp___14 = quote((char const *)ent->fts_path);
 6845|      0|            tmp___15 =
 6846|      0|                gettext("skipping %s, since it\'s on a different device");
 6847|      0|            error(0, 0, (char const *)tmp___15, tmp___14);
 6848|      0|            return ((enum RM_status)4);
 6849|      0|          }
 6850|      0|        }
 6851|      0|      }
 6852|      0|    }
 6853|      1|    if ((int)ent->fts_info == 6) {
 6854|      0|      tmp___16 = 1;
 6855|      1|    } else {
 6856|      1|      if ((int)ent->fts_info == 4) {
 6857|      0|        tmp___16 = 1;
 6858|      1|      } else {
 6859|      1|        tmp___16 = 0;
 6860|      1|      }
 6861|      1|    }
 6862|      1|    is_dir = (_Bool)tmp___16;
 6863|      1|    tmp___17 = prompt((FTS const *)fts, (FTSENT const *)ent, is_dir, x,
 6864|      1|                      (enum Prompt_action)3, (Ternary *)((void *)0));
 6865|      1|    s___0 = tmp___17;
 6866|      1|    if ((unsigned int)s___0 != 2U) {
 6867|      0|      return (s___0);
 6868|      0|    }
 6869|      1|    tmp___18 = excise(fts, ent, x, is_dir);
 6870|      1|    return (tmp___18);
 6871|      0|  case_2:
 6872|      0|    while (1) {
 6873|      0|      tmp___19 = quote((char const *)ent->fts_path);
 6874|      0|      tmp___20 = gettext(
 6875|      0|          "WARNING: Circular directory structure.\nThis almost certainly means "
 6876|      0|          "that you have a corrupted file system.\nNOTIFY YOUR SYSTEM "
 6877|      0|          "MANAGER.\nThe following directory is part of the cycle:\n  %s\n");
 6878|      0|      error(0, 0, (char const *)tmp___20, tmp___19);
 6879|      0|      goto while_break___0;
 6880|      0|    }
 6881|      0|  while_break___0:
 6882|      0|    fts_skip_tree(fts, ent);
 6883|      0|    return ((enum RM_status)4);
 6884|      0|  case_7:
 6885|      0|    tmp___21 = quote((char const *)ent->fts_path);
 6886|      0|    tmp___22 = gettext("traversal failed: %s");
 6887|      0|    error(0, ent->fts_errno, (char const *)tmp___22, tmp___21);
 6888|      0|    fts_skip_tree(fts, ent);
 6889|      0|    return ((enum RM_status)4);
 6890|      0|  switch_default:
 6891|      0|    tmp___23 = quote((char const *)ent->fts_path);
 6892|      0|    tmp___24 =
 6893|      0|        gettext("unexpected failure: fts_info=%d: %s\nplease report to %s");
 6894|      0|    error(0, 0, (char const *)tmp___24, (int)ent->fts_info, tmp___23,
 6895|      0|          "bug-coreutils@gnu.org");
 6896|      0|    abort();
 6897|       |
 6898|      0|    return ((enum RM_status)0);
 6899|      0|  }
 6900|      0|}
 6901|      1|enum RM_status rm(char *const *file, struct rm_options const *x) {
 6902|      1|  enum RM_status rm_status;
 6903|      1|  int bit_flags;
 6904|      1|  FTS *fts;
 6905|      1|  FTS *tmp;
 6906|      1|  FTSENT *ent;
 6907|      1|  char *tmp___0;
 6908|      1|  int *tmp___1;
 6909|      1|  int *tmp___2;
 6910|      1|  enum RM_status s;
 6911|      1|  enum RM_status tmp___3;
 6912|      1|  char *tmp___4;
 6913|      1|  int *tmp___5;
 6914|      1|  int tmp___6;
 6915|       |
 6916|      1|  {
 6917|      1|    rm_status = (enum RM_status)2;
 6918|      1|    if (*file) {
 6919|      1|      bit_flags = 536;
 6920|      1|      if (x->one_file_system) {
 6921|      0|        bit_flags |= 64;
 6922|      0|      }
 6923|      1|      tmp = xfts_open(file, bit_flags,
 6924|      1|                      (int (*)(FTSENT const **, FTSENT const **))((void *)0));
 6925|      1|      fts = tmp;
 6926|      2|      while (1) {
 6927|      2|        ent = fts_read(fts);
 6928|      2|        if ((unsigned long)ent == (unsigned long)((void *)0)) {
 6929|      1|          tmp___2 = __errno_location();
 6930|      1|          if (*tmp___2 != 0) {
 6931|      0|            tmp___0 = gettext("fts_read failed");
 6932|      0|            tmp___1 = __errno_location();
 6933|      0|            error(0, *tmp___1, (char const *)tmp___0);
 6934|      0|            rm_status = (enum RM_status)4;
 6935|      0|          }
 6936|      1|          goto while_break;
 6937|      1|        }
 6938|      1|        tmp___3 = rm_fts(fts, ent, x);
 6939|      1|        s = tmp___3;
 6940|      1|        if (!((unsigned int)s == 2U)) {
 6941|      0|          if (!((unsigned int)s == 3U)) {
 6942|      0|            if (!((unsigned int)s == 4U)) {
 6943|      0|              __assert_fail(
 6944|      0|                  "((s) == RM_OK || (s) == RM_USER_DECLINED || (s) == "
 6945|      0|                  "RM_ERROR)",
 6946|      0|                  "/home/khheo/project/benchmark/coreutils-8.4/src/remove.c",
 6947|      0|                  624U, "rm");
 6948|      0|            }
 6949|      0|          }
 6950|      0|        }
 6951|      1|        while (1) {
 6952|       |
 6953|      1|          if ((unsigned int)s == 4U) {
 6954|      0|            rm_status = s;
 6955|      1|          } else {
 6956|      1|            if ((unsigned int)s == 3U) {
 6957|      0|              if ((unsigned int)rm_status == 2U) {
 6958|      0|                rm_status = s;
 6959|      0|              }
 6960|      0|            }
 6961|      1|          }
 6962|      1|          goto while_break___0;
 6963|      1|        }
 6964|      1|      while_break___0:;
 6965|      1|      }
 6966|      1|    while_break:
 6967|      1|      tmp___6 = fts_close(fts);
 6968|      1|      if (tmp___6 != 0) {
 6969|      0|        tmp___4 = gettext("fts_close failed");
 6970|      0|        tmp___5 = __errno_location();
 6971|      0|        error(0, *tmp___5, (char const *)tmp___4);
 6972|      0|        rm_status = (enum RM_status)4;
 6973|      0|      }
 6974|      1|    }
 6975|      1|    return (rm_status);
 6976|      1|  }
 6977|      1|}
 6978|       |extern char *optarg;
 6979|       |extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
 6980|       |                                        isatty)(int __fd);
 6981|       |extern
 6982|       |    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
 6983|       |                                     atexit)(void (*__func)(void));
 6984|       |extern
 6985|       |    __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
 6986|       |                                        textdomain)(char const *__domainname);
 6987|       |extern __attribute__((__nothrow__)) char *(__attribute__((
 6988|       |    __leaf__)) bindtextdomain)(char const *__domainname, char const *__dirname);
 6989|      0|__inline static void emit_ancillary_info(void) {
 6990|      0|  char *tmp;
 6991|      0|  char *tmp___0;
 6992|      0|  char *tmp___1;
 6993|      0|  char *tmp___2;
 6994|      0|  char const *lc_messages;
 6995|      0|  char const *tmp___3;
 6996|      0|  char *tmp___4;
 6997|      0|  char *tmp___5;
 6998|      0|  int tmp___6;
 6999|      0|  char *tmp___7;
 7000|      0|  char *tmp___8;
 7001|       |
 7002|      0|  {
 7003|      0|    tmp = last_component(program_name);
 7004|      0|    tmp___0 = gettext("\nReport %s bugs to %s\n");
 7005|      0|    printf((char const *)tmp___0, tmp, "bug-coreutils@gnu.org");
 7006|      0|    tmp___1 = gettext("%s home page: <http://www.gnu.org/software/%s/>\n");
 7007|      0|    printf((char const *)tmp___1, "GNU coreutils", "coreutils");
 7008|      0|    tmp___2 = gettext(
 7009|      0|        "General help using GNU software: <http://www.gnu.org/gethelp/>\n");
 7010|      0|    fputs_unlocked((char const *)tmp___2, stdout);
 7011|      0|    tmp___3 = (char const *)setlocale(5, (char const *)((void *)0));
 7012|      0|    lc_messages = tmp___3;
 7013|      0|    if (lc_messages) {
 7014|      0|      tmp___6 = strncmp(lc_messages, "en_", (size_t)3);
 7015|      0|      if (tmp___6) {
 7016|      0|        tmp___4 = last_component(program_name);
 7017|      0|        tmp___5 = gettext("Report %s translation bugs to "
 7018|      0|                          "<http://translationproject.org/team/>\n");
 7019|      0|        printf((char const *)tmp___5, tmp___4);
 7020|      0|      }
 7021|      0|    }
 7022|      0|    tmp___7 = last_component(program_name);
 7023|      0|    tmp___8 = gettext(
 7024|      0|        "For complete documentation, run: info coreutils \'%s invocation\'\n");
 7025|      0|    printf((char const *)tmp___8, tmp___7);
 7026|      0|    return;
 7027|      0|  }
 7028|      0|}
 7029|      1|__inline static int priv_set_remove_linkdir(void) {
 7030|       |
 7031|      1|  { return (-1); }
 7032|      1|}
 7033|       |static struct option const long_opts[12] = {
 7034|       |    {"directory", 0, (int *)((void *)0), 'd'},
 7035|       |    {"force", 0, (int *)((void *)0), 'f'},
 7036|       |    {"interactive", 2, (int *)((void *)0), 128},
 7037|       |    {"one-file-system", 0, (int *)((void *)0), 129},
 7038|       |    {"no-preserve-root", 0, (int *)((void *)0), 130},
 7039|       |    {"preserve-root", 0, (int *)((void *)0), 131},
 7040|       |    {"-presume-input-tty", 0, (int *)((void *)0), 132},
 7041|       |    {"recursive", 0, (int *)((void *)0), 'r'},
 7042|       |    {"verbose", 0, (int *)((void *)0), 'v'},
 7043|       |    {"help", 0, (int *)((void *)0), -130},
 7044|       |    {"version", 0, (int *)((void *)0), -131},
 7045|       |    {(char const *)((void *)0), 0, (int *)((void *)0), 0}};
 7046|       |static char const *const interactive_args[7] = {
 7047|       |    "never", "no", "none", "once", "always", "yes", (char const *)((void *)0)};
 7048|       |static enum interactive_type const interactive_types[6] = {
 7049|       |    (enum interactive_type const)0, (enum interactive_type const)0,
 7050|       |    (enum interactive_type const)0, (enum interactive_type const)1,
 7051|       |    (enum interactive_type const)2, (enum interactive_type const)2};
 7052|      0|static void diagnose_leading_hyphen(int argc, char **argv) {
 7053|      0|  int i;
 7054|      0|  char const *arg;
 7055|      0|  struct stat st;
 7056|      0|  char const *tmp;
 7057|      0|  char *tmp___0;
 7058|      0|  char *tmp___1;
 7059|      0|  int tmp___2;
 7060|       |
 7061|      0|  {
 7062|      0|    i = 1;
 7063|      0|    while (1) {
 7064|       |
 7065|      0|      if (!(i < argc)) {
 7066|      0|        goto while_break;
 7067|      0|      }
 7068|      0|      arg = (char const *)*(argv + i);
 7069|      0|      if ((int const) * (arg + 0) == 45) {
 7070|      0|        if (*(arg + 1)) {
 7071|      0|          tmp___2 = lstat(arg, &st);
 7072|      0|          if (tmp___2 == 0) {
 7073|      0|            tmp = quote(arg);
 7074|      0|            tmp___0 = quotearg_n_style(1, (enum quoting_style)1, arg);
 7075|      0|            tmp___1 = gettext("Try `%s ./%s\' to remove the file %s.\n");
 7076|      0|            fprintf(stderr, (char const *)tmp___1, *(argv + 0), tmp___0, tmp);
 7077|      0|            goto while_break;
 7078|      0|          }
 7079|      0|        }
 7080|      0|      }
 7081|      0|      i++;
 7082|      0|    }
 7083|      0|  while_break:;
 7084|      0|    return;
 7085|      0|  }
 7086|      0|}
 7087|       |__attribute__((__noreturn__)) void usage(int status);
 7088|      0|void usage(int status) {
 7089|      0|  char *tmp;
 7090|      0|  char *tmp___0;
 7091|      0|  char *tmp___1;
 7092|      0|  char *tmp___2;
 7093|      0|  char *tmp___3;
 7094|      0|  char *tmp___4;
 7095|      0|  char *tmp___5;
 7096|      0|  char *tmp___6;
 7097|      0|  char *tmp___7;
 7098|      0|  char *tmp___8;
 7099|      0|  char *tmp___9;
 7100|       |
 7101|      0|  {
 7102|      0|    if (status != 0) {
 7103|      0|      tmp = gettext("Try `%s --help\' for more information.\n");
 7104|      0|      fprintf(stderr, (char const *)tmp, program_name);
 7105|      0|    } else {
 7106|      0|      tmp___0 = gettext("Usage: %s [OPTION]... FILE...\n");
 7107|      0|      printf((char const *)tmp___0, program_name);
 7108|      0|      tmp___1 = gettext("Remove (unlink) the FILE(s).\n\n  -f, --force         "
 7109|      0|                        "  ignore nonexistent files, never prompt\n  -i        "
 7110|      0|                        "            prompt before every removal\n");
 7111|      0|      fputs_unlocked((char const *)tmp___1, stdout);
 7112|      0|      tmp___2 = gettext(
 7113|      0|          "  -I                    prompt once before removing more than three "
 7114|      0|          "files, or\n                          when removing recursively.  "
 7115|      0|          "Less intrusive than -i,\n                          while still "
 7116|      0|          "giving protection against most mistakes\n      --interactive[=WHEN] "
 7117|      0|          " prompt according to WHEN: never, once (-I), or\n                   "
 7118|      0|          "       always (-i).  Without WHEN, prompt always\n");
 7119|      0|      fputs_unlocked((char const *)tmp___2, stdout);
 7120|      0|      tmp___3 =
 7121|      0|          gettext("      --one-file-system  when removing a hierarchy "
 7122|      0|                  "recursively, skip any\n                          directory "
 7123|      0|                  "that is on a file system different from\n                   "
 7124|      0|                  "       that of the corresponding command line argument\n");
 7125|      0|      fputs_unlocked((char const *)tmp___3, stdout);
 7126|      0|      tmp___4 = gettext(
 7127|      0|          "      --no-preserve-root  do not treat `/\' specially\n      "
 7128|      0|          "--preserve-root   do not remove `/\' (default)\n  -r, -R, "
 7129|      0|          "--recursive   remove directories and their contents recursively\n  "
 7130|      0|          "-v, --verbose         explain what is being done\n");
 7131|      0|      fputs_unlocked((char const *)tmp___4, stdout);
 7132|      0|      tmp___5 = gettext("      --help     display this help and exit\n");
 7133|      0|      fputs_unlocked((char const *)tmp___5, stdout);
 7134|      0|      tmp___6 =
 7135|      0|          gettext("      --version  output version information and exit\n");
 7136|      0|      fputs_unlocked((char const *)tmp___6, stdout);
 7137|      0|      tmp___7 =
 7138|      0|          gettext("\nBy default, rm does not remove directories.  Use the "
 7139|      0|                  "--recursive (-r or -R)\noption to remove each listed "
 7140|      0|                  "directory, too, along with all of its contents.\n");
 7141|      0|      fputs_unlocked((char const *)tmp___7, stdout);
 7142|      0|      tmp___8 = gettext("\nTo remove a file whose name starts with a `-\', for "
 7143|      0|                        "example `-foo\',\nuse one of these commands:\n  %s -- "
 7144|      0|                        "-foo\n\n  %s ./-foo\n");
 7145|      0|      printf((char const *)tmp___8, program_name, program_name);
 7146|      0|      tmp___9 = gettext("\nNote that if you use rm to remove a file, it is "
 7147|      0|                        "usually possible to recover\nthe contents of that "
 7148|      0|                        "file.  If you want more assurance that the contents "
 7149|      0|                        "are\ntruly unrecoverable, consider using shred.\n");
 7150|      0|      fputs_unlocked((char const *)tmp___9, stdout);
 7151|      0|      emit_ancillary_info();
 7152|      0|    }
 7153|      0|    exit(status);
 7154|      0|  }
 7155|      0|}
 7156|      1|static void rm_option_init(struct rm_options *x) {
 7157|       |
 7158|      1|  {
 7159|      1|    x->ignore_missing_files = (_Bool)0;
 7160|      1|    x->interactive = (enum rm_interactive)4;
 7161|      1|    x->one_file_system = (_Bool)0;
 7162|      1|    x->recursive = (_Bool)0;
 7163|      1|    x->root_dev_ino = (struct dev_ino *)((void *)0);
 7164|      1|    x->stdin_tty = (_Bool)isatty(0);
 7165|      1|    x->verbose = (_Bool)0;
 7166|      1|    x->require_restore_cwd = (_Bool)0;
 7167|      1|    return;
 7168|      1|  }
 7169|      1|}
 7170|       |static struct dev_ino dev_ino_buf;
 7171|      1|int main(int argc, char **argv) {
 7172|      1|  _Bool preserve_root;
 7173|      1|  struct rm_options x;
 7174|      1|  _Bool prompt_once;
 7175|      1|  int c;
 7176|      1|  int i;
 7177|      1|  ptrdiff_t tmp;
 7178|      1|  char *tmp___0;
 7179|      1|  char const *tmp___1;
 7180|      1|  char *tmp___2;
 7181|      1|  int *tmp___3;
 7182|      1|  size_t n_files;
 7183|      1|  char **file;
 7184|      1|  char *tmp___4;
 7185|      1|  char *tmp___5;
 7186|      1|  char *tmp___6;
 7187|      1|  _Bool tmp___7;
 7188|      1|  enum RM_status status;
 7189|      1|  enum RM_status tmp___8;
 7190|      1|  int tmp___9;
 7191|       |
 7192|      1|  {
 7193|      1|    preserve_root = (_Bool)1;
 7194|      1|    prompt_once = (_Bool)0;
 7195|      1|    set_program_name((char const *)*(argv + 0));
 7196|      1|    setlocale(6, "");
 7197|      1|    bindtextdomain("coreutils", "/usr/local/share/locale");
 7198|      1|    textdomain("coreutils");
 7199|      1|    atexit(&close_stdin);
 7200|      1|    rm_option_init(&x);
 7201|      1|    priv_set_remove_linkdir();
 7202|      1|    while (1) {
 7203|      1|      c = getopt_long(argc, (char *const *)argv, "dfirvIR", long_opts,
 7204|      1|                      (int *)((void *)0));
 7205|      1|      if (!(c != -1)) {
 7206|      1|        goto while_break;
 7207|      1|      }
 7208|      0|      if (c == 100) {
 7209|      0|        goto case_100;
 7210|      0|      }
 7211|      0|      if (c == 102) {
 7212|      0|        goto case_102;
 7213|      0|      }
 7214|      0|      if (c == 105) {
 7215|      0|        goto case_105;
 7216|      0|      }
 7217|      0|      if (c == 73) {
 7218|      0|        goto case_73;
 7219|      0|      }
 7220|      0|      if (c == 114) {
 7221|      0|        goto case_114;
 7222|      0|      }
 7223|      0|      if (c == 82) {
 7224|      0|        goto case_114;
 7225|      0|      }
 7226|      0|      if (c == 128) {
 7227|      0|        goto case_128;
 7228|      0|      }
 7229|      0|      if (c == 129) {
 7230|      0|        goto case_129;
 7231|      0|      }
 7232|      0|      if (c == 130) {
 7233|      0|        goto case_130;
 7234|      0|      }
 7235|      0|      if (c == 131) {
 7236|      0|        goto case_131;
 7237|      0|      }
 7238|      0|      if (c == 132) {
 7239|      0|        goto case_132;
 7240|      0|      }
 7241|      0|      if (c == 118) {
 7242|      0|        goto case_118;
 7243|      0|      }
 7244|      0|      if (c == -130) {
 7245|      0|        goto case_neg_130;
 7246|      0|      }
 7247|      0|      if (c == -131) {
 7248|      0|        goto case_neg_131;
 7249|      0|      }
 7250|      0|      goto switch_default;
 7251|      0|    case_100:
 7252|      0|      goto switch_break;
 7253|      0|    case_102:
 7254|      0|      x.interactive = (enum rm_interactive)5;
 7255|      0|      x.ignore_missing_files = (_Bool)1;
 7256|      0|      prompt_once = (_Bool)0;
 7257|      0|      goto switch_break;
 7258|      0|    case_105:
 7259|      0|      x.interactive = (enum rm_interactive)3;
 7260|      0|      x.ignore_missing_files = (_Bool)0;
 7261|      0|      prompt_once = (_Bool)0;
 7262|      0|      goto switch_break;
 7263|      0|    case_73:
 7264|      0|      x.interactive = (enum rm_interactive)5;
 7265|      0|      x.ignore_missing_files = (_Bool)0;
 7266|      0|      prompt_once = (_Bool)1;
 7267|      0|      goto switch_break;
 7268|      0|    case_114:
 7269|      0|      x.recursive = (_Bool)1;
 7270|      0|      goto switch_break;
 7271|      0|    case_128:
 7272|      0|      if (optarg) {
 7273|      0|        tmp = __xargmatch_internal("--interactive", (char const *)optarg,
 7274|      0|                                   interactive_args,
 7275|      0|                                   (char const *)(interactive_types),
 7276|      0|                                   sizeof(interactive_types[0]), argmatch_die);
 7277|      0|        i = (int)interactive_types[tmp];
 7278|      0|      } else {
 7279|      0|        i = 2;
 7280|      0|      }
 7281|      0|      if (i == 0) {
 7282|      0|        goto case_0;
 7283|      0|      }
 7284|      0|      if (i == 1) {
 7285|      0|        goto case_1;
 7286|      0|      }
 7287|      0|      if (i == 2) {
 7288|      0|        goto case_2;
 7289|      0|      }
 7290|      0|      goto switch_break___0;
 7291|      0|    case_0:
 7292|      0|      x.interactive = (enum rm_interactive)5;
 7293|      0|      prompt_once = (_Bool)0;
 7294|      0|      goto switch_break___0;
 7295|      0|    case_1:
 7296|      0|      x.interactive = (enum rm_interactive)4;
 7297|      0|      x.ignore_missing_files = (_Bool)0;
 7298|      0|      prompt_once = (_Bool)1;
 7299|      0|      goto switch_break___0;
 7300|      0|    case_2:
 7301|      0|      x.interactive = (enum rm_interactive)3;
 7302|      0|      x.ignore_missing_files = (_Bool)0;
 7303|      0|      prompt_once = (_Bool)0;
 7304|      0|      goto switch_break___0;
 7305|      0|    switch_break___0:;
 7306|      0|      goto switch_break;
 7307|      0|    case_129:
 7308|      0|      x.one_file_system = (_Bool)1;
 7309|      0|      goto switch_break;
 7310|      0|    case_130:
 7311|      0|      preserve_root = (_Bool)0;
 7312|      0|      goto switch_break;
 7313|      0|    case_131:
 7314|      0|      preserve_root = (_Bool)1;
 7315|      0|      goto switch_break;
 7316|      0|    case_132:
 7317|      0|      x.stdin_tty = (_Bool)1;
 7318|      0|      goto switch_break;
 7319|      0|    case_118:
 7320|      0|      x.verbose = (_Bool)1;
 7321|      0|      goto switch_break;
 7322|      0|    case_neg_130:
 7323|      0|      usage(0);
 7324|      0|      goto switch_break;
 7325|      0|    case_neg_131:
 7326|      0|      version_etc(stdout, "rm", "GNU coreutils", Version, "Paul Rubin",
 7327|      0|                  "David MacKenzie", "Richard M. Stallman", "Jim Meyering",
 7328|      0|                  (char *)((void *)0));
 7329|      0|      exit(0);
 7330|      0|      goto switch_break;
 7331|      0|    switch_default:
 7332|      0|      diagnose_leading_hyphen(argc, argv);
 7333|      0|      usage(1);
 7334|      0|    switch_break:;
 7335|      0|    }
 7336|      1|  while_break:;
 7337|      1|    if (argc <= optind) {
 7338|      0|      if (x.ignore_missing_files) {
 7339|      0|        exit(0);
 7340|      0|      } else {
 7341|      0|        tmp___0 = gettext("missing operand");
 7342|      0|        error(0, 0, (char const *)tmp___0);
 7343|      0|        usage(1);
 7344|      0|      }
 7345|      0|    }
 7346|      1|    if (x.recursive) {
 7347|      0|      if (preserve_root) {
 7348|      0|        x.root_dev_ino = get_root_dev_ino(&dev_ino_buf);
 7349|      0|        if ((unsigned long)x.root_dev_ino == (unsigned long)((void *)0)) {
 7350|      0|          tmp___1 = quote("/");
 7351|      0|          tmp___2 = gettext("failed to get attributes of %s");
 7352|      0|          tmp___3 = __errno_location();
 7353|      0|          error(1, *tmp___3, (char const *)tmp___2, tmp___1);
 7354|      0|        }
 7355|      0|      }
 7356|      0|    }
 7357|      1|    n_files = (size_t)(argc - optind);
 7358|      1|    file = argv + optind;
 7359|      1|    if (prompt_once) {
 7360|      0|      if (x.recursive) {
 7361|      0|        goto _L;
 7362|      0|      } else {
 7363|      0|        if (3UL < n_files) {
 7364|      0|        _L:
 7365|      0|          if (x.recursive) {
 7366|      0|            tmp___4 = gettext("%s: remove all arguments recursively? ");
 7367|      0|            tmp___6 = tmp___4;
 7368|      0|          } else {
 7369|      0|            tmp___5 = gettext("%s: remove all arguments? ");
 7370|      0|            tmp___6 = tmp___5;
 7371|      0|          }
 7372|      0|          fprintf(stderr, (char const *)tmp___6, program_name);
 7373|      0|          tmp___7 = yesno();
 7374|      0|          if (!tmp___7) {
 7375|      0|            exit(0);
 7376|      0|          }
 7377|      0|        }
 7378|      0|      }
 7379|      0|    }
 7380|      1|    tmp___8 = rm((char *const *)file, (struct rm_options const *)(&x));
 7381|      1|    status = tmp___8;
 7382|      1|    if (!((unsigned int)status == 2U)) {
 7383|      0|      if (!((unsigned int)status == 3U)) {
 7384|      0|        if (!((unsigned int)status == 4U)) {
 7385|      0|          __assert_fail("((status) == RM_OK || (status) == RM_USER_DECLINED || "
 7386|      0|                        "(status) == RM_ERROR)",
 7387|      0|                        "/home/khheo/project/benchmark/coreutils-8.4/src/rm.c",
 7388|      0|                        352U, "main");
 7389|      0|        }
 7390|      0|      }
 7391|      0|    }
 7392|      1|    if ((unsigned int)status == 4U) {
 7393|      0|      tmp___9 = 1;
 7394|      1|    } else {
 7395|      1|      tmp___9 = 0;
 7396|      1|    }
 7397|      1|    exit(tmp___9);
 7398|      1|  }
 7399|      1|}

